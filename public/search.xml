<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Missing Semester of Your CS Education</title>
    <url>/2023/09/20/A-Missing-Semester-of-Your-CS-Education/</url>
    <content><![CDATA[<p>见 "E:Missing Semester of Your CS Education.md"</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>变量的声明就是 <code>var name = xxx;</code>。其中 <code>var</code> 是
<code>variable</code> 的缩写（虽然和方差 variance 的缩写一样）。</p>
<p>在 JS 中使用 {} 来分块，同一个 {}
中的语句我们称之为一组语句，它们要么都执行，要么都不执行。</p>
<p>其实函数也是一个对象，可以如下定义一个函数：<code>f = new Function("console.log('this is a function. ')")</code>。但是一般不这么使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;lys&#x27;,</span><br><span class="line">    age: 19,</span><br><span class="line">    address: &#x27;SDU&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj) &#123;</span><br><span class="line">    console.log(x); // 这样只是枚举的对象中的元素名字</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj)&#123;</span><br><span class="line">    console.log(obj[x]); // 不能直接 obj.x 来获得具体元素，应用 [] 的引用方式。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组创建 <code>var arr = new Array()</code> 或者
<code>var arr = []</code>。但是一般不使用 <code>new Array()</code>
的创建方式。并且数组中的元素类型也是不一定的，不一定非要是 Number
类型的。 其实数组也是一个对象，只不过索引方式是
[]，所以对象有的东西数组也有。</p>
<p>数组既然是对象，就有方法，在 JS 中数组有一些常用的方法： 1.
<code>push()</code>
向数组末尾添加一个或者多个元素，并且返回新的数组的长度。 2.
<code>pop()</code> 从数组末尾删除一个元素，并且返回删除的元素。 3.
<code>unshift()</code>
向数组的<strong>开头</strong>添加一个或者多个元素，并且返回新的数组的长度。
4. <code>shift()</code> 从数组开头删除一个元素，并且返回删除的元素。 5.
<code>join()</code> 将所有的元素连接成一个字符串。 6.
<code>slice()</code> 返回数组的一部分，不修改原数组。</p>
<p>建立函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function xxx() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是构造函数 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br></pre></td></tr></table></figure> 如果不写前面的 function 直接
new，会出现错误。</p>
<p>arr.forEach(xx) 中间 xx 都要传递一个函数，如果之前定义了
<code>function fun() &#123;&#125;</code> 就写为
<code>arr.forEach(fun)</code>，但是一般不这样，一般都是用匿名函数。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.forEach(function(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 上面就是输出 a，遍历的时候会将 arr 中的元素传递给
function。 会传递三个参数，第一个是数组当前遍历到元素
value，第二个是当前遍历到的索引 index，第三个是正在遍历的数组。</p>
<p>函数在调用的时候，浏览器会向里面传递两个隐含的参数 1. 上下文对象的
this 2. 封装实参的类数组对象
arguments，在调用函数的时候，我们所传递的实参都会在 arguments
中保存。</p>
<p>在 JS 中，对象有 3 类 <img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1.png" class> DOM Document Object Model JS
通过 DOM 对于 HTML 文档进行操作，只要理解了 DOM，就可以随心所欲操作 WEB
页面。</p>
<p>节点 Node 是构成 HTML 文档的最基本的单元，常用节点分为四类 - 文档节点
整个 HTML 文档 - 元素节点 HTML 文档中的 HTML 标签 - 属性节点 元素的属性
- 文本节点 HTML 标签中的文本 <img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9.png" class></p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7.png" class>
<p>上面的三个属性是每一个节点都有的三个属性。</p>
<p>innerHTML 可以获得到文字</p>
<p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。JavaScript 与
HTML 之间的交互是通过事件实现的。比如对于 Web
应用来说，有下面一些有代表性的事件：点击某个元素、将鼠标移动至某个元素上方、按下键盘上某个键等等。</p>
<p><code>onload</code> 事件会在整个页面加载完成之后发生。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onload= function() &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这一段代码是页面加载完成之后执行的。</p>
<p>标签就是元素，元素就是标签。</p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9.png" class>
<p>innerHTML 对于「自结束标签」没有意义。如： <img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%87%AA%E7%BB%93%E6%9D%9F%E6%A0%87%E7%AD%BE.png" class>
如果想读取元素的属性，直接 <code>元素.属性名</code>。但是读取元素的
<code>class</code> 属性的时候不能直接 <code>元素.class</code> 因为 class
是 JS 中的保留字，应该写为 <code>元素.className</code></p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%9F%A5%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9.png" class>
<p>但是 <code>childNodes</code> 有个缺陷，此时如果我们使用
<code>children</code>
就不会出现这种问题了，它返回的是当前元素的所有子元素。
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/childnodes%E7%BC%BA%E9%99%B7.png" class></p>
<p><code>innerText</code> 和 <code>innerHTML</code> 类似，但是
<code>innerText</code> 获取的会将 html 标签去除。</p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9.png" class>
<p><code>getElementsByName()</code> 一般用来操作一些表单项目。</p>
<p>获取 <code>body</code> 标签的话有两种方式： 1.
<code>var body = document.getElementsByTagName()[0];</code> 因为
<code>getElementsByTagName()</code> 返回的是一个集合
<code>Collection</code>，但是我们又只有一个
<code>body</code>，所以直接返回索引 0 就可以了。 2. 其实在
<code>document</code> 中就有一个属性 <code>body</code>，我们直接
<code>var body = document.body;</code> 就可以了。</p>
<p><code>html</code> 元素是 <code>document.documentElement;</code></p>
<p><code>document.all</code> 代表的是页面的所有元素。也可以写成
<code>document.getElementsByTagName("*")</code></p>
<p><code>document.getElementsByClassName();</code> 可以根据元素的
<code>class</code> 属性值获取一组节点对象。</p>
<p><code>document.querySelector();</code>
需要一个选择器字符串作为参数，可以根据一个 CSS
选择器来查询一个元素节点对象。但是使用这个方法只会返回唯一的一个元素，如果满足条件的元素有多个，但是只会返回第一个。如果需要多个就使用
<code>document.querySelectorAll();</code></p>
<p><code>父节点.insertBefore(新节点, 旧节点)</code>
是在旧节点前面添加新节点。</p>
<p>超链接点击以后会默认跳转页面，如果我们不希望出现此默认行为，我们可以在超链接的
<code>onclick = function() &#123;&#125;</code> 中写上
<code>return false;</code></p>
<p><code>confirm()</code>
函数会弹出一个带有确定和取消两个按键的提示框，并且如果我们点击确定，会返回
true，如果点击取消，会返回 false。</p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class>
<p>一个比较细节容易忽视的点，直观上我们认为 this 和 allA[i] 是一样的。
图中，我们的 <code>onclick = function() &#123;&#125;</code>
可以认为只是函数之间的一个赋值，里面的内容并没有执行。只有我们在点击按钮的时候，<code>function</code>
里面的内容才会执行。如果我们 <code>function</code> 里面使用
<code>allA[i]</code>，等到我们点击的时候 for
循环早就已经执行完毕，此时的 i 必然是 all
的length，所以就会出现错误。我们正确的做法应该是将 function 里面的
allA[i] 改为 this。</p>
<p>通过 JS 修改元素的样式：<code>元素.style.样式名 = 样式值</code>
其中样式值需要是一个字符串。 注意，如果 CSS 样式名称中含有
<code>-</code>，如 <code>background-color</code> 这种命名在 JS
中是不合法的，我们需要将这种命名改为驼峰命名法，去掉
<code>-</code>，然后将 <code>-</code> 的字母大写。</p>
<p>通过 JS 的 style
修改的往往是内联样式，而内联样式有较高的优先级，所以通过 JS
修改的样式往往会立即显示。</p>
<p>事件对象：
当事件的响应函数被触发的时候，浏览器每次会将一个事件对象作为实参传递进响应函数。在事件对象中封装了当前关于事件的一切信息，比如鼠标的坐标、键盘的哪一个按键被按下、鼠标滚轮的移动方向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a title.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                document.onmousemove = function(event) &#123;</span><br><span class="line">                    var clientX = event.clientX;</span><br><span class="line">                    var clientY = event.clientY;</span><br><span class="line">                    box1.style.left = clientX + &quot;px&quot;;</span><br><span class="line">                    box1.style.top = clientY + &quot;px&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;box id=&quot;box1&quot;&gt;&lt;/box&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>clientX</code> 和 <code>clientY</code>
是用于我们鼠标在当前可见窗口的坐标，所以对于有滚动条的窗口的话可能会出现一些错误。所以我们这时候使用
<code>pageX</code> 和 <code>pageY</code>
这两和属性是相对于整个页面的。</p>
<img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/document%E5%92%8Cwindow.png" class>
<p>事件的冒泡(bubble)
所谓事件的冒泡就是事件的想上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在开发中，大部分情况冒泡是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。
<code>event.cancelBubble = true;</code></p>
<p>我们希望只绑定一次事件，即可应用到多个元素之上，即使元素是后来添加的。我们可以尝试将元素绑定给其共同的祖先元素。然后通过冒泡来实现事件的发生。这其实就是事件的「委派」。</p>
<p><code>document.getElementsByTagName();</code>
返回的不是一个数组（一个NodeList对象，指定标签名的集合
collection），虽然我们可以遍历，它也有长度。</p>
<p>点击超链接时会自动默认跳转，我们把超链接的 <code>href</code> 修改为
<code>javascript:;</code> 就不会发生跳转了。</p>
<p>事件给谁绑定的，function 中的 this 就是谁。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ul.onclick = function() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">    alert(&quot;我是一个响应函数。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
像这一个，第一个 <code>alert</code> 输出的就是
<code>[object HTMLUListElement]</code>。
但是事件绑定对象不等于事件触发对象，我们如果想要获得事件<strong>触发对象</strong>需要使用
<code>event.target</code> 属性。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;this is a test.&lt;/title&gt;</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var btn1 = document.getElementById(&quot;btn1&quot;);</span><br><span class="line">                var ul = document.getElementsByTagName(&quot;ul&quot;)[0];</span><br><span class="line">                btn1.onclick = function() &#123;</span><br><span class="line">                    var li = document.createElement(&quot;li&quot;);</span><br><span class="line">                    li.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27; class=&#x27;link&#x27;&gt;新建的超链接&lt;/a&gt;&quot;</span><br><span class="line">                    ul.appendChild(li);</span><br><span class="line">                &#125;</span><br><span class="line">                ul.onclick = function(event) &#123;</span><br><span class="line">                    if (event.target.className == &#x27;link&#x27;) &#123;</span><br><span class="line">                        alert(&quot;这是一个响应函数&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;button id=&quot;btn1&quot;&gt;我是一个按钮&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>对象.事件 = 函数</code>
的形式绑定响应函数，它只能同时为一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，那么后面的就会覆盖掉前面的。
我们可以使用 <code>addEventListener(xxx, xxx, xxx)</code>
为元素绑定响应函数。 它的参数： 1. 事件的字符串，如果是 onclick
不要前面的 on 2. 回调函数，当事件被触发时，该函数会被调用。 3.
是否在捕获阶段触发，需要布尔值，一般是 false</p>
<p>JavaScript中的call()函数是用于调用函数的方法之一，它允许你显式地指定函数内部的this关键字，并传递参数给该函数。call()方法的语法如下：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionName.call(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>
总之，call()方法是JavaScript中用于在指定上下文对象上调用函数的强大工具，它允许你更灵活地控制函数的执行环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UFT-8&quot;&gt;</span><br><span class="line">        this is a test.</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                box1.onmousedown = function(event) &#123;</span><br><span class="line">                    var offsetX = event.clientX - box1.offsetLeft;</span><br><span class="line">                    var offsetY = event.clientY - box1.offsetTop;</span><br><span class="line">                    document.onmousemove = function(event) &#123;</span><br><span class="line">                        var x = event.clientX;</span><br><span class="line">                        var y = event.clientY;</span><br><span class="line">                        box1.style.left = x - offsetX + &quot;px&quot;;</span><br><span class="line">                        box1.style.top = y - offsetY + &quot;px&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    document.onmouseup = function() &#123;</span><br><span class="line">                        document.onmousemove = null;</span><br><span class="line">                        document.onmouseup = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>实现一个小方块位置的拖拽。</p>
<p>键盘事件一般都会绑定给可以获取到焦点的对象或者是
<code>document</code> 对象。对于 <code>onkeydown</code>
事件来说，如果我们一直按着某个按键不松手，则事件就会一直触发。当
<code>onkeydown</code>
连续触发时，第一次和第二次之间的间隔会长一点，其他后面的会非常快，这是为了防止我们误操作。</p>
<p>我们可以使用 <code>event</code> 的 <code>keyCode</code>
属性可以返回被按下键的 <code>Unicode</code> 编码。或者使用
<code>key</code> 属性直接返回被按键的按键。 如果判断 <code>alt</code>
或者 <code>ctrl</code> 或者 <code>shift</code>
和某个键是否同时被按下，可以同时使用 <code>event</code> 的
<code>altKey、shiftKey、ctrlKey</code> 属性和 <code>key</code>
属性。</p>
<p>BOM browser object model 浏览器对象模型 BOM 可以使我们通过 JS
来操作浏览器，DOM 可以使我们通过 JS 来操作网页。 <img src="/.com//08/28/JavaScript%E5%9F%BA%E7%A1%80/bom%E5%AF%B9%E8%B1%A1.png" class></p>
<p><code>uerAgent</code> 用户代理，通常指的是浏览器，其中
<code>navigator</code> 的属性 <code>userAgent</code>
是一个字符串，包含用来描述浏览器的内容，不同的浏览器有着不同的
userAgent</p>
<p>Gecko CSS 渲染的一个引擎。</p>
<p><code>history</code> 对象 <code>length</code>
属性，返回浏览器历史列表中 url 数量。 方法：<code>back</code> 加载
<code>history</code> 列表中前一个 url，<code>forward</code> 加载
<code>history</code> 列表中下一个 url，<code>go(xx)</code>
加载列表中某一个具体的页面，xx
如果是正，就是前多少个，如果是负，就是加载后面第xx个页面。</p>
<p><code>location</code> 对象 如果直接打印 <code>location</code>
可以获取当前的地址栏，也就是网页的完整路径。如果直接将
<code>location</code> 修改为一个路径，就会直接跳转到那个页面。</p>
<p><code>window</code> 的 <code>setInterval</code> 方法。(Interval 是
间隔、中场休息、幕间休息、间隙 的意思) - 定时调用 -
可以将一个函数，每隔一段时间执行一次 - 参数： 1. 回调函数 2.
每次调用的时间间隔，单位是毫秒 - 返回值： 返回一个 Number 类型的数据
这个数字用来作为定时器的唯一标识(因为一个页面上可能有很多个定时器)
比如我们的 <code>clearInterval(xx)</code>
方法，可以用来关闭一个定时器，其中的 <code>xx</code>
就需要我们的标识作为参数。<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(function() &#123;</span><br><span class="line">    xxx.innerHTML = ++count;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></p>
<p>延时调用：一个函数不是马上执行，而是一段时间之后再执行(只会执行一次)。
用法和定时调用差不多 <code>setTimeout(xxx);</code>
<code>clearTimeout(xxx);</code> 是关闭延时调用。</p>
<p>延时调用其实和定时调用是可以互相代替的。</p>
<p>JSON(JavaScript Object Notation) 因为和 JavaScript
中对象的表示方法一样，只不过在 JSON 中属性名字必须加双引号。 JSON 分类：
1. 对象 <code>&#123;&#125;</code> 2. 数组 <code>[]</code></p>
<p>在 JS 中，为我们提供了一个工具类就叫做
JSON，这个对象可以帮助我们将一个 JSON 转换为 JS 对象，也可以将一个 JS
对象转换为 JSON。 <code>JSON.parse(xx);</code> - 将字符串转换为 JS 对象
- 需要一个 JSON 字符串作为参数，返回一个 JS 对象</p>
<p><code>JSON.stringfy();</code> - 将 JS 对象转换为字符串 - 需要一个 JS
对象作为参数，但会一个 JSON 字符串。</p>
<p><code>===</code>
是严格相等的意思，它用于比较两个值是否完全相等，包括值和数据类型。
使用严格相等运算符是 JavaScript
编程中的一种良好实践，因为它可以减少潜在的错误和不确定性，确保比较的值具有相同的类型和值。</p>
]]></content>
      <tags>
        <tag>JavaScript, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo blog instructions list</title>
    <url>/2023/08/23/hexo-blog-instruction-list/</url>
    <content><![CDATA[<table>
<thead>
<tr class="header">
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>hexo n "我的博客" / hexo new "我的博客"</td>
<td>新建文章</td>
</tr>
<tr class="even">
<td>hexo p / hexo publish</td>
<td>发表草稿文章</td>
</tr>
<tr class="odd">
<td>hexo g / hexo generate</td>
<td>生成</td>
</tr>
<tr class="even">
<td>hexo s / hexo server</td>
<td>启动本地预览服务</td>
</tr>
</tbody>
</table>
<h3 id="插入图片">插入图片</h3>
<ol type="1">
<li>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。
在 hexo 中使用 <strong>文章资源文件夹</strong> 需要在
<code>config.yaml</code> 文件中更改一下配置： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
当该配置被应用后，使用 hexo new
命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。
但是若干原因，需要使用
<code>&#123; %asset_image xxx.jpg 这是一张图片% &#125;</code> 来引用。</li>
<li>另一种方法是，在 <code>source</code> 文件夹下建立一个文件夹
<code>_pic</code> 专门用来存放图片，此时在 md 文件中
<code>![img](/_pic/xxx.jpg)</code> 的格式引用就可以了。
(不知道为啥这种没成功)</li>
</ol>
<h3 id="搭建参考">搭建参考</h3>
<ol type="1">
<li><p>https://zhuanlan.zhihu.com/p/94038688#:~:text=hexo</p></li>
<li><p>https://zhuanlan.zhihu.com/p/44213627</p></li>
<li><p>https://segmentfault.com/a/1190000002632530 hexo
常用命令笔记</p></li>
<li><p>https://blog.csdn.net/as480133937/article/details/100138838 hexo
博客美化配置</p></li>
<li><p>https://theme-next.js.org/docs/getting-started/</p></li>
<li><p>https://theme-next.js.org/docs/theme-settings/</p></li>
<li><p>https://hexo.io/zh-cn/docs/configuration</p></li>
<li><p>https://zhuanlan.zhihu.com/p/552639819</p></li>
<li><p>https://blog.csdn.net/qq_34243930/article/details/103994419#2_65
关于 hexo 创建文章的讲解</p></li>
<li><p>https://zhuanlan.zhihu.com/p/265077468 hexo 博客插入图片</p></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>log</title>
    <url>/2023/09/18/log/</url>
    <content><![CDATA[<h4 id="年9月18日">2023年9月18日</h4>
<ol type="1">
<li>多种计算逆元的方式：扩展欧几里得、费马小定理、递推、阶乘</li>
<li>扩展欧几里得推导：先假设一组解
<code>x^&#123;'&#125; y^&#123;'&#125;</code>，然后找到和原来的解 <code>x y</code>
之间的对应关系 或者 非递归实现</li>
<li>组合数的各种公式和基础二项式反演了解：
https://oi-wiki.org/math/combinatorics/combination/
https://zhuanlan.zhihu.com/p/602675596</li>
</ol>
<h4 id="年9月21日">2023年9月21日</h4>
<ol type="1">
<li>矩阵加速递推 Fibonacci 数列的项公式推导。
不动点法？求解微分方程？</li>
<li>康托展开与康托逆展开 直接看 OI-Wiki 就行 全排列 next_permutation
函数</li>
<li>Hanoi 问题的数学方法求解(无需开辟新空间，直接输出移动方式) 对于
最小块的移动 是隔一个移动一次，而且是有规律的 lowbit
函数可以知道移动哪一个块
根据最小块的移动规律和lowbit函数就可以直接计算出哪一块移动到哪一个地方了</li>
</ol>
<h4 id="年9月27日">2023年9月27日</h4>
<ol type="1">
<li>二叉树中序遍历和前序或者中序和后序可以确定二叉树的结构</li>
<li>二叉树的层序遍历、中序遍历、前序遍历、后序遍历的非递归实现</li>
<li>二叉树的括号形式解析和输出二叉树的括号形式，当然是非递归形式。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python 数学建模与实验</title>
    <url>/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>虽然列表 list
可以完成数组操作，但不是真正意义上的数组，当数据量很大时，其速度很慢，故提供了
NumPy 扩展库完成数组操作。很多高级扩展库也依赖于它，比如 Scipy, Pandas
和 Matplotlib 等。</p>
<p>数组创建的几种方式： <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA.png" class></p>
<p>NumPy 中的数组 array 和 list
的区别是：列表中可以是数据类型不同的元素，而 array
数组只允许存储相同数据类型。</p>
<p>二维数组中的索引 list 为 a[i][j] 而 array 为 a[i, j]</p>
<p>一般索引： 感觉有的地方还是和 matlab 很相似的。 <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%B8%80%E8%88%AC%E7%B4%A2%E5%BC%95.png" class></p>
<p>文本文件读取： <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E6%9C%AC%E8%AF%BB%E5%8F%96.png" class> 二进制文件读取： <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" class>
另外，如果我们使用 NumPy 专用的二进制存取函数
<code>load() save() savez()</code>
会自动处理元素的类型和形状等信息。</p>
<p>open
打开文件的时候，如果打开的文件不在当前的目录，需要指定完整路径。注意，此时文件路径中的
<code>\</code> 要改为 <code>\\</code>，例如
<code>e:\mypython\test.txt</code> 应该改为
<code>e:\\mypython\\test.txt</code>. <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F.png" class></p>
<p>join 函数： <img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/join%E5%87%BD%E6%95%B0.png" class></p>
<h4 id="数据处理工具-pandas">数据处理工具 Pandas</h4>
<p>Pandas(Panel data, 面板数据) 是在 NumPy 的基础上开发的，是 Python
最强大的数据分析和探索工具之一。</p>
<h4 id="matplotlib">Matplotlib</h4>
<p>Matplotib 是 Python 强大的数据可视化工具，类似于 MATLAB 语言。</p>
<p>pie 绘制饼状图 bar 绘制柱状图 hist 绘制二维直方图 scatter
绘制散点图</p>
<img src="/.com//08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%E9%A2%9C%E8%89%B2.png" class>
<h4 id="scipy">scipy</h4>
<p>scipy 包含各种专用于科学计算常见问题的工具箱。其中 scipy.stats
则是统计和随机数的专门的库。 NumPy
能生成一定概率分布的随机数，但是如果需要更具体的概率密度、分布函数等，就用到
scipy.stats 模块了。Python 做简单的统计分析也可以用 scipy.stats
模块。</p>
<h3 id="section"></h3>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客食用指北</title>
    <url>/2023/11/12/hexo%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h4 id="字体的设置">字体的设置</h4>
<p>参见
https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</p>
<h4 id="数学公式的配置">数学公式的配置</h4>
<p>使用 mathjax 渲染，卸载掉之前的插件。</p>
<p>具体参见：</p>
<ol type="1">
<li>https://blog.csdn.net/weixin_45073562/article/details/120289648</li>
<li>https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E9%85%8D%E7%BD%AEMathJax/</li>
</ol>
<h4 id="评论系统的配置">评论系统的配置</h4>
<ol type="1">
<li>https://blog.csdn.net/weixin_48927364/article/details/123321038</li>
<li>https://qianfanguojin.top/2022/01/20/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0-Waline-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>JavaScript进阶</title>
    <url>/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="基础回顾">基础回顾</h4>
<p>数据类型： 1. 基本类型 String Number boolean undefined null 2.
对象(引用)类型 Object Function Array</p>
<p>判断： 1. <code>typeof</code> 返回的数据类型的字符串表达 2.
<code>instanceof</code> 3. <code>===</code> 和 <code>==</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123; // 这是一个 **类型对象**，因为函数也是一个对象。</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(); // 这是一个实例对象。</span><br></pre></td></tr></table></figure>
<p><code>null</code> 和 <code>undefined</code> <code>null</code>
定义了并且赋值了，只是值为 <code>null</code>，而 <code>undefined</code>
是定义了但是没有赋值。初始赋值为 <code>null</code>
表示将要是一个对象。程序的最后赋值为 <code>null</code>
可以释放内存。</p>
<p>栈：全局变量 / 局部变量 堆：对象
(对象本身在栈里面，而表示对象的变量在栈空间，比如函数和函数名的关系)</p>
<p>JS 在调用函数传递变量的时候是 <strong>值传递</strong>（理解可能不同）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">function add(a) &#123;</span><br><span class="line">    a = a + 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 程序输出为 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    var b = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数执行完以后 <code>b</code>
这个局部变量会自动释放，而后面对应的对象因为没有再被指向，被认为是垃圾对象，是在后面的某个时刻由垃圾回收器回收，释放空间。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">b = null;</span><br></pre></td></tr></table></figure> <code>b=null;</code> 以后，<code>b</code>
所指向的对象没有被任何其他变量指向，所以会被标记为垃圾对象，由
<code>JS</code> 引擎在一定时间后回收，而 <code>b</code>
这个全局变量仍然存在。
在<code>JavaScript</code>中，全局变量通常在整个应用程序的生命周期内存在，不会自动释放内存。<code>JavaScript</code>
引擎会负责管理全局变量的内存，而不需要手动释放。当全局变量不再被引用时，<code>JavaScript</code>引擎会自动将其标记为可回收，并在适当的时候进行垃圾回收以释放内存。
<code>JavaScript</code>
的垃圾回收机制主要处理对象的内存释放，而不负责释放变量的内存。变量的生命周期通常由其作用域决定。在全局作用域中声明的变量通常会在整个应用程序的生命周期内存在，除非您显式删除它们或应用程序终止。在局部作用域中声明的变量在离开作用域时会被销毁，相应的内存也会被释放。</p>
<p>什么时候必须使用 <code>['属性名']</code> 的方式？ 1.
属性名包含特殊字符：如<code>-</code> 和 <code></code>。 2.
使用表达式来动态访问属性 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;John&quot;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var propertyName = &quot;name&quot;;</span><br><span class="line">console.log(person[propertyName]); // 使用方括号来访问属性</span><br></pre></td></tr></table></figure></p>
<p><code>test.call/apply(obj);</code> 这个意思是把 <code>test</code>
函数临时作为 <code>obj</code> 内部的函数来调用。<code>obj</code>
内部可以没有 <code>test</code> 函数。</p>
<p><code>JavaScript</code>
中的回调函数是一种常见的编程概念，它允许您将一个函数作为参数传递给另一个函数，并在需要时执行该函数。这通常用于处理异步操作，例如处理文件读取、网络请求、定时器等等，因为在这些情况下，不能立即得到结果，而需要在操作完成后执行特定的代码。</p>
<p>IIFE(Immediately-Invoked Function Expression)</p>
<p><code>this</code> 是什么？ -
任何函数本质上都是通过某个对象来调用，如果我们没有直接指定，就是
<code>window</code> 来调用。 - 所有函数内部都以一个变量
<code>this</code>。 - 这个 <code>this</code>
的值是当前调用函数的对象。</p>
<p>在<code>JavaScript</code>中声明的全局函数通常是<code>window</code>对象的一部分，而不是<code>document</code>对象的一部分，这是因为<code>JavaScript</code>最初是为浏览器环境设计的，并且全局作用域在浏览器中通常与<code>window</code>对象关联。</p>
<p>在浏览器环境中，<code>window</code>对象代表整个浏览器窗口，它包含了全局<code>JavaScript</code>作用域的所有内容，包括全局变量和函数。当您声明一个全局函数时，它实际上是<code>window</code>对象的一个属性。这意味着您可以在全局范围内访问这个函数，无需任何其他前缀。</p>
<h4 id="js-原型和原型链">JS 原型和原型链</h4>
<p>JS 的复杂类型都是对象类型(<code>Object</code>)，而 JS
不是一门完全面向对象的编程语言，所以如何涉及继承机制，这是一个问题。</p>
<h5 id="构造函数">构造函数</h5>
<p>因为 JS 中没有类(<code>Class</code>)这个概念，所以 JS 的设计者使用了
<strong>构造函数</strong> 来实现继承机制。 &gt; ES6 中的
<code>Class</code> 可以看成一个语法糖，它的绝大部分功能，ES5
都可以做到，新的 <code>Class</code>
写法只是让原型的写法更加清晰、更像面向对象编程的语言而已。</p>
<p>在构造函数中，通过 <code>this</code> 赋值的属性或者方法，是每个实例的
<strong>实例属性</strong> 和
<strong>实例方法</strong>，<strong>无法共享公共属性</strong>。所以就又设计出了一个<strong>原型对象</strong>，来存储这个<strong>构造函数的公共属性以及方法</strong>。</p>
<h5 id="函数的-prototype原型">函数的 <code>prototype</code>(原型)</h5>
<ul>
<li>每一个函数都有一个 <code>prototype</code> 属性，它默认指向一个
<code>Object</code> 空实例对象(即称为：原型对象，但是
<code>Object</code> 不满足)。 &gt; 为什么要有这个空对象？ &gt;
它可以方便我们对于一个函数添加个性化的属性和方法，如果没有这个空对象而是直接链接到
Obejct，那么不同函数之间的个性化操作都会添加到 Obejct
下，会产生很多不必要的冲突和麻烦。</li>
<li>原型对象中有一个属性 <code>constructor</code>，它指向函数对象。</li>
<li>给原型对象添加属性(一般是方法) -&gt;
实例对象可以访问使用。（感觉和类与对象的关系很像）
构造函数和它的原型对象相互引用。 每一个函数 <code>function</code>
都有一个 <code>prototype</code>，即显式原型(属性) 每一个对象都有一个
<code>__proto__</code> 可以称为隐式原型(属性)
对象隐式原型的值就是函数显式原型的值。</li>
</ul>
<h5 id="原型链">原型链</h5>
<ul>
<li>访问一个对象的属性时，现在自身属性中查找，找到返回。</li>
<li>如果没有，再沿着 <code>__proto__</code>
这条链向上查找，找到返回。</li>
<li>如果最终没有找到，返回 <code>undefined</code>。</li>
<li>一直是沿着隐式原型找的，所以我们的原型链本质上是一个
<strong>隐式原型链</strong> <img src="/.com//08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B.png" class> <img src="/.com//08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class>
所有函数的隐式原型都是相同的，<code>fun = new Function()</code> 都是
<code>Function</code> 的实例对象。</li>
<li>在读取对象的属性时，会自动到原型链中查找。</li>
<li>设置对象的属性时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。</li>
</ul>
<p>To do: 利用js快速完成大学生新生安全教育课程
https://blog.csdn.net/m0_38072683/article/details/118878085</p>
]]></content>
      <tags>
        <tag>JavaScript, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS记录</title>
    <url>/2023/09/01/CSS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="行内样式">行内样式</h4>
<p><code>style</code> 是 CSS 的属性名 在 CSS 中名-值对中间用
<code>:</code> <code>font-size: xx px;</code> 可以设置字体大小
一般不推荐使用行内样式，不能复用并且不利于维护。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 style=&quot;color: red; font-size: 50px;&quot;&gt;Hello World&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="内部样式">内部样式</h4>
<p>在 <code>&lt;head&gt;</code> 标签或者 <code>&lt;body&gt;</code>
标签中加一个 <code>&lt;style&gt;</code> 标签(不过一般都是写在
<code>head</code> 里面)。</p>
<h4 id="外部样式">外部样式</h4>
<p>可以新建一个 <code>xxx.css</code> 文件，然后在 HTML 文件的
<code>&lt;head&gt;</code> 标签中加一个 <code>&lt;link&gt;</code> 标签
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure> 其中 <code>rel</code> 是 <code>relation</code>
的缩写，就是说 <code>href</code> 的文件和当前 HTML 文件的关系。</p>
<h4 id="样式优先级">样式优先级</h4>
<p>行内样式的优先级 &gt; 内部样式
对于内部样式和外部样式，它俩平级，但是后来者居上，也就是说，谁写在后面，就是展现谁的样式。</p>
<h4 id="选择器">选择器</h4>
<ol type="1">
<li><p>通配选择器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>类选择器：在标签中添加属性 <code>class="xxx"</code>，注意在
<code>style</code> 中的格式，需要在 <code>xxx</code> 前面加一个
<code>.</code>，来区分类名和标签名。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 要是一个标签属于两个
<code>class</code> 的话，写成 <code>class="xxx yyy"</code>
的格式，而不是分开写两个 <code>class</code>，那样的话后一个
<code>class</code> 会被忽略。</p></li>
<li><p>ID 选择器： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>交集选择器：
就是将两个选择器紧紧的写在一起。如果交集选择器中有元素，元素必须在开头(因为字母放在最后会引起单词的歧义)，并且我们交集的条件可以是多个。
<code>id</code> 选择器理论上可以作为交集选择器，但是我们的
<code>id</code> 是唯一的，已经可以唯一定义了，所以一般就是
<code>class</code> 和标签一起写。
同时也不存在两个元素同时在标签选择器中。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>并集选择器 就是在不同选择器之间加上逗号 <code>,</code>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,.beauty,.dog,.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不过这样写的话，逗号和点写在一起看起来有些乱，我们一般竖着写：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,</span><br><span class="line">.beauty,</span><br><span class="line">.dog,</span><br><span class="line">.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>后代选择器 比如说 <code>ul</code> 中的所有
<code>li</code>，中间直接空格就可以。但是除了选择了儿子以外，孙子
<code>li</code> 也被选择了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>子代选择器 <code>div</code> 标签中的子代 <code>a</code>
标签(排除了孙子等标签，只有儿子) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&gt;a &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>兄弟选择器 用 <code>+</code> 连接，只有紧紧相邻的兄弟，如果
<code>div</code> 紧紧相邻的没有 <code>p</code>，但是有 <code>p</code>
中间隔了别的标签，也不不起作用的。(睡在我下铺的兄弟) 相邻兄弟选择器
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div+p &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 如果是 <code>div~p &#123;&#125;</code> 就是 <code>div</code>
的所有兄弟 <code>p</code>，而不是紧紧相邻的了。</p></li>
<li><p>属性选择器 <code>[title] &#123;&#125;</code> 选择具有 <code>title</code>
属性的标签 <code>[title="xxx"] &#123;&#125;</code> 选择具有 <code>title</code>
属性并且属性内容是 <code>xxx</code> 的标签。
<code>[title^="a"] &#123;&#125;</code> 选择具有 <code>title</code>
属性并且属性内容是以 <code>a</code> 开头的标签。
<code>[title$="a"] &#123;&#125;</code> 选择具有 <code>title</code>
属性并且属性内容是以 <code>a</code> 结尾的标签。
<code>[title*="a"] &#123;&#125;</code> 选择具有 <code>title</code>
属性并且属性内容中含有 <code>a</code> 的标签</p></li>
</ol>
<h4 id="伪类选择器">伪类选择器</h4>
<p>可以理解为是对于元素的状态的一种描述。比如，已经访问过的超链接和未访问过的超链接，就是加一个冒号，后面就是元素的状态
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a:visited &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="三大特性">三大特性</h4>
<ol type="1">
<li>层叠性
如果样式发生了冲突，就会根据一定的规则(选择器优先级)，进行样式层叠(覆盖)。(当权重一样的时候，我们才考虑在代码中的顺序)</li>
<li>继承性
元素会自动拥有其父元素、或者祖先元素上设置的<strong>某些样式</strong>，优先继承离得最近的。
常见的可继承属性：<code>test-?? font-?? line-?? color</code></li>
<li>优先级
<code>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样式</code></li>
</ol>
<h4 id="像素-pixel">像素 Pixel</h4>
<p>虽然 <code>cm</code> 和 <code>mm</code>
这两个单位也可以用在网页中，但是对于网页来说，这两个单位不够精细。所以我们就是用
<code>px</code> 这个单位(是 Pixel 的缩写)，因为它很小，所以很精细。
<img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%83%8F%E7%B4%A0.png" class>
可以看出来，虽然电脑屏幕一般大小，但是右边的像素多，所以每一个像素的大小就小。所以像素我们不确定多么大，需要看屏幕，它是一个相对单位。
像素点越小，呈现出来的图片就越细腻，越清晰</p>
<h4 id="颜色">颜色</h4>
<ol type="1">
<li>颜色名 但是它太有限了，并且不是很精确，所以开发的时候一般不用。</li>
<li>RGB 或者 RGBA RGB 中三个字母分别是 RED GREEN BLUE(范围都是从 0 到
255) <code>rgb(xx, xx, xx);</code> <code>rgba(xx, xx, xx, xx);</code>
前三位和 <code>rgb</code> 相同，最后一位是透明度，范围是 0 - 1。</li>
<li>HEX 或者 HEXA <code>#xxxxxx</code>
井号后面一共六位，每一位都是十六进制的数字，每两位组合起来分别表示红、绿、蓝
然后 HEXA 就像
RGBA，就是添加了一个透明度，它也是用两位十六进制来表示，也就是说一共八位。</li>
<li>HSL 或者 HSLA 这两个东西用的不是很多。
<code>hsl(hue, saturation, lightness);</code> 色相、饱和度、亮度
<code>Hue</code> 在这里是用角度表示的，写为 <code>xxdeg</code> HELA 就是
<code>hsl(hue, saturation, lightness, xx);</code> 最后一位 0 - 1
表示透明度。 <img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E8%89%B2%E7%9B%B8%E7%8E%AF.png" class></li>
</ol>
<h4 id="字体属性">字体属性</h4>
<p><code>font-family: "xxx";</code>
字体族，其实就是字体样式。通常情况下，把字体分为两大类。第一类是衬线字体，第二类是非衬线字体。衬线字体的横竖撇捺特别有棱角，目前写网页还是非衬线字体比较多。</p>
<p><code>font-style: xxx;</code> 字体风格。默认为
<code>normal</code>，斜体是 <code>italic</code></p>
<p><code>font-weight:xxx;</code> 字体粗细，参数为
<code>lighter normal bold bolder</code>，或者写 100 - 1000
的数字，数字越大越粗。</p>
<h4 id="文本属性">文本属性</h4>
<p><code>letter-spacing:xxx px;</code> 字母间距(汉字被认为是字母)
<code>word-spacing:xxx px;</code> 词间距
<code>text-decoration:xxx;</code> 文本修饰
<code>overline underline line-through</code>
还可以改为波浪线等形式，并且也可以改颜色。 <code>text-indent:xx;</code>
文本缩进 <code>text-align:xxx;</code> <code>xxx</code> 可以是
<code>left center right</code> 就是靠哪里对齐。
<code>line-height:xxx;</code>
调整行高，就是上下之间的距离变大，但是字体的大小不变。其中
<code>xxx</code> 可以为像素、也可以写一个数字，表示是
<code>font-size</code> 的多少倍，也可以写成百分比，表示是
<code>font-size</code> 的多少倍。 <code>vertical-align:xxx;</code>
<code>xxx</code> 可以是 <code>top baseline bottom middle</code></p>
<h4 id="列表属性">列表属性</h4>
<p><code>list-style-type:xxx;</code> <code>xxx</code> 可以是
<code>none square lower-roman upper-roman decimal</code>
<code>list-style-position:xxx;</code> 可以是 <code>inside outside</code>
<code>list-style-image:xxx;</code> 找一个图片，自定义前面的点。</p>
<h4 id="表格属性">表格属性</h4>
<p><code>border-width:xxx px;</code> 宽度 <code>border-color:xxx;</code>
颜色 <code>border-style:xxx;</code> 样式
边框的相关属性，不仅仅是表格可以使用，其他元素如 <code>h1 p</code>
也可以使用。 <code>table-layout:fixed;</code> 可以控制表格的列宽。
<code>border-spacing:xxx px;</code> 控制单元格之间的距离。
<code>borer-collapse: collapse;</code>
合并相邻单元格的标签。写了合并以后，上面的
<code>border-spacing:xxx;</code> 无论 <code>xx</code> 是多少都失效了。
<code>empty-cells: show / hide;</code> 隐藏没有内容的单元格。
<code>caption-side:xxx;</code> 设置表格标题的位置，可以是
<code>top bottom</code></p>
<h4 id="背景属性">背景属性</h4>
<p><code>background-color:xxx;</code>
<code>background-repeat:repeat / no-repeat / repeat-y / repeat-x;</code>
如果图片较小，是否重复显示 <code>background-image:xxx;</code>
<code>background-position:xxx;</code>
可以控制背景图片的位置。<code>xxx</code> 可以是
<code>left top / left bottom / left center / xx px xx px</code></p>
<h4 id="鼠标属性">鼠标属性</h4>
<p><code>cursor:xxx;</code> 参数可以为
<code>pointer / move / wait / crosshair / help</code>
<code>cursor: url("xxx"),pointer;</code> 其中 <code>xx</code>
是一个图片的地址，此时鼠标的样式就变为了图片的样子。</p>
<h4 id="css-常用的长度单位">CSS 常用的长度单位</h4>
<ol type="1">
<li><code>px</code></li>
<li><code>em</code> 相当于当前元素的 <code>font-size</code>
的倍数。如果自己没有就沿着父元素一直网上找，如果都没有，就是用默认的。</li>
<li><code>rem</code> r 是 root 的意思。相对于根元素的
<code>font-size</code> 的倍数，如果没有，就使用默认的。</li>
<li><code>%</code> 相对于父元素计算。</li>
</ol>
<h4 id="盒子模型">盒子模型</h4>
<ol type="1">
<li>块元素 block
在页面中独占一行，不会与任何元素共占一行，是从上到下排列的。
默认宽度就是撑满父级元素，高度由内容决定。</li>
<li>行内元素 inline
在页面中不是独占一行，一行中不能容下的行内元素，会在下一行继续从左到右排列。
默认宽度和高度都是由内容决定。 但是 <strong>无法通过 CSS
设置宽和高。</strong> 最具有代表性的其实就是
<code>&lt;span&gt;</code></li>
<li>行内块元素 inline-block
又叫做内联块元素。在页面中不独占一行，会在下一行继续从左到右排列。
默认宽度和高度都是由内容决定。 <strong>可以通过 CSS
设置宽和高。</strong> 最具代表性的其实是 <code>&lt;img&gt;</code>
<img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%90%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.png" class></li>
</ol>
<h5 id="修改元素的显示模式">修改元素的显示模式</h5>
<p>上面是各种元素的默认显示形式，不过我们可以在 CSS 中修改
<code>display</code> 属性来调整它的显示形式。
<code>display: block / inline-block / inline;</code> 如果是
<code>display: none;</code>
那么这个元素就直接不显示了，并且也不会占用网页的空间。</p>
<h5 id="盒子模型的组成部分">盒子模型的组成部分</h5>
<p>我们设置的背景颜色会填充内边距区域，也会填充边框区域。
外边距不会影响盒子大小，只会影响其位置。 <img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%88%86%E5%8C%BA.png" class></p>
<p><code>width-min width-max height-min height-max padding-left padding-top padding-bottom padding-right</code></p>
<p><code>border</code> 的属性同样也可以是
<code>border-left-width border-left-style ...</code></p>
<p><code>margin</code> 的属性可以同 <code>padding</code> 一样修改。</p>
<h4 id="处理溢出">处理溢出</h4>
<p><code>overflow: hidden;</code> 直接隐藏，还可以写
<code>scroll auto</code> 默认是 <code>visible</code>，也可以 x y
方向分开处理，就是写成 <code>overflow-x</code> 和
<code>overflow-y</code></p>
<h4 id="隐藏元素的方式">隐藏元素的方式</h4>
<ol type="1">
<li>就是 <code>display: none;</code>
通过这种方式隐藏的元素不会再去占据页面的位置。</li>
<li>有一个属性专门控制元素的显示 <code>visibility: show;</code> 默认是
<code>show</code>，如果想隐藏就改为
<code>hidden</code>。不过通过这种方式隐藏的仍然会占位。</li>
</ol>
<p>一个关于开发者模式四个分区作用的说明。 <img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F.png" class>
<img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.png" class></p>
<h4 id="浮动-float">浮动 float</h4>
<p>浮动最早期设计出来是为了实现文字环绕图片或者说文字环绕文字。现在浮动是主流的页面布局方式之一。
1. 给第一个子元素设置 <code>margin-top</code>
会被父元素抢走，但是如果这个子元素浮动以后，就不会这样了。 2.
浮动后的元素不会被当作文本处理了(行内和行内块都会被当作文本处理) 3.
脱离文档流 4. 不会独占一行，可以共用一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a test.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .outer &#123;</span><br><span class="line">                background-color: gray;</span><br><span class="line">                border: black 1px solid;</span><br><span class="line">            &#125;</span><br><span class="line">            .box &#123;</span><br><span class="line">                margin: 10px;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: skyblue;</span><br><span class="line">                border: solid black 1px;</span><br><span class="line">            &#125;</span><br><span class="line">            .box1 &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;box box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>浮动之后，盒子因为脱离了标准文档流，它撑不起父盒子的高度，导致父盒子高度塌陷
##### 清除浮动带来影响的方式 1. 父盒子设置固定高度
虽然，给父盒子设置了固定高度能暂时解决我们的问题，但是它的使用不灵活，如果未来子盒子的高度需求发生了改变(网页的多处地方)，那么我们得手动需要更改父盒子的高度。后期不易维护。
2. 内墙法
所谓内墙法,有一个规则:在浮动元素的后面加一个空的块级元素(通常是div),并且该元素设置clear:both；属性。
clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。
3. 伪元素清除法 https://juejin.cn/post/6886247611318140942
在最后补加一个没有实际意义的块元素 <code>div</code>，然后添加
<code>div</code> 的 CSS 属性
<code>clear: both;</code>，这个块元素没有高，没有宽，没有内容，就是专门用来撑起父元素。
或者更加优雅写成 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx::after &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 其中 <code>content: ''</code>
表示元素为空，<code>display: block</code>
才能撑起父元素(因为另起一行了)，<code>clear: both;</code>
就是消除之前的浮动带来的所有影响。 4. <code>overflow: hidden;</code></p>
<h4 id="定位">定位</h4>
<p>开启相对定位的元素并未脱离文档流。
如果一个元素开启了定位，那么它的层级就比普通元素的层级高。 相对定位： 1.
对于元素的位置进行微调。 2. 配合绝对定位</p>
<p>绝对定位： 1. 一旦开启绝对定位，就脱离了文档流。 2.
绝对定位参考的点是它的包含块。
对于没有脱离文档流的元素，它的父元素就是它的包含块。
对于脱离文档流的元素，它的第一个开启定位的祖先元素就是它的包含块。 3.
不论是块元素、行内元素还是行内块元素，只要进行了绝对定位，就变成了<strong>定位元素</strong>
定位元素： 1. 默认被内容撑开。 2. 但是也是可以进行设置的。</p>
<p>固定定位： 就是直接对于视口定位。 1. 并且元素变成了定位元素。 2.
脱离了文档流。</p>
<p>粘性定位： <code>position: sticky;</code>
参考点是离它最近的拥有滚动行为的祖先元素。包含粘性定位元素的父容器也不在视图上时，胶水就失效了。</p>
<p>这几个定位的层级是平等的。</p>
<h4 id="z-index">z-index</h4>
<p>属性 <code>z-index</code>(纯数值，没有单位) 就相当于 <code>z</code>
轴上的坐标，<code>z</code>
越大，层级越高，所以在屏幕上显示的优先级越高。</p>
<h4 id="布局">布局</h4>
<p>版心的大小一般是 900 - 1200 px <img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%90%8D%E8%AF%8D.png" class></p>
<h4 id="重置默认样式">重置默认样式</h4>
<ol type="1">
<li>使用全局选择器
在简单的案例中，我们可能使用这种方式，但是实际开发中我们不会使用。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123; padding: 0px; margin: 0px; &#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>reset.css</code>
可以是自己一直以来的一个标准模板，也可以是使用一些公司开源的自己的
<code>reset.css</code>(比如小米、阿里...)</li>
<li><code>Normalize.css</code>
是一种最新方案，它再清楚默认样式的基础上，保留了一些有价值的默认样式。
这是一个标准化的东西，有很多的网站和用户去维护这个东西。
http://necolas.github.io/normalize.css/</li>
</ol>
<h4 id="练习">练习</h4>
<img src="/.com//09/01/CSS%E8%AE%B0%E5%BD%95/%E7%BB%83%E4%B9%A01.png" class>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        .leftfix &#123;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .rightfix &#123;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .clearfix &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: 960px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        .top-header &#123;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 80px; </span><br><span class="line">        &#125;</span><br><span class="line">        .logo,</span><br><span class="line">        .banner1,</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 80px;</span><br><span class="line">            line-height: 80px;</span><br><span class="line">        &#125;</span><br><span class="line">        .logo &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner1 &#123;</span><br><span class="line">            width: 540px;</span><br><span class="line">            margin: 0 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .menu &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 30px;</span><br><span class="line">            margin: 10px auto;</span><br><span class="line">            line-height: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item1,</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            height: 198px;</span><br><span class="line">            width: 368px;</span><br><span class="line">            border: solid black 1px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item3,</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            width: 178px;</span><br><span class="line">            height: 198px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item7,</span><br><span class="line">        .item8,</span><br><span class="line">        .item9 &#123;</span><br><span class="line">            width: 198px;</span><br><span class="line">            height: 128px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">            line-height: 128px;</span><br><span class="line">        &#125;</span><br><span class="line">        .footer &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            line-height: 60px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;!--header--&gt;</span><br><span class="line">        &lt;div class=&quot;top-header clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;logo leftfix&quot;&gt;</span><br><span class="line">                logo</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner1 leftfix&quot;&gt;</span><br><span class="line">                banner1</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner2 leftfix&quot;&gt;</span><br><span class="line">                banner2</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--menu--&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            菜单</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--content--&gt;</span><br><span class="line">        &lt;div class=&quot;content clearfix&quot;&gt;</span><br><span class="line">            &lt;!--left--&gt;</span><br><span class="line">            &lt;div class=&quot;left-content leftfix&quot;&gt;</span><br><span class="line">                &lt;!--top--&gt;</span><br><span class="line">                &lt;div class=&quot;top-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item1 leftfix&quot;&gt;</span><br><span class="line">                        栏目一</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item2 leftfix&quot;&gt;</span><br><span class="line">                        栏目二</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;!--bottom--&gt;</span><br><span class="line">                &lt;div class=&quot;bottom-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item3 leftfix&quot;&gt;栏目三&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item4 leftfix&quot;&gt;栏目四&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item5 leftfix&quot;&gt;栏目五&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item6 leftfix&quot;&gt;栏目六&lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--right--&gt;</span><br><span class="line">            &lt;div class=&quot;right-content leftfix&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;item7&quot;&gt;栏目七&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item8&quot;&gt;栏目八&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item9&quot;&gt;栏目九&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--footer--&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">            页脚</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>调整背景图的位置用 <code>background-position:xxx;</code></p>
<p>布局里面，一堆东西横向排列一堆东西纵向排列，而且这一堆东西还很相似，往往我们都用
ul li</p>
<p>大多数情况都是给子元素开启固定定位，给父元素开启相对定位。</p>
<p>img
方式引入图片的话，我们不需要给出宽和高，就是图片默认的宽和高。但是
<code>div</code> 设置图片背景的时候，<code>div</code>
必须先有宽和高，才能显示图片。</p>
]]></content>
      <tags>
        <tag>CSS, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2023/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>具体的更多可以参见代码 <code>GetTreeOrderNor.cpp</code> 和
<code>ParseTreeSequence.cpp</code></p>
<p>这是一段输入先序遍历和中序遍历输出后序遍历的代码。 <figure class="highlight plaintext"><figcaption><span><iostream></iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    public:</span><br><span class="line">        char value;</span><br><span class="line">        TreeNode* leftChild;</span><br><span class="line">        TreeNode* rightChild;</span><br><span class="line">        TreeNode(char val) : value(val), leftChild(nullptr), rightChild(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* buildTree(std::vector&lt;char&gt; preOrder, std::vector&lt;char&gt; inOrder) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;char, int&gt; vis;</span><br><span class="line">    for (int i = 0; i &lt; inOrder.size(); ++i) &#123;</span><br><span class="line">        vis[inOrder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = new TreeNode(preOrder[0]);</span><br><span class="line">    s.push(root);</span><br><span class="line">    for (int i = 1; i &lt; preOrder.size(); ++i) &#123;</span><br><span class="line">        TreeNode* curNode = new TreeNode(preOrder[i]);</span><br><span class="line">        TreeNode* parent = nullptr;</span><br><span class="line">        while (!s.empty() &amp;&amp; vis[s.top()-&gt;value] &lt; vis[preOrder[i]]) &#123;</span><br><span class="line">            parent = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent) &#123;</span><br><span class="line">            parent-&gt;rightChild = curNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            s.top()-&gt;leftChild = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(curNode);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPostOrder(TreeNode* root) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;TreeNode*, bool&gt; tag;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    while (!s.empty() || cur) &#123;</span><br><span class="line">        if (cur) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;leftChild;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (tag[s.top()] == 1) &#123;</span><br><span class="line">                std::cout &lt;&lt; s.top()-&gt;value;</span><br><span class="line">                s.pop();</span><br><span class="line">                cur = nullptr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tag[s.top()] = 1;</span><br><span class="line">                cur = s.top()-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string pre, in;</span><br><span class="line">    while (std::cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">        std::vector&lt;char&gt; preOrder(pre.begin(), pre.end());</span><br><span class="line">        std::vector&lt;char&gt; inOrder(in.begin(), in.end());</span><br><span class="line">        TreeNode* root = buildTree(preOrder, inOrder);</span><br><span class="line">        getPostOrder(root);</span><br><span class="line">        std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>matlab记录</title>
    <url>/2023/08/26/matlab%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<img src="/.com//08/26/matlab%E8%AE%B0%E5%BD%95/matlab%E7%82%B9%E4%B9%98%E7%82%B9%E9%99%A4.png" class>
<p>x:y:z 一般表示 x 初值 y 步长 z 终值</p>
<p>if - end 和 if - else - end</p>
<p>x(i) 访问 x 数组中下标为 i 的元素</p>
<p>meshgrid
函数是MATLAB中用于生成网格采样点数的函数，通常进行2D、3D图形的绘制。
<img src="/.com//08/26/matlab%E8%AE%B0%E5%BD%95/meshgrid%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC.png" class> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = -10:0.5:10;</span><br><span class="line">y = -10:0.5:10;</span><br><span class="line">[xx, yy] = meshgrid(x, y);</span><br><span class="line">z = xx .^2 - yy .^2;</span><br><span class="line">mesh(xx, yy, z);</span><br></pre></td></tr></table></figure></p>
<p>https://blog.csdn.net/qq_54186956/article/details/127274462 sym syms
函数应用</p>
<img src="/.com//08/26/matlab%E8%AE%B0%E5%BD%95/subs%E5%87%BD%E6%95%B0.png" class>
<p>在命令行输入 <code>format rat</code>
后，输出为分数格式，不再约成小数。</p>
<p>在命令行输入 <code>doc xxx</code> 可以直接查看官方解释
<code>xxx</code> 函数的文档。</p>
<p><code>num2str(xxx)</code> 其中 xxx
是一个数，转换一个行向量，每个字符代表向量的一个元素</p>
<p><code>result = [s1, s2]</code> 进行字符串拼接</p>
<img src="/.com//08/26/matlab%E8%AE%B0%E5%BD%95/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.jpg" class>
<p>提取矩阵的行数：<span class="math inline">\(length(A(:,1))\)</span>
提取矩阵的列数：<span class="math inline">\(length(A(1,:))\)</span></p>
<p>matlab 中读取图片和显示图片函数 <code>imread</code> 和
<code>imshow</code>
https://blog.csdn.net/dp327264/article/details/105087849</p>
<p><code>subplot</code> 函数是将多个图片画到一个画面上的工具
<code>subplot(m,n,p)</code> 表示 m 行 n 列从左到右 从上到下第 p 个</p>
<p>灰度图像二值化：图像二值化（ Image
Binarization）就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。
在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p>
<p>matlab 中关于数字图像处理的工具箱是 IPT(Image Processing Toolbox)</p>
<img src="/.com//08/26/matlab%E8%AE%B0%E5%BD%95/%E7%81%B0%E5%BA%A6%E5%9B%BE.png" class>
<p>对于汉字处理的话，灰度图会引入误差，所我们转化为二值图。</p>
<p><code>find(xx)</code> 函数可以返回满足 xx 条件的下标组成的行向量。
例如 <code>x=[1 2 3 4 5 6 7]; find(x &gt;= 5)</code>
返回的就是：<code>5     6     7</code></p>
<p><code>max(A)</code> A 可以是矩阵或者向量，就是返回其中最大的元素</p>
<p>元组是matlab的数据类型之一，其元胞中可存储文本，数值，矩阵等等不同的数据类型，因此应用较为方便。因此，在采用matlab进行数据处理时，对元组的创建、读取、写入、转化函数的掌握尤为重要。
<code>cell(dim)</code> 是创建 dim<span class="math inline">\(\times\)</span>dim维的空元组，下标必须是正整数，不能是
0.</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
<<<<<<< HEAD
    <title>python爬虫</title>
    <url>/2023/09/04/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h4 id="识别网页所用技术">识别网页所用技术</h4>
<p>构建网站所用的技术类型会对我们如何爬取信息产生影响。有一个十分有用的工具可以检查网站构建的技术类型--detectem
模块，该模块需要 python3.5+ 环境以及 Docker</p>
<h4 id="python-读写文件">python 读写文件</h4>
<ol type="1">
<li>open() + close() <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先打开文件：</span><br><span class="line">f = open(&#x27;C:\\Users\\Administrator\\Desktop\\测试文件.txt&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">#再使用read()方法，查看文件里的内容：</span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line">$关闭文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure> 注意如果使用
<code>open</code>，结尾一定要使用close（）来关闭文件。原因主要是：</li>
=======
    <title>数据结构关键记录</title>
    <url>/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="课堂笔记">课堂笔记</h3>
<p>2023-9-6 #### 链表</p>
<p>TO DO 定义一个模板类 ?</p>
<p>如何判断链表是否有环 1. 使用 map
对于地址打上标记，如果同一个地址被访问了两次就是有环的。 2.
快慢指针(Floyd's Cycle Detection Algorithm)，使用同余方程得到 <span class="math inline">\(a + kp\)</span> 和 <span class="math inline">\(b +
kq \pmod{n}\)</span>，其中 a b 分别是两个指针进入环的初始步长，k
是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 <span class="math inline">\(b - a \equiv k(p - q)\)</span> 它们的步长差值为 1
的时候可以始终保证同余。</p>
<p>对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为
1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。
下面是一段 Python 程序演示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure> ##### 找出有环链表的入环点
可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S
点，入环点是 T 点，绿色的部分是慢指针所走过的路程。
对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S
点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。
可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以
ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。
<img src="/.com//09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class></p>
<h5 id="floyd-判圈算法和-brent-判圈算法">Floyd 判圈算法和 Brent
判圈算法</h5>
<p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。
其实上面的快慢指针方法就是 Floyd
判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。
还有一种判圈的算法，比它更快，就是 <strong>Brent</strong>
判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第
n 轮，乌龟跳到兔子的位置，兔子走<span class="math inline">\(2^{n-1}\)</span>步。</p>
<h5 id="扩展">扩展</h5>
<p>在申明类中的成员函数后面加上 <code>const</code>
函数就成了只读函数，如
<code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure> &gt;
静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字"static"的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure> 函数指针的应用： 1. 把函数作为参数传入另一个函数
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2. 第二个例子，排序上的应用 使用 <code>ascending</code> 和
<code>descending</code> 两个函数代替大小判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> lambda
函数的书写结构： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <!-- 
函数指针应用？lambda 函数？ 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- STL 中的**迭代子类**？？ --&gt;</span><br><span class="line"></span><br><span class="line">#### 分而治之 divide-and-conquer</span><br><span class="line">##### 归并排序</span><br><span class="line">一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</span><br><span class="line">&gt; 整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 **性质滚性质**，一直带动，所以可以达到加速的目标。</span><br><span class="line">&#123;%asset_img 时间复杂度计算.png%&#125;</span><br><span class="line"></span><br><span class="line">TO DO:</span><br><span class="line">？？非递归版本的归并排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 快速排序</span><br><span class="line">&lt;!-- 快速排序时间复杂度</span><br><span class="line">最坏 概率统计的意义下？ --&gt;</span><br><span class="line">关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点...</span><br><span class="line">&#123;%asset_img 快速排序算法.png%&#125;</span><br><span class="line">关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</span><br><span class="line">&#123;%asset_img 快速排序时间复杂度.png%&#125;</span><br><span class="line">&#123;%asset_img 快速排序平均时间复杂度.png%&#125;</span><br><span class="line">上面摘自知乎 https://zhuanlan.zhihu.com/p/341201904</span><br><span class="line">##### 2-D maxima finding problem</span><br><span class="line">这是一个 maxima 问题，一般这种问题有两种解决方式。</span><br><span class="line">1. 排序法</span><br><span class="line">&#123;%asset_img 排序法极大点.png%&#125;</span><br><span class="line">2. 分治法</span><br><span class="line">&#123;%asset_img 分治法极大点.png%&#125;</span><br><span class="line">摘自知乎 https://zhuanlan.zhihu.com/p/27850478</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- 平面极大点</span><br><span class="line">分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 --&gt;</span><br><span class="line"></span><br><span class="line">##### the closest pair problem</span><br><span class="line">感觉 OI-Wiki 讲解的很全面</span><br><span class="line">https://oi-wiki.org/geometry/nearest-points/</span><br><span class="line">还有推广：平面最小周长三角形</span><br><span class="line">$\dfrac&#123;d \times 2d&#125;&#123;\frac&#123;1&#125;&#123;4&#125; \times \pi \times (\frac&#123;d&#125;&#123;2&#125;)^&#123;2&#125;&#125;$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</span><br><span class="line"></span><br><span class="line">&lt;!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）</span><br><span class="line"></span><br><span class="line">时间复杂度？ --&gt;</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### the convex hull problem</span><br><span class="line">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- ?</span><br><span class="line">一个著名算法，礼物算法？ Jarvis March</span><br><span class="line">首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着</span><br><span class="line">不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了</span><br><span class="line">但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去</span><br><span class="line">找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 --&gt;</span><br><span class="line"></span><br><span class="line">##### matrix multiplication </span><br><span class="line">&lt;!-- ?</span><br><span class="line">P Q R S T U V?</span><br><span class="line">时间复杂度大概是 $O(\log_2(7)) \approx O(n^&#123;2.81&#125;)$?</span><br><span class="line">但是仍然不是最优的，具体可以自己去搜索一下 --&gt;</span><br><span class="line">使用类实现的矩阵的一些基础操作，可以看 `Fibonacci.cpp`</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### FFT</span><br><span class="line">分治做法，见 `FFT.md` 和 `FFT.cpp`(使用自带的 complex 类实现)</span><br><span class="line">其中，使用自己手写类实现的 FFT 在 `FFTClass.cpp`</span><br><span class="line">(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</span><br><span class="line"></span><br><span class="line">##### Medians and Order Statistics</span><br><span class="line">对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log&#123;n&#125;)$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</span><br><span class="line">每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</span><br><span class="line">还有一种递归的算法，分为 5 个数，</span><br><span class="line"></span><br><span class="line">nth_element() ?? 函数</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。</span><br><span class="line">只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。</span><br><span class="line">为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</span><br><span class="line"></span><br><span class="line">##### Abstract Data Type(ADT)</span><br><span class="line">抽象数据类型</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</span><br><span class="line">不想改变内部元素的时候记得加 const，如果不加的话，`void Func(const List&amp; l) &#123; l.print(); &#125;` 其中不允许调用，因为 Func 有修改成员变量的风险。</span><br><span class="line">**常引用？**</span><br><span class="line">**把函数当作函数的参数？**</span><br><span class="line">派生类禁止父类的函数或者方法？ </span><br><span class="line">括号匹配问题 Bracket Matching Problem</span><br><span class="line">计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</span><br><span class="line">双端队列 dequeue</span><br><span class="line">环形数组</span><br><span class="line"></span><br><span class="line">#### 递归消除</span><br><span class="line">##### 一般性消除办法</span><br><span class="line">- 利用堆栈，模拟栈来实现，见 `Hanoi.cpp`</span><br><span class="line"></span><br><span class="line">汉诺塔问题 递归求解，如何去掉递归求解。</span><br><span class="line">$f_n = 2 f_&#123;n - 1&#125; + 1$，所以 $(f_n + 1) = 2(f_&#123;n - 1&#125; + 1)$</span><br><span class="line"></span><br><span class="line">##### 倒水问题</span><br><span class="line">这种任务方案其实挺多的。其实，背后对应的是**辗转相除法**。</span><br><span class="line">我们可以倒出来的水的数量就是余数。</span><br><span class="line">设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 `ax + by = c`，如果有解，就是 $\gcd&#123;(a, b)&#125; | c$</span><br><span class="line"></span><br><span class="line">##### 求解组合数</span><br><span class="line">https://oi-wiki.org/math/combinatorics/combination/ 见 OI-Wiki各种组合数公式</span><br><span class="line">https://zhuanlan.zhihu.com/p/602675596 二项式反演</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是**过于耦合了**。所以，对于一个类来说，接口是很重要的。</span><br><span class="line"></span><br><span class="line">##### lowbit</span><br><span class="line"></span><br><span class="line">#### 树和二叉树</span><br><span class="line">树中所有节点度数的最大值叫做整个树的度。</span><br><span class="line"></span><br><span class="line">##### 树的表示</span><br><span class="line">一共有四种表示树的方式：</span><br><span class="line">1. 树形结构。很直观、形象</span><br><span class="line">2. 文氏图表示法。使用集合以及集合的包含关系描述树结构。</span><br><span class="line">3. 凹入表示法。使用线段的伸缩描述树结构。</span><br><span class="line">4. 括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</span><br><span class="line"></span><br><span class="line">树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</span><br><span class="line"></span><br><span class="line">按层次遍历二叉树，可能还是比较吃内存的。</span><br><span class="line">DLR LDR LRD </span><br><span class="line">前序 中序 后序 和 根的区别？</span><br><span class="line"></span><br><span class="line">##### 非递归遍历</span><br><span class="line">对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 `GetTreeOrderNor.cpp` </span><br><span class="line">递归形式参见 `GetTreeOrderRecursion.cpp` </span><br><span class="line">给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 `ParseTreeSequence.cpp`</span><br><span class="line"></span><br><span class="line">##### 中序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">这样也可以充分利用空间</span><br><span class="line">将叶子节点的右孩子指向下一个应改遍历的节点(因为一开始叶子节点的右孩子是 null，造成了浪费)</span><br><span class="line">并且加一个 bool 类型的变量，表示这个节点的右孩子是不是进行了修改。</span><br><span class="line">这样中序遍历的时候好像也会简单很多(在中序遍历的意义下，将二叉树变成了一个单链表)</span><br><span class="line">这样二叉树的遍历就不再依赖于堆栈，并且产生了向前向后的两个方向，和双链表的行为是比较相似的。</span><br><span class="line"></span><br><span class="line">##### 前序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">顺序建立就是修改右子树</span><br><span class="line">但是如果反过来会出现左孩子已经被占用的问题，此时需要借助堆栈</span><br><span class="line"></span><br><span class="line">##### 后序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%asset_img 线索二叉树.png%&#125;</span><br><span class="line"></span><br><span class="line">#### 堆</span><br><span class="line"></span><br><span class="line">##### 二叉堆</span><br><span class="line"></span><br><span class="line">当我们谈论到堆(Heap)时，通常指的是二叉堆(Binary Heap)，它是一种特殊的树形结构，常用于实现优先队列和一些图算法(物理存储上是数组，但是逻辑结构上是二叉树，这也是为什么我们可以使用 vector 来模拟的原因)。</span><br><span class="line"></span><br><span class="line">堆的性质：</span><br><span class="line">1. 二叉树结构：堆是一种完全二叉树，除了最后一层，别的层的节点都是满的，最后一层的节点从左向右填充。</span><br><span class="line">2. 小根堆：任何父节点的值都小于等于其子节点的值。</span><br><span class="line">3. 不唯一性：对于给定的数据集，可能存在多个不同的最小堆或者最大堆。</span><br><span class="line">4. 只是保证了节点的权值大于两个儿子节点的权值，也就是说，堆维护的更是我们关注的相对大小关系，尤其是最顶部的元素大小，我们并不关心全序大小关系(也无法维护)。</span><br><span class="line"></span><br><span class="line">&gt;   在实际中，实现堆（Heap）通常更倾向于使用向量（数组）来模拟二叉树的结构，而不是构建一个显式的二叉树数据结构。</span><br><span class="line"></span><br><span class="line">##### 二项堆</span><br><span class="line"></span><br><span class="line">##### Fibonacci 堆</span><br><span class="line"></span><br><span class="line">##### lazy 机制</span><br><span class="line"></span><br><span class="line">上面的最简单的二叉堆做法呢，我们很好地利用了二叉树序号之间的关系(父子的序号有关系)，但是我们在更新的时候每一次都是 $\log&#123;n&#125;$ 的复杂度，不是很优，比如说有些元素我们以后根本用不到，而堆又本身不是关注全序关系的，所以我们可以利用 lazy 机制。</span><br><span class="line"></span><br><span class="line">TODO </span><br><span class="line">现在库里面的堆，基本上都不是基于 **二叉堆**(Binary Heap) 实现的。</span><br><span class="line">Fibonacci 堆 也是希望我们去更多地了解一些堆。</span><br><span class="line">堆的合并、二叉堆的合并？</span><br><span class="line">二项堆</span><br><span class="line">重载运算符</span><br><span class="line"></span><br><span class="line">#### 编码问题</span><br><span class="line"></span><br><span class="line">结构光扫描中，我们如何马上知道这条光是第几条光？就要用到编码了</span><br><span class="line">能不能发明一种序列，使得连续的几个在序列中是唯一的，longest ？ 是多长？</span><br><span class="line">3 个颜色的话，先画出 27 个节点。RRR 的话，连接 RRG RRB(它的后继节点)</span><br><span class="line">寻找访问序列最长的，而且不能重复</span><br><span class="line">深度遍历可以吗？最好不要写递归，可以队列、栈</span><br><span class="line"></span><br><span class="line">#### 霍夫曼树</span><br><span class="line"></span><br><span class="line">每一次找权值最小两个节点，变为 n - 1 个节点</span><br><span class="line">1. 能不能构建出来</span><br><span class="line">2. 总体的最小代价</span><br><span class="line">可以搜索霍夫曼树的题目</span><br><span class="line">实现持久化的最小两个数？手写优先队列？平衡树？</span><br><span class="line"></span><br><span class="line">#### 左倾堆 / 左倾树 / 左偏堆 / 左偏树</span><br><span class="line"></span><br><span class="line">虽然二叉堆的插入、删除操作挺好的，但是不支持合并。所以我们想寻找一种数据结构使得堆在合并的时候比较高效。</span><br><span class="line">&gt; Leftist Heap is a priority queue data structure that also supports merge of heaps in O(log n) time.</span><br><span class="line"></span><br><span class="line">FHQ Treap TODO</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji TODO</span><br><span class="line"></span><br><span class="line">最优传输理论</span><br><span class="line"></span><br><span class="line">启发式合并堆</span><br><span class="line"></span><br><span class="line">#### 二叉平衡树</span><br><span class="line"></span><br><span class="line">可以证明平衡二叉树的高度为 $\log&#123;n&#125;$ 吗？</span><br><span class="line"></span><br><span class="line">N(h) = 1 + N(h - 1) + N(h - 2); AVL 树的高度推导 N(h) 表示高度为 h 时最不平衡时的节点个数。</span><br><span class="line"></span><br><span class="line">我们是按照左右子树的树高度之差来定义的，这只是定义平衡的一种。但是还有很多别的方式，比如左右子树的节点。</span><br><span class="line"></span><br><span class="line">维护平衡的机制有很多种，比如说典型的 B 树，2-3-4树，它所有的叶子都在同一个高度上面。它最不满的情况就是一个满二叉树，所以它可以保证高度在 $\log$ 级别。</span><br><span class="line"></span><br><span class="line">AVL B树 红黑树 234树 Treap</span><br><span class="line">红黑树的实际应用比较频繁，它的效率比较高一点。红黑树和 234树之间的关系？？ TODO</span><br><span class="line"></span><br><span class="line">插入的时候常常面临三种情形。</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/MashPlant/solution2-p3369 B 树代码</span><br><span class="line"></span><br><span class="line">LCT问题？ Link Cut Tree</span><br><span class="line"></span><br><span class="line">Treap 的高度 log 证明？</span><br><span class="line"></span><br><span class="line">#### the mathematics of rubik&#x27;s cube</span><br><span class="line"></span><br><span class="line">#### Dijkstra 算法</span><br><span class="line"></span><br><span class="line">正确性证明？</span><br><span class="line"></span><br><span class="line">多边形</span><br><span class="line"></span><br><span class="line">差分约束问题 线性规划问题 max \sum d 要求比 dijkstra 更加严苛？</span><br><span class="line"></span><br><span class="line">Gorubi </span><br><span class="line"></span><br><span class="line">最短路的话线性规划没有 dijkstra 更加优</span><br><span class="line"></span><br><span class="line">A* 算法？</span><br><span class="line"></span><br><span class="line">#### 二叉树在区间上？</span><br><span class="line"></span><br><span class="line">维护直接的 Rank 感觉代价过于高，因为每一次删除和插入都要把其余元素都改变一次，所以我们不直接维护 Rank。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二叉树序列化？https://zhuanlan.zhihu.com/p/26418233</span><br><span class="line"></span><br><span class="line">#### 线段相交的问题</span><br><span class="line"></span><br><span class="line">两个结构：</span><br><span class="line">1. 处理事件的优先队列(关键位置停下来，遇到了水平线段的左端点，遇到了水平线段的右端点，遇到了竖直线段)(需要使用一个二叉树维护水平线段，包括水平竖直关系)(水平线段的 y 高度使用二叉树维护了？树套树？)</span><br><span class="line">2. 维护扫描的每个关键位置的全序列表</span><br><span class="line"></span><br><span class="line">#### kd 树</span><br><span class="line"></span><br><span class="line">grid 2d tree</span><br><span class="line">quadtree(四叉树，每一个格子一分为 4) bsptree(每一次有一个平面，对于所在的平面二分，在二维的情况下就是直线)</span><br><span class="line"></span><br><span class="line">上面的结构，除了 grid 的应用都是很多的。各自在不同的应用场景下使用。</span><br><span class="line"></span><br><span class="line">kd 树其实是 bst 树的延申。可是很多时候一维数据是不够的，很多情况都是高维的东西。在机器学习中应用也很多。</span><br><span class="line">ray tracing</span><br><span class="line">2d range serach</span><br><span class="line"></span><br><span class="line">从乱序中在 O(n) 的时间复杂度下找出中位数。</span><br><span class="line"></span><br><span class="line">1. 每一刀下去，都是将矩形分为两个部分。</span><br><span class="line">2. 奇偶相间，第一层竖线划分，第二层就是水平划分。(优化就是把点很紧密的包在一块？)</span><br><span class="line"></span><br><span class="line">nth_element 严格 O(n) 查找中位数</span><br><span class="line"></span><br><span class="line">#### 跳表 Skip List</span><br><span class="line"></span><br><span class="line">跳表是相对年轻的一个数据结构，1990 年由 Bill Pugh 提出。</span><br><span class="line">我们需要区分一下数据域和指针域</span><br><span class="line">https://www.cnblogs.com/bigsai/p/14193225.html</span><br><span class="line"></span><br><span class="line">#### KMP</span><br><span class="line"></span><br><span class="line">前缀和后缀的问题</span><br><span class="line"></span><br><span class="line">BM 算法？</span><br><span class="line"></span><br><span class="line">DFA</span><br><span class="line"></span><br><span class="line">#### 并查集(Union-find)</span><br><span class="line"></span><br><span class="line">虽然并查集的代码是最少的一个，但是确实非常有用的。它可以解决**等价类**相关的问题。</span><br><span class="line"></span><br><span class="line">link-by-size 按照大小合并，此时最高高度不超过 log n</span><br><span class="line">当然也有按照 rank(height)高度合并。</span><br><span class="line"></span><br><span class="line">还有路径压缩(path compression)</span><br><span class="line"></span><br><span class="line">无路径压缩的时候，复杂度是 $m \log n$</span><br><span class="line">有路径压缩的时候，复杂度是 $m \alpha (m, n)$</span><br><span class="line">其中，$\alpha$ 是反阿克曼函数。</span><br><span class="line"></span><br><span class="line">#### 图</span><br><span class="line"></span><br><span class="line">每一个节点有 in 和 out 两个邻接表</span><br><span class="line"></span><br><span class="line">矩阵的形式存储的时候，可能并行化运算的时候更加容易。</span><br><span class="line"></span><br><span class="line">prim 求最小生成树</span><br><span class="line"></span><br><span class="line">稠密图和稀疏图使用不同的堆复杂度还不一样？？</span><br><span class="line"></span><br><span class="line">Kruskal 实现最小生成树</span><br><span class="line"></span><br><span class="line">稀疏图 prim 和 kruskal 复杂度差不多，但是稠密图中似乎 prim 算法比较好。</span><br><span class="line"></span><br><span class="line">cut 割</span><br><span class="line"></span><br><span class="line">割中最小权值的边一定出现在最小生成树上 证明了 Prim 的正确性？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 欧拉回路问题</span><br><span class="line"></span><br><span class="line">桥 bridge 它的去除，影响了整个图的连通性</span><br><span class="line"></span><br><span class="line">证明方式</span><br><span class="line"></span><br><span class="line">如何找到欧拉回路(两种算法)?</span><br><span class="line"></span><br><span class="line">Fleury&#x27;s Algorithm 此时经常有一种方法和它相提并论，Hierholzer(希尔霍尔策算法) 算法，后者实际上运行效率会更高一点(标记的注意事项？)，感觉有一个硬伤，并查集没有办法递增式构建？？。</span><br><span class="line"></span><br><span class="line">欧拉骰子？？</span><br><span class="line"></span><br><span class="line">相联系的有一个哈密顿回路问题。</span><br><span class="line"></span><br><span class="line">#### </span><br><span class="line"></span><br><span class="line">### 作业</span><br><span class="line"></span><br><span class="line">1. 手写一个 List</span><br><span class="line"></span><br><span class="line">见 `List.cpp` `LinkList.h` `LinkList.cpp` </span><br><span class="line">其中，`List.cpp` 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 `Node&lt;T&gt;*` 的形式。</span><br><span class="line">但是在 `LinkList.h` 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 `&lt;T&gt;` 了，这种形式也是我们更加推荐的。</span><br><span class="line"></span><br><span class="line">2. 手写一个面向对象的快速排序</span><br><span class="line">`quick_sort.cpp` 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢</span><br><span class="line">其中，需要注意`函数对象`的写法。</span><br><span class="line"></span><br><span class="line">非递归版本：</span><br><span class="line">**双指针前移法**</span><br><span class="line">感觉很强，短小精悍</span><br><span class="line">见 `QuickSortNor.cpp`</span><br><span class="line">使用自己手写的栈，实现了对于类的非递归版本的快速排序。</span><br><span class="line"></span><br><span class="line">3.  </span><br><span class="line">&lt;!-- 基于自己写的链表</span><br><span class="line">实现堆栈</span><br><span class="line">放在不同的文件中</span><br><span class="line">想规范一下大家写代码习惯 --&gt;</span><br><span class="line">在这次的作业中，注意：</span><br><span class="line">我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template&lt;class E&gt;</span><br></pre></td></tr></table></figure> template<class U> friend std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, const LinkList<U>&amp; list); ```
其中，ostream 是一种返回类型。</p>
<ol start="4" type="1">
<li></li>
>>>>>>> 9765a0451f8c3a7c1034c7182fd8d7d06b4ad395
</ol>
<ul>
<li>节约资源和内存耗损；</li>
<li>可以释放所占用的系统资源并尽早将文件置于更安全的状态，只有关闭文件后，文件内容才能同步到磁盘。</li>
</ul>
<ol start="2" type="1">
<li><code>with open</code> 推荐使用 with
的作用相当于调用close（）方法，因此当我们使用with open(
)在对文件操作完成后，无需通过close()关闭文件，文件会自动关闭，这种方法的安全系数更高，同时也避免了有些时候忘记关闭文件的毛病。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;file_name&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;) as f:</span><br></pre></td></tr></table></figure> <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class> <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class></li>
</ol>
<h4 id="python-requests-模块">python requests 模块</h4>
<p>python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP
请求，并获取响应结果。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response = requests.get(url=url, headers=headers)</span><br></pre></td></tr></table></figure> 返回一个 response
对象，该对象包含了具体的响应信息，如状态码、响应头(200 OK 404
NotFound)、响应内容等。 对于其中的content 和 text 属性</p>
<blockquote>
<p>content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b'这样的标志，这是字节字符串的标志，而text是，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode('utf-8')，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 发送GET请求</span><br><span class="line">url = &#x27;https://example.com/some-page&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"># 尝试获取内容的编码方式</span><br><span class="line">encoding = response.apparent_encoding ## 来尝试获取爬取内容的编码方式。这个属性会尝试根据响应内容来猜测编码方式，通常用于解决服务器没有显式提供编码信息的情况。</span><br><span class="line"></span><br><span class="line"># 设置编码方式并解码内容</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line"></span><br><span class="line"># 打印内容</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们一般可以爬取网页的 <code>html</code> 代码。</p>
<h4 id="python-标准库-os-模块">python 标准库 os 模块</h4>
<p>Python的os模块是一个用于与操作系统交互的内置模块。它提供了许多功能，允许你执行各种文件和目录操作，例如创建、删除、移动和重命名文件和目录，以及检查文件和目录的属性。下面是一些os模块的常见用法和功能：
1. 获取当前工作目录(current work directory) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current_directory = os.getcwd()</span><br><span class="line">print(current_directory)</span><br></pre></td></tr></table></figure> 2.
列出目录中的文件和子目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">files_and_dirs = os.listdir(&#x27;/path/to/directory&#x27;)</span><br><span class="line">print(files_and_dirs)</span><br></pre></td></tr></table></figure> 3. 创建目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.mkdir(&#x27;/path/to/new_directory&#x27;)</span><br></pre></td></tr></table></figure> 4.
删除目录 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.rmdir(&#x27;/path/to/directory_to_delete&#x27;)</span><br></pre></td></tr></table></figure> 5. 检查文件或者目录是否存在 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if os.path.exists(&#x27;/path/to/file_or_directory&#x27;):</span><br><span class="line">    print(&quot;存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不存在&quot;)</span><br></pre></td></tr></table></figure> 其他 os
模块 <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/os%E6%A8%A1%E5%9D%97.png" class></p>
<h4 id="xpath">XPath</h4>
<p>XPath（XML Path
Language）是一种用于在XML文档中定位和选择元素的查询语言。它是一种重要的标准，广泛用于XML文档的解析和数据提取。XPath不仅可以用于XML文档，还可以用于HTML文档，因此它在Web开发和数据抓取中也非常有用。
(感觉可能类似于正则表达式？只是另一种不同的方式) <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/xpath.png" class>
<img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E6%9C%AA%E7%9F%A5%E8%8A%82%E7%82%B9.png" class></p>
<h4 id="正则表达式">正则表达式</h4>
<p><code>Regular Expression</code> 或者简称 <code>regex, RE</code>.
它的设计思想是用一种<strong>描述性的语言</strong>来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<h4 id="re-库">RE 库</h4>
<p>RE 库就是正则表达式库，通过 RE
库我们可以匹配某些特定字符串的一些内容，比如爬虫爬取网页的时候，通过 RE
库可以获取网页内容中的某些特定标签内容。 量词： <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E9%87%8F%E8%AF%8D.png" class> 字符类：
- <code>[]</code>: 匹配括号内的任意一个字符。例如 <code>[abc]</code>
匹配字符 a、b 或者 c - <code>[^ ]</code>:
匹配括号内字符以外的任意一个字符。例如 [^abc] 就是除了
a、b或者c以外的任意字符。 <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png" class></p>
<h5 id="常用函数">常用函数</h5>
<ul>
<li><code>re.search(pattern, string, flags=0)</code>
在字符串中搜索第一个匹配的模式，并返回一个匹配对象。</li>
<li><code>re.match(pattern, string, flags=0)</code>
在字符串的开头匹配模式，并返回一个匹配对象。</li>
<li><code>re.findall(pattern, string, flags=0)</code>
返回一个包含所有匹配项的列表。</li>
<li><code>re.sub(pattern, repl, string, count=0, flags=0)</code>
用指定的替换字符串替换匹配的文本。</li>
<li><code>re.split(pattern, string, maxsplit=0, flags=0)</code>
根据模式拆分字符串。 其中 <code>flags</code>
是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。
&gt; 在Python中，前缀r表示一个原始字符串（raw
string）。原始字符串中的反斜杠字符，而不会被解释为转义字符。这在处理正则表达式等包含大量反斜杠的字符串时非常有用，因为正则表达式模式本身通常包含许多反斜杠，这些反斜杠需要被保留而不被解释为转义字符。</li>
</ul>
<h4 id="python-爬取图片简单示例">python 爬取图片简单示例</h4>
<p>我们打开一个下载图片的网址 https://pic.netbian.com/new/
我们向这个网站发送请求以后获得的 <code>text</code> 就是网站的
<code>html</code> 代码。我们分析一下其中的 <code>html</code> 代码
<img src="/.com//09/04/python%E7%88%AC%E8%99%AB/html%E4%BB%A3%E7%A0%81.png" class> 其中的 <code>/uploads/allimg/xxx</code>
就是我们的图片的具体地址。 我们可以使用正则表达式(re 库)来获取
<code>html</code> 代码中所有符合图片格式的地址，然后存储到
<code>img</code> 中。再向图片的具体地址发送请求，此时我们使用 python
的文件读写(二进制模式)，就可以批量地将图片下载下来了。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url = &quot;https://pic.netbian.com/&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encoding = response.apparent_encoding</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line">parr = re.compile(&#x27;src=&quot;(/u.*?)&quot;.alt=&quot;(.*?)&quot;&#x27;) # 匹配图片链接和图片名字 使用正则表达式</span><br><span class="line">image = re.findall(parr, text) # 所有的图片链接</span><br><span class="line">path = &quot;photos&quot;</span><br><span class="line">if not os.path.isdir(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">for i in image:</span><br><span class="line">    link = i[0]</span><br><span class="line">    name = i[1]</span><br><span class="line">    with open(path+&quot;/&#123;name&#125;.jpg&quot;.format(name),&quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https://pic.netbian.com&quot; + link)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(name+&quot;.jpg 获取成功......&quot;)</span><br></pre></td></tr></table></figure>
爬取王者荣耀头像，感觉写的很丑很傻。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">url = &quot;https://pvp.qq.com/web201605/herolist.shtml&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, &quot;</span><br><span class="line">                  &quot;like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encode = response.apparent_encoding</span><br><span class="line">text = response.content.decode(encode)</span><br><span class="line">pattern = re.compile(r&#x27;(//game.+\.jpg)&#x27;)</span><br><span class="line">pattern1 = re.compile(r&#x27;alt=&quot;(.+?)&quot;&#x27;)</span><br><span class="line">images = re.findall(pattern, text)</span><br><span class="line">names = re.findall(pattern1, text)</span><br><span class="line">path = &quot;heroes&quot;</span><br><span class="line">if not os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">cnt = 0</span><br><span class="line">for element in images:</span><br><span class="line">    cur = element</span><br><span class="line">    with open(path + &quot;/&#123;&#125;.jpg&quot;.format(names[cnt]), &quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https:&quot; + cur)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(&quot;捕获成功&quot;)</span><br><span class="line">    cnt = cnt + 1</span><br></pre></td></tr></table></figure></p>
<h4 id="lxml-库">lxml 库</h4>
<p>lxml 库是一个使用 python 编写的库，可以迅速、灵活地处理 XML 和
HTML。</p>
<p>其中 lxml.etree 模块是最常用的 HTML、XML
文档解析模块。其中lxml.etree.Element是处理xml的一个核心类，Element对象可以直观的理解为是XML中的节点。使用Element类，可以实现对XML节点、节点属性、节点内文本的操作。</p>
<p>https://blog.csdn.net/weixin_57440207/article/details/116363166 lxml
库的基本使用。</p>
<h4 id="beautifulsoup-示例">BeautifulSoup 示例</h4>
<p>上面的都是比较基础的，对于一些动态的网页结构还是无能为力的。
我们可以使用 python <code>bs4</code> 库的 <code>BeautifulSoup</code>
库来对于请求后获得的 <code>html</code> 文本进行解析。
这是一段爬取豆瓣网站上<code>电影top250</code>的电影名称。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                  &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for page_num in range(0, 250, 25):</span><br><span class="line">    url = f&quot;https://movie.douban.com/top250?start=&#123;page_num&#125;&amp;filter=&quot;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    encode = response.apparent_encoding</span><br><span class="line">    content = response.content.decode(encode)</span><br><span class="line">    html = BeautifulSoup(content, &#x27;lxml&#x27;)</span><br><span class="line">    titles = html.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)</span><br><span class="line">    for title in titles:</span><br><span class="line">        if &#x27;/&#x27; not in title.string:</span><br><span class="line">            print(title.string)</span><br></pre></td></tr></table></figure>
我们通过 <code>BeatifulSoup(content, 'lxml')</code> 获取的是一个
BeatifulSoup 解析得到的结构。 其中 content 就是我们请求网站获得的 html
代码，后面的 <code>lxml</code> 是一个 html
的解析器，我们需要手动指定解析器，因为 BeautifulSoup 不仅仅可以解析
html。 <code>html = BeautifulSoup(content, 'lxml')</code> 获得到的
html，有许多的方法。 其中如果我们想获得哪一元素，比如说段落，就可以直接
<code>html.findAll("p")</code> 返回的是一个可以迭代的对象。如果直接写
<code>html.find("p")</code> 则是获得的第一个段落元素。
如果我们仍想要对于段落进一步细化，我们可以在后面加上参数，其中的格式是若干组键值。比如，我们想获取类名为<code>title</code>的span，就可以写为
<code>titles = html.findAll("span", attrs=&#123;"class": "title"&#125;)</code>
对于提取到的元素，我们会获得一个 <code>bs4.element.Tag</code> 就是一个
bs4 中的 Tag 对象，比如说我们有一个 <code>cur</code> 是
<code>bs4.elemnt.tag</code> 对象。 <code>cur.name</code>
就是输出标签的名字，比如 <code>p</code> <code>img</code>
<code>div</code> 如果我们想要获得里面的单个属性值，就直接
<code>cur['xx']</code> 或者
<code>cur.get('xx')</code>，如果我们想获取全部的属性值，就是
<code>cur.attrs</code> 获得标签内的文本，<code>cur.get_text()</code></p>
<h4 id="selenium">Selenium</h4>
<p>前面都是模拟发送一个 <code>request</code>
获得返回，下面是真是模拟我们打开浏览器后进行操作。 Python 中的 Selenium
是一个用于自动化网页操作和测试的强大工具。它提供了一种方式来模拟用户在浏览器中的操作，例如打开网页、填写表单、点击按钮、抓取数据等。
Selenium 的核心之一就是
WebDriver，它是一个接口，允许我们与不同的浏览器进行交互。我们需要下载与我们所使用浏览器相对应的
WebDriver 驱动程序。将 WebDriver 的路径指定为您的 Python 脚本中。</p>
<p>下面是一段打开百度首页并且搜索「你好」的代码。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line">from selenium.webdriver.common.by import By # 使用 find_element by=xxx 一定要引入这个</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;kw&#x27;).send_keys(&#x27;你好&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;su&#x27;).click()</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure>
下面是查找元素的 by 赋值情况，后面的 <code>value</code>
就是目标的索引值。这是新版本的 <code>find</code> 操作，之前的
<code>find_element_by</code> 方法现在已经弃用。 <img src="/.com//09/04/python%E7%88%AC%E8%99%AB/selenium%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0.png" class></p>
<p>对于查找后，如果是 <code>find_elements</code>
得到的是一个链表，如果是 <code>find_element</code> 得到的是一个
<code>&lt;class 'selenium.webdriver.remote.webelement.WebElement'&gt;</code>，后面对于这个类元素，我们可以
<code>xxx.click()</code> 点击 <code>xxx.send_keys("xxx")</code> 发送信息
<code>xxx.text</code> 获取文本 <code>xxx.clear()</code> 清除元素内容 如
input 中的内容 <code>get_attribute("value")</code>
获得<code>value</code>的属性值 <code>current_url</code>
可以获取当前页面的 url</p>
<p>下面是更深入的对于鼠标和键盘 模拟鼠标操作需要读入类
<code>ActionChains</code>
<code>from selenium.webdriver.common.action_chains import ActionChains</code>
<img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C.png" class></p>
<p>模拟键盘操作的话，也需要导入键盘的类
<code>from selenium.webdriver.common.keys import Keys</code>
<img src="/.com//09/04/python%E7%88%AC%E8%99%AB/%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C.png" class></p>
<h5 id="延时等待">延时等待</h5>
<p>遇到使用ajax加载的网页，页面元素可能不是同时加载出来的，这个时候尝试在get方法执行完成时获取网页源代码可能并非浏览器完全加载完成的页面。所以，这种情况下需要设置延时等待一定时间，确保全部节点都加载出来。
有三种方式： 1. 强制等待 直接 <code>time.sleep(xx)</code>(记得先导入包
<code>import time</code>) 2. 隐式等待 <code>implicitly_wait(xx)</code>
设置等待时间，如果到时间还有元素没有加载出来就会抛出异常。 3. 显式等待
设置一个等待时间和等待条件，在规定时间内，每隔一段时间查看下条件是否成立，如果成立那么程序就继续执行，否则就抛出一个超时异常。</p>
<h5 id="对-cookie-的操作亦称为-http-cookie">对 Cookie 的操作(亦称为 Http
Cookie)</h5>
<p>Cookie
通常用于在客户端（浏览器）和服务器之间存储一些小型数据，以便在用户与网站进行交互时进行识别、跟踪和状态管理。
 爬虫中常常使用 selenium + requests 实现
cookie持久化，即先用 selenium 模拟登陆获取 cookie ，再通过 requests 携带
cookie 进行请求。 <code>webdriver</code> 提供 cookie
的几种操作：读取、添加和删除。 1.
get_cookies：以字典的形式返回当前会话中可见的 cookie 信息。 2.
get_cookie(name)：返回 cookie 字典中key == name 的 cookie 信息 3.
dd_cookie(cookie_dict)：将 cookie 添加到当前会话中 4.
delete_cookie(name)：删除指定名称的单个 cookie 5.
delete_all_cookies()：删除会话范围内的所有cookie</p>
<p>https://blog.csdn.net/kobepaul123/article/details/128796839
https://blog.csdn.net/weixin_50835854/article/details/117170894 selenium
爬取图片 https://zhuanlan.zhihu.com/p/270391233
https://blog.csdn.net/qq_37267676/article/details/111667266
https://zhuanlan.zhihu.com/p/366773104</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">for index in range(0, 250, 25):</span><br><span class="line">    driver.get(f&#x27;https://movie.douban.com/top250?start=&#123;index&#125;&amp;filter=&#x27;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    list = driver.find_elements(by=By.XPATH, value=&#x27;//div[@class=&quot;pic&quot;]/a/img&#x27;)</span><br><span class="line">    for cur in list:</span><br><span class="line">        print(cur.get_attribute(&#x27;alt&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="selenium-和-splinter">selenium 和 splinter</h4>
<p>splinter和selenium都是用于测试网页的程序，可以模拟浏览器操作，进行自动化测试，可以用于爬虫，自动抢票，网页自动化处理等。Selenium是Splinter的底层，Splinter是Selenium的一个上层封装。使用splinter和selenium时也会用到和html，css相关的使用。</p>
<h4 id="scrapy-框架">Scrapy 框架</h4>
<p><code>Scrapy</code> 是一个异步网络 python
爬虫框架，可以高效地处理大量的请求和响应。它能够并行发送HTTP请求，从而加快数据抓取速度。异步处理允许我们同时处理多个请求而无需等待每一个请求的完成，这对于大规模的数据抓取任务十分有用。
它的优势： 1. 内置选择器(Selector)，使用 XPath 或者 CSS
选择器语法，使我们可以轻松获取 HTML 文档中的数据(我们不需要再去使用 bs4
?)。 2. 模块化和可扩展性
允许我们将爬虫任务分解为多个模块，包括爬虫、中间件、管道等，使代码易于维护和扩展。
3. 自动化处理
Scrapy提供了强大的自动化功能，包括请求的调度、URL跟踪、重试失败的请求等。它还支持自动限速，以避免过度请求目标网站，从而遵守网站的使用政策。
4. 内置 HTTP 请求处理
Scrapy可以处理HTTP请求和响应的所有细节，包括Cookies、User-Agent、重定向、状态码处理等。这减轻了用户的负担，让你专注于爬取和数据处理。</p>
<p>https://www.runoob.com/w3cnote/scrapy-detail.html 上面讲解了 Scrapy
的爬行流程，感觉还是挺形象的。只有当调度器中不存在任何 request
的时候，整个程序才会停止，又因为对于下载失败的 url 会再次进入
scheduler(调度器)，所以对于下载失败的 url，Scrapy 会重新进行下载。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>二项堆</title>
    <url>/2023/10/09/%E4%BA%8C%E9%A1%B9%E5%A0%86/</url>
    <content><![CDATA[<p>二项堆是二项树的集合。</p>
<p>二项树是一种递归定义的有序树，定义如下：</p>
<ol type="1">
<li><p>二项树 B0 只有一个节点</p></li>
<li><p>二项树 Bk 由两颗二项树 B(k-1)
组成，其中一棵树是另一棵树的最左孩子。</p></li>
</ol>
<<<<<<< HEAD
<h4 id="二项堆的性质">二项堆的性质</h4>
<ol type="1">
<li><span class="math inline">\(B_k\)</span> 一共有 <span class="math inline">\(2_k\)</span> 个节点</li>
<li><span class="math inline">\(B_k\)</span> 的高度为 k</li>
<li><span class="math inline">\(B_k\)</span> 在深度为 i 处恰好有 <span class="math inline">\(C_k^{i}\)</span> 个节点</li>
<li>根的度数为 k，大于任何其他节点的度数。</li>
=======
<p>多叉树到二叉树的转化？</p>
<p>Weighted Path Length of Tree, WPL</p>
<p>中位数寻找？TODO</p>
<p>为什么需要将 友元函数的定义直接写进去 ？ TODO</p>
<ol start="10" type="1">
<li><p>了解一下 Fibonacci 堆，有精力的同学可以尝试实现。</p></li>
<li><p>实现一个左偏堆</p></li>
<li><p>写一个 AVL 维护平衡，支持插入删除查找</p></li>
<li><p>R G B 非递归扫描？搜索如何存储路径状态？(直接将一个 vector
作为参数传入)</p></li>
<li><p>实现 Treap Splay FHQTreap ?（附加）</p></li>
<li><p>魔方？rubik's cube?</p></li>
<li><p>若干不相交的多边形，输出从多边形外面一点到外面另一点的最短路径。</p></li>
<li><p>尝试完善代码，为二叉树每一个节点添加
size，同时提供一个接口，返回一个节点的 rank。</p></li>
<li><p>写一个 kd 树代码，支持最近邻的查询，查找一个框框有多少点？输入 n
个点，输出就是求最近的点，维护一个 kd
树的类，需要的基本行为还是最好支持一下，不过我们最关心的还是最近点。</p></li>
<li><p>快速排序进阶。多种排序方式组合实现一个高效的快速排序。
使用快速排序(在其函数上进行修改)实现线性查找元素第 k 小。
荷兰旗问题？</p></li>
<li><p>给定若干竖直和水平的随机长度的线段，并且保证一个 y 坐标或者一个 x
坐标下只有一条线段，求这些线段的交点个数。</p></li>
<li><p>最长公共子序列</p></li>
<li><p>bitset 求解高维偏序问题</p></li>
<li><p>k 短路问题</p></li>
<li><p>完成 KMP 算法</p></li>
<li><p>并查集实现 鼓励大家实现基于 rank 的
union，希望并查集中有路径压缩的功能（不需要新写一个函数，只需要在 find
时顺便修改）。</p></li>
<li><p>实现 Prim 算法</p></li>
<li><p>实现 Kruskal 算法</p></li>
<li><p>教材以 Fleury 算法为主，但是老师更希望实现
希尔霍尔策算法，体会在桥边上有没有更好的策略。</p></li>
<li></li>
>>>>>>> 9765a0451f8c3a7c1034c7182fd8d7d06b4ad395
</ol>
<h4 id="二项堆的优势和劣势">二项堆的优势和劣势</h4>
<p>其实就是比二叉堆支持了合并操作？ <img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231018140027829.png" alt="image-20231018140027829"></p>
<h4 id="code">Code</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinomialHeapNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        <span class="type">int</span> degree;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* sibling;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* child;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* parent;</span><br><span class="line">        <span class="built_in">BinomialHeapNode</span>(T val)</span><br><span class="line">            : <span class="built_in">value</span>(val)</span><br><span class="line">            , <span class="built_in">degree</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">sibling</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">child</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinomialHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">topNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">top</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionHeap</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">decrease</span><span class="params">(BinomialHeapNode&lt;T&gt;*, <span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BinomialHeap</span>() &#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">extractMin</span><span class="params">()</span></span>;  </span><br><span class="line">        BinomialHeapNode&lt;T&gt;* head;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">top</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">linkNode</span><span class="params">(BinomialHeapNode&lt;T&gt;*&amp;, BinomialHeapNode&lt;T&gt;*&amp;)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">mergeTopLink</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">getTopLink</span><span class="params">(BinomialHeapNode&lt;T&gt;*, BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">insert</span>(T val) &#123;</span><br><span class="line">    <span class="built_in">Insert</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">Insert</span>(T val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">BinomialHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">BinomialHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">    <span class="comment">// BinomialHeapNode&lt;T&gt;* newHead = getTopLink(head, newNode);</span></span><br><span class="line">    newNode-&gt;sibling = head;</span><br><span class="line">    head = newNode;</span><br><span class="line">    head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BinomialHeap&lt;T&gt;::<span class="built_in">top</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">top</span>(head)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">top</span>(BinomialHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* ans = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans) ans = cur;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; ans-&gt;value) ans = cur;</span><br><span class="line">        cur = cur-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">extractMin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">extractMin</span>() &#123;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* minNode = <span class="built_in">top</span>(head);</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* cur = head;</span><br><span class="line">    <span class="keyword">if</span> (cur == minNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;sibling) &#123;</span><br><span class="line">            head = head-&gt;sibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;sibling != minNode)</span><br><span class="line">            cur = cur-&gt;sibling;</span><br><span class="line">        cur-&gt;sibling = cur-&gt;sibling-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;BinomialHeapNode&lt;T&gt;*&gt; v;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* curNode = minNode-&gt;child;</span><br><span class="line">    <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curNode) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(curNode);</span><br><span class="line">            curNode = curNode-&gt;sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BinomialHeapNode&lt;T&gt;* element : v)</span><br><span class="line">            element-&gt;sibling = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">            <span class="comment">// 获取 minNode 的 pre，和 后面连接</span></span><br><span class="line">            <span class="comment">// 取反 v 然后再合并两个根链 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">                v[i]-&gt;sibling = v[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BinomialHeapNode&lt;T&gt;* newHead = getTopLink(head, v[0]);</span></span><br><span class="line">        <span class="comment">// head = mergeTopLink(newHead);</span></span><br><span class="line">        head = <span class="built_in">getTopLink</span>(head, v[<span class="number">0</span>]);</span><br><span class="line">        head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">unionHeap</span>(BinomialHeapNode&lt;T&gt;* h2) &#123;</span><br><span class="line">    head = <span class="built_in">getTopLink</span>(head, h2);</span><br><span class="line">    head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">decrease</span>(BinomialHeapNode&lt;T&gt;* cur, <span class="type">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur || !head) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;illegal decreasing!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;value -= key;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* parent = cur-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; cur-&gt;value &lt; parent-&gt;value) &#123;</span><br><span class="line">        T temp = cur-&gt;value;</span><br><span class="line">        cur-&gt;value = parent-&gt;value;</span><br><span class="line">        parent-&gt;value = temp;</span><br><span class="line">        cur = parent;</span><br><span class="line">        parent = cur-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">linkNode</span>(BinomialHeapNode&lt;T&gt;*&amp; cur, BinomialHeapNode&lt;T&gt;*&amp; newNode) &#123;</span><br><span class="line">    newNode-&gt;parent = cur;</span><br><span class="line">    newNode-&gt;sibling = cur-&gt;child;</span><br><span class="line">    cur-&gt;child = newNode;</span><br><span class="line">    ++cur-&gt;degree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">getTopLink</span>(BinomialHeapNode&lt;T&gt;* p1, BinomialHeapNode&lt;T&gt;* p2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;degree &lt;= p2-&gt;degree) &#123;</span><br><span class="line">        newHead = p1;</span><br><span class="line">        p = p1;</span><br><span class="line">        p1 = p1-&gt;sibling;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = p2;</span><br><span class="line">        p = p2;</span><br><span class="line">        p2 = p2-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;degree &lt;= p2-&gt;degree) &#123;</span><br><span class="line">            p-&gt;sibling = p1;</span><br><span class="line">            p1 = p1-&gt;sibling;</span><br><span class="line">            p = p-&gt;sibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;sibling = p2;</span><br><span class="line">            p2 = p2-&gt;sibling;</span><br><span class="line">            p = p-&gt;sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) p-&gt;sibling = p1;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;sibling = p2;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">mergeTopLink</span>(BinomialHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* x = cur;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* nxt = x-&gt;sibling;</span><br><span class="line">    <span class="keyword">while</span> (nxt) &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;a&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;degree != nxt-&gt;degree || (nxt-&gt;sibling &amp;&amp; nxt-&gt;sibling-&gt;degree == x-&gt;degree)) &#123;</span><br><span class="line">            prev = x;</span><br><span class="line">            x = nxt; <span class="comment">// 连续三个一样的，并且现在的 x 指向了第一个位置 或者 当前不一样和下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;value &lt;= nxt-&gt;value) &#123;</span><br><span class="line">            x-&gt;sibling = nxt-&gt;sibling;</span><br><span class="line">            <span class="built_in">linkNode</span>(x, nxt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur = nxt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;sibling = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">linkNode</span>(nxt, x);</span><br><span class="line">            x = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        nxt = x-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>博弈论及其应用</title>
    <url>/2023/10/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>博弈论的<strong>精髓在于</strong>：博弈中的一个理性决策者必须在考虑其它局中人行动的基础上来选择自己最理想的行动方案。</p>
<h4 id="囚徒困境-prisoners-dilemma">囚徒困境 prisoners' dilemma</h4>
<p>两个嫌疑犯被分别关在两个房间由警察审讯，警察告诉每个嫌疑犯：如果两个人都不承认，每人将被判为1年；如果两个人都坦白，各判8年；如果其中一人坦白，另一人抵赖，坦白者释放，抵赖者判10年。每个囚徒将面临四种可能结果，被判0年、1年、8年、10年。</p>
<p>但在上述例子中，一个人的最优选择并不依赖于他人的选择。这样的最优战略，被称为“占优战略”(dominant
strategy)。由所有参与人的占优战略构成的战略组合被称为“占优均衡”。
占优战略均衡的出现只要求所有人都是理性的，但不要求每个参与人知道其他参与人是否理性.</p>
<p>「囚徒困境」表明<strong>个人理性和集体理性之间的冲突</strong>。
这样的例子有：寡头竞争、军备竞赛、团队生产中的劳动供给、公共产品的供给。</p>
<h4 id="博弈的划分">博弈的划分</h4>
<p>有合作博弈和非合作博弈，其中非合作博弈按照参与人的先后顺序又可以分为<strong>静态博弈和动态博弈</strong></p>
<p>非合作博弈按照参与人对其他人(对手)的特征、战略空间以及支付函数的知识可以划分为：<strong>完全信息博弈和不完全信息博弈</strong></p>
<img src="/.com//10/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E9%9D%9E%E5%90%88%E4%BD%9C%E5%8D%9A%E5%BC%88%E5%88%92%E5%88%86.png" class>
<p>垄断最优产量小于非垄断的情况，但是对于垄断企业的利润大于非垄断情况下两个企业的利润和。</p>
]]></content>
      <tags>
        <tag>GameTheory</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/08/23/test/</url>
    <content><![CDATA[<p>{ %asset_img machine_learning.jpg this is a example image. %}</p>
]]></content>
  </entry>
  <entry>
    <title>公共关系实务</title>
    <url>/2023/09/18/%E5%85%AC%E5%85%B1%E5%85%B3%E7%B3%BB%E5%AE%9E%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="第二章-公共关系产生与发展">第二章 公共关系产生与发展</h4>
<p>古代时期--公共关系思想的萌芽</p>
<h4 id="扩展">扩展</h4>
<p>公共关系确实有一段黑暗的历史，我们不否认，正视历史。</p>
]]></content>
  </entry>
  <entry>
    <title>决策分析方法</title>
    <url>/2023/08/25/%E5%86%B3%E7%AD%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>策略集、状态集和溢损函数是构成一个决策问题的三项最基本要素。</p>
<h4 id="风险型决策">风险型决策</h4>
<p>风险型决策也称作随机决策，是在状态概率已知的条件下进行的决策。</p>
<h5 id="最大可能准则">最大可能准则</h5>
<p>在若干种自然状态发生的概率相差很大，而相对应的益损值又相差不大时，这种决策准则效果较好。但是如果若干种自然状态发生的概率都很小，而且相互很接近时，使用这种决策准则的效果不会好，甚至会引起很严重的错误。
##### 期望值准则
期望值准则就是选择期望益损值最大（或者最小）的方案作为最优方案。</p>
<h4 id="决策树法">决策树法</h4>
<p>采用决策树法的步骤： 1.
画出决策树。一般是从左往右画，先画出决策点，再画出由决策点引起的方案分支。
2. 计算方案的期望益损值。 3.
根据期望益损值进行决策，将期望益损值小的舍去，而期望益损值大的方案则保留，这就是最优策略。</p>
<h4 id="不确定型决策">不确定型决策</h4>
<p>不确定型决策是在只有几种自然状态可能发生，但是这些状态发生的概率并不知道时做出的决策。
由于不确定型问题不知道状态的概率，所以无法计算每种方案的益损值，于是这类问题在理论上没有一个最优决策准则提供决策者决策，它存在着几种不同的决策分析方法，每种都有合理性。
##### 乐观准则 从最乐观状态出发，每种方案都按照最有利状态来考虑。<span class="math inline">\(R^{*} = \max\limits_i \{\max\limits_j
r_{ij}\}\)</span> ##### 悲观准则
从最悲观的观点出发对每个方案按最不利的状态来考虑，然后从中选取最优方案。<span class="math inline">\(R^{*} = \max\limits_{i} \{\min\limits_{j}
r_{ij}\}\)</span> ##### 折衷准则 引入一个表达乐观程度的乐观系数。<span class="math inline">\(R^{*} = \max\limits_i \{\lambda \max\limits_j
r_{ij} +(1 - \lambda) \min\limits_{j} r_{ij}\}\)</span> ##### 等可能准则
假定每种自然状态发生的概率总是相同的。 ##### 后悔值准则
后悔值准则是从后悔值考虑，希望能找到一个这样的策略，以使在实施这个策略时能产生较少的后悔。所谓后悔就是指每种状态下最大收益值与此状态下其他益损值之差。在所有方案的最大后悔值中选最小者，此时对应的方案为最优策略。
<span class="math inline">\(R^{*} =\min\limits_{i} \{\max\limits_{j}
RV_{ij}\}\)</span>，其中 <span class="math inline">\(RV_{ij} =
\max\limits_{i} r_{ij} - r_{ij}\)</span></p>
<h4 id="层次分析法">层次分析法</h4>
<p>层次分析法是对一些较为复杂、模糊的问题做出决策的多准则决策方法，它特别适用于难以完全定量分析的问题。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>回归分析与时间序列方法</title>
    <url>/2023/08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>统计推断的另一类重要问题是假设检验问题。在总体的分布函数未知或者只知道其形式、但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对于所提出的假设做出是接受还是拒绝的决策，<strong>假设检验</strong>就是做出这一决策的过程。</p>
<p>这种只对于第一种错误的概率进行控制，而不考虑第二种错误的概率的检验，称为显著性检验。对应的还有双边假设检验、右边检验和左边检验。
<img src="/.com//08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C.png" class></p>
<h4 id="一元线性回归方程的检验">一元线性回归方程的检验</h4>
<p>根据样本数据算出的回归可能有一定的抽样误差。为了考察这两个变量在同体内是否是存在线性关系以及回归方程对估计预测因变量的有效性如何，首先进行的就是显著性检验。</p>
<h5 id="t-检验">t 检验</h5>
<p>t 检验又称学生 t
检验，是统计推断中一种非常常见的检验方法，<strong>用于统计量服从正态分布</strong>但是方差未知(如果知道方差，我们可以直接
Z 检验，或者叫做 U 检验，就是正态检验)的情况。</p>
<p>t检验的前提是要求样本服从正态分布或近似正态分布，不然可以利用一些变换（取对数、开根号、倒数等等）试图将其转化为服从正态分布是数据，如若还是不满足正态分布，只能利用非参数检验方法。</p>
<p>t 检验最常见的四个用途： 1. 单样本均值检验（One-sample t-test）
用于检验 总体方差未知、正态数据或近似正态的 单样本的均值 是否与
已知的总体均值相等 2. 两独立样本均值检验（Independent two-sample
t-test） 用于检验 两对独立的 正态数据或近似正态的 样本的均值
是否相等，这里可根据总体方差是否相等分类讨论 3.
配对样本均值检验（Dependent t-test for paired samples） 用于检验
一对配对样本的均值的差 是否等于某一个值 4. 回归系数的显著性检验（t-test
for regression coefficient significance） 用于检验
回归模型的解释变量对被解释变量是否有显著影响</p>
<p>具体内容见 https://zhuanlan.zhihu.com/p/138711532</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h4 id="参考见">参考见</h4>
<p>https://oi-wiki.org/math/combinatorics/combination/ 组合式公式
https://zhuanlan.zhihu.com/p/602675596 笔记</p>
<p>一共有两种情况</p>
<p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu">炫酷反演魔术
- command_block 的博客 - 洛谷博客 (luogu.com.cn)</a>
介绍了反演的来历、各种反演</p>
<p><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html">二项式反演及其应用
- GXZlegend - 博客园 (cnblogs.com)</a> 有几个题目讲解</p>
<img src="/.com//09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/%E5%BC%95%E7%90%86.png" class>
<p><a href="https://www.cnblogs.com/GDOI2018/p/14491894.html">二项式反演
- __allenge - 博客园 (cnblogs.com)</a></p>
]]></content>
      <tags>
        <tag>Math Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>左偏树</title>
    <url>/2023/10/11/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<h4 id="参考资料">参考资料</h4>
<p>https://www.cnblogs.com/skywang12345/p/3638327.html</p>
<p>https://www.luogu.com.cn/problem/solution/P3377</p>
<p>https://zh.wikipedia.org/wiki/%E5%B7%A6%E5%81%8F%E6%A0%91</p>
<p>https://oi-wiki.org/ds/leftist-tree/</p>
<p>https://www.jvruo.com/archives/343/</p>
<h5 id="to-do">TO DO</h5>
<p>左偏树实现删除任意节点？而不只是根节点。（其实就是从删除的节点一直向上递归，直到
cur.npl == cur.rightChild.npl + 1）</p>
<p>其实我们可以从左偏树的 merge
操作中看出来，左偏树的子树也是一个左偏树</p>
<p>好像如果想实现左偏树减小任意一个节点的值，可以先删除那个节点，再添加减小后的值。</p>
<figure>
<img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231018233914144.png" alt="image-20231018233914144">
<figcaption aria-hidden="true">image-20231018233914144</figcaption>
</figure>
<h4 id="code">Code</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEFTISTHEAP_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFTISTHEAP_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftistHeapNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        <span class="type">int</span> npl;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* leftChild;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* rightChild;</span><br><span class="line">        <span class="built_in">LeftistHeapNode</span>()</span><br><span class="line">            : <span class="built_in">npl</span>(<span class="number">-1</span>)</span><br><span class="line">            , <span class="built_in">leftChild</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">rightChild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LeftistHeapNode</span>(T val)</span><br><span class="line">            : <span class="built_in">npl</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">value</span>(val)</span><br><span class="line">            , <span class="built_in">leftChild</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">rightChild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftistHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* root;</span><br><span class="line">        <span class="built_in">LeftistHeap</span>()</span><br><span class="line">            : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LeftistHeap</span>(T val) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">LeftistHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(LeftistHeap&lt;T&gt;)</span></span>;</span><br><span class="line">        <span class="comment">// void remove(LeftistHeapNode&lt;T&gt;*);</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function">LeftistHeapNode&lt;T&gt;* <span class="title">merge</span><span class="params">(LeftistHeapNode&lt;T&gt;*, LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(LeftistHeap&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">postOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">postOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">postOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    <span class="built_in">postOrder</span>(cur-&gt;rightChild);</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">inOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">inOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">inOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(cur-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">preOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">preOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    <span class="built_in">preOrder</span>(cur-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">insert</span>(T value) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">LeftistHeap</span>&lt;T&gt;(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">insert</span>(LeftistHeap&lt;T&gt;* heap) &#123;</span><br><span class="line">    root = <span class="built_in">merge</span>(root, heap-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">merge</span>(LeftistHeap&lt;T&gt; heap) &#123;</span><br><span class="line">    root = <span class="built_in">merge</span>(root, heap.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LeftistHeapNode&lt;T&gt;* LeftistHeap&lt;T&gt;::<span class="built_in">merge</span>(LeftistHeapNode&lt;T&gt;* x, LeftistHeapNode&lt;T&gt;* y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;value &gt; y-&gt;value) &#123;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rightChild = <span class="built_in">merge</span>(x-&gt;rightChild, y);</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leftChild == <span class="literal">nullptr</span> || x-&gt;leftChild-&gt;npl &lt; x-&gt;rightChild-&gt;npl) &#123;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* temp = x-&gt;leftChild;</span><br><span class="line">        x-&gt;leftChild = x-&gt;rightChild;</span><br><span class="line">        x-&gt;rightChild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;rightChild == <span class="literal">nullptr</span> || x-&gt;leftChild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        x-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;npl = (x-&gt;leftChild-&gt;npl &gt; x-&gt;rightChild-&gt;npl) ? (x-&gt;rightChild-&gt;npl + <span class="number">1</span>) : (x-&gt;leftChild-&gt;npl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void LeftistHeap&lt;T&gt;::remove(LeftistHeapNode&lt;T&gt;* removeNode) &#123;</span></span><br><span class="line"><span class="comment">//     if (!root) &#123;</span></span><br><span class="line"><span class="comment">//         throw std::runtime_error(&quot;the heap is empty!&quot;);</span></span><br><span class="line"><span class="comment">//         return ;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;the heap is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    LeftistHeapNode&lt;T&gt;* l = root-&gt;leftChild;</span><br><span class="line">    LeftistHeapNode&lt;T&gt;* r = root-&gt;rightChild;</span><br><span class="line">    root = <span class="built_in">merge</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>差分方程模型</title>
    <url>/2023/08/24/%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>在连续系统里，我们用常微分方程表示时域； 而在离散系统里，由于输入 |
输出都是离散信号，微分失去了意义，所以用差分计算。</p>
</blockquote>
<p>设有未知序列 <span class="math inline">\(\{x_n\}\)</span>，称 <span class="math inline">\(F(n;x_n,x_{n + 1}, ..., x_{n + k}) = 0\)</span> 为
k 阶差分方程。</p>
<p>关于差分方程的解，可以参考文章
https://zhuanlan.zhihu.com/p/385787482</p>
<h4 id="金融问题中的差分方程模型">金融问题中的差分方程模型</h4>
<p>现在有一笔 p 万元的贷款，贷款期是 n 年，月利率是
r，采用等额还款的方式逐月偿还，计算每月的还款数。 设 k 个月后，欠额为
<span class="math inline">\(A_k\)</span>，每月还款 m 元，则有 <span class="math inline">\(A_{k + 1} = (1 +r)A_k - m\)</span></p>
<h4 id="养老保险模型">养老保险模型</h4>
<p>设 k 个月后所交资金以及利息总和为 <span class="math inline">\(F_k\)</span>，则有 <span class="math inline">\(F_k
= (1 + r)F_{k - 1} + p, k &lt;= N\)</span> 和 <span class="math inline">\(F_k = (1 +r)F_{k - 1} - q, N &lt; k &lt;=
M\)</span>，N 个月后，不再交钱，只拿钱。</p>
<h4 id="市场经济中的蛛网模型">市场经济中的蛛网模型</h4>
<p>在自由竞争的社会中，很多领域会出现 <strong>循环波动</strong>
的现象，比如说自由市场上商品的价格。
将时间离散化为时段，一个时期相当于商品的一个生产周期。设 k
时段商品数量为 <span class="math inline">\(x_k\)</span>，商品价格为
<span class="math inline">\(y_k\)</span></p>
<p>同一时段商品的价格取决于该段商品的数量，<span class="math inline">\(y_k =
f(x_k)\)</span>，称为需求函数，我们自然地认为这个函数是单调下降函数。</p>
<p>下一段商品的数量取决于上一个时段的商品价格，<span class="math inline">\(x_{k + 1} =
g(y_k)\)</span>，称为供应函数，假设为单调上升函数。</p>
<p>在进行市场经济分析中，f
取决于消费者对于某种产品的需求程度以及消费水平，g
取决于生产能力和管理水平。</p>
<p>两个曲线的交点 <span class="math inline">\(P(x_0, y_0)\)</span>
处，<span class="math inline">\(|f&#39;(x_0)| &lt;
|g&#39;(x_0)|\)</span> 时，P 点稳定，反之不稳定。</p>
<p>设 <span class="math inline">\(|f&#39;(x_0)| = \alpha, |g&#39;(y_0)|
= \frac{1}{\beta}\)</span>，在 P 点附近取 <span class="math inline">\(y_k - y_0 = -\alpha(x_k - x_0), x_{k + 1} - x_0 =
\beta(y_k - y_0)\)</span>，消去 <span class="math inline">\(y_k\)</span>，得到 <span class="math inline">\(x_k\)</span>
的递推式，可以求出通项，求极限和上面的条件等价。</p>
<h4 id="简单的种群增长模型">简单的种群增长模型</h4>
<p>利用了矩阵的特征方程求解。对角化或者化为若尔当标准型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>微分方程模型</title>
    <url>/2023/08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="微分方程模型">微分方程模型</h4>
<p>如果能得到解析解的形式固然便于分析和应用，但是大多数微分方程无法得到解析解，因此研究其稳定性和数值解法就十分重要。</p>
<ol type="1">
<li><img src="/.com//08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/liuliangxishu.jpg" class title="流量系数">
容器漏水问题。 好像是 <span class="math inline">\(Q = Sv\)</span>
流量前面一个系数，不是很懂。</li>
<li>导弹追踪问题 列出关于斜率的微分方程，然后代入初值条件。</li>
</ol>
<h5 id="传染病模型">传染病模型</h5>
<p>我们一开始不把所有的因素考虑在内，而是抓住主要因素，把问题简化，建立相应的数学模型。然后与实际比较，再做出修改。</p>
<ol type="1">
<li>指数模型 用 <span class="math inline">\(i(t)\)</span> 表示 t
时刻病人的数量，每个病人传染的人数为 k, 则有 <span class="math inline">\(i(t + \Delta t) - i(t) = ki(t)\Delta t\)</span>
解得 <span class="math inline">\(i(t) =
i_0e^{kt}\)</span>，随着时间增长，人数是无穷的，不符合实际，所以我们对于这个模型进行修改。</li>
<li>SI 模型 设 t 时刻病人为 <span class="math inline">\(i(t)\)</span>，健康人数为 <span class="math inline">\(s(t)\)</span>，每个病人传染的人数和健康人数呈正比，比例系数为
k，则有 <span class="math inline">\(i(t + \Delta t) - i(t) = i(t)\Delta
ks(t) = ki(t)(n - i(t))\)</span>，解得 <span class="math inline">\(i(t)
= \dfrac{n}{1 + (\frac{n}{i_0} - 1)e^{-kt}}\)</span> 医学上一般称这个
<span class="math inline">\(i(t)\)</span> 曲线为传染病曲线。
但是这个模型的缺点是，当 <span class="math inline">\(t \to
+\infty\)</span> 的时候，人人都会生病，这是不符合实际的。</li>
<li>SIS 模型 考虑到人们生病后是恢复的，或者说有人可能会感染多次。
在上一个模型的基础上，添加日治愈率 <span class="math inline">\(\mu\)</span>，和病人的数量呈正比。 现在就有 <span class="math inline">\(i(t + \Delta t) - i(t) = (ks(t)i(t) - \mu
i(t))\Delta t, i(0) = i_0\)</span>。</li>
</ol>
<h4 id="捕鱼业的持续收获模型">捕鱼业的持续收获模型</h4>
<h6 id="阻滞增长模型-logistic-模型">阻滞增长模型 (Logistic 模型)</h6>
<p>将增长率 r 修正为 r - sx 一个关于 x
的线性函数。自然资源和环境限制所能容纳的最大人数为 <span class="math inline">\(x_m\)</span>，也就是 <span class="math inline">\(x
= x_m\)</span> 的时候，<span class="math inline">\(r =0\)</span>，所以有
<span class="math inline">\(r(x) = r(1 -
\dfrac{x}{x_m})\)</span>，其实和上面传染病模型中的 SI
模型是差不多的。)</p>
<ol type="1">
<li>产量模型 记时刻 t 时渔场中的鱼量为 <span class="math inline">\(x(t)\)</span>，由 Logistic 模型则有 <span class="math inline">\(x&#39;(t) = f(x) = rx(1 - \frac{x}{N})\)</span>，N
是环境允许的最大鱼量。 设捕鱼强度为 E，也就是单位时间捕鱼量为 <span class="math inline">\(Ex\)</span>，记 <span class="math inline">\(F(x) =
f(x) - Ex\)</span>，则持续捕捞下，平衡的鱼量为 <span class="math inline">\(x_0 = N(1 - \frac{E}{r})\)</span> <span class="math inline">\(x_0 \times E\)</span>
求二次函数的最值，就是最大的持续捕捞量了，此时 <span class="math inline">\(E =
\dfrac{r}{2}\)</span>（好像和高中生物学的一样了）。
(其实和人口增长差不多)</li>
<li>效益模型</li>
<li>捕捞过度模型</li>
</ol>
<h4 id="战争模型">战争模型</h4>
<p>「兰彻斯特平方定律」：作战部队的实力同投入战斗的士兵人数的平方成正比。</p>
<ol type="1">
<li>正规战模型 以 <span class="math inline">\(x(t), y(t)\)</span>
分别表示 t
时刻红军和蓝军的士兵人数，每队士兵的减员率和对方士兵的人数成正比，所以有方程
<span class="math inline">\(\frac{\mathrm{d}x}{\mathrm{d}t} = -ay,
\frac{\mathrm{d}y}{\mathrm{d}t} = -bx\)</span>，这两个式子相除，积分得到
<span class="math inline">\(ay^2 - bx^2 = ay_0^{2} - bx_0^{2} =
c\)</span></li>
<li>混合战模型
红军游击队，蓝军正规部队，但是游击队伍位于不易发现的有利位置，所以把红军的人员损失方程再乘一个
x，表示损失与自身规模大小有关。 <span class="math inline">\(\frac{\mathrm{d}x}{\mathrm{d}t} = -cxy +
f(t)\)</span>，f(t) 表示红军的增援情况。</li>
<li>游击战模型 双方都是游击队伍。就都变成上个模型红军的方程形式。</li>
</ol>
<p>恩格尔(Engel)将第二次世界大战时美军和日军争夺硫磺岛所进行的战斗资料进行分析，发现与兰彻斯特作战数学模型非常吻合，这说明兰彻斯特作战数学模型是可以来描述实际战争的。</p>
<h4 id="对药物剂量开处方">对药物剂量开处方</h4>
<h4 id="捕食者食饵模型">捕食者——食饵模型</h4>
<p>感觉和战争模型比较相似，不过这里的捕食者和被捕食者是会自然增长的（其实等价于战争模型中的援助）。</p>
<h4 id="微分方程的数值解">微分方程的数值解</h4>
<p>很多方程往往复杂且大多数情况下求不出解析解，因而在实际生产和科研中，常常是求满足精度要求的近似解。</p>
<ol type="1">
<li>欧拉方法</li>
<li>梯形方法</li>
<li>龙格-库塔方法</li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>抢课脚本</title>
    <url>/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>本质上就是模拟一个请求。
我们点击选课页面的时候，是将带有特定功能的数据包发送给对方，也就是服务器，然后得到服务器的反馈。
&gt; 之前 Github
上下载的学长写的选课脚本因为学校系统后台的更新没办法使用了，于是想为何不自己学习一下，自己写一个。</p>
<h4 id="抓包-capture-packet">抓包 capture packet</h4>
<p>因为Web
表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防
CRSF
攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。
使用 F12 开发者工具找了一圈也没找到 Github 上下载的 SDU
抢课脚本的路径，搜索了一下感觉就是运用了抓包。 ##### 抓包工具的原理 那
Fiddler 举例，Fiddler
相当于一个「代理」，浏览器访问服务器页面时，就会先把 HTTP 请求先发送给
Fiddler，Fiddler 再把请求转发给服务器，当服务器返回数据时，Fiddler
拿到返回数据，再把数据交给浏览器。 因此 Fiddler
对于浏览器和服务器之间的交互细节是非常清楚的，进而可以帮助我们完成相应的抓包工作(其实后来感觉浏览器自带的开发者工具中的「网络」就够用了)。
<img src="/.com//09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/fiddler.png" class></p>
<h4 id="url-编码">url 编码</h4>
<p>这段文字中，<code>https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/xsxkGgxxkxk</code>
是 URL 基本部分，用于定位服务器上的特定资源或者页面。 <code>?</code>
表示查询字符串的开始。然后在 <code>?</code>
后面，通常会带有一个或者多个参数，每个参数都有一个名称和一个对应的值，它们之间用等号<code>=</code>连接，并且多个参数之间使用和号<code>&amp;</code>分隔。
其中，参数的值是根据 <code>url</code> 编码的，因此需要
<code>url decoding</code> 来将他们还原为原始文本。 可以直接使用 python
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib.parse import unquote</span><br><span class="line"></span><br><span class="line">encoded_value = &quot;%E6%96%87%E5%AD%A6&quot;</span><br><span class="line">decoded_value = unquote(encoded_value, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">print(decoded_value)</span><br></pre></td></tr></table></figure> &gt; 在计算机编程领域，特别是在处理字符串时，"quote"
通常表示在文本中添加引号或对特殊字符进行编码，而 "unquote"
则表示将文本中的引号或编码解除，还原为原始的形式。</p>
<h4 id="referer">Referer</h4>
<p>Referer（也写作"referrer"，拼写时不包括第二个
"e"）是一个HTTP头部字段，通常在Web请求中使用。这个字段用于指示请求的来源或引用页面的URL。当您从一个网页点击链接跳转到另一个页面时，浏览器通常会在请求中包含Referer字段，以告知目标页面是从哪个页面链接过来的。
Referer字段对于网站分析、统计和跟踪用户流量非常有用，因为它可以帮助网站所有者了解访问者是如何到达其网站的。例如，如果您运营一个电子商务网站，您可以使用Referer字段来确定哪些外部网站或广告渠道为您带来了最多的流量和销售。
需要注意的是，虽然Referer字段通常包含有用的信息，但它并不是100%可信的，因为用户可以通过浏览器设置或浏览器插件来修改或禁用Referer字段。因此，在进行任何安全性或敏感性操作时，不应仅依赖于Referer字段来验证请求的来源。</p>
<h4 id="network-栏">Network 栏</h4>
<p>这一栏通常会用来监视和分析与当前网页加载和网络请求相关的信息。下面是它的一些常见用途：
1. 查看网络请求。<code>Network</code>
栏显示了当前页面加载期间发出的所有网络请求，包括HTML、CSS、JavaScript、图像、API请求等。
2. 查看请求头和响应头。我们可以通过 <code>Network</code> 来查看
<code>RequestHeaders</code> 和
<code>ResponseHeaders</code>，这对于检查服务器返回的信息、设置请求头来模拟不同的客户端环境或者调试跨域问题很有帮助。
3. 筛选和搜索请求。<code>Network</code>
栏通常提供了筛选和搜索功能，使你可以根据请求类型（XHR、Fetch、Document等）或关键字来查找特定的请求，从而更轻松地定位问题或查找特定资源。</p>
<h4 id="request-具体操作">request 具体操作</h4>
<p>打开 F12，选择 <code>Network</code> 一栏。
然后在找到上搜索自己想选择的课程，点击右侧的「选课」按键(即使课程已经被选满了也无所谓，我们需要的是课程数据包的来源信息)，此时观察
<code>Network</code> 栏目，最下方应该会出现一个 <code>ggxxkxk</code>
开头的文件，点击后会出现它的具体信息。 如图： <img src="/.com//09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/selectCourseInfo.png" class> 其中
<code>Request Url</code> 就是我们获得数据包的地址，<code>kcid</code> 和
<code>jx0404id</code> 后面的数字感觉没有什么实际意义，不过可以在 HTML
代码中「选课」按键的属性值中找到，也可以查看 HTML
代码对应一下而不需要点击「选课」按键。 <code>Cookie</code>
代表的是我们的身份信息，是服务器辨识我们身份的信息，和
<code>User-Agent</code> 还有 <code>referer</code> 一起设置在请求头中。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def selectCourse():</span><br><span class="line">    cur_num = 0</span><br><span class="line">    url = &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/ggxxkxkOper?kcid=xxxxxx&#x27; \</span><br><span class="line">          &#x27;&amp;cfbs=null&amp;jx0404id=xxxxxxx&amp;xkzy=&amp;trjf=&#x27;</span><br><span class="line">    cookie = &#x27;你的 Cookie&#x27;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                      &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#x27;cookie&#x27;: cookie,</span><br><span class="line">        &#x27;referer&#x27;: &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/getGgxxk&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    while True:</span><br><span class="line">        response = requests.get(url=url, headers=headers)</span><br><span class="line">        data = json.loads(response.content.decode(response.apparent_encoding))</span><br><span class="line">        cur_num = cur_num + 1</span><br><span class="line">        print(f&quot;&#123;cur_num&#125; &#123;data[&#x27;message&#x27;]&#125;&quot;)</span><br><span class="line">        if data[&#x27;message&#x27;] != &#x27;选课失败：此课堂选课人数已满！&#x27;:</span><br><span class="line">            break</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    selectCourse()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="链接">链接</h4>
<p>https://www.cnblogs.com/xubin97/p/10331558.html 抢课脚本链接
https://blog.csdn.net/shenqueying/article/details/79426884 referer
的作用 https://blog.csdn.net/weixin_43314519/article/details/107095245
讲的挺好，还用到了多线程</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录2</title>
    <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h4 id="树状数组">树状数组</h4>
<p>树状数组或二元索引树(Binary Indexed Tree)，又以其发明者命名为 Fenwick
树。其初衷是解决数据压缩里面的累计频率(Cumulative
Frequency)的计算问题。</p>
<p>满足差分性质？ 不满足差分性质的实现？</p>
<p>树状数组倍增？</p>
<p>多维树状数组</p>
<h4 id="treap">Treap</h4>
<p>有旋和非旋。一种弱平衡的二叉搜索树。</p>
<p>删除操作，可以找到后继以后交换值，然后向右删除？还是一直旋转操作？</p>
<p>无旋 splite 和合并</p>
<p>复杂度正确性证明？？</p>
<p>https://www.luogu.com.cn/problem/solution/P3369?page=3</p>
<h4 id="sqrt-tree">sqrt tree</h4>
<p>开方树</p>
<p>使用场合？复杂度证明？代码实现？同类之间的区别？</p>
<h4 id="线段树">线段树</h4>
<p>求解最大和子段？区间染色问题？ 线段树的动态开点</p>
<p>主席树</p>
<p>是不是都能解决区间乘积 区间 min max gcd？</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>插值与拟合建模</title>
    <url>/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<p>插值方法实数值分析中的一种古老而重要的方法。在实际生产和科学实验中，有时候仅仅能获得函数
f(x) 在若干点的函数值或者微商值，即只能给出 f(x)
的一张数据表。如果根据这张数据表构造一个函数 <span class="math inline">\(\varphi(x)\)</span>
，使之满足这张表中的数据，这样的函数 <span class="math inline">\(\varphi(x)\)</span> 就是函数 f(x)
的逼近函数。这种逼近问题称为插值问题。</p>
<h4 id="插值多项式的存在性和唯一性">插值多项式的存在性和唯一性</h4>
<p>设 <span class="math inline">\(p_n(x) = a_0 + a_1x + a_2x^{2} + ... +
a_nx^n\)</span>，由插值条件可以得到非齐次线性方程组： <img src="/.com//08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E6%9D%A1%E4%BB%B6%E9%9D%9E%E9%BD%90%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%BB%84.png" class title="插值条件非齐次方程组">
可以由 <span class="math inline">\(\text{Vandermonde}\)</span>
行列式，各个点是互异的来得到系数矩阵的行列式 <span class="math inline">\(D \neq 0\)</span>。由 <span class="math inline">\(\text{Cramer}\)</span>
法则知道，方程有唯一的解，所以多项式存在且唯一。</p>
<p><strong>几何解释：</strong> 一个 n 次的多项式一定可以由 n + 1
个点唯一确定。</p>
<h4 id="lagrange-插值公式">Lagrange 插值公式</h4>
<img src="/.com//08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%85%AC%E5%BC%8F.png" class title="拉格朗日插值公式">
<h4 id="newton-插值公式">Newton 插值公式</h4>
<p>https://www.zhihu.com/question/22320408/answer/141973314
马同学关于牛顿插值的解释
牛顿插值法的特点在于：每增加一个点，不会导致之前的重新计算，只需要算和新增点有关的就可以了（这里不同于拉格朗日插值法）。</p>
<h4 id="两种插值的比较">两种插值的比较</h4>
<p>也不是很懂，给出 ChatGPT 的解释</p>
<ol type="1">
<li><p>数值稳定性：
牛顿插值通常在数值上更稳定，特别是在高次插值中。高次的拉格朗日插值多项式的系数可能会变得非常大，导致数值计算问题，这在计算机中可能会引发数值溢出或不稳定性。牛顿插值使用分裂差分形式，这种形式在数值计算上通常更可靠。</p></li>
<li><p>数据更新效率：
如果您需要在运行时动态添加新的数据点并更新插值多项式，牛顿插值更为高效。因为在牛顿插值中，您可以通过添加一个新的数据点来更新插值多项式，而不需要重新计算整个多项式。</p></li>
<li><p>分布不均匀的数据：
如果您的数据点分布不均匀，拉格朗日插值可能会导致插值多项式的阶数变得非常高，这会增加计算的复杂性和开销。牛顿插值在这种情况下通常更具优势。</p></li>
</ol>
<p>然而，需要注意的是，即使在大数据集的情况下，牛顿插值也不是绝对适用的。在一些特定情况下，如数据点的数量非常大或插值多项式的次数非常高，都可能导致数值计算问题。在这种情况下，考虑使用更高级的插值技术，例如分段插值（如样条插值）或基于快速傅里叶变换的方法，以提高数值稳定性和计算效率。选择合适的插值方法需要综合考虑数据的性质、计算需求和数值稳定性。</p>
<h4 id="三次样条插值函数">三次样条插值函数</h4>
<p>三次样条插值在科学和工程计算中起到重要作用，它只在插值区间的断点比
Lagrange 插值多两个边界条件，但是却在内节点处二阶导数连续。
样条一词来源于工程制图。绘图员为了将一些指定点（称作样点）连接成一条光滑的曲线，往往把富有弹性的细长木条（称为样条）固定在样点上，然后画下木条表示的曲线所形成的样条曲线。</p>
<p>有三种边界条件： 1. 自然边界(Natural Spline) 指端点处二阶导数为 0. 2.
固定边界(Clamped Spline) 指定端点一阶导数，这里分别定为 A 和 B，即 <span class="math inline">\(S_0&#39;(x_0) = A, S_{n - 1}^{x_n} = B\)</span> 3.
非扭结边界(Not-A-Knot Spline)
强制第一个插值点的三阶导数等于第二个点的三阶导数，最后一个点的三阶导数等于倒数第二个点的三阶导数。</p>
<p>https://zhuanlan.zhihu.com/p/62860859?utm_medium=social&amp;utm_oi=1127691903852081152&amp;utm_psn=1678405306240057344&amp;utm_source=qq
关于三次样条的具体推导和最终求解矩阵方程。</p>
<h4 id="最小二乘法拟合">最小二乘法拟合</h4>
<p><span class="math inline">\(r_i = y_i - \varphi(x_i)\)</span>
称为残量，<span class="math inline">\(\boldsymbol{r} = (r_0, r_1, ...,
r_m)^{T}\)</span> 称为<strong>残向量</strong>。所以用 <span class="math inline">\(\varphi(x)\)</span> 去拟合 <span class="math inline">\(f(x)\)</span> 的问题就变成了残量的大小问题。
我们用 <span class="math inline">\(\sum\limits_{i = 0}^{m} r_i^{2} =
\boldsymbol{r^{T}}\boldsymbol{r}\)</span> 去度量残量的大小。
后面的具体推导可以参考： 1. https://zhuanlan.zhihu.com/p/128083562 2.
https://zhuanlan.zhihu.com/p/109986821 3.
https://zhuanlan.zhihu.com/p/38128785</p>
<p>最终结果就是参数向量 <span class="math inline">\(\widehat{w} =
\boldsymbol{(X^{T}X)^{-1}X^{T}Y}\)</span></p>
<p>内积表示？？？</p>
<h4 id="最佳平方逼近">最佳平方逼近</h4>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契堆</title>
    <url>/2023/10/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/</url>
    <content><![CDATA[<p>斐波那契堆数据结构有两种用途。</p>
<ol type="1">
<li>支持一系列操作，这些操作构成了所谓的「可合并堆」</li>
<li>斐波那契的一系列操作可以在常数时间内完成，这使得这种数据结构非常适合需要频繁调用这些操作的应用。</li>
</ol>
<h4 id="优势与劣势">优势与劣势</h4>
<p>斐波那契堆有着更好的均摊时间复杂度，但是最坏情况下的时间复杂度会比较高。在一些很多条边的稠密图中，每一次调用
DECREASE-KEY 需要 O(1) 此时比普通的二项堆是要好一些的。</p>
<p>但是从实际角度出发，除了某些需要管理大量数据的应用以外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比普通的二项堆或者(K
项堆)并不那么适用。</p>
<h4 id="插入操作">插入操作</h4>
<p>斐波那契堆的根链表是「双向链表」，我们将 min
节点看作为双向链表的表头。后面插入节点的时候就是将节点插入到 min
节点之前，也就是双向链表的末尾。</p>
<h4 id="合并操作">合并操作</h4>
<p>合并操作就是将一个堆的根链表插入到另一个堆的根链表上。</p>
<h4 id="减小节点值">减小节点值</h4>
<p>难点在于，如果我们减小节点值后，破坏了「最小堆」的性质，应该如何维护呢？</p>
<ol type="1">
<li>首先，将「被减小节点」它所在的最小堆剥离出来，然后将该节点或者其子树(如果有的话)关联到根链中。</li>
<li>对于「被减少节点」的原父节点进行「级联剪切」。所谓级联剪切，就是在被减小节点破坏了最小堆性质，并且被切下来以后，再从它的父节点递归进行级联剪切的操作。
级联剪切具体地：如果父节点的 marked 为 false，赋值为 true，然后退出。
否则，将父节点也从最小堆中切下来，继续递归。
marked标记的作用就是用来标记"该节点的子节点是否有被删除过"，它的作用是来实现级联剪切。而级联剪切的真正目的是为了防止"最小堆"由二叉树演化成链表。</li>
</ol>
<h4 id="增加节点值">增加节点值</h4>
<p>​</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIBONACCI_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIBONACCI_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciHeapNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="type">int</span> degree;</span><br><span class="line">    <span class="type">bool</span> marked;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* parent;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* child;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* nxt;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* prev;</span><br><span class="line">    <span class="built_in">FibonacciHeapNode</span>(T val)</span><br><span class="line">        : <span class="built_in">value</span>(val)</span><br><span class="line">        , <span class="built_in">degree</span>(<span class="number">0</span>)</span><br><span class="line">        , <span class="built_in">marked</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">parent</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">child</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">nxt</span>(<span class="keyword">this</span>)</span><br><span class="line">        , <span class="built_in">prev</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        FibonacciHeapNode&lt;T&gt;* minNode; </span><br><span class="line">        <span class="comment">// 外部访问接口</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">FibonacciHeapNode&lt;T&gt;* <span class="title">extractMin</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">FibonacciHeap</span>()</span><br><span class="line">            : <span class="built_in">minNode</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">size</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">maxDegree</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// 内部实现细节</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">int</span> maxDegree;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">consolidate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">decrease</span><span class="params">(FibonacciHeapNode&lt;T&gt;*, T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">cutNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">cascading</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">insert</span>(T val) &#123;</span><br><span class="line">    <span class="built_in">insertNode</span>(<span class="keyword">new</span> <span class="built_in">FibonacciHeapNode</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">insertNode</span>(FibonacciHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        minNode = cur;</span><br><span class="line">        maxDegree = <span class="number">1</span>; <span class="comment">// Initialize maxDegree</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;prev = minNode-&gt;prev;</span><br><span class="line">        cur-&gt;nxt = minNode;</span><br><span class="line">        minNode-&gt;prev-&gt;nxt = cur;</span><br><span class="line">        minNode-&gt;prev = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;value &lt; minNode-&gt;value) &#123;</span><br><span class="line">            minNode = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkAdd</span><span class="params">(FibonacciHeapNode&lt;T&gt;* x, FibonacciHeapNode&lt;T&gt;* y)</span> </span>&#123;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* temp;</span><br><span class="line">    temp = x-&gt;nxt;</span><br><span class="line">    x-&gt;nxt = y-&gt;nxt;</span><br><span class="line">    y-&gt;nxt-&gt;nxt = x;</span><br><span class="line">    y-&gt;nxt = temp;</span><br><span class="line">    temp-&gt;prev = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">extractMin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">removeNode</span>(FibonacciHeapNode&lt;T&gt;* x) &#123;</span><br><span class="line">    x-&gt;prev-&gt;nxt = x-&gt;nxt;</span><br><span class="line">    x-&gt;nxt-&gt;prev = x-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">FibonacciHeap&lt;T&gt;* <span class="title">heapUnion</span><span class="params">(FibonacciHeap&lt;T&gt;* h1, FibonacciHeap&lt;T&gt;* h2)</span> </span>&#123;</span><br><span class="line">    FibonacciHeap&lt;T&gt;* temp;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h2-&gt;maxDegree &gt; h1-&gt;maxDegree) &#123;</span><br><span class="line">        temp = h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">        h2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h1-&gt;minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        h1-&gt;minNode = h2-&gt;minNode;</span><br><span class="line">        h1-&gt;size = h2-&gt;size;</span><br><span class="line">        h1-&gt;maxDegree = h2-&gt;maxDegree;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h2-&gt;minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">linkAdd</span>(h1-&gt;minNode, h2-&gt;minNode);</span><br><span class="line">        <span class="keyword">if</span> (h1-&gt;minNode-&gt;value &gt; h2-&gt;minNode-&gt;value)</span><br><span class="line">            h1-&gt;minNode = h2-&gt;minNode;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::<span class="built_in">extractMin</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (minNode == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* child = <span class="literal">nullptr</span>;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* Min = minNode;</span><br><span class="line">    <span class="keyword">while</span> (Min-&gt;child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        child = Min-&gt;child;</span><br><span class="line">        <span class="built_in">removeNode</span>(child);</span><br><span class="line">        <span class="keyword">if</span> (child-&gt;nxt == child)</span><br><span class="line">            Min-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            Min-&gt;child = child-&gt;nxt;</span><br><span class="line">        <span class="built_in">linkAdd</span>(child, minNode);</span><br><span class="line">        child-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">removeNode</span>(Min);</span><br><span class="line">    <span class="keyword">if</span> (Min-&gt;nxt == Min) &#123;</span><br><span class="line">        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minNode = Min-&gt;nxt;</span><br><span class="line">        <span class="built_in">consolidate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    --size;</span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">consolidate</span>() &#123;</span><br><span class="line">    <span class="type">int</span> maxDegreePossible = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">log2</span>(size)) + <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; <span class="built_in">degreeTable</span>(maxDegreePossible, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through the root list and consolidate nodes with the same degree</span></span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* cur = minNode;</span><br><span class="line">    std::vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; rootsToVisit;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        rootsToVisit.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        cur = cur-&gt;nxt;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cur != minNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FibonacciHeapNode&lt;T&gt;* node : rootsToVisit) &#123;</span><br><span class="line">        <span class="type">int</span> degree = node-&gt;degree;</span><br><span class="line">        <span class="keyword">while</span> (degreeTable[degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            FibonacciHeapNode&lt;T&gt;* other = degreeTable[degree];</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;value &gt; other-&gt;value) &#123;</span><br><span class="line">                <span class="comment">// Swap the nodes if necessary</span></span><br><span class="line">                FibonacciHeapNode&lt;T&gt;* temp = node;</span><br><span class="line">                node = other;</span><br><span class="line">                other = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Link other as a child of node</span></span><br><span class="line">            <span class="built_in">linkAdd</span>(node, other);</span><br><span class="line">            degreeTable[degree] = <span class="literal">nullptr</span>;</span><br><span class="line">            degree++;</span><br><span class="line">        &#125;</span><br><span class="line">        degreeTable[degree] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild the root list with consolidated nodes</span></span><br><span class="line">    minNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDegreePossible; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degreeTable[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                minNode = degreeTable[i];</span><br><span class="line">                minNode-&gt;nxt = minNode;</span><br><span class="line">                minNode-&gt;prev = minNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">insertNode</span>(degreeTable[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::decrease(FibonacciHeapNode&lt;T&gt;* cur, T value) &#123;</span></span><br><span class="line"><span class="comment">//     FibonacciHeapNode&lt;T&gt;* parent;</span></span><br><span class="line"><span class="comment">//     if (minNode == nullptr || cur == nullptr) return ;</span></span><br><span class="line"><span class="comment">//     if (value &gt;= cur-&gt;value) &#123;</span></span><br><span class="line"><span class="comment">//         throw std::runtime_error(&quot;illegal decreasing.&quot;);</span></span><br><span class="line"><span class="comment">//         return ;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     cur-&gt;value = value;</span></span><br><span class="line"><span class="comment">//     if (parent != null &amp;&amp; cur-&gt;value &lt; parent-&gt;value) &#123;</span></span><br><span class="line"><span class="comment">//         cutNode(cur, parent);</span></span><br><span class="line"><span class="comment">//         cascading(parent);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if (cur-&gt;value &lt; minNode)</span></span><br><span class="line"><span class="comment">//         minNode = cur;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::cutNode(FibonacciHeapNode&lt;T&gt;* cur, FibonacciHeapNode&lt;T&gt;* parent) &#123;</span></span><br><span class="line"><span class="comment">//     removeNode(cur);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::cascading(FibonacciHeapNode&lt;T&gt;* parent) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="参考文章">参考文章</h4>
<p>https://www.cnblogs.com/skywang12345/p/3659060.html 算法导论</p>
<p>https://www.cnblogs.com/junyuhuang/p/4463758.html</p>
<p>https://wangkuiwu.github.io/2013/03/05/fabonacci-cpp/</p>
<p>https://blog.csdn.net/u013148167/article/details/54236076</p>
]]></content>
  </entry>
  <entry>
    <title>快速排序的几种实现</title>
    <url>/2023/09/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="双指针前移法">双指针前移法</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 5;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int partition(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	int pre = left;</span><br><span class="line">	int cur = pre + 1;</span><br><span class="line">	int key = v[left];</span><br><span class="line">	while (cur &lt;= right) &#123;</span><br><span class="line">		if (v[cur] &lt; key &amp;&amp; ++pre != cur) swap(v[cur], v[pre]);</span><br><span class="line">		++cur;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(v[left], v[pre]); // 将基准元素放回正确的位置</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line">	s.push(left);</span><br><span class="line">	s.push(right);</span><br><span class="line">	while (!s.empty()) &#123;</span><br><span class="line">		int r = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		int l = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		if (l &gt;= r) continue;</span><br><span class="line">		int boundary = partition(v, l, r);</span><br><span class="line">		s.push(l);</span><br><span class="line">		s.push(boundary - 1);</span><br><span class="line">		s.push(boundary + 1);</span><br><span class="line">		s.push(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; v;	</span><br><span class="line">	int x;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		v.push_back(x);</span><br><span class="line">	&#125;	</span><br><span class="line">	quickSort(v, 0, n - 1);</span><br><span class="line">	for (auto element : v) &#123;</span><br><span class="line">		cout &lt;&lt; element &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录</title>
    <url>/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="课堂笔记">课堂笔记</h3>
<p>2023-9-6 #### 链表</p>
<p>TO DO 定义一个模板类 ?</p>
<p>如何判断链表是否有环 1. 使用 map
对于地址打上标记，如果同一个地址被访问了两次就是有环的。 2.
快慢指针(Floyd's Cycle Detection Algorithm)，使用同余方程得到 <span class="math inline">\(a + kp\)</span> 和 <span class="math inline">\(b +
kq \pmod{n}\)</span>，其中 a b 分别是两个指针进入环的初始步长，k
是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 <span class="math inline">\(b - a \equiv k(p - q)\)</span> 它们的步长差值为 1
的时候可以始终保证同余。</p>
<p>对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为
1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。
下面是一段 Python 程序演示： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure> ##### 找出有环链表的入环点
可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S
点，入环点是 T 点，绿色的部分是慢指针所走过的路程。
对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S
点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。
可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以
ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。
<img src="/.com//09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class></p>
<h5 id="floyd-判圈算法和-brent-判圈算法">Floyd 判圈算法和 Brent
判圈算法</h5>
<p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。
其实上面的快慢指针方法就是 Floyd
判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。
还有一种判圈的算法，比它更快，就是 <strong>Brent</strong>
判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第
n 轮，乌龟跳到兔子的位置，兔子走<span class="math inline">\(2^{n-1}\)</span>步。</p>
<h5 id="扩展">扩展</h5>
<p>在申明类中的成员函数后面加上 <code>const</code>
函数就成了只读函数，如
<code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure> &gt;
静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字"static"的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure> 函数指针的应用： 1. 把函数作为参数传入另一个函数
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2. 第二个例子，排序上的应用 使用 <code>ascending</code> 和
<code>descending</code> 两个函数代替大小判断 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> lambda
函数的书写结构： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <!-- 
函数指针应用？lambda 函数？ 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- STL 中的**迭代子类**？？ --&gt;</span><br><span class="line"></span><br><span class="line">#### 分而治之 divide-and-conquer</span><br><span class="line">##### 归并排序</span><br><span class="line">一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</span><br><span class="line">&gt; 整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 **性质滚性质**，一直带动，所以可以达到加速的目标。</span><br><span class="line">&#123;%asset_img 时间复杂度计算.png%&#125;</span><br><span class="line"></span><br><span class="line">TO DO:</span><br><span class="line">？？非递归版本的归并排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 快速排序</span><br><span class="line">&lt;!-- 快速排序时间复杂度</span><br><span class="line">最坏 概率统计的意义下？ --&gt;</span><br><span class="line">关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点...</span><br><span class="line">&#123;%asset_img 快速排序算法.png%&#125;</span><br><span class="line">关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</span><br><span class="line">&#123;%asset_img 快速排序时间复杂度.png%&#125;</span><br><span class="line">&#123;%asset_img 快速排序平均时间复杂度.png%&#125;</span><br><span class="line">上面摘自知乎 https://zhuanlan.zhihu.com/p/341201904</span><br><span class="line">##### 2-D maxima finding problem</span><br><span class="line">这是一个 maxima 问题，一般这种问题有两种解决方式。</span><br><span class="line">1. 排序法</span><br><span class="line">&#123;%asset_img 排序法极大点.png%&#125;</span><br><span class="line">2. 分治法</span><br><span class="line">&#123;%asset_img 分治法极大点.png%&#125;</span><br><span class="line">摘自知乎 https://zhuanlan.zhihu.com/p/27850478</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- 平面极大点</span><br><span class="line">分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 --&gt;</span><br><span class="line"></span><br><span class="line">##### the closest pair problem</span><br><span class="line">感觉 OI-Wiki 讲解的很全面</span><br><span class="line">https://oi-wiki.org/geometry/nearest-points/</span><br><span class="line">还有推广：平面最小周长三角形</span><br><span class="line">$\dfrac&#123;d \times 2d&#125;&#123;\frac&#123;1&#125;&#123;4&#125; \times \pi \times (\frac&#123;d&#125;&#123;2&#125;)^&#123;2&#125;&#125;$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</span><br><span class="line"></span><br><span class="line">&lt;!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）</span><br><span class="line"></span><br><span class="line">时间复杂度？ --&gt;</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### the convex hull problem</span><br><span class="line">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- ?</span><br><span class="line">一个著名算法，礼物算法？ Jarvis March</span><br><span class="line">首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着</span><br><span class="line">不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了</span><br><span class="line">但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去</span><br><span class="line">找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 --&gt;</span><br><span class="line"></span><br><span class="line">##### matrix multiplication </span><br><span class="line">&lt;!-- ?</span><br><span class="line">P Q R S T U V?</span><br><span class="line">时间复杂度大概是 $O(\log_2(7)) \approx O(n^&#123;2.81&#125;)$?</span><br><span class="line">但是仍然不是最优的，具体可以自己去搜索一下 --&gt;</span><br><span class="line">使用类实现的矩阵的一些基础操作，可以看 `Fibonacci.cpp`</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### FFT</span><br><span class="line">分治做法，见 `FFT.md` 和 `FFT.cpp`(使用自带的 complex 类实现)</span><br><span class="line">其中，使用自己手写类实现的 FFT 在 `FFTClass.cpp`</span><br><span class="line">(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</span><br><span class="line"></span><br><span class="line">##### Medians and Order Statistics</span><br><span class="line">对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log&#123;n&#125;)$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</span><br><span class="line">每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</span><br><span class="line">还有一种递归的算法，分为 5 个数，</span><br><span class="line"></span><br><span class="line">nth_element() ?? 函数</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。</span><br><span class="line">只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。</span><br><span class="line">为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</span><br><span class="line"></span><br><span class="line">##### Abstract Data Type(ADT)</span><br><span class="line">抽象数据类型</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</span><br><span class="line">不想改变内部元素的时候记得加 const，如果不加的话，`void Func(const List&amp; l) &#123; l.print(); &#125;` 其中不允许调用，因为 Func 有修改成员变量的风险。</span><br><span class="line">**常引用？**</span><br><span class="line">**把函数当作函数的参数？**</span><br><span class="line">派生类禁止父类的函数或者方法？ </span><br><span class="line">括号匹配问题 Bracket Matching Problem</span><br><span class="line">计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</span><br><span class="line">双端队列 dequeue</span><br><span class="line">环形数组</span><br><span class="line"></span><br><span class="line">#### 递归消除</span><br><span class="line">##### 一般性消除办法</span><br><span class="line">- 利用堆栈，模拟栈来实现，见 `Hanoi.cpp`</span><br><span class="line"></span><br><span class="line">汉诺塔问题 递归求解，如何去掉递归求解。</span><br><span class="line">$f_n = 2 f_&#123;n - 1&#125; + 1$，所以 $(f_n + 1) = 2(f_&#123;n - 1&#125; + 1)$</span><br><span class="line"></span><br><span class="line">##### 倒水问题</span><br><span class="line">这种任务方案其实挺多的。其实，背后对应的是**辗转相除法**。</span><br><span class="line">我们可以倒出来的水的数量就是余数。</span><br><span class="line">设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 `ax + by = c`，如果有解，就是 $\gcd&#123;(a, b)&#125; | c$</span><br><span class="line"></span><br><span class="line">##### 求解组合数</span><br><span class="line">https://oi-wiki.org/math/combinatorics/combination/ 见 OI-Wiki各种组合数公式</span><br><span class="line">https://zhuanlan.zhihu.com/p/602675596 二项式反演</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是**过于耦合了**。所以，对于一个类来说，接口是很重要的。</span><br><span class="line"></span><br><span class="line">##### lowbit</span><br><span class="line"></span><br><span class="line">#### 树和二叉树</span><br><span class="line">树中所有节点度数的最大值叫做整个树的度。</span><br><span class="line"></span><br><span class="line">##### 树的表示</span><br><span class="line">一共有四种表示树的方式：</span><br><span class="line">1. 树形结构。很直观、形象</span><br><span class="line">2. 文氏图表示法。使用集合以及集合的包含关系描述树结构。</span><br><span class="line">3. 凹入表示法。使用线段的伸缩描述树结构。</span><br><span class="line">4. 括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</span><br><span class="line"></span><br><span class="line">树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</span><br><span class="line"></span><br><span class="line">按层次遍历二叉树，可能还是比较吃内存的。</span><br><span class="line">DLR LDR LRD </span><br><span class="line">前序 中序 后序 和 根的区别？</span><br><span class="line"></span><br><span class="line">##### 非递归遍历</span><br><span class="line">对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 `GetTreeOrderNor.cpp` </span><br><span class="line">递归形式参见 `GetTreeOrderRecursion.cpp` </span><br><span class="line">给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 `ParseTreeSequence.cpp`</span><br><span class="line"></span><br><span class="line">##### 中序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">这样也可以充分利用空间</span><br><span class="line">将叶子节点的右孩子指向下一个应改遍历的节点(因为一开始叶子节点的右孩子是 null，造成了浪费)</span><br><span class="line">并且加一个 bool 类型的变量，表示这个节点的右孩子是不是进行了修改。</span><br><span class="line">这样中序遍历的时候好像也会简单很多(在中序遍历的意义下，将二叉树变成了一个单链表)</span><br><span class="line">这样二叉树的遍历就不再依赖于堆栈，并且产生了向前向后的两个方向，和双链表的行为是比较相似的。</span><br><span class="line"></span><br><span class="line">##### 前序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">顺序建立就是修改右子树</span><br><span class="line">但是如果反过来会出现左孩子已经被占用的问题，此时需要借助堆栈</span><br><span class="line"></span><br><span class="line">##### 后序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%asset_img 线索二叉树.png%&#125;</span><br><span class="line"></span><br><span class="line">#### 堆</span><br><span class="line"></span><br><span class="line">##### 二叉堆</span><br><span class="line"></span><br><span class="line">当我们谈论到堆(Heap)时，通常指的是二叉堆(Binary Heap)，它是一种特殊的树形结构，常用于实现优先队列和一些图算法(物理存储上是数组，但是逻辑结构上是二叉树，这也是为什么我们可以使用 vector 来模拟的原因)。</span><br><span class="line"></span><br><span class="line">堆的性质：</span><br><span class="line">1. 二叉树结构：堆是一种完全二叉树，除了最后一层，别的层的节点都是满的，最后一层的节点从左向右填充。</span><br><span class="line">2. 小根堆：任何父节点的值都小于等于其子节点的值。</span><br><span class="line">3. 不唯一性：对于给定的数据集，可能存在多个不同的最小堆或者最大堆。</span><br><span class="line">4. 只是保证了节点的权值大于两个儿子节点的权值，也就是说，堆维护的更是我们关注的相对大小关系，尤其是最顶部的元素大小，我们并不关心全序大小关系(也无法维护)。</span><br><span class="line"></span><br><span class="line">&gt;   在实际中，实现堆（Heap）通常更倾向于使用向量（数组）来模拟二叉树的结构，而不是构建一个显式的二叉树数据结构。</span><br><span class="line"></span><br><span class="line">##### 二项堆</span><br><span class="line"></span><br><span class="line">##### Fibonacci 堆</span><br><span class="line"></span><br><span class="line">##### lazy 机制</span><br><span class="line"></span><br><span class="line">上面的最简单的二叉堆做法呢，我们很好地利用了二叉树序号之间的关系(父子的序号有关系)，但是我们在更新的时候每一次都是 $\log&#123;n&#125;$ 的复杂度，不是很优，比如说有些元素我们以后根本用不到，而堆又本身不是关注全序关系的，所以我们可以利用 lazy 机制。</span><br><span class="line"></span><br><span class="line">TODO </span><br><span class="line">现在库里面的堆，基本上都不是基于 **二叉堆**(Binary Heap) 实现的。</span><br><span class="line">Fibonacci 堆 也是希望我们去更多地了解一些堆。</span><br><span class="line">堆的合并、二叉堆的合并？</span><br><span class="line">二项堆</span><br><span class="line">重载运算符</span><br><span class="line"></span><br><span class="line">#### 编码问题</span><br><span class="line"></span><br><span class="line">结构光扫描中，我们如何马上知道这条光是第几条光？就要用到编码了</span><br><span class="line">能不能发明一种序列，使得连续的几个在序列中是唯一的，longest ？ 是多长？</span><br><span class="line">3 个颜色的话，先画出 27 个节点。RRR 的话，连接 RRG RRB(它的后继节点)</span><br><span class="line">寻找访问序列最长的，而且不能重复</span><br><span class="line">深度遍历可以吗？最好不要写递归，可以队列、栈</span><br><span class="line"></span><br><span class="line">#### 霍夫曼树</span><br><span class="line"></span><br><span class="line">每一次找权值最小两个节点，变为 n - 1 个节点</span><br><span class="line">1. 能不能构建出来</span><br><span class="line">2. 总体的最小代价</span><br><span class="line">可以搜索霍夫曼树的题目</span><br><span class="line">实现持久化的最小两个数？手写优先队列？平衡树？</span><br><span class="line"></span><br><span class="line">#### 左倾堆 / 左倾树 / 左偏堆 / 左偏树</span><br><span class="line"></span><br><span class="line">虽然二叉堆的插入、删除操作挺好的，但是不支持合并。所以我们想寻找一种数据结构使得堆在合并的时候比较高效。</span><br><span class="line">&gt; Leftist Heap is a priority queue data structure that also supports merge of heaps in O(log n) time.</span><br><span class="line"></span><br><span class="line">FHQ Treap TODO</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji TODO</span><br><span class="line"></span><br><span class="line">最优传输理论</span><br><span class="line"></span><br><span class="line">启发式合并堆</span><br><span class="line"></span><br><span class="line">#### 二叉平衡树</span><br><span class="line"></span><br><span class="line">可以证明平衡二叉树的高度为 $\log&#123;n&#125;$ 吗？</span><br><span class="line"></span><br><span class="line">N(h) = 1 + N(h - 1) + N(h - 2); AVL 树的高度推导 N(h) 表示高度为 h 时最不平衡时的节点个数。</span><br><span class="line"></span><br><span class="line">我们是按照左右子树的树高度之差来定义的，这只是定义平衡的一种。但是还有很多别的方式，比如左右子树的节点。</span><br><span class="line"></span><br><span class="line">维护平衡的机制有很多种，比如说典型的 B 树，2-3-4树，它所有的叶子都在同一个高度上面。它最不满的情况就是一个满二叉树，所以它可以保证高度在 $\log$ 级别。</span><br><span class="line"></span><br><span class="line">AVL B树 红黑树 234树 Treap</span><br><span class="line">红黑树的实际应用比较频繁，它的效率比较高一点。红黑树和 234树之间的关系？？ TODO</span><br><span class="line"></span><br><span class="line">插入的时候常常面临三种情形。</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/MashPlant/solution2-p3369 B 树代码</span><br><span class="line"></span><br><span class="line">LCT问题？ Link Cut Tree</span><br><span class="line"></span><br><span class="line">Treap 的高度 log 证明？</span><br><span class="line"></span><br><span class="line">#### the mathematics of rubik&#x27;s cube</span><br><span class="line"></span><br><span class="line">#### Dijkstra 算法</span><br><span class="line"></span><br><span class="line">正确性证明？</span><br><span class="line"></span><br><span class="line">多边形</span><br><span class="line"></span><br><span class="line">差分约束问题 线性规划问题 max \sum d 要求比 dijkstra 更加严苛？</span><br><span class="line"></span><br><span class="line">Gorubi </span><br><span class="line"></span><br><span class="line">最短路的话线性规划没有 dijkstra 更加优</span><br><span class="line"></span><br><span class="line">A* 算法？</span><br><span class="line"></span><br><span class="line">#### 二叉树在区间上？</span><br><span class="line"></span><br><span class="line">维护直接的 Rank 感觉代价过于高，因为每一次删除和插入都要把其余元素都改变一次，所以我们不直接维护 Rank。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二叉树序列化？https://zhuanlan.zhihu.com/p/26418233</span><br><span class="line"></span><br><span class="line">#### 线段相交的问题</span><br><span class="line"></span><br><span class="line">两个结构：</span><br><span class="line">1. 处理事件的优先队列(关键位置停下来，遇到了水平线段的左端点，遇到了水平线段的右端点，遇到了竖直线段)(需要使用一个二叉树维护水平线段，包括水平竖直关系)(水平线段的 y 高度使用二叉树维护了？树套树？)</span><br><span class="line">2. 维护扫描的每个关键位置的全序列表</span><br><span class="line"></span><br><span class="line">#### kd 树</span><br><span class="line"></span><br><span class="line">grid 2d tree</span><br><span class="line">quadtree(四叉树，每一个格子一分为 4) bsptree(每一次有一个平面，对于所在的平面二分，在二维的情况下就是直线)</span><br><span class="line"></span><br><span class="line">上面的结构，除了 grid 的应用都是很多的。各自在不同的应用场景下使用。</span><br><span class="line"></span><br><span class="line">kd 树其实是 bst 树的延申。可是很多时候一维数据是不够的，很多情况都是高维的东西。在机器学习中应用也很多。</span><br><span class="line">ray tracing</span><br><span class="line">2d range serach</span><br><span class="line"></span><br><span class="line">从乱序中在 O(n) 的时间复杂度下找出中位数。</span><br><span class="line"></span><br><span class="line">1. 每一刀下去，都是将矩形分为两个部分。</span><br><span class="line">2. 奇偶相间，第一层竖线划分，第二层就是水平划分。(优化就是把点很紧密的包在一块？)</span><br><span class="line"></span><br><span class="line">nth_element 严格 O(n) 查找中位数</span><br><span class="line"></span><br><span class="line">#### 跳表 Skip List</span><br><span class="line"></span><br><span class="line">跳表是相对年轻的一个数据结构，1990 年由 Bill Pugh 提出。</span><br><span class="line">我们需要区分一下数据域和指针域</span><br><span class="line">https://www.cnblogs.com/bigsai/p/14193225.html</span><br><span class="line"></span><br><span class="line">#### KMP</span><br><span class="line"></span><br><span class="line">前缀和后缀的问题</span><br><span class="line"></span><br><span class="line">BM 算法？</span><br><span class="line"></span><br><span class="line">DFA</span><br><span class="line"></span><br><span class="line">#### 并查集(Union-find)</span><br><span class="line"></span><br><span class="line">虽然并查集的代码是最少的一个，但是确实非常有用的。它可以解决**等价类**相关的问题。</span><br><span class="line"></span><br><span class="line">link-by-size 按照大小合并，此时最高高度不超过 log n</span><br><span class="line">当然也有按照 rank(height)高度合并。</span><br><span class="line"></span><br><span class="line">还有路径压缩(path compression)</span><br><span class="line"></span><br><span class="line">无路径压缩的时候，复杂度是 $m \log n$</span><br><span class="line">有路径压缩的时候，复杂度是 $m \alpha (m, n)$</span><br><span class="line">其中，$\alpha$ 是反阿克曼函数。</span><br><span class="line"></span><br><span class="line">#### 图</span><br><span class="line"></span><br><span class="line">每一个节点有 in 和 out 两个邻接表</span><br><span class="line"></span><br><span class="line">矩阵的形式存储的时候，可能并行化运算的时候更加容易。</span><br><span class="line"></span><br><span class="line">prim 求最小生成树</span><br><span class="line"></span><br><span class="line">稠密图和稀疏图使用不同的堆复杂度还不一样？？</span><br><span class="line"></span><br><span class="line">Kruskal 实现最小生成树</span><br><span class="line"></span><br><span class="line">稀疏图 prim 和 kruskal 复杂度差不多，但是稠密图中似乎 prim 算法比较好。</span><br><span class="line"></span><br><span class="line">cut 割</span><br><span class="line"></span><br><span class="line">割中最小权值的边一定出现在最小生成树上 证明了 Prim 的正确性？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 欧拉回路问题</span><br><span class="line"></span><br><span class="line">桥 bridge 它的去除，影响了整个图的连通性</span><br><span class="line"></span><br><span class="line">证明方式</span><br><span class="line"></span><br><span class="line">如何找到欧拉回路(两种算法)?</span><br><span class="line"></span><br><span class="line">Fleury&#x27;s Algorithm 此时经常有一种方法和它相提并论，Hierholzer(希尔霍尔策算法) 算法，后者实际上运行效率会更高一点(标记的注意事项？)，感觉有一个硬伤，并查集没有办法递增式构建？？。</span><br><span class="line"></span><br><span class="line">欧拉骰子？？</span><br><span class="line"></span><br><span class="line">相联系的有一个哈密顿回路问题。</span><br><span class="line"></span><br><span class="line">#### </span><br><span class="line"></span><br><span class="line">### 作业</span><br><span class="line"></span><br><span class="line">1. 手写一个 List</span><br><span class="line"></span><br><span class="line">见 `List.cpp` `LinkList.h` `LinkList.cpp` </span><br><span class="line">其中，`List.cpp` 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 `Node&lt;T&gt;*` 的形式。</span><br><span class="line">但是在 `LinkList.h` 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 `&lt;T&gt;` 了，这种形式也是我们更加推荐的。</span><br><span class="line"></span><br><span class="line">2. 手写一个面向对象的快速排序</span><br><span class="line">`quick_sort.cpp` 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢</span><br><span class="line">其中，需要注意`函数对象`的写法。</span><br><span class="line"></span><br><span class="line">非递归版本：</span><br><span class="line">**双指针前移法**</span><br><span class="line">感觉很强，短小精悍</span><br><span class="line">见 `QuickSortNor.cpp`</span><br><span class="line">使用自己手写的栈，实现了对于类的非递归版本的快速排序。</span><br><span class="line"></span><br><span class="line">3.  </span><br><span class="line">&lt;!-- 基于自己写的链表</span><br><span class="line">实现堆栈</span><br><span class="line">放在不同的文件中</span><br><span class="line">想规范一下大家写代码习惯 --&gt;</span><br><span class="line">在这次的作业中，注意：</span><br><span class="line">我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template&lt;class E&gt;</span><br></pre></td></tr></table></figure> template<class U> friend std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, const LinkList<U>&amp; list); ```
其中，ostream 是一种返回类型。</p>
<ol start="4" type="1">
<li></li>
</ol>
<ul>
<li>以非递归的形式实现汉诺塔，并且尽量少内存。 见
<code>Hanoi.cpp</code></li>
<li>写最大公约数递推的程序。给定两个整数，写出最大公约数的标准形式，d =
ax + by，x y 可能是负数 我们规定 |x| &lt; |y| 此时取值是唯一的。 见
<code>exgcd.cpp</code>
上面的扩展欧几里得是递归实现的，但是我们还是追求非递归版本，讲解参考下面的博客：
https://www.cnblogs.com/zbhfz/p/11267438.html </li>
</ul>
<ol start="5" type="1">
<li>非递归全排列 康托展开 非递归，根据排列规律输出所有的排列</li>
</ol>
<p>见 <code>CantorExpansion.cpp</code> <code>permutation.cpp</code>
<code>next_permutation.cpp</code></p>
<ol start="6" type="1">
<li><p>求斐波那契数列通项 特征根法怎么来的呢？
人们发现特征根对于分解递推式子是有帮助的 对于一个具体的 n 输出 F_n
矩阵加速递推 见 <code>Fibonacci.cpp</code></p></li>
<li><p>写一写二叉树的数据结构，支持几种遍历方式 层次 先序 中序 后序
每一个节点都不保存父亲节点 可以使用堆栈来实现 不要递归</p></li>
</ol>
<p>如果给出了不同遍历方式得到的结果，如何获得原来树的结构？</p>
<p>二叉树有一个函数，传入两个字符串序列，是不是都能恢复成原来的二叉树结构？最后输出括号表示方式的形式。</p>
<p>见 <code>ParseTreeSequence.cpp</code> 和
<code>GetTreeOrderNor.cpp</code></p>
<p>还有一种比较简洁的方式可以参考 于老师代码中的
<code>parseTree.cpp</code></p>
<ol start="8" type="1">
<li>如何形成中序遍历意义下的线索二叉树(双向的)
并且用自己的线索二叉树再次实现双向遍历</li>
</ol>
<p>前序和后序不完美</p>
<p>线索二叉树的必要？历史的产物？</p>
<ol start="9" type="1">
<li>自己搜索霍夫曼树的题目</li>
</ol>
<p>多叉树到二叉树的转化？</p>
<p>Weighted Path Length of Tree, WPL</p>
<p>中位数寻找？TODO</p>
<p>为什么需要将 友元函数的定义直接写进去 ？ TODO</p>
<ol start="10" type="1">
<li><p>了解一下 Fibonacci 堆，有精力的同学可以尝试实现。</p></li>
<li><p>实现一个左偏堆</p></li>
<li><p>写一个 AVL 维护平衡，支持插入删除查找</p></li>
<li><p>R G B 非递归扫描？搜索如何存储路径状态？(直接将一个 vector
作为参数传入)</p></li>
<li><p>实现 Treap Splay FHQTreap ?（附加）</p></li>
<li><p>魔方？rubik's cube?</p></li>
<li><p>若干不相交的多边形，输出从多边形外面一点到外面另一点的最短路径。</p></li>
<li><p>尝试完善代码，为二叉树每一个节点添加
size，同时提供一个接口，返回一个节点的 rank。</p></li>
<li><p>写一个 kd 树代码，支持最近邻的查询，查找一个框框有多少点？输入 n
个点，输出就是求最近的点，维护一个 kd
树的类，需要的基本行为还是最好支持一下，不过我们最关心的还是最近点。</p></li>
<li><p>快速排序进阶。多种排序方式组合实现一个高效的快速排序。
使用快速排序(在其函数上进行修改)实现线性查找元素第 k 小。
荷兰旗问题？</p></li>
<li><p>给定若干竖直和水平的随机长度的线段，并且保证一个 y 坐标或者一个 x
坐标下只有一条线段，求这些线段的交点个数。</p></li>
<li><p>最长公共子序列</p></li>
<li><p>bitset 求解高维偏序问题</p></li>
<li><p>k 短路问题</p></li>
<li><p>完成 KMP 算法</p></li>
<li><p>并查集实现 鼓励大家实现基于 rank 的
union，希望并查集中有路径压缩的功能（不需要新写一个函数，只需要在 find
时顺便修改）。</p></li>
<li><p>实现 Prim 算法</p></li>
<li><p>实现 Kruskal 算法</p></li>
<li><p>教材以 Fleury 算法为主，但是老师更希望实现
希尔霍尔策算法，体会在桥边上有没有更好的策略。</p></li>
<li></li>
</ol>
--></p>]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记2</title>
    <url>/2023/11/12/%E6%9D%82%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="apt">apt</h4>
<p>Ubuntu 主要使用 apt(Advanced Package Tool)作为包管理工具。APT
是一套工具集，用于安装、更新、卸载和管理软件包。</p>
<p>下面是一些常见的 apt 指令： sudo apt update:
用于更新本地包信息的命令，以确保系统知道可用的软件包和更新。 sudo apt
upgrade: 用于升级已安装软件包的命令。 sudo apt install package_name:
用于安装特定软件包的命令。 sudo apt remove package_name:
用于卸载已安装的软件包。 sudo apt search search_term:
用于在存储库中搜索软件包的命令。 sudo apt list:
用于列出可用的软件包。</p>
<p>Ubuntu的软件存储库包含大量的开源软件包，而APT使得管理和安装这些软件包变得非常方便。APT还支持依赖解决，确保软件包安装时满足其所需的依赖项。</p>
<p>虽然 Ubuntu 使用 apt，但是我们也可以在 Ubuntu
上面安装其他的包管理工具。</p>
<h4 id="arch-linux">Arch Linux</h4>
<p>Arch
Linux是一种面向Linux发烧友和高级用户的Linux发行版，以其<strong>极简的设计和强大的定制性</strong>而闻名。</p>
<p>Arch
Linux采用滚动发布模型，这意味着它不会按照固定的版本发布，而是持续更新软件包以提供最新的功能和安全性修复。</p>
<p>Arch
Linux的包管理系统使用称为"pacman"的工具，它允许用户轻松地安装、更新和删除软件包。用户可以通过Arch
User
Repository（AUR）来访问大量社区维护的软件包，这些软件包不包含在官方仓库中，从而增加了软件可用性。</p>
<p>由于Arch
Linux的定制性，用户必须亲自配置和设置系统，包括桌面环境、窗口管理器和其他系统组件。这使得Arch
Linux适合那些喜欢自定义自己的Linux系统的用户，但也可能对新手来说有一定的学习曲线。</p>
<h4 id="数据库结构">数据库结构</h4>
<p>一般数据库中有着不同的用户，不同用户下有着不同是数据库，并且不同数据库下有着不同的表格。</p>
<p>这是数据库管理的一种基本安全和隔离策略，有助于确保数据的完整性、安全性和隔离。</p>
<p>下面是一些应用情况：</p>
<ol type="1">
<li><p><strong>不同用户访问不同的数据库</strong>：不同用户可以被授予访问不同数据库的权限。这意味着用户A可以访问数据库A，而用户B可以访问数据库B，但它们无法相互访问对方的数据库。</p></li>
<li><p><strong>不同用户访问相同数据库的不同表格</strong>：即使多个用户可以访问相同的数据库，也可以根据其权限来访问和操作不同的表格。例如，用户A可能只能访问表格X，而用户B可以访问表格Y。</p></li>
<li><p><strong>权限级别不同</strong>：用户的权限级别可以不同，例如只读用户、读写用户、管理员等。这决定了用户可以执行的操作和管理的范围。</p></li>
</ol>
<h4 id="gis-系统">GIS 系统</h4>
<h4 id="os.path.join-函数">os.path.join 函数</h4>
<p><code>os.path.join</code> 函数用于构建文件和目录路径。
它可以接受任意数量的字符串参数，然后根据操作系统的规则构建有效的路径字符串。
<strong>这对于创建跨平台的路径非常有用</strong>，因为不同操作系统使用不同的路径分隔符（例如，在Unix和Linux系统上是/，在Windows系统上是）。</p>
<h4 id="os.listdir-函数">os.listdir() 函数</h4>
<p><code>os.listdir()</code> 函数用于列出指定目录中的文件和子目录。</p>
<h4 id="dos-命令">Dos 命令</h4>
<h4 id="低代码平台">低代码平台</h4>
<p>低代码平台(Low-Code
Platform)是一种用于应用程序开发的软件开发工具或平台，它旨在简化和加速应用程序开发过程。这种平台允许开发人员使用图形用户界面、拖放式元素和少量的编程代码来创建应用程序，而不需要从头开始编写大量的传统编程代码。</p>
<h4 id="jdk-和-jre">JDK 和 JRE</h4>
<ol type="1">
<li><p>Java开发工具包 (JDK): JDK
是用于开发Java应用程序的核心工具集。它包括Java编译器 (javac)、Java虚拟机
(JVM)、标准类库和各种开发工具。JDK是开发Java应用程序的必备组件，你需要安装它才能开始编写和运行Java代码。</p></li>
<li><p>Java运行时环境 (JRE): JRE
包含Java应用程序的运行时组件，包括Java虚拟机 (JVM)
和标准类库。如果你只需要运行Java应用程序而不是开发它们，你可以安装JRE而不是完整的JDK。</p></li>
</ol>
<p>它们的简写是： JDK: Java Development Kit（Java开发工具包） JRE: Java
Runtime Environment（Java运行时环境）</p>
<p>javac 是 Java 编程语言中的编译器。它用于将 Java 源代码文件（以 .java
为扩展名）转换成 Java 字节码文件（以 .class
为扩展名），这些字节码文件可以由 Java
虚拟机（JVM）执行。编译器负责将源代码翻译成计算机可以理解的字节码，以便在运行时执行。</p>
<p>使用 javac 命令，你可以编译你的 Java
源代码文件，检查代码中是否有语法错误，以及生成可执行的字节码文件。</p>
<h4 id="使用-jvm-执行">使用 JVM 执行</h4>
<p>使用 JVM 执行编译后的 java 代码，有很多重要作用。</p>
<ol type="1">
<li><p>跨平台性：Java程序编译成字节码，而不是与特定操作系统或硬件相关的本地机器代码。这使得Java应用程序具有跨平台性，可以在支持Java的不同操作系统上运行，只要这些系统上安装了相应的JVM。这大大简化了跨平台开发和部署。</p></li>
<li><p>安全性：JVM提供了各种安全特性，包括字节码验证和安全沙箱，以确保Java应用程序在运行时不会执行危险的操作或访问系统资源。这有助于防止恶意代码的执行和对系统的潜在损害。</p></li>
<li><p>内存管理：JVM负责Java应用程序的内存管理，包括垃圾回收。这减轻了开发人员的负担，因为他们不必手动分配和释放内存，而是依赖JVM来自动处理内存管理。</p></li>
<li><p>性能优化：JVM具有即时编译器和其他优化技术，可以在运行时提高Java应用程序的性能。它可以根据应用程序的行为动态进行性能调整，以提供更高的执行效率。</p></li>
<li><p>多线程支持：JVM提供了多线程支持，允许Java应用程序轻松地创建和管理多个线程，以实现并行执行和并发操作。</p></li>
<li><p>异常处理：JVM提供了强大的异常处理机制，使开发人员能够更容易地检测和处理错误条件，从而增加应用程序的可靠性。</p></li>
</ol>
<h4 id="python-解释器">python 解释器</h4>
<p>Python也使用了虚拟机的概念，具有跨平台性质。Python代码通常由Python解释器执行，这个<strong>解释器充当了Python虚拟机的角色</strong>。Python解释器负责将Python源代码转换为字节码，然后在Python虚拟机上执行这些字节码。</p>
<h4 id="java-环境管理">Java 环境管理</h4>
<p>构建工具(Apache Meaven  Gradle):</p>
<ol type="1">
<li><p><strong>项目构建自动化</strong>。构建工具可以自动化构建过程，包括编译
Java 源代码、打包 JAR
文件、运行单元测试、生成文档等。这大大减少了开发人员手动操作的负担。</p></li>
<li><p><strong>依赖管理</strong>。构建工具可以管理项目的依赖关系，包括第三方库、框架和插件。</p></li>
<li><p>多模块项目支持：构建工具允许你将项目分解为多个模块，每个模块可以有自己的构建配置。这有助于组织大型项目并提高代码的模块化性。</p></li>
</ol>
<p>依赖管理：</p>
<ol type="1">
<li><p>引入第三方库：Java项目通常依赖于各种第三方库和框架，如数据库驱动程序、HTTP客户端库、日志库等。通过在项目配置文件中定义这些依赖关系，你可以告诉构建工具从中央仓库或其他位置下载这些库，然后将它们添加到你的项目中。</p></li>
<li><p>版本控制：依赖管理工具允许你指定依赖库的版本号，确保你使用的是特定版本，避免不同版本之间的冲突。</p></li>
<li><p>自动下载和更新：一旦依赖关系被定义，构建工具可以自动下载和更新这些依赖项，从而简化了维护过程。</p></li>
<li><p>可重用性：依赖管理使你的项目可以更容易地与其他项目共享，因为其他项目可以使用相同的依赖定义。</p></li>
</ol>
<h4 id="vector-赋值">vector 赋值</h4>
<ol type="1">
<li>使用赋值操作符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination;</span><br><span class="line">destination = source; // 使用赋值操作符</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用拷贝构造函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination(source); // 使用拷贝构造函数</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>使用 <code>assign</code> 函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination;</span><br><span class="line">destination.assign(source.begin(), source.end()); // 使用 assign 函数</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>使用范围初始化 / 范围构造函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination(source.begin(), source.end()); // 范围初始化</span><br></pre></td></tr></table></figure>
<h4 id="vector-构造">vector 构造</h4>
<ol type="1">
<li>默认构造函数 其实也就是直接声明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector; // 创建一个空的整数向量</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>指定大小的构造函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector(5); // 创建一个包含5个默认构造的整数的向量</span><br></pre></td></tr></table></figure>
<p>默认值为 0</p>
<ol start="3" type="1">
<li>指定大小和初值的构造函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector(5, 42); // 创建一个包含5个值为42的整数的向量</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li>拷贝构造 有两种，一种是范围的拷贝构造，另一种是直接写另一个 vector
的拷贝构造</li>
</ol>
<p>``` std::vector<int> myVector(myIteratorBegin, myIteratorEnd); //
用迭代器范围初始化向量</int></p>
<p>std::vector<int> myVector(otherVector); // 使用另一个向量初始化新向量
```s</int></p>
]]></content>
  </entry>
  <entry>
    <title>登录实现</title>
    <url>/2023/09/07/%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>一个讲解 https://www.jianshu.com/p/53e687c198b5</p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>现代优化算法</title>
    <url>/2023/08/25/%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>20 世纪 70
年代初期，随着计算复杂性的理论逐步形成，科学工作者发现并证明了大量来源于实际生活中的组合最优化问题是非常难解的，即所谓的
NP 完全问题和 NP 难问题。 80
年代一些现代化优化算法，如遗传算法、模拟退火算法、人工神经网络算法等。这些算法可以比较容易的解决一些复杂的、常规算法很难解决的问题。</p>
<h4 id="遗传算法genetic-algorithm-ga">遗传算法(Genetic Algorithm,
GA)</h4>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>概率论中各种分布</title>
    <url>/2023/10/24/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<figure>
<img src="file:///C:\Users\24964\Documents\Tencent%20Files\2496438098\nt_qq\nt_data\Pic\2023-10\Ori\78e67b20b808405a7fe8f2e1746f58c6.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="离散分布">离散分布</h3>
<h4 id="bernoulli-分布bernoulli-distribution">Bernoulli 分布(Bernoulli
Distribution)</h4>
<h5 id="符号x-sim-b1-p">符号：<span class="math inline">\(X \sim B(1,
p)\)</span></h5>
<h5 id="概率px-k-pk1-p1-k">概率：<span class="math inline">\(P(X = k) =
p^{k}(1-p)^{1-k}\)</span></h5>
<h5 id="期望ex-0times-1-p-1-times-p-p">期望：<span class="math inline">\(E(X) = 0\times (1-p) + 1 \times p =
p\)</span></h5>
<h5 id="方差dx-ex2---ex2-p---p2-p1-p">方差：<span class="math inline">\(D(X) = E(X^{2}) - E(X)^{2} = p - p^2 =
p(1-p)\)</span></h5>
<h5 id="性质">性质：</h5>
<h5 id="应用">应用：</h5>
<h4 id="二项分布binomial-distribution">二项分布(Binomial
Distribution)</h4>
<h5 id="符号xsim-bn-p">符号：<span class="math inline">\(X\sim B(n,
p)\)</span></h5>
<h5 id="概率">概率：</h5>
$$
<span class="math display">\[\begin{aligned}
P(X = k) = \begin{pmatrix}

n \\
k
\end{pmatrix} (1-p)^{n - k}p^k
\end{aligned}\]</span>
<p>$$</p>
<h5 id="期望">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X)= \sum\limits_{k = 0}^{n}kp(X = k) =\sum\limits_{k = 0}^{n}
k\begin{pmatrix}
n \\
k
\end{pmatrix} (1-p)^{n - k}p^k \\
= \sum\limits_{k = 1}^{n}\begin{pmatrix} n - 1\\ m -
1\end{pmatrix}p^{k}(1-p)^{n - k} \quad \quad \quad \\
= \sum\limits_{k = 0}^{n - 1}np\begin{pmatrix}n - 1 \\ k \end{pmatrix}
p^{k}(1-p)^{n - 1 - k} \quad \\
= np\times (p + (1 - p))^{n - 1} \quad \quad \quad \quad \quad  \\
= np \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad
\quad \quad
\end{aligned}
\]</span></p>
<h5 id="方差">方差：</h5>
$$
<span class="math display">\[\begin{aligned}
D(X) = E(X^{2}) - E(X)^{2} =E(X(X-1)+X) - E(X)^{2} \\
=E(X(X-1)) + E(X) - E(X)^{2} \quad \quad \quad \quad  \\

E(X(X-1)) = \sum\limits_{k = 0}^{n}k(k - 1)\begin{pmatrix} n \\
k\end{pmatrix} p^{k}(1-p)^{n - k} \quad \quad \quad \quad \quad \quad
\quad \quad \quad \quad  \\ = n(n - 1)\sum\limits_{k = 2}^{n}
\begin{pmatrix} n - 2\\ k - 2\end{pmatrix} p^{k}(1 - p)^{n - l} \quad
\quad \\
= n(n - 1)\sum\limits_{k = 0}^{n - 2}\begin{pmatrix} n - 2 \\ k
\end{pmatrix} p^{k + 2}(1-p)^{n - 2 - k} \\
= n(n - 1) p^{2} (1 + (1 - p))^{n - 2} \ \ \ \  \quad \quad \quad
\quad  \\
= n(n - 1)p^{2} \quad \quad \quad \quad \quad \quad \quad \quad \quad \
\ \ \quad \quad \\

D(X) = n(n -1)p^{2} + np - n^{2}p^{2}  = np(1-p) \quad \quad \quad
\end{aligned}\]</span>
<p>$$</p>
<h5 id="性质-1">性质：</h5>
<h5 id="应用-1">应用：</h5>
<ol type="1">
<li>一段时间内物理实验仪器捕获的粒子数目。</li>
<li>一段时间内计算机病毒的入侵数。</li>
<li>一本书中的错字数。</li>
</ol>
<h4 id="多项分布multinomial-distribution">多项分布(Multinomial
Distribution)</h4>
<p>多项分布(Multinomial
Distribution)，它是二项分布的推广。二项分布的试验结果只有两个(成功和失败)，而多项分布的试验结果则多于两个。</p>
<h5 id="联合概率函数">联合概率函数：</h5>
<p><span class="math display">\[
\begin{aligned}
P(X_1 = x_1, X_2 = x_2, ..., X_k = x_k) = \dfrac{n!}{x_1!x_2!...x_k!}
p_1^{x_1}p_2^{x_2}...p_{k}^{x_k}
\end{aligned}
\]</span> 多项分布对于每一个结果都有均值和方差，分别为：</p>
<h5 id="期望-1">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X_i) = np_i
\end{aligned}
\]</span></p>
<h5 id="方差-1">方差：</h5>
<p><span class="math display">\[
D(X_i) = np_i(1-p_i)
\]</span></p>
<h4 id="泊松分布possion-distribution">泊松分布(Possion
Distribution)</h4>
<h5 id="符号xsim-plambda">符号：<span class="math inline">\(X\sim
P(\lambda)\)</span></h5>
<h5 id="概率px-x-dfrace-lambdalambdax-x">概率：<span class="math inline">\(P(X = x) = \dfrac{e^{-\lambda}\lambda^{x}
}{x!}\)</span></h5>
<p>证明： 由 <span class="math inline">\(\lambda\)</span>
的定义，单位时间内随机事件发生 <span class="math inline">\(\lambda\)</span>
次，并且每一次事件发生都是独立的，和时间没有关系的。</p>
<p>所以如果我们将单位单位时间划分为 n 份，当 n
趋近于正无穷的时候，我们可以认为每一段时间内事件发生的次数是均匀的。所以每一段时间事件发生的概率都是
<span class="math inline">\(\dfrac{\lambda}{n}\)</span> <span class="math display">\[
\begin{aligned}
P(X = x) = \lim\limits_{n \to +\infty}\begin{pmatrix} n \\
x\end{pmatrix} (\dfrac{\lambda}{n})^{x}(1 - \dfrac{\lambda}{n})^{n - x}
= \dfrac{\lambda^{k}}{k!}e^{-\lambda}
\end{aligned}
\]</span></p>
<h5 id="期望-2">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \sum\limits_{k=0}^{+\infty} k
\dfrac{\lambda^{k}}{k!}e^{-\lambda} \\
&amp;= \lambda e^{-\lambda} \sum\limits_{k = 1}^{+\infty}
\dfrac{\lambda^{k - 1}}{(k - 1)!} \\
&amp;= \lambda e^{-\lambda} e^{\lambda} \\
&amp;= \lambda
\end{aligned}
\]</span></p>
<h5 id="方差-2">方差：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X^{2}) = E(X(X - 1) + X) = E(X(X-1)) + E(X) \\
\end{aligned}
\]</span></p>
$$
<span class="math display">\[\begin{aligned}

E(X(X - 1)) &amp;= \sum\limits_{k = 1}^{+\infty} k(k - 1)
\dfrac{\lambda^{k}}{k!}e^{-\lambda} \\
&amp;=\sum\limits_{k = 2}^{+\infty}\dfrac{\lambda^{k}}{(k -
2)!}e^{-\lambda} \\
&amp;= \lambda^{2}e^{-\lambda}\sum\limits_{k =
0}^{+\infty}\dfrac{\lambda^{k}}{k!}\\
&amp;= \lambda^{2}
\end{aligned}\]</span>
<p>$$</p>
<p><span class="math display">\[
\begin{aligned}
D(X) &amp;= E(X^{2}) - E(X)^{2} \\
&amp;= E(X(X - 1)) + E(X) - E(X)^{2} \\
&amp;= \lambda^{2} + \lambda - \lambda^{2}\\
&amp;= \lambda
\end{aligned}
\]</span></p>
<h5 id="性质-2">性质：</h5>
<ol type="1">
<li>伯努利分布是二项分布的特殊情况，当 n = 1
的时候，二项分布变为伯努利分布。泊松分布可以被看作是二项分布的极端情况，在试验次数非常多或者成功概率非常小的情况下，可以近似为泊松分布。指数分布也可以由泊松分布推导而来。</li>
<li>泊松分布中 <span class="math inline">\(\lambda\)</span>
表示单位时间内随机事件的平均发生次数。在一个特定时间内，某一个事件都会在任意时刻发生(前提是，每次发生都是独立的，并且跟事件没有关系)。</li>
</ol>
<h5 id="应用-2">应用：</h5>
<p>泊松分布是用来描述在给定时间段内随机事件发生次数的分布。例如一天之间收到的电子邮件数量。</p>
<h4 id="几何分布geometric-distribution">几何分布(Geometric
Distribution)</h4>
<h5 id="符号xsim-gp">符号：<span class="math inline">\(X\sim
G(p)\)</span></h5>
<h5 id="概率px-k-1-pk---1p">概率：<span class="math inline">\(P(X = k) =
(1-p)^{k - 1}p\)</span></h5>
<h5 id="期望-3">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \sum\limits_{k = 1}^{+\infty} k \cdot (1-p)^{k - 1}p \\
&amp;=p \sum\limits_{k = 1}^{+\infty} \left( \int k \cdot (1-p)^{k -
1}\right)&#39; \\
&amp;= p \left(-\sum\limits_{k = 1}^{+\infty}(1-p)^{k} \right)&#39; \\
&amp;= p \cdot \dfrac{1}{p^{2}} \\
&amp;= \dfrac{1}{p}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
D(X) &amp;= E(X^{2}) - E(X)^{2} \\
&amp;= \sum\limits_{k = 1}^{+\infty} k^{2}(1 - p)^{k - 1}p -
\dfrac{1}{p^{2}} \\
&amp;= p \left[\sum\limits_{k = 1}^{+\infty}(k+ 1)kq^{k - 1} -
\sum\limits_{k = 1}^{+\infty} kq^{k - 1} \right] - \dfrac{1}{p^{2}} \\
&amp;= \dfrac{1 - p}{p^{2}}
\end{aligned}
\]</span></p>
<h5 id="性质-3">性质：</h5>
<h4 id="超几何分布hypergeometric-distribution">超几何分布(Hypergeometric
Distribution)</h4>
<h5 id="符号">符号：</h5>
<h5 id="概率px-k-fracbeginpmatrix-m-kendpmatrix-beginpmatrix-n---m-n---kendpmatrix-beginpmatrix-n-mendpmatrix-k-leq-minn-m-k_1">概率：<span class="math inline">\(P(X = k) = \frac{\begin{pmatrix} M \\
k\end{pmatrix} \begin{pmatrix} N - M \\ n - k\end{pmatrix}
}{\begin{pmatrix} N \\ M\end{pmatrix} }, k \leq \min(n, M) =
k_1\)</span></h5>
<h5 id="期望-4">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \sum\limits_{k = 1}^{k_1} k \cdot \frac{\begin{pmatrix} M \\
k\end{pmatrix} \begin{pmatrix} N - M \\ n -
k\end{pmatrix}}{\begin{pmatrix} N \\ M\end{pmatrix}} \\
&amp;= \sum\limits_{k = 1}^{k_1} \begin{pmatrix} N - M \\ n -
k\end{pmatrix}\times \frac{\frac{M(M - 1)!}{(k - 1)!(M - k)!}}{\frac{N(N
- 1)!}{n(n - 1)!(N-n)!}} \\
&amp;= \dfrac{nM}{N}\sum\limits_{k = 1}^{k_1} \frac{\begin{pmatrix} M -
1 \\ k - 1\end{pmatrix}\begin{pmatrix}N - M \\ n - k \end{pmatrix}
}{\begin{pmatrix} N - 1\\ n - 1\end{pmatrix}}\\
&amp;= \dfrac{nM}{N} \frac{\sum\limits_{k = 1}^{k_1} \begin{pmatrix} M -
1 \\ k - 1\end{pmatrix}\begin{pmatrix}N - 1 - (M - 1) \\ n - 1 - (k - 1)
\end{pmatrix}}{\begin{pmatrix} N - 1 \\ n - 1\end{pmatrix}} \\
&amp;= \dfrac{nM}{N}
\end{aligned}
\]</span></p>
<h5 id="方差-3">方差：</h5>
<p><span class="math display">\[
E(X^{2})= E(X(X - 1) + X) = E(X(X - 1)) + E(X)
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
E(X(X - 1))) &amp;= \sum\limits_{k = 0}^{k_1} k(k - 1)
\frac{\begin{pmatrix}M \\k \end{pmatrix} \begin{pmatrix} N - M \\ n -
k\end{pmatrix}}{\begin{pmatrix} N \\ n\end{pmatrix}} \\
&amp;= \frac{nM(n - 1)(M - 1)}{N(N - 1)} \sum\limits_{k = 2}^{k_1}
\frac{\begin{pmatrix} M - 2 \\ k - 2\end{pmatrix} \begin{pmatrix} N - M
\\ n - k\end{pmatrix}}{\begin{pmatrix} N - 2 \\ n - 2\end{pmatrix}} \\
&amp;= \frac{nM(n - 1)(M - 1)}{N(N - 1)}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
D(X) = E(X(X - 1))) + E(X) - E(X)^{2}  = \frac{nM(N - M)(N - n)}{N^{2}(N
- 1)}
\end{aligned}
\]</span></p>
<h5 id="性质-4">性质：</h5>
<ol type="1">
<li>当总物品个数远远大于选的个数，或者总物品个数区域无穷大的时候，超几何分布可以近似为二项分布。</li>
<li></li>
</ol>
<h5 id="应用-3">应用：</h5>
<h4 id="负二项分布帕斯卡分布-negative-binomial-distribution-pascal-distribution">负二项分布(帕斯卡分布,
Negative Binomial Distribution, Pascal Distribution)</h4>
<h5 id="符号x-sim-textpascaln-p">符号：<span class="math inline">\(X
\sim \text{Pascal}(n, p)\)</span></h5>
<h5 id="概率px-x-beginpmatrix-x---1-r---1endpmatrixpr1--px---r">概率：<span class="math inline">\(P(X = x) = \begin{pmatrix} x - 1\ \\ r -
1\end{pmatrix}p^{r}(1 -p)^{x - r}\)</span></h5>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024232853695.png" alt="image-20231024232853695">
<figcaption aria-hidden="true">image-20231024232853695</figcaption>
</figure>
<h5 id="期望-5">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \sum\limits_{x = r}^{+\infty} x f(x) \\
&amp;= \sum\limits_{x = r}^{+\infty} x\begin{pmatrix} x - 1 \\ r -
1\end{pmatrix} p^{r}(1 - p)^{x - r} \\
&amp;= \frac{r}{p} \sum\limits_{x = r}^{+\infty} \begin{pmatrix}x  \\ r
\end{pmatrix} p^{r + 1} (1 - p)^{x  - r} \\
&amp;= \frac{rp}{1 - p}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
E(X^{2}) &amp;= \sum\limits_{x = r}^{+\infty} x^{2}f(x) \\
&amp;= \sum\limits_{x = r}^{+\infty} x^{2} \begin{pmatrix}x - 1 \\ r-  1
\end{pmatrix}p^{r}(1 - p)^{x - r} \\
&amp;= \frac{r}{p} \sum\limits_{x = r}^{+\infty} x\begin{pmatrix} x \\
r\end{pmatrix}p^{r + 1} (1 - p)^{x- r} \\
&amp;= \frac{r}{p} \left[\sum\limits_{x = r}^{+\infty}(x +
1)\begin{pmatrix} x  \\ r\end{pmatrix} p^{r+ 1}(1 - p)^{x - r} -
\sum\limits_{x = r}^{+\infty}\begin{pmatrix} x \\ r\end{pmatrix} p^{r+
1}(1 - p)^{x - r}\right] \\
&amp;= \frac{r}{p}(\frac{r + 1}{p} - 1) \\
&amp;= \frac{r(r - p + 1)}{p^{2}}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
D(X) = E(X^{2}) - E(X)^{2} = \frac{r(1 - p)}{p^{2}}
\end{aligned}
\]</span></p>
<h5 id="性质-5">性质：</h5>
<p>Binomial 分布和 Negative Binomial 分布都是多次重复的 Bernoulli
实验。</p>
<p>Binomial关注的是，重复Bernoulli实验成功概率为p，条件为总共实验N次，随机变量为N次实验中成功实验次数k（k∈Z,k∈[0,N]），该随机变量[概率分布为Binomial分布。</p>
<p>Negative
Binomial关注的是，重复Bernoulli实验成功概率为p，条件为累计出现r次失败，随机变量为成功实验次数k（k∈Z,k∈[0,+∞)），该随机变量的概率分布为Negative
Binomial分布。</p>
<p>Binomial和Negative
Binomial分布的随机变量都是成功实验次数，条件不同。从定义上来看，”负“可以理解为站在失败次数的角度看成功。</p>
<h5 id="应用-4">应用：</h5>
<h4 id="伽马-泊松分布gamma-poisson-distribution">伽马-泊松分布(Gamma-Poisson
Distribution)</h4>
<h5 id="符号x-sim-textgamma-poissonalpha-beta">符号：<span class="math inline">\(X \sim \text{gamma-Poisson}(\alpha,
\beta)\)</span></h5>
<h5 id="概率密度函数">概率密度函数：</h5>
<p><span class="math display">\[
\begin{aligned}
f(x) = \dfrac{\Gamma(x + \beta)
\alpha^{x}}{\Gamma(\beta)(1+\alpha)^{\beta + x}x!}
\end{aligned}
\]</span></p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024233912306.png" alt="image-20231024233912306">
<figcaption aria-hidden="true">image-20231024233912306</figcaption>
</figure>
<h5 id="期望-6">期望：</h5>
<p><span class="math display">\[
E(X) = \alpha\beta
\]</span></p>
<h5 id="方差-4">方差：</h5>
<p><span class="math display">\[
\begin{aligned}
D(X) = \alpha \beta + \alpha^{2}\beta
\end{aligned}
\]</span></p>
<h5 id="性质-6">性质：</h5>
<ol type="1">
<li>做变换：<span class="math inline">\(\alpha = (1 - p) / p, \beta =
n\)</span>，就得到 Pascal 分布</li>
</ol>
<h4 id="zeta-分布zeta-distribution">Zeta 分布(Zeta Distribution)</h4>
<h5 id="符号x-sim-textzetaalpha">符号：<span class="math inline">\(X
\sim \text{Zeta}(\alpha)\)</span></h5>
<h5 id="概率函数">概率函数：</h5>
<p><span class="math display">\[
\begin{aligned}
f(x) = \dfrac{1}{x^{\alpha}\sum\limits_{i = 1}^{+\infty}(1/i)^{\alpha}}
\quad x = 1, 2, 3, ...
\end{aligned}
\]</span></p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026215915467.png" alt="image-20231026215915467">
<figcaption aria-hidden="true">image-20231026215915467</figcaption>
</figure>
<h5 id="累计分布函数">累计分布函数</h5>
<p><span class="math display">\[
\begin{aligned}
F(x) = P(X \leq x) = \dfrac{\sum\limits_{i = 1}^{x}
(1/i)^{\alpha}}{\zeta(\alpha)} \quad x = 1, 2, ...
\end{aligned}
\]</span></p>
<h5 id="期望-7">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) = \dfrac{\zeta(\alpha - 1)}{\zeta(\alpha)}
\end{aligned}
\]</span></p>
<h5 id="方差-5">方差：</h5>
<p><span class="math display">\[
\begin{aligned}
D(X) = \dfrac{\zeta(\alpha)\zeta(\alpha - 2) - \zeta(\alpha -
1)^{2}}{\zeta(\alpha)^{2}}
\end{aligned}
\]</span></p>
<h4 id="zipf-分布齐夫定律">Zipf 分布(齐夫定律)</h4>
<h5 id="符号x-sim-textzipfalpha-n">符号：<span class="math inline">\(X
\sim \text{Zipf}(\alpha, n)\)</span></h5>
<h5 id="概率函数-1">概率函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{1}{x^{\alpha}\sum\limits_{i = 1}^{n}(1 / i)^{\alpha}}
\quad  x = 1, 2, 3, ..., n
\]</span></p>
<p>下面是 <span class="math inline">\(\alpha = 1, n = 10\)</span></p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026224615881.png" alt="image-20231026224615881">
<figcaption aria-hidden="true">image-20231026224615881</figcaption>
</figure>
<p>我们记 <span class="math inline">\(H_{n, \alpha} = \sum\limits_{i =
1}^{n} \left(\dfrac{1}{i}\right)^{\alpha}\)</span></p>
<h5 id="期望-8">期望：</h5>
<p><span class="math display">\[
E(X) = \dfrac{H_{n, \alpha - 1}}{H_{n, \alpha}}
\]</span></p>
<h5 id="方差-6">方差：</h5>
<p><span class="math display">\[
D(X) = \dfrac{H_{n, \alpha - 2}H_{n, \alpha} - H_{n, \alpha}^{2}}{H_{n,
\alpha}^{2}}
\]</span></p>
<h5 id="齐夫定律">齐夫定律：</h5>
<p>在自然语言的语料库里，一个单词出现的率与它在频
率表里的排名成反比。所以，频率最高的单词出现的频率大约是出现频率第二位的单词的2
倍，而出现频率第二位的单词侧是出现频率第四位的单词的2倍。这个定律被作为任何与幂
定律概率分布有关的事物的参考。</p>
<h5 id="应用-or-遵循该定律的现象">应用 or 遵循该定律的现象：</h5>
<ol type="1">
<li>英文单词或中文汉字的出现频率：不仅适用于语料全体，也适用于单独的一篇文章</li>
<li>网页访问频率</li>
<li>城镇人口与城镇等级的关系</li>
<li>收入前3%的人的收入</li>
<li>地震震级</li>
<li>固体破碎时的碎片大小</li>
</ol>
<h3 id="连续分布">连续分布</h3>
<h4 id="均匀分布uniform-distribution">均匀分布(Uniform
Distribution)</h4>
<h5 id="符号x-sim-ua-b">符号：<span class="math inline">\(X \sim U(a,
b)\)</span></h5>
<h5 id="概率密度函数-1">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases} \dfrac{1}{b - a} , a &lt; x &lt; b \\
0\end{cases}
\]</span> ##### 分布函数：</p>
<p><span class="math display">\[
F(x) = \begin{cases}
\frac{x - a}{b - a}, &amp;a &lt; x &lt; b \\
0,&amp;x &lt; a \\
1,&amp;x &gt; b
\end{cases}
\]</span></p>
<h5 id="期望-9">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_{-\infty}^{+\infty} x \cdot f(x) \mathrm{d}x \\
&amp;= \int_{a}^{b} \dfrac{x}{b - a} \mathrm{d}x \\
&amp;= \dfrac{a + b}{2}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
E(X^{2}) &amp;= \int_{a}^{b} \dfrac{x^{2}}{b - a} \mathrm{d}x\\
&amp;= \dfrac{a^{2}+ab + b^{2}}{3}
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
D(X) &amp;= E(X^{2}) - E(X)^{2} \\
&amp;= \dfrac{a^{2}+ab + b^{2}}{3} - \left( \dfrac{a+b}{2}\right)^{2} \\
&amp;= \dfrac{(b - a)^{2}}{12}
\end{aligned}
\]</span></p>
<h5 id="性质-7">性质：</h5>
<h5 id="应用-5">应用：</h5>
<h4 id="指数分布exponential-distribution">指数分布(Exponential
Distribution)</h4>
<p>指数分布一个很重要的特征就是无记忆性 <span class="math inline">\(P(x
&gt; s | x &gt; t) = P(x &gt; s - t), s &gt; t\)</span> 。如果我们使用 x
表示等待的时间。那么这个式子的含义就是
<strong>未来我还需要等到多少时间和我已经等待了多长时间没有关系</strong>。</p>
<p>无记忆性的离散版本是 <strong>几何分布。</strong></p>
<h5 id="符号xsim-elambda">符号：<span class="math inline">\(X\sim
E(\lambda)\)</span></h5>
<h5 id="概率密度函数-2">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
\lambda e^{-\lambda x}, &amp;x &gt; 0 \\
\\
0, &amp;x \leq 0
\end{cases}
\]</span></p>
<p>推导：</p>
<p>我们根据实际情况来考虑，如果一个产品的使用寿命是 T，分布函数是 <span class="math inline">\(F(t)\)</span>，那么寿命大于 t 的概率为 <span class="math inline">\(S(t) = 1- F(t)\)</span></p>
<p>如果一个产品已经使用 t 时间，那么在 <span class="math inline">\((t, t
+ \Delta t)\)</span> 这一段时间内，死亡的「风险」为: <span class="math display">\[
\lambda(t) = \lim\limits_{\Delta t \to 0} \dfrac{P(t \leq T \leq t +
\Delta t)}{\mathrm{d}t \cdot S(t)} = \dfrac{f(t)}{S(t)} =
-\dfrac{S&#39;(t)}{S(t)} = -\dfrac{\mathrm{d}}{\mathrm{d}t}\ln(S(t))
\]</span> &gt;
解释：因为我们首先需要活到这个时间，然后在这个时间段死亡，所以有 <span class="math inline">\(S(t) \cdot \lambda(t) = p(T = t)\)</span></p>
<p>我们称这个 <span class="math inline">\(\lambda(t)\)</span>
为风险函数（到这里还没有涉及到无记忆性，这个 <span class="math inline">\(\lambda(t)\)</span> 是一个普遍的风险函数）</p>
<p>如果我们要满足无记忆性，就要有 <span class="math inline">\(\lambda(t)
=
\text{Const}\)</span>（也就是我们在每一个时间下「死亡」的概率都是等大的）</p>
<p>或者我们由「无记忆性」的直接式子推导：<span class="math inline">\(P(T
&gt; s | T &gt; t) = P(T &gt; s - t) \Rightarrow P(t \leq T \leq t +
\Delta t) = P(T &lt; \mathrm{d}t) \cdot S(t)\)</span> 也是得到 <span class="math inline">\(\lambda(t) = \text{Const}\)</span></p>
<p>所以有 <span class="math display">\[
-\dfrac{\mathrm{d}}{\mathrm{d}t}\ln(S(t)) = \text{Const}
\]</span> 解得 <span class="math inline">\(F(t) = 1 - e^{-\text{Const}
\cdot t}\)</span></p>
<p>其中，<span class="math inline">\(\text{Const}\)</span>
表示每一个时间点死亡的风险大小，也就是每一个时间点死亡的概率大小。</p>
<h5 id="分布函数">分布函数：</h5>
<p><span class="math display">\[
F(x) = \begin{cases}
1 - e^{-\lambda x}, &amp;x &gt; 0 \\
0, &amp;x \leq 0
\end{cases}
\]</span> ##### 期望：</p>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_{-\infty}^{+\infty} x \cdot f(x) \mathrm{d}x \\
&amp;= \int_0^{+\infty} x \cdot \lambda e^{-\lambda x} \mathrm{d}x \\
&amp;= x(-e^{-\lambda x})|_{0}^{+\infty} - \int_{0}^{+\infty}
-e^{-\lambda x} \mathrm{d}x \\
&amp;= \frac{1}{\lambda}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
E(X^{2}) &amp;= \int_0^{+\infty} x^{2} \cdot \lambda e^{-\lambda x}
\mathrm{d}x \\
&amp;= \int_0^{+\infty} x^{2} \mathrm{d}(-e^{-\lambda x}) \\
&amp;= x^{2}(-e^{-\lambda x})|_{0}^{+\infty} +
2\int_0^{+\infty}xe^{-\lambda x} \mathrm{d}x \\
&amp;= \frac{2}{\lambda^{2}}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
D(X) = E(X^{2}) - E(X)^{2} = \frac{1}{\lambda^{2}}
\]</span></p>
<h5 id="性质-8">性质：</h5>
<p>指数分布通常用来建模持续时间，只不过指数分布能够建模的持续时间具有比较特殊的性质，也就是所谓的“无记忆性”</p>
<p>无记忆性： $$</p>
<p>$$</p>
<h5 id="应用-6">应用：</h5>
<ol type="1">
<li><p>泊松分布、指数分布、二项分布、伯努利分布之间的关系：</p>
<p>当 n 趋近于无穷大时，二项分布可以近似为泊松分布；当 <span class="math inline">\(\lambda\)</span> 趋近于无穷大
时，泊松分布可以近似为正态分布；而指数分布则是泊松分布在连续时间上的推广，因此也与泊松
分布有一定的联系。但是，这些分布之间的应用场景和特点是不同的，需要根据实际问题选择合适
的分布模型。</p></li>
<li></li>
</ol>
<h4 id="正态分布高斯分布-normal-distribution">正态分布(高斯分布, Normal
Distribution)</h4>
<h5 id="符号xsim-nmu-sigma2">符号：<span class="math inline">\(X\sim
N(\mu, \sigma^{2})\)</span></h5>
<h5 id="概率密度函数-3">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{1}{\sqrt{2\pi}
\sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}}(\mu \in R, \sigma &gt; 0)
\]</span> ##### 分布函数：</p>
<h5 id="期望-10">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_{-\infty}^{+\infty} x \cdot \frac{1}{\sqrt{2 \pi}
\sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \\
&amp;=\int_{-\infty}^{+\infty}(x - \mu + \mu) \cdot
\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x - \mu)^{2}}{2\sigma^{2}}}
\mathrm{d}(x - \mu)\\
&amp;= \int_{-\infty}^{+\infty}
\frac{t}{\sqrt{2\pi}\sigma}e^{-\frac{t^{2}}{2\sigma^{2}}} \mathrm{d}t +
\mu \int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x -
\mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \\
&amp;= 0 + \mu \\
&amp;= \mu
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
D(X) &amp;= \int_{-\infty}^{+\infty} x^{2} \cdot \frac{1}{\sqrt{2 \pi}
\sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \\
&amp;= \int_{-\infty}^{+\infty}(x - \mu)^{2} f(x) \mathrm{d}x + 2\mu
\int_{-\infty}^{+\infty}x \cdot f(x) \mathrm{d}x - \mu^{2}
\int_{-\infty}^{+\infty} f(x)\mathrm{d}x \\
&amp;= \frac{1}{\sqrt{2\pi} \sigma}\int_{0}^{+\infty}
\sqrt{t}e^{\frac{t}{2\sigma^{2}}} \mathrm{d}t + 2\mu^{2} - \mu^{2}\\
&amp;= \sigma^{2}
\end{aligned}
\]</span> ##### 性质：</p>
<p>标准正态分布：</p>
<h5 id="应用-7">应用：</h5>
<h4 id="多元高斯分布multivariate-gaussian-distribution">多元高斯分布(Multivariate
Gaussian Distribution)</h4>
<h5 id="概率密度函数-4">概率密度函数：</h5>
<h5 id="应用多元高斯分布的性质和应用在统计学机器学习信号处理和贝叶斯推断等领域中都非常重要">应用：多元高斯分布的性质和应用在统计学、机器学习、信号处理和贝叶斯推断等领域中都非常重要。</h5>
<h4 id="混合高斯分布mixture-of-gaussian-distributions">混合高斯分布(Mixture
of Gaussian Distributions)</h4>
<h5 id="应用-8">应用：</h5>
<p>混合高斯模型在许多领域中有广泛的应用，如模式识别、聚类分析、异常检测和图像分割。它允许建模复杂的数据分布，其中数据点可以由多个不同的分布生成，而不仅仅是单一的高斯分布。这使得混合高斯模型成为数据建模和分析中的强大工具。</p>
<h4 id="对数正态分布log-normal-distribution">对数正态分布(Log-Normal
Distribution)</h4>
<h4 id="伽马分布gamma-distribution">伽马分布(Gamma Distribution)</h4>
<h5 id="符号x-sim-gaalpha-lambda">符号：<span class="math inline">\(X
\sim Ga(\alpha, \lambda)\)</span></h5>
<h5 id="概率密度函数-5">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
\dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} x^{\alpha - 1}e^{-\lambda x},
&amp;x \geq 0\\
0 &amp; x &lt; 0
\end{cases}
\]</span> ##### 期望：</p>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \dfrac{\lambda^{\alpha}}{\Gamma(\alpha)}\int_{0}^{+\infty}
x^{\alpha} e^{-\lambda x} \mathrm{d}x \\ &amp;=
\dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} \int_{0}^{+\infty}
\dfrac{t^{\alpha}}{\lambda ^{\alpha + 1}}e^{-t} \mathrm{d}t \\
&amp;= \dfrac{\Gamma(\alpha  +1)}{\Gamma(\alpha) \cdot \lambda} \\
&amp;= \frac{\alpha}{\lambda}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
E(X^{2}) &amp;= \int_{0}^{+\infty} x^{2} \cdot
\dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} x^{\alpha - 1}e^{-\lambda x}
\mathrm{d}x \\
&amp;= \dfrac{1}{\lambda^{2}\Gamma(\alpha)} \int_0^{+\infty}
t^{\alpha+1}e^{-t}\mathrm{d}t \\
&amp;= \dfrac{\alpha(\alpha + 1)}{\lambda^{2}}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
D(X) = E(X^{2}) - E(X)^{2}  = \dfrac{\alpha}{\lambda^{2}}
\]</span> ##### 性质：</p>
<ol type="1">
<li><p><span class="math inline">\(\alpha = 1\)</span>
的时候，伽马分布与指数分布之间的关系就建立起来了，有 <span class="math inline">\(Ga(1, \lambda ) = E(\lambda)\)</span></p></li>
<li><p>当 <span class="math inline">\(\alpha = \dfrac{n}{2}, \lambda =
\dfrac{1}{2}\)</span>
的时候，伽马分布和卡方分布之间的关系就建立起来了，有 <span class="math inline">\(Ga(\dfrac{n}{2}, \dfrac{1}{2}) =
\mathcal{X}^{2}(n)\)</span></p></li>
<li><p>伽马分布的可加性。<img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231024194312138.png" alt="image-20231024194312138"></p></li>
<li></li>
</ol>
<h5 id="应用-9">应用：</h5>
<h4 id="对数伽马分布log-gamma-distribution">对数伽马分布(Log-Gamma
Distribution)</h4>
<h5 id="符号x-sim-textlog-gammaalpha-beta">符号：<span class="math inline">\(X \sim \text{log-gamma}(\alpha,
\beta)\)</span></h5>
<h5 id="概率密度函数-6">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{e^{\beta x}e^{-e^{x} / a}}{\alpha^{\beta}\Gamma(\beta)}
-\infty &lt; x &lt; +\infty
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024233520269.png" alt="image-20231024233520269"></p>
<h4 id="贝塔分布beta-distribution">贝塔分布(Beta Distribution)</h4>
<h5 id="符号x-sim-betaalpha-beta">符号：<span class="math inline">\(X
\sim \Beta(\alpha, \beta)\)</span></h5>
<h5 id="概率密度函数-7">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
\dfrac{1}{\Beta(\alpha, \beta)} x^{\alpha - 1}(1-x)^{\beta - 1}, 0 &lt;
x &lt; 1 \\
0
\end{cases}
\]</span> ##### 分布函数：</p>
<h5 id="期望-11">期望：</h5>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_0^{1}x \cdot \dfrac{1}{\Beta(\alpha, \beta)} x^{\alpha
- 1}(1-x)^{\beta - 1} \mathrm{d}x \\
&amp;= \dfrac{\Beta(\alpha + 1, \beta)}{\Beta(\alpha, \beta)}
\int_0^{1}\dfrac{1}{\Beta(\alpha + 1, \beta)} x^{(\alpha + 1) -
1}(1-x)^{\beta - 1} \mathrm{d}x \\
&amp;= \dfrac{\Gamma(\alpha + 1)\Gamma(\beta)}{\Gamma(\alpha + \beta +
1)} \cdot \dfrac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)} \\
&amp;= \dfrac{\alpha}{\alpha + \beta}
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
E(X^{2}) &amp;= \int_0^{1} \dfrac{1}{\Beta(\alpha, \beta)}x^{(\alpha +
2) - 1}(1 - x)^{\beta - 1} \mathrm{d}x \\
&amp;= \dfrac{\Beta(\alpha + 2, \beta)}{\Beta(\alpha, \beta)} \\
&amp;= \dfrac{\alpha(\alpha + 1)}{(\alpha + \beta)(\alpha + \beta + 1)}
\end{aligned}
\]</span></p>
<p><span class="math display">\[
D(X) = E(X^{2}) - E(X)^{2} = \dfrac{\alpha \beta}{(\alpha +
\beta)^{2}(\alpha + \beta + 1)}
\]</span></p>
<h5 id="性质-9">性质：</h5>
<ol type="1">
<li><span class="math inline">\(Beta(1, 1) = U(0, 1)\)</span></li>
</ol>
<h5 id="应用-10">应用：</h5>
<h4 id="威布尔分布韦伯分布weibull-distribution">威布尔分布(韦伯分布，Weibull
Distribution)</h4>
<p>概率密度函数： <span class="math display">\[
f(x;\lambda, k) = \begin{cases}
\dfrac{k}{\lambda}(\dfrac{x}{\lambda})^{k -
1}e^{-(\dfrac{x}{\lambda})^k}, &amp;x \geq 0 \\
0, &amp;x &lt; 0
\end{cases}
\]</span> 其中，x 是随机变量，<span class="math inline">\(\lambda &gt;
0\)</span> 是比例系数(scale parameter)，<span class="math inline">\(k
&gt; 0\)</span> 是形状参数(shape
parameter)。显然，它的累计分布函数是扩展的指数分布函数。</p>
<h5 id="期望-12">期望：</h5>
<p><span class="math display">\[
E(X) = \lambda \Gamma(1 + \dfrac{1}{k})
\]</span> ##### 方差：</p>
<p><span class="math display">\[
D(X) = \lambda^{2}\left[\Gamma(1 + \dfrac{2}{k}) - \Gamma^{2}(1 +
\dfrac{1}{k})\right]
\]</span> ##### 应用：</p>
<p>威布尔分布在<a href="https://baike.baidu.com/item/可靠性工程/3129248?fromModule=lemma_inlink">可靠性工程</a>中被广泛应用。</p>
<ol type="1">
<li>研究生产过程和运输时间关系</li>
<li>预测天气</li>
<li>可靠性和失效分析</li>
<li>雷达系统</li>
<li>对接受的杂波信号依分布建模</li>
<li>量化寿险模型的重复索赔</li>
<li>描述风速分布</li>
</ol>
<h4 id="瑞利分布rayleigh-distribution">瑞利分布(Rayleigh
Distribution)</h4>
<p>瑞利分布就是两个垂直分量服从独立且均值为0,标准差相同的高斯分布叠加之后的模。
换句话说，复高斯分布的模服从瑞利分布。</p>
<p><a href="https://zhuanlan.zhihu.com/p/573644622">瑞利分布的推导过程 -
知乎 (zhihu.com)</a> 瑞利分布</p>
<h4 id="柯西分布柯西-洛伦兹分布cauchy-distribution">柯西分布(柯西-洛伦兹分布，Cauchy
Distribution)</h4>
<h5 id="符号x-sim-textcauthya-alpha">符号：<span class="math inline">\(X
\sim \text{Cauthy}(a, \alpha)\)</span></h5>
<h5 id="概率密度函数-8">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{1}{\alpha\pi[1 + ((x - a) / \alpha)^{2}]} \quad \quad
-\infty &lt; x &lt; +\infty
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025112236557.png" alt="image-20231025112236557"></p>
<h5 id="由来推导">由来推导：</h5>
<p>柯西分布描述了以随机角度倾斜的线段切割 x 轴的水平距离分布。</p>
<p><img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025113546164.png" alt="image-20231025113546164"> <span class="math display">\[
\tan(\theta) = \dfrac{x}{b} \\
\theta = \arctan{\dfrac{x}{b}} \\
\mathrm{d}\theta = \dfrac{1}{1 + \frac{x^{2}}{b^{2}}}
\dfrac{\mathrm{d}x}{b}
\]</span> 所以可以使用 <span class="math inline">\(\dfrac{\mathrm{d}\theta}{\pi} = \dfrac{1}{\pi}
\dfrac{b\mathrm{d}x}{b^2 + x ^{2}}\)</span> 来计算关于 x 的分布。 <span class="math display">\[
\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} \dfrac{\theta}{\pi} = 1
\Rightarrow \int_{-\infty}^{+\infty} \dfrac{1}{\pi} \dfrac{b
\mathrm{d}x}{b^2 + x^{2}} = 1
\]</span> 所以，<span class="math inline">\(P(X = x) = \dfrac{1}{\pi}
\dfrac{b}{(x - m)^{2} + b^2}\)</span></p>
<h5 id="分布函数-1">分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X \leq x) = \dfrac{1}{2\pi}\left(\pi - 2\arctan(\dfrac{a -
x}{\alpha})\right) \quad -\infty &lt; x &lt; +\infty
\]</span> ##### 期望：</p>
<p>不存在</p>
<h5 id="方差-7">方差：</h5>
<p>不存在</p>
<h5 id="应用-11">应用：</h5>
<ol type="1">
<li>柯西分布，也称为柯西-洛伦兹分布或洛伦兹分布，是描述共振行为的连续分布。它还描述了以随机角度倾斜的线段切割
x 轴的水平距离分布。</li>
<li>在量子世界，粒子和粒子距离很远，比如，电子到原子核的距离，就好比一个汽车到三千公里外的一个城市距离，因此，要显著描述电子的位置分布，只能是柯西-洛伦兹分布，不能用高斯分布刻画，因为高斯分布尺度不够，信号太弱，噪声将把电子的电磁能量淹没，模型无效。</li>
</ol>
<h5 id="性质-10">性质：</h5>
<ol type="1">
<li>柯西分布的取值范围非常广，很大的值也有一定概率取到，因而柯西分布也称为heavy-tail
distribution。并且相比于gaussian，概率密度的最大取值只有0.1，就是x=0的那个地方。</li>
</ol>
<h4 id="拉普拉斯分布双指数分布laplace-distribution">拉普拉斯分布(双指数分布，Laplace
Distribution)</h4>
<h5 id="符号x-sim-textlaplacealpha_1-alpha_2">符号：<span class="math inline">\(X \sim \text{Laplace}(\alpha_1,
\alpha_2)\)</span></h5>
<h5 id="概率密度函数-9">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
\dfrac{1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_1}}, &amp;x &lt; 0 \\
\dfrac{1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_2}}, &amp; x \geq 0
\end{cases}
\]</span></p>
<blockquote>
<p>The Laplace distribution is an alternative to the normal distribution
with heavier tails. The probability density function for three different
parameters settings is illustrated below.</p>
</blockquote>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024230803046.png" alt="image-20231024230803046">
<figcaption aria-hidden="true">image-20231024230803046</figcaption>
</figure>
<h5 id="分布函数-2">分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X \leq x) = \begin{cases}
\dfrac{\alpha_1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_1}} &amp;x &lt;
0 \\
1 - \dfrac{\alpha_2}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_2}}&amp;x
\geq 0
\end{cases}
\]</span> ##### 期望：</p>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_{-\infty}^{0} x \cdot f(x)\mathrm{d}x +
\int_0^{+\infty} x \cdot f(x) \mathrm{d}x\\
&amp;= \alpha_2 - \alpha_1
\end{aligned}
\]</span> ##### 方差：</p>
<p><span class="math display">\[
\begin{aligned}
D(X) &amp;= \int_{-\infty}^{0} x^2 \cdot f(x)\mathrm{d}x +
\int_0^{+\infty} x^2 \cdot f(x) \mathrm{d}x\\
&amp;= \alpha_1^{2} + \alpha_2^{2}
\end{aligned}
\]</span> ##### 性质：</p>
<ol type="1">
<li>可看作两平移指数分布背靠背拼接在一起，因此又称双指数分布 (Double
exponential distribution)</li>
</ol>
<h5 id="应用-12">应用：</h5>
<h4 id="玻尔兹曼分布boltzmann-distribution">玻尔兹曼分布(Boltzmann
Distribution)</h4>
<h4 id="幂律分布power-distribution">幂律分布(Power Distribution)</h4>
<h5 id="符号xsim-textpower1-beta">符号：<span class="math inline">\(X\sim \text{Power}(1, \beta)\)</span></h5>
<h5 id="概率密度函数-10">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \beta x^{\beta - 1} \quad \quad 0 &lt; x &lt; 1
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024235040777.png" alt="image-20231024235040777"></p>
<h5 id="分布函数-3">分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X \leq x) = x^{\beta}
\]</span> ##### 期望：</p>
<p><span class="math display">\[
E(X) =
\]</span> ##### 方差：</p>
<h4 id="三角分布standard-triangular-distribution">三角分布(Standard
Triangular Distribution)</h4>
<h5 id="符号x-sim-texttriangular-1-1-1">符号：<span class="math inline">\(X \sim \text{Triangular}(-1, 1, 1)\)</span></h5>
<h5 id="概率密度函数-11">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \begin{cases}
x + 1, &amp;-1 &lt; x &lt; 0 \\
1 - x, &amp; 0 \leq x &lt; 1
\end{cases}
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025114540132.png" alt="image-20231025114540132"></p>
<h5 id="分布函数-4">分布函数：</h5>
<p><span class="math display">\[
F(x) = \begin{cases}
\frac{1}{2}x^{2} + x + \frac{1}{2}, &amp;-1 &lt; x &lt; 0 \\
-\frac{1}{2}x^{2} + x + \frac{1}{2}, &amp;0 \leq x &lt; 1
\end{cases}
\]</span> ##### 期望：</p>
<p><span class="math display">\[
E(X) = 0
\]</span> ##### 方差：</p>
<p><span class="math display">\[
D(X) = \dfrac{1}{6}
\]</span> 更一般的，三角形分布是底限为 a，众数为 c，上限为 b
的连续概率分布。 <span class="math display">\[
f(x|a, b, c) = \begin{cases}
\dfrac{2(x - a)}{(b - a)(c - a)} \quad a \leq x \leq c \\
\\
\dfrac{2(b - x)}{(b - a)(b - c)} \quad c \leq x \leq b
\end{cases}
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025124956772.png" alt="image-20231025124956772"></p>
<h4 id="逻辑斯谛分布增长分布-log-logistic-distribution">逻辑斯谛分布(增长分布,
Log-Logistic Distribution)</h4>
<h5 id="符号x-sim-textloglogisticlambda-kappa">符号：<span class="math inline">\(X \sim \text{loglogistic}(\lambda,
\kappa)\)</span></h5>
<h5 id="概率密度函数-12">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{\lambda\kappa(\lambda\kappa)^{\kappa - 1}}{(1 + (\lambda
x)^{\kappa})^{2}} \quad x &gt; 0
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025130217056.png" alt="image-20231025130217056"></p>
<h5 id="分布函数-5">分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X &lt;= x) = \dfrac{(\lambda x)^{\kappa}}{1 + (\lambda
x)^{\kappa}}  \quad x &gt; 0
\]</span> ##### 期望：</p>
<p><span class="math display">\[
\begin{aligned}
E(X) &amp;= \int_0^{+\infty} x \cdot f(x) \mathrm{d}x \\
&amp;= \dfrac{1}{\lambda}
\int_0^{+\infty}\dfrac{m^{\frac{1}{k}}}{(1+m)^{2}} \mathrm{d}m \\
&amp;= \dfrac{1}{\kappa \lambda} \cdot \dfrac{\pi}{\sin
(\frac{\pi}{\kappa})} \\
&amp;= \dfrac{\pi}{\kappa \lambda(\sin (\frac{\pi}{\kappa})}
\end{aligned}
\]</span> 其中，计算的时候可以使用留数定理。</p>
<h5 id="方差-8">方差：</h5>
<p><span class="math display">\[
D(X) = \dfrac{\pi \left(2\kappa(1 - \cos (\frac{\pi}{\kappa})^{2}) +
\pi\sin(\frac{\pi(\kappa + 2)}{\kappa}) \right)}{\left(\sin
(\frac{\pi(\kappa + 2)}{\kappa}) \right)\left(
\cos(\frac{\pi}{\kappa})^{2} - 1\right)(\lambda \kappa)^{2}}
\]</span></p>
<h4 id="逻辑分布logistic-distribution">逻辑分布(Logistic
Distribution)</h4>
<h5 id="符号x-sim-textlogisticlambda-kappa">符号：<span class="math inline">\(X \sim \text{logistic}(\lambda,
\kappa)\)</span></h5>
<h5 id="概率密度函数-13">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{\lambda^{\kappa}\kappa e^{\kappa x}}{(1 + (\lambda
e^{x})^{\kappa})^{2}} \quad -\infty &lt; x &lt; +\infty
\]</span> <img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025134453817.png" alt="image-20231025134453817"></p>
<h5 id="分布函数-6">分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X \leq x) = \dfrac{\lambda^{\kappa}e^{\kappa x}}{1 +
\lambda^{\kappa}e^{x}} \quad -\infty &lt; x &lt; +\infty
\]</span> ##### 期望：</p>
<p><span class="math display">\[
E(X) = -\ln \lambda
\]</span> ##### 方差：</p>
<p><span class="math display">\[
D(X) = \dfrac{\pi ^{2}}{3\kappa^{2}}
\]</span></p>
<h4 id="t-分布t-distribution">t 分布(T Distribution)</h4>
<p>如果 <span class="math inline">\(X\sim N(0, 1), Y \sim
\chi^{2}(n)\)</span>，则有 <span class="math inline">\(Z =
\dfrac{X}{\sqrt{\frac{Y}{n}}} \sim t(n)\)</span></p>
<h5 id="概率密度函数-14">概率密度函数：</h5>
<p><span class="math display">\[
\begin{aligned}
f(z) =\dfrac{\Gamma(\frac{n +
1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}\left(\dfrac{z^{2}}{n} +
1\right)^{-\frac{n + 1}{2}}
\end{aligned}
\]</span> ##### 推导：</p>
做变换： <span class="math display">\[
\begin{aligned}
\begin{cases}
u = \dfrac{X}{\sqrt{\frac{Y}{n}}} \\
\\
v = Y
\end{cases}
\end{aligned}
\]</span> 所以有反函数： <span class="math display">\[
\begin{cases}
X = u\sqrt{\dfrac{v}{n}} \\
\\
Y = v
\end{cases}
\]</span> 雅可比行列式是： <span class="math display">\[
|J| =
\]</span> 所以原问题的分布函数变为： $$
<span class="math display">\[\begin{aligned}
\iint\limits_{A}f(x,y)\mathrm{d}x\mathrm{d}y &amp;=
\iint\limits_{B}f(x(u, v),y(u, v)) |J| \mathrm{d}u \mathrm{d}v \\
&amp;=
\int_{-\infty}^{z}\int_{0}^{+\infty}f_X(u\sqrt{\dfrac{v}{u}})f_Y(v)
(\dfrac{v}{n})^{-\frac{1}{2}} \mathrm{d}u \mathrm{d}v \\

\end{aligned}\]</span>
<span class="math display">\[
有
\]</span>
<span class="math display">\[\begin{aligned}
f_X(x) = \dfrac{1}{\sqrt{2\pi}}e^{-\frac{x^{2}}{2}} \\
f_Y(y) = \dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}y^{\frac{n}{2}-
1}e^{-\frac{y}{2}}
\end{aligned}\]</span>
<span class="math display">\[
所以：
\]</span>
<span class="math display">\[\begin{aligned}
F(Z) &amp;= \int_{-\infty}^{z}\int_0^{+\infty}
\dfrac{1}{\sqrt{2\pi}}e^{-\frac{1}{2}u^{2}\frac{v}{n}}
\dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}v^{\frac{n}{2} - 1}
e^{-\frac{v}{2}}(\dfrac{v}{n})^{-\frac{1}{2}} \mathrm{d}v\mathrm{d}u \\
&amp;=
\int_{-\infty}^{z}\dfrac{1}{\sqrt{n\pi}\sqrt{2}}\dfrac{1}{2^{\frac{n}{2}}
\Gamma(\frac{n}{2})} \int_0^{+\infty}e^{-\frac{1}{2}u^{2}\frac{v}{n} -
\frac{v}{2}}v^{\frac{n - 1}{2}} \mathrm{d}u \mathrm{d}v
\end{aligned}\]</span>
<p>$$</p>
<h5 id="期望-13">期望：</h5>
<p><span class="math display">\[
E(X) = 0
\]</span></p>
<h5 id="方差-9">方差：</h5>
<p><span class="math display">\[
V(X) = \dfrac{n}{n - 2}
\]</span></p>
<h5 id="性质-11">性质：</h5>
<h5 id="应用-13">应用：</h5>
<h4 id="f-分布f-distribution">F 分布(F Distribution)</h4>
<p>F 分布也被称为「方差比分布(Variance Ratio
Distribution)」和「Fisher-Snedecor Distribution」。</p>
<p>设 <span class="math inline">\(U \sim \chi^{2}(n_1), V \sim
\chi^{2}(n_2)\)</span>，并且 U 和 V 相互独立，则称随机变量 <span class="math inline">\(F = \dfrac{U / n_1}{V / n_2}\)</span> 服从自由度为
<span class="math inline">\((n_1, n_2)\)</span> 的 F 分布</p>
<h5 id="概率密度函数-15">概率密度函数：</h5>
<p><span class="math display">\[
f(z) = \dfrac{\Gamma(\frac{n_1 +
n_2}{2})(\frac{n_1}{n_2})^{\frac{n_1}{2}}z^{\frac{n_1}{2} -
1}}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})\left[1 +
\frac{n_1}{n_2}z\right]^{\frac{n_1 + n_2}{2}}}
\]</span></p>
<h5 id="推导">推导：</h5>
<p><span class="math inline">\(\text{lemma1}:\)</span> <span class="math display">\[
f_{\frac{Y}{X}}(z) = \int_{-\infty}^{+\infty}|x|f(x, xz)\mathrm{d}x
\]</span> <span class="math inline">\(\text{lemma2}:\)</span> <span class="math display">\[
f_{aX + b} = \dfrac{1}{|a|}f_X(\dfrac{y - b}{a}) \quad a \neq 0
\]</span> 所以我们可以得到 <span class="math inline">\(Y =
\dfrac{U}{n_1}, X = \dfrac{V}{n_2}\)</span> 的概率密度函数为： <span class="math display">\[
f_Y(y) =
\dfrac{(\frac{n_1}{2})^{\frac{n_1}{2}}}{\Gamma(\frac{n_1}{2})}y^{\frac{n_1}{2}
- 1}e^{-\frac{n_1y}{2}} \quad y &gt; 0
\]</span></p>
<p><span class="math display">\[
f_X(x) =
\dfrac{(\frac{n_2}{2})^{\frac{n_2}{2}}}{\Gamma(\frac{n_2}{2})}y^{\frac{n_2}{2}
- 1}e^{-\frac{n_2y}{2}} \quad x &gt; 0
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
f_F(z) &amp;= f_{\frac{Y}{X}}(z) \\
&amp;= \int_0^{+\infty} xf(x, xz) \mathrm{d}x \\
&amp;= \int_0^{+\infty} xf_Y(xz)f_X(x) \mathrm{d}x \\
&amp;= \int_0^{+\infty} x
\dfrac{(\frac{n_1}{2})^{\frac{n_1}{2}}}{\Gamma(\frac{n_1}{2})}(xz)^{\frac{n_1}{2}
- 1}e^{-\frac{n_1y}{2}}
\cdot  \dfrac{(\frac{n_2}{2})^{\frac{n_2}{2}}}{\Gamma(\frac{n_2}{2})}y^{\frac{n_2}{2}
- 1}e^{-\frac{n_2y}{2}} \mathrm{d}x \\
&amp;= \dfrac{(n_1 / 2)^{n_1 / 2}(n_2 / 2)^{n_2 /
2}}{\Gamma(\frac{n_1}{2}) \Gamma(\frac{n_2}{2})}z^{\frac{n_1}{n_2} -
1}\int_0^{+\infty}x^{\frac{n_1 + n_2}{2} - 1}e^{\frac{-x}{2}(n_1z +
n_2)} \mathrm{d}x \\
\end{aligned}
\]</span></p>
<p>设 <span class="math inline">\(u = \dfrac{x}{2}(n_1z +
n_2)\)</span></p>
<p>最后得到： <span class="math display">\[
f(z) = \dfrac{\Gamma(\frac{n_1 +
n_2}{2})(\frac{n_1}{n_2})^{\frac{n_1}{2}}z^{\frac{n_1}{2} -
1}}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})\left[1 +
\frac{n_1}{n_2}z\right]^{\frac{n_1 + n_2}{2}}}
\]</span></p>
<h5 id="期望-14">期望：</h5>
<p><span class="math display">\[
E(X) = \dfrac{n_2}{n_2 - 2}
\]</span></p>
<h5 id="方差-10">方差：</h5>
<p><span class="math display">\[
V(X) = \dfrac{2n_2^{2}(n_1+ n_2 - 2)}{n_1}
\]</span></p>
<h5 id="性质-12">性质：</h5>
<ol type="1">
<li><p><span class="math inline">\(F_{1 - \alpha}(n_1, n_2) =
\dfrac{1}{F_{\alpha}(n_2, n_1)}\)</span> 证明： <span class="math display">\[
\begin{aligned}
1 - \alpha &amp;= P\{F &gt; F_{1 - \alpha}(n_1, n_2)\} \\
&amp;= P\{\dfrac{1}{F} &lt; \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}\} \\
&amp;= 1 - P\{\dfrac{1}{F} \geq \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}\} \\
&amp;= 1 - P\{\dfrac{1}{F} &gt; \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}\} \\
\end{aligned}
\]</span> 所以 <span class="math inline">\(P\{\dfrac{1}{F} &gt;
\dfrac{1}{F_{1 - \alpha}(n_1, n_2)}\} = \alpha\)</span> 并且 <span class="math inline">\(\dfrac{1}{F} \sim F(n_2, n_1)\)</span>，所以 <span class="math inline">\(F_{1 - \alpha}(n_1, n_2) =
\dfrac{1}{F_{\alpha}(n_2, n_1)}\)</span></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/453635917">F分布概率密度公式推导 -
知乎 (zhihu.com)</a></p></li>
</ol>
<h5 id="应用-14">应用：</h5>
<h4 id="chi-分布卡方分布-chi-distribution"><span class="math inline">\(\chi 分布\)</span>(卡方分布, <span class="math inline">\(\chi\)</span> Distribution)</h4>
<p><span class="math inline">\(Z_1, Z_2, ..., Z_k\)</span>
是独立、标准正态分布的随机变量，把他们的平方和记为 Q，则有 <span class="math inline">\(Q = \sum\limits_{i = 1}^{k} Z_i^{2}\)</span></p>
<p>这个 Q 是服从自由度为 K 的卡方分布的。通常会被记为 <span class="math inline">\(Q \sim \chi^{2}(k)\)</span></p>
<h5 id="符号q-sim-chi2k">符号：<span class="math inline">\(Q \sim
\chi^{2}(k)\)</span></h5>
<h5 id="概率密度函数-16">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{1}{2^{\frac{n}{2}}\Gamma(\dfrac{n}{2})}x^{^{\frac{n}{2}} -
1}e^{-\frac{x^{2}}{2}} \quad z &gt; 0
\]</span></p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026212407458.png" alt="image-20231026212407458">
<figcaption aria-hidden="true">image-20231026212407458</figcaption>
</figure>
<h5 id="k-阶矩">K 阶矩</h5>
<p><span class="math display">\[
\begin{aligned}
E(X^{k}) &amp;= \int_0^{+\infty} x^{k} \cdot
\dfrac{1}{2^{\frac{n}{2}}\Gamma(\dfrac{n}{2})}x^{^{\frac{n}{2}} -
1}e^{-\frac{x^{2}}{2}} \mathrm{d}x \\
\end{aligned}
\]</span></p>
<p>设 <span class="math inline">\(\dfrac{x^{2}}{2}=
t\)</span>，式子变为： <span class="math display">\[
\begin{aligned}
E(X^{k}) &amp;=
\dfrac{2^{\frac{k}{2}}}{\Gamma(\frac{n}{2})}\int_0^{+\infty} t^{\frac{n
+ k}{2} - 1}e^{-t}\mathrm{d}t \\
&amp;= \dfrac{2^{k / 2}\Gamma(\frac{n + k}{2})}{\Gamma(n / 2)}
\end{aligned}
\]</span></p>
<h5 id="期望-15">期望：</h5>
<p><span class="math display">\[
E(X) = \dfrac{\sqrt{2}\Gamma(\frac{n + 1}{2})}{\Gamma(n / 2)}
\]</span></p>
<h5 id="方差-11">方差：</h5>
<p><span class="math display">\[
E(X^{2}) = \dfrac{2\Gamma(n / 2 + 1)}{\Gamma(n / 2)} = n
\]</span></p>
<p>所以 <span class="math display">\[
D(X) = E(X^{2}) - E(X)^{2} = n^{2} - E(X)^{2}
\]</span></p>
<h5 id="性质-13">性质：</h5>
<h5 id="应用-15">应用：</h5>
<h4 id="狄拉克分布">狄拉克分布</h4>
<h4 id="多项式分布和迪利克雷分布">多项式分布和迪利克雷分布</h4>
<h4 id="帕累托分布布拉德福分布-pareto-distribution">帕累托分布(布拉德福分布,
Pareto Distribution)</h4>
<p>这个分布是是从大量真实世界的现象中发现的<a href="https://zh.wikipedia.org/wiki/冪定律">幂定律</a>分布。这个分布在经济学以外，也被称为<strong>布拉德福分布</strong>。</p>
<h5 id="分布函数-7">分布函数：</h5>
<p><span class="math display">\[
P(X &gt; x) = \left(\dfrac{x}{x_{\min}} \right)^{-k}
\]</span></p>
<p>其中，x 是任何一个大于 <span class="math inline">\(x_{\min}\)</span>
的数，<span class="math inline">\(x_{\min}\)</span> 是 X
最小的可能值(正数)。</p>
<h5 id="概率密度">概率密度：</h5>
$$
<span class="math display">\[\begin{aligned}
p(x) = \begin{cases}
0 \quad x &lt; x_{\min} \\
\\
\\
\dfrac{kx_{\min}^{k}}{x^{k + 1}} \quad x &gt; x_{\min}

\end{cases}
\end{aligned}\]</span>
<p>$$</p>
<p>帕累托分布属于连续概率分布。「齐夫定律」也被称为「Zeta
分布」，也可以被认为是在离散概率分布中的帕累托分布。</p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026223709526.png" alt="image-20231026223709526">
<figcaption aria-hidden="true">image-20231026223709526</figcaption>
</figure>
<h5 id="期望-16">期望：</h5>
<p><span class="math display">\[
E(X) = \int_0^{+\infty} x\cdot f(x) \mathrm{d}x = \dfrac{x_\min k}{k -
1}
\]</span></p>
<h5 id="方差-12">方差：</h5>
<p><span class="math display">\[
D(X) = \dfrac{x_\min}{k - 1}\sqrt{\dfrac{k}{k - 2}}
\]</span></p>
<h5 id="应用-16">应用：</h5>
<ol type="1">
<li>财富在个人之间的分布</li>
<li>人类居住区的大小</li>
<li>对维基百科条目的访问</li>
<li>接近绝对零度时，玻色一爱因斯坦疑聚的团簇</li>
<li>在互联网流量中文件尺寸的分布</li>
<li>油田的石油储备数量</li>
<li>龙卷风带来的灾难的数量</li>
</ol>
<h5 id="引申">引申：</h5>
<p>帕累托法则(Pareto
Principle)，或者叫做「二八定律」，「关键少数法则」，「巴莱多定律」。这个定律指出，约仅有
20% 的因素影响了 80% 的结果。也就是说，所有变因中，最重要的仅有
20%，虽然剩余的 80% 占了大多数。</p>
<h4 id="反正弦分布arcsin-distribution">反正弦分布(Arcsin
Distribution)</h4>
<h5 id="符号x-sim-textarcsinx">符号：<span class="math inline">\(X \sim
\text{arcsin}(x)\)</span></h5>
<h5 id="概率密度函数-17">概率密度函数：</h5>
<p><span class="math display">\[
f(x) = \dfrac{1}{\pi \sqrt{x(1 - x)}} \quad 0 &lt; x &lt; 1
\]</span></p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026220704838.png" alt="image-20231026220704838">
<figcaption aria-hidden="true">image-20231026220704838</figcaption>
</figure>
<h5 id="累计分布函数-1">累计分布函数：</h5>
<p><span class="math display">\[
F(x) = P(X \leq x) = \dfrac{\pi + 2\arcsin(2x - 1)}{2\pi}
\]</span></p>
<h5 id="期望-17">期望：</h5>
<p><span class="math display">\[
E(X) = \dfrac{1}{2}
\]</span></p>
<h5 id="方差-13">方差：</h5>
<p><span class="math display">\[
D(X) = \dfrac{1}{8}
\]</span></p>
<h5 id="性质-14">性质：</h5>
<p>对于积分 <span class="math inline">\(\int_{a}^{b}\dfrac{\mathrm{d}x}{\sqrt{(x - a)(b -
x)}}\)</span> 它的结果是<span class="math inline">\(\pi\)</span></p>
<p>对于这样类型的积分，我们一般是通过换元进行计算 <span class="math inline">\(x =a\cos^{2}\theta +
b\sin^{2}\theta\)</span>，那么原来的积分可以变为一个简单的积分： <span class="math display">\[
\int_a^{b}\dfrac{\mathrm{d}x}{\sqrt{(x - a)(b - x)}} =
2\int_0^{\frac{\pi}{2}} \mathrm{d}\theta = \pi
\]</span> 对于这个式子的含义继续深究</p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026221614582.png" alt="image-20231026221614582">
<figcaption aria-hidden="true">image-20231026221614582</figcaption>
</figure>
<p>所以原来的定积分就正好代表了上半圆的弧长，也就是整个圆的半周长。</p>
<figure>
<img src="/.com//Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026221707845.png" alt="image-20231026221707845">
<figcaption aria-hidden="true">image-20231026221707845</figcaption>
</figure>
<h3 id="参考">参考</h3>
<p>https://zhuanlan.zhihu.com/p/517424307</p>
<p>https://zhuanlan.zhihu.com/p/164883777</p>
<p><a href="https://zhuanlan.zhihu.com/p/449733211">常见分布的数学期望和方差及相关证明
- 知乎 (zhihu.com)</a></p>
<p>https://zhuanlan.zhihu.com/p/578567547 特征函数推导</p>
<p>https://zhuanlan.zhihu.com/p/353187472
https://www.zhihu.com/question/354825596/answer/893242882 指数分布</p>
<p>https://zhuanlan.zhihu.com/p/503557666 正态分布</p>
<p>怎么来理解伽玛（gamma）分布？ - 知之的回答 - 知乎
https://www.zhihu.com/question/34866983/answer/60191363
伽马分布和其他分布之间的关系</p>
<p>伽马分布，指数分布，卡方分布之间的关系及期望，方差 - 拾柒的文章 -
知乎 https://zhuanlan.zhihu.com/p/379131967</p>
<p><a href="https://zhuanlan.zhihu.com/p/303359921">深入理解高斯分布 -
知乎 (zhihu.com)</a> 多元高斯分布</p>
<p><a href="https://zhuanlan.zhihu.com/p/596023351">混合高斯分布与其参数估计 -
知乎 (zhihu.com)</a> 混合高斯分布</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>组合优化与随机性模型</title>
    <url>/2023/08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在有限个可行解集合中找出最优解，这类问题称为组合优化问题。如最短路径问题、最小连接问题、分配问题、运输问题、服务点设置问题、中国邮递员问题、背包问题、装箱问题等等。</p>
<p>贪心法和分支定界法是组合优化问题中常见的两种有效的方法。</p>
<h4 id="随机性模型">随机性模型</h4>
<ol type="1">
<li>报童问题
一个分区间讨论收益的问题（可以抽象为类似的生产或者进货然后销售求最大收益的问题），下面的问题建模对于未出售完的报纸进行退回（可以抽象为低价处理）。
设没份报纸的进价为 b，零售价为 a，退回价格为
c，报童应该如何购进报纸数量以获得最高的收入？ <img src="/.com//08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%8A%A5%E7%AB%A5%E9%97%AE%E9%A2%98.png" class title="收入和 n 的函数关系"> 假设需求量 r
的分布为 <span class="math inline">\(P\{r = k\} = f(k), k = 0, 1, 2,
...\)</span> 但是注意到 G
是一个<strong>随机目标函数</strong>，求其最大值没有什么意义，我们转为求解其最大期望。
<span class="math inline">\(\overline{G}(n) = \sum\limits_{r = 0}^{n}[(a
- b)r - (b - c)(n - r)]f(r) + \sum\limits_{r = n + 1}^{+\infty}
(a-b)nf(r)\)</span>，<strong>该问题很难求解，可以将上述函数进行连续化</strong>（数列求和和积分之间的转化使问题求解简单），可以得到
<span class="math inline">\(\overline{G}(n) = \int_0^{n}[(a - b)r - (b -
c)(n - r)]f(r)\mathrm{d}r + \int_{n + 1}^{+\infty} (a -
b)nf(r)\mathrm{d}r\)</span>，所求问题变为 <span class="math inline">\(\max \overline{G}(n)\)</span>，求导，导数为
0，得到 <span class="math inline">\(\int_0^{n} f(r)\mathrm{d}r =
\frac{a- b}{a - c}\)</span> 的时候，期望收益最大。</li>
<li>轧钢中的浪费问题
由于收到环境技术的影响，得到的钢材的长度是随机的，其数值上大体呈正态分布，均值可以通过调整轧机设定，而均方误差是由设备的精度决定的，不能随意改变。如果粗轧后的钢材长度大于规定长度，精轧时要把多余的部分切除，造成浪费；而如果粗轧后的钢材长度小于规定长度，则造成整根浪费。（一般我们不会利用多余的切除部分再次制作成钢材，因为实际生产中钢材长度
<span class="math inline">\(l &gt;&gt; \sigma\)</span>）
这样我们有模型总的平均浪费长度： $W = <em>{l}^{+} (x - l)f(x)x +
</em>{-}^{l} xf(x) x = <em>{-}^{+}xf(x)x - l</em>{-}^{+} f(x)x $ $ =
E(X) - lP{X &gt; l} = m - lp$ 其中，<span class="math inline">\(p = P\{X
&gt; l\} = 1 - \Phi(\frac{l - m}{\sigma})\)</span> 但是上式中，W
的含义是没轧一根钢材平均浪费的长度，这是从<strong>最终的产量分析浪费量</strong>；但是从实际中一个工厂的发展来看，工厂追求的是效益，可以由生产一根成品钢材浪费的平均长度来衡量，所以目标函数修改为：
<span class="math inline">\(J = \frac{W}{P\{X &gt; l\}} = \frac{m -
lp}{p}= \dfrac{m}{1 - \Phi(\frac{l - m}{\sigma}) -
l}\)</span>，决策目标为 <span class="math inline">\(\min
J(m)\)</span></li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵求导</title>
    <url>/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h4 id="向量变元的实值函数">向量变元的实值函数</h4>
<p>单纯的对于<strong>向量</strong>求导和实数的求导大同小异，也是常数为
0，乘法有链式法则，除法的形式也是一样的。
其中有行向量形式和列向量形式（也叫做<strong>梯度向量形式</strong>，记作
<span class="math inline">\(\nabla _{x}f(\boldsymbol{x})\)</span>）
然后就是几个比较重要的常见公式</p>
<h4 id="几个重要的向量变元求导公式">几个重要的向量变元求导公式</h4>
<p>符合分子布局或者分母布局的形式(谁是列向量就是什么布局)</p>
<img src="/.com//08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC.png" class title="矩阵求导公式">
<h4 id="矩阵变元的实值函数">矩阵变元的实值函数</h4>
<p>实值函数的求导其实还是比较容易理解的。对于矩阵变元无非是对于矩阵中每一个元素求导。
和对于向量变元的实值函数求导差不多，也是有着四个求导法则，分别对应常数、线性相加、乘法和商。</p>
<h4 id="几个重要的矩阵变元的求导公式">几个重要的矩阵变元的求导公式</h4>
<img src="/.com//08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E5%8F%98%E5%85%83%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F.png" class title="矩阵变元常用求导公式">
<h4 id="更详细证明了解链接">更详细证明了解链接</h4>
<p>比较懒，贴几个链接，更深的内容可以看 <strong>矩阵分析</strong>
相关的书籍。 https://www.zhihu.com/question/352174717/answer/1436808747
https://zhuanlan.zhihu.com/p/263777564
https://zhuanlan.zhihu.com/p/273729929 讲解最小二乘法的高维形式
https://zhuanlan.zhihu.com/p/38128785</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>网管会</title>
    <url>/2023/10/28/%E7%BD%91%E7%AE%A1%E4%BC%9A/</url>
    <content><![CDATA[<p>ipconfig/all 命令可以看一下网络的配置</p>
<p>一般来说 ip 地址都是一个设备一个，但是可以有多张网卡，多个设备？</p>
<p>路由器一个地址？手机和路由器地址之间的关系？</p>
<p>2011 年 IPV4 已经使用完了，我们开始使用 IPV6</p>
<h4 id="逐渐推广的-ipv6">逐渐推广的 IPV6</h4>
<p>每组中的前导 0 都可以省略，连续两个或者多个均为 0，使用 ::
代替，但是只能使用一个</p>
<h4 id="ipv4-和-ipv6-如何过渡">IPV4 和 IPV6 如何过渡？</h4>
<h4 id="子网掩码-子网划分-前缀长度">子网掩码 / 子网划分 / 前缀长度</h4>
<h4 id="doh-dot">DOH DOT</h4>
<p>外网、内网？</p>
<h4 id="mac-地址">Mac 地址</h4>
<p>网络是分层的？</p>
<p>QQ 上的去，但是网页上不去</p>
<p>校园网登录地址？</p>
<h4 id="路由">路由</h4>
<p>交换机 AC + AP</p>
<p>如果统一反应网络问题，可能是总层楼的交换机坏掉了。</p>
<h4 id="限速">限速</h4>
<p>V4 下载 60 上传 100 V6 都是千兆的</p>
<p>Steam 下载很快，但是下载别的东西很慢，内网？？</p>
<h4 id="流量">流量</h4>
<p>中国流量商用的很贵，很多都想来换取流量？京东云？</p>
<h4 id="路由追踪">路由追踪</h4>
<h4 id="网线双绞线">网线(双绞线)</h4>
<p>网线的连接标准有两种，T568A 和 T568B</p>
<p>双绞线的好处？</p>
<p>PoE 网线连接的时候同时有一个供电？一般是 48V。标准 PoE 和非标准
PoE</p>
<p>多 AP 方案无线漫游协议</p>
<p>无线加密：wpa2、AES 加密算法</p>
<h4 id="ipconfig">ipconfig</h4>
<p>如果 IPV4 地址是以 169.254 开头说明没有获取到 ip 地址。因为这是
windows 通过 DHCP 自动生成的地址。</p>
<h4 id="osi-七层网络模型">OSI 七层网络模型</h4>
<h4 id="作业">作业：</h4>
<ol type="1">
<li>下周六前提交</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/2023/08/31/%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="auto.js">Auto.js</h4>
<p>Auto.js 是一种基于 JavaScript 的自动化工具，它允许你编写和运行
JavaScript 脚本来自动化执行 Android 设备上的各种任务。因此，Auto.js 使用
JavaScript 作为其编程语言。</p>
<p>关于 Auto.js 和 JavaScript 的关系如下：</p>
<ol type="1">
<li><p>Auto.js 使用 JavaScript：Auto.js 的脚本是用 JavaScript
编写的，因此你可以在 Auto.js 中编写标准的 JavaScript 代码。这使得
Auto.js 在编写和运行自动化脚本时非常灵活，因为你可以使用 JavaScript
的语法和功能。</p></li>
<li><p>Auto.js 扩展了 JavaScript：尽管 Auto.js 使用 JavaScript
作为其编程语言，但它还提供了一组额外的 API 和库，这些 API 和库允许你与
Android
设备的各种功能和资源进行交互，如模拟用户输入、操作屏幕、访问文件系统等。这些功能通常不是标准的
JavaScript 语言特性，而是 Auto.js 为 Android
自动化提供的功能扩展。</p></li>
<li><p>Auto.js 是 JavaScript 的运行环境：Auto.js 提供了一个运行
JavaScript 脚本的环境，这个环境专门设计用于在 Android
设备上执行脚本。它允许你使用 JavaScript 控制 Android
设备的各种操作，例如自动点击、滑动、截屏等等。</p></li>
</ol>
<p>总之，Auto.js 是一个工具，它使用 JavaScript 作为编程语言，并扩展了
JavaScript，以便在 Android 设备上执行自动化任务。这使得开发人员可以使用
JavaScript 的语法和功能，结合 Auto.js 提供的 Android 自动化
API，编写用于自动化控制和操作 Android 应用和设备的脚本。</p>
<h4 id="c-赋值">C++ 赋值</h4>
<ul>
<li>对于函数的变量，我们可以使用值传递或者引用传递，取决于函数的参数类型。如果是带有
<code>&amp;</code>，此时就是引用传递，在函数中对于变量修改会影响到函数外部的值。对于数组，向函数传递的实际上是指向数组首元素的指针，这意味着参数的本质上是通过地址传递的，所以函数内部的修改可以影响到外部。</li>
<li>在C++中，当您将一个类对象赋值给另一个类对象时，默认情况下是使用复制构造函数来执行赋值操作，因此这也是一种值传递。这意味着目标对象会被复制为源对象的一个副本，两个对象之间是相互独立的，修改一个对象的属性不会影响另一个对象。</li>
</ul>
<h4 id="vscode-重命名所有匹配项">VSCode 重命名所有匹配项</h4>
<p>按住 <code>alt</code> + <code>shift</code>
https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf
VScode 的快捷键表</p>
<h4 id="es5-和-es6-含义">ES5 和 ES6 含义</h4>
<p>ES6 和 ES5 是 JavaScript 的不同版本，它们代表了不同的
ECMAScript（简称 ES）标准。ECMAScript 是 JavaScript
语言的标准化规范，规定了 JavaScript 语法、特性和行为。 1.
ES5（ECMAScript 5）： ES5 是 JavaScript
的第五个主要版本，它在2009年发布。它引入了许多重要的新特性，例如严格模式（Strict
Mode）、数组方法（如 forEach、map、filter
等）和更强大的对象属性定义（Object.defineProperty）。ES5被广泛支持，并且在早期的浏览器中是主要的
JavaScript 标准。 2. ES6（ECMAScript 2015）： ES6 是 JavaScript
的第六个主要版本，也称为 ECMAScript
2015。它于2015年发布，并引入了许多新的特性和语法改进，如箭头函数、类、模块、解构赋值、let
和 const 变量声明等。ES6使得 JavaScript
更加现代化和强大，并提供了更好的开发工具和技术。尽管它在发布时得到了广泛的支持，但由于浏览器的兼容性问题，需要一些时间才能在所有主要环境中广泛使用。</p>
<h4 id="span">Span</h4>
<p><span> 是一个行内元素（inline
element）或内联元素，用于在文本中包裹一部分内容，而不会引入新的块级元素或换行。<span>
通常用于对文本的一部分进行样式设置或添加其他属性，以便在不破坏文本流的情况下对其进行操作。
<span>
元素本身不会对其包含的文本内容产生任何视觉效果，它主要用于以下情况：</span></span></span></p>
<ol type="1">
<li>样式设置：你可以使用 <span> 元素为文本添加 CSS
样式，例如更改文本的颜色、字体、背景色等。这使得你可以有选择性地为文本的一部分应用样式，而不必更改整个段落或文本块的样式。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;span style=&quot;color: red;&quot;&gt;red text&lt;/span&gt; and this is &lt;span style=&quot;font-weight: bold;&quot;&gt;bold text&lt;/span&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></span></li>
<li>JavaScript 操作：<span> 通常用于 JavaScript 操作，你可以通过
JavaScript 选择 <span> 元素并修改其内容或属性。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Click &lt;span id=&quot;mySpan&quot; onclick=&quot;changeText()&quot;&gt;here&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function changeText() &#123;</span><br><span class="line">  var spanElement = document.getElementById(&quot;mySpan&quot;);</span><br><span class="line">  spanElement.innerHTML = &quot;clicked!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></span></span></li>
</ol>
<h4 id="html-中-img-标签中的-alt-属性">HTML 中 img 标签中的 alt
属性</h4>
<p><code>alt</code> 属性用于提供图片的替代文本(Alternative Text) 1.
替代文字：如果图像无法加载或无法显示，浏览器会显示 alt
属性中的文本，以提供对图像内容的文字描述，从而使页面更具可访问性。 2.
辅助工具：屏幕阅读器等辅助技术会读取 alt
文本，以向用户描述图像。因此，良好的 alt
文本可以帮助视觉障碍者理解图像的含义。 3. 优化 SEO：搜索引擎可以使用 alt
文本来理解图像的内容，从而更好地索引和排名网页。 4.
图像加载失败时的占位符。 5.
提示信息：一些浏览器在用户将鼠标悬停在图像上时会显示 alt
文本作为工具提示，以提供附加信息。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;example.jpg&quot; alt=&quot;一只可爱的猫咪&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="axios-和-jquery">axios 和 jQuery</h4>
<p>axios 是一个独立的 JavaScript 库，专注于处理 HTTP
请求。它是一个现代的、基于 Promise
的库，主要用于前端和后端（Node.js）开发，提供了清晰、简单的 API。 <span class="math inline">\(.ajax() 是 jQuery 库的一部分，用于处理各种类型的
AJAX 请求。它除了处理 HTTP 请求外，还包括许多其他功能，如 DOM
操作、事件处理、动画等。因此，\)</span>.ajax() 只是 jQuery 库的一部分。
总结来说就是，axios 是一个相对较小的库，专注于 HTTP
请求。你可以单独引入它，而无需加载整个 jQuery 库。$.ajax() 是 jQuery
的一部分，如果你只需要进行 HTTP 请求，使用 jQuery
会显得冗余，因为它包含了许多其他功能。</p>
<h4 id="vscode-多光标编辑">VSCode 多光标编辑</h4>
<ol type="1">
<li>按住 <code>alt</code> 点击多个位置(这个方法选择就没有约束)。</li>
<li>按住鼠标滚轮，往下拖动(这个方法只是支持在同一竖线上的多位置编辑)。</li>
</ol>
<h4 id="快速创建-html-模板">快速创建 HTML 模板</h4>
<p>创建xxx.html文件，输入: ! + Tab</p>
<h4 id="实体字符">实体字符</h4>
<p>在HTML中，实体字符是一种特殊的编码方式，用来表示一些特殊字符或保留字符，以确保它们能够正确地显示在网页上，而不会被解释为HTML标记。以下是一些常见的HTML实体字符
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/%E5%AE%9E%E4%BD%93%E5%AD%97%E7%AC%A6.png" class></p>
<h4 id="系统变量和用户变量">系统变量和用户变量</h4>
<p>系统变量与用户变量的区别，最重要的即系统变量的优先级高于用户变量。</p>
<h4 id="beautifulsoup-库">BeautifulSoup 库</h4>
<p>Beautiful Soup
是一个Python库，用于从HTML或XML文档中提取数据。它是一个强大的解析库，可以帮助你轻松地解析复杂的网页内容，并从中提取所需的信息。
它可以帮助我们(在使用Beautiful
Soup库时，通常需要指定一个底层的解析器，而 lxml
是一个常用的解析器之一，因为它具有高性能和稳定性。Beautiful
Soup本身并没有自带解析器，因此需要依赖第三方解析器来处理HTML或XML文档)：
1. 解析 HTML 和 XML。将他们转换为 Python 对象的树状结构。 2.
寻找元素。寻找特定的元素、属性、文本内容，从而提取所需的数据。 3.
修改文档结构。 4. 清除数据。</p>
<h4 id="re-regular-expression-regex">RE regular expression regex</h4>
<p>正则表达式，是用来简介表达一组字符串特征的表达式，最主要的应用在字符串匹配。
具体内容见文章 python 爬虫。</p>
<h4 id="ip-地址">IP 地址</h4>
<p>IP地址（Internet Protocol
Address，互联网协议地址）是一种用于在计算机网络中唯一标识和定位设备的数字地址。IP地址在互联网通信中起到了非常重要的作用，它允许设备在全球范围内进行通信。
一些概念和要点： 1.
唯一性：每个设备（如计算机、服务器、路由器）连接到互联网时都被分配一个唯一的IP地址。这确保了在互联网上的每个设备都可以被准确标识和寻址。
2. IPv4和IPv6：有两个主要的IP地址版本，分别是IPv4（Internet Protocol
Version 4）和IPv6（Internet Protocol Version
6）。IPv4地址是32位的，通常以点分十进制表示，如192.168.1.1。IPv6地址是128位的，通常以冒号分隔的十六进制表示，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。由于IPv4地址空间有限，IPv6被引入以满足不断增长的互联网连接需求。
3.
分层和路由：IP地址的设计允许数据在网络中进行分层和路由。它可以告诉路由器和交换机如何将数据包从源设备传送到目标设备，经过多个网络节点。
4.
公共和私有IP地址：IP地址可以是公共的或私有的。公共IP地址用于直接连接到互联网，而私有IP地址用于在私有网络中进行内部通信。私有IP地址通常在家庭网络和企业内部网络中使用，路由器负责将这些地址与公共IP地址进行映射。
5.
动态和静态IP地址：IP地址可以是动态的或静态的。动态IP地址由DHCP（动态主机配置协议）服务器动态分配给设备，而静态IP地址是由网络管理员手动配置的，通常不会更改。
6.
网络服务：IP地址不仅用于标识设备，还用于定位网络服务和资源，如网站、邮件服务器、数据库服务器等。DNS（域名系统）用于将域名映射到IP地址，使人们更容易访问网络资源。</p>
<h4 id="ctrl-r">Ctrl + R</h4>
<p>在 VSCode 中可以直接搜索文件夹。</p>
<h4 id="抓包-packet-capture">抓包 packet capture</h4>
<p>「抓包」是将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包经常被用来进行数据截取等。</p>
<h5 id="为什么抓包">为什么抓包</h5>
<ol type="1">
<li>Web
表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防
CRSF
攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li>
<li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li>
</ol>
<h5 id="常用的抓包工具">常用的抓包工具</h5>
<ol type="1">
<li>httpwatch</li>
<li>fiddler</li>
<li>wireshark</li>
<li>firebug</li>
</ol>
<h4 id="hmac-sha256-算法">HMAC-SHA256 算法</h4>
<p>HMAC-SHA256（Hash-based Message Authentication Code with
SHA-256）是一种基于哈希函数和密钥的消息认证码算法，用于确保消息的完整性和认证消息的发送方。它是SHA-256哈希函数与密钥结合使用</p>
<h4 id="token-cookie-和-session">Token Cookie 和 Session</h4>
<ol type="1">
<li>Token Token
是一种轻量级的身份验证令牌，通常是一个长字符串，用于识别用户。
<strong>原理：</strong>当用户登录应用程序时，服务器会颁发一个Token给客户端（通常是JSON
Web Token -
JWT）。客户端将Token存储在本地（通常是在浏览器的localStorage或sessionStorage中，或在移动应用的存储中）。后面客户端的每个
HTTP 请求都会在 Headers 中附带
Token，服务器<strong>只需要通过特定的密钥和加密算法来验证即可</strong>，不需要再去额外存储用户的
Token 信息。 <strong>优点：</strong>
无状态(只需要验证，无需存储)、可扩展性强，适用于分布式系统和 API。
<strong>缺点：</strong> 需要额外的处理来管理 Token
的过期、刷新和安全性。</li>
<li>Cookie
Cookie是一小段数据，由服务器发送到用户浏览器，存储在用户本地。它通常包含了一些标识信息和可选的数据。
<strong>原理：</strong>
服务器在响应HTTP请求时，可以通过Set-Cookie头来设置Cookie。浏览器会将Cookie存储在用户的计算机上，并在后续请求中自动发送给服务器。
<strong>优点：</strong> 简单、易用，可以持久保存数据，对用户透明。
<strong>缺点：</strong>
有限的存储容量，每个请求都会带上Cookie，可能会影响性能和安全性（例如，可能受到跨站脚本攻击的影响）。</li>
<li>Session
Session是一种服务器端机制，用于跟踪用户在应用程序中的状态和身份。
<strong>原理：</strong>
服务器在用户登录时创建一个唯一的会话标识，通常是一个Session
ID，并将其存储在服务器上。Session ID
可以存储在Cookie中或通过URL重写等方式传递给客户端。
<strong>优点：</strong> 相对于 Cookie 更加安全，可以存储更多的数据，不受
Cookie 容量限制。 <strong>缺点：</strong>
占用服务器内存，需要额外的服务器资源，不适于分布式系统。
通常，现代Web应用程序使用Token进行身份验证和授权，而Cookie和Session用于保持用户状态和临时数据的存储。</li>
</ol>
<h4 id="通信协议">通信协议</h4>
<p>通信协议是计算机和网络设备之间进行数据交换和通信的<strong>规则</strong>和<strong>约定</strong>。它们定义了数据的格式、传输方式、错误检测和纠正机制以及通信参与方之间的行为。</p>
<h5 id="osi-模型">1. OSI 模型</h5>
<p>OSI 模型即 <strong>开放式通信系统互联参考模型</strong>(Open System
Interconnection Reference Model)，是国际标准化组织 ISO
提出的一个试图使各种计算机在世界范围内互联为网络的标准框架，简称 OSI</p>
<p>OSI 七层模型 OSI
定义了网络互连的七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/OSI%E6%A8%A1%E5%9E%8B.png" class> 首字母组成 All people seem to need data processing.
所有人似乎都需要数据处理，这句话可以帮助来记忆。</p>
<h5 id="tcpip-协议族">2. TCP/IP 协议族</h5>
<p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP
两种协议。实际生活当中有时也确实就是指这两种协议。然而很多情况下，它只是利用
IP 进行通信时所必须用到的协议群的统称。 它是把 OSI
七层模型简化成了五层模型，每一层模型都呼叫它的下一层所提供的网络来完成自己的需求。
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/OSI%E4%B8%8ETCPIP%E5%85%B3%E8%81%94.png" class></p>
<h5 id="tcp-协议">3. TCP 协议</h5>
<p>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP
协议之前，必须<strong>先建立</strong> TCP
连接。在传送数据完毕以后，<strong>必须释放</strong>已经建立的 TCP
连接(HTTP 协议通常使用 TCP 作为传输协议，HTTP
是典型的无状态，所以可以用来理解 TCP 协议)。</p>
<p>每一条 TCP 连接只能有两个端点，是点对点的。</p>
<p>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP
连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p>
<p>TCP
协议是<strong>面向字节流</strong>的，意味着TCP将数据视为一连串的字节而不是消息或数据块的集合。</p>
<p>产生的影响： 1. 无消息边界。
在TCP连接中，数据被视为一个连续的字节流，没有明确的消息边界或分隔符。这意味着TCP不会为你自动识别消息的开始或结束。你需要自行定义和实现消息的分割和解析机制。
2. 字节级的精确性
TCP保证了数据的字节级精确性，即接收到的数据的每个字节都与发送端相匹配。如果数据在传输过程中损坏或丢失，TCP会负责重传丢失的部分，以确保接收端获得完整且准确的数据。</p>
<p>TCP
提供了可靠的、有效的数据传输但是不考虑消息的边界。因此，我们在使用 TCP
协议的时候，应用程序需要负责<strong>定义和实现消息的分割和解析方法</strong>。</p>
<p>https://zhuanlan.zhihu.com/p/64155705 TCP 协议详解</p>
<h5 id="http-协议">4. HTTP 协议</h5>
<p>HTTP 是 Hyper Text Transfer Protocol(超文本传输协议) 的缩写。HTTP
协议用于 WWW 服务器传输超文本到本地浏览器的传送协议。
它不仅可以保证计算机<strong>正确快速地传输</strong>超文本文档，还确定传输文档中哪一部分，以及哪部分内容首先显示(如文本优先于图像)。
HTTP
是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，是一个无状态的协议。</p>
<p><strong>特点：</strong> 1.
简单快速。客户向服务器请求服务的时候，只需要请求方法和路径。请求方法通常包括
GET、HEAD、POST。 2. 灵活。HTTP
允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。</p>
<p><strong>持久连接</strong> HTTP 1.1
版本的变化，就是引入了持久连接（persistent connection），即 TCP
连接默认不关闭，可以被多个请求复用，不用声明
<code>Connection: keep-alive</code>。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在发送最后一个请求时，发送
<code>Connection: close</code>，明确要求服务器关闭 TCP 连接。</p>
<p><strong>Content-Length</strong> 字段 一个 TCP
连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪个回应的。这就是
Content-Length 字段的作用，声明本次回应的数据长度。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Length: 3295</span><br></pre></td></tr></table></figure>
上面代码告诉浏览器，本次回应的长度是3295个字节，后面的字节就属于下一个回应了。</p>
<p>在 1.0 版本中，Content-Length
字段不是必需的，因为浏览器发现服务器关闭了 TCP
连接，就表明收到的数据包已经全了。 使用 Content-Length
的前提是，服务器发送回应前，必须知道回应的数据长度。<strong>对于一些很耗时的动态操作来说，这意味着服务器要完成所有操作以后才可以发送数据</strong>(毕竟是动态的)，显然这样的数据并不是很高。更好的处理方法是，产生一块数据就发送一块，采用「流模式」(stream)
取代「缓存模式」(buffer)。 因此，1.1 版本规定可以不使用 Content-Length
字段，而是使用「分块传输编码」(chunked transfer
encoding)。只要请求或者回应的头信息有 Transfer-Encoding
字段，就表明回应将由数量未定的数据块组成。 <img src="/2023/08/31/%E6%9D%82%E8%AE%B0/http%E5%92%8Ctcp%E5%85%B3%E7%B3%BB.png" class></p>
<h5 id="ftp-协议">5. FTP 协议</h5>
<p>FTP 协议(File Transfer Protocol)，也是运行在 TCP
上，保证了文件传输的可靠性。与 HTTP 相比，FTP
面向的直接是服务器的文件系统，并且具有维持状态的特点，在文件传输管理上，FTP
更胜一筹。 <strong>传输流程</strong> <img src="/.com//08/31/%E6%9D%82%E8%AE%B0/FTP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class>
一共有两个并行的连接，一个是「控制连接」(port:
21)，另一个是「数据连接」(port: 20)。
其中，控制连接用于在两个主机之间传输控制信息，如口令、用户标识、存放，获取文件等命令。数据连接用于实际发送一个文件，发送完文件以后数据连接是会关闭的。
由于 FTP 使用一个独立的控制连接，所以我们也称 FTP
的控制信息是带外(out-of-band) 传送的。HTTP 协议是在传输文件的同一个 TCP
连接中发送请求和响应首部行的，所以，HTTP 也可以说是带内 (in-band)
发送控制信息的。 <strong>传输方式</strong> FTP
支持两种方式的传输：文本(ASCII)方式和二进制(Binary)方式。
通常文本文件的传输采用 ASCII
方式；而图像、声音文件、加密和压缩文件等非文本文件采用二级制传输方式。
<strong>传输模式</strong> FTP 有两种传输模式--主动(FTP
Port)模式和被动(FTP
Passive)模式。由于主动模式存在着安全问题，最近几年，大部分的 FTP
客户端开始默认使用被动模式。 https://zhuanlan.zhihu.com/p/337513218
https://zhuanlan.zhihu.com/p/141472331</p>
<h5 id="dns-协议">6. DNS 协议</h5>
<p>互联网上主机的一种标识方式是使用它的「主机名」(hostname)，如
<code>www.facebook.com</code>、<code>www.google.com</code>
等。但是这是我们人类的记忆方式，路由器不会这么理解，路由器喜欢定长的、有层次结构的
IP 地址。 &gt; 主机名 (Hostname)
是计算机或者设备在网络上的名称标识符，用于唯一标识一个特定的计算机或者网络设备。<strong>主机名</strong>通常是人类可读的形式，<strong>但是在网络协议中国会被映射为
IP 地址进行通信</strong>。</p>
<p>IP 地址由 4 字节组成，并且有着严格的层次结构。例如
<code>121.7.106.83</code> 然而路由器喜欢的是 IP
地址进行解析，我们人类便于记忆的确实网址，此时就用到 DNS 了。 DNS
的全称是 <code>Domain Name System</code>，是由一个分层的 DNS 服务器(DNS
Server)
实现的分布式数据库；还是一个使得主机能够查询分布式数据库的应用层协议。DNS
服务器通常是运行 <code>Berkeley Internet Name Domain</code> 软件的 Unix
机器。DNS 协议运行在 UDP 之上，使用 53 端口。</p>
<p>DNS 是<strong>一个分布式的系统</strong></p>
<p>https://zhuanlan.zhihu.com/p/346236071</p>
<h4 id="h-文件和-hpp-文件区别">h 文件和 hpp 文件区别</h4>
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/h%E5%92%8Chpp.png" class>
<h4 id="低耦合-low-coupling">低耦合 Low Coupling</h4>
<p>是在讨论软件工程中的一种设计原则，旨在创建更可维护、可扩展和可重用的代码。低耦合涉及到将代码分解成松散耦合的模块或组件，这些模块之间的依赖性尽量降低。</p>
<h4 id="lambda-表达式">lambda 表达式</h4>
<p>在 C++ 中，lambda 表达式的结构： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameters) -&gt; return_type &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 解释：
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class></p>
<h4 id="delete-和-delete">delete 和 delete[]</h4>
<p>当你使用 new[]
来分配动态数组时，编译器会记住你分配了多少个元素，因此在释放内存时，你必须使用
delete[] 来确保所有元素都得到释放。如果你使用 delete（而不是
delete[]）来尝试释放动态数组的内存，将导致未定义的行为，可能会导致内存泄漏或程序崩溃。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* data_ = new int[size];</span><br><span class="line">delete[] data_;</span><br></pre></td></tr></table></figure></p>
<h4 id="静态数组">静态数组</h4>
<p>静态数组需要在编译的时候知道它的大小 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[size];</span><br></pre></td></tr></table></figure> 也就是说其中的
<code>size</code> 需要是一个常量表达式。如果我们
<code>cin &gt;&gt; size;</code> 后面又 <code>int a[size];</code>
是不行的，因为静态数组要求 <strong>编译的时候大小就确定。</strong></p>
<p>静态数组的内存分配发生在程序的静态存储区域，通常在编译的时候分配，并且在程序结束的时候才会释放，具有全局的声明周期。</p>
<h4 id="动态数组">动态数组</h4>
<p>动态数组的大小在运行的时候确定，通常在堆中分配内存。<code>int* ptr = new int[size];</code>。在最后不使用的时候记得要
<code>delete[] ptr;</code> 其中 <code>new int[size]</code>
会在堆上分配一段连续的内存，大小为 <code>size * sizeof(int)</code>
个字节，然后返回一个指向这块内存的指针，并将这个指针赋值给
<code>ptr</code></p>
<p>堆上分配的内存不会自动释放，需要程序员负责在确保不需要的时候手动释放，否则可能导致内存泄漏。</p>
<h4 id="栈内存">栈内存</h4>
<p>栈内存用于存储局部变量和函数调用信息。每个线程通常都有自己的栈。
栈内存的分配和释放是自动的，发生在函数的入栈和出栈过程中。当函数返回时，其局部变量的内存会自动被释放。
栈内存的生命周期与函数调用有关，它们在函数调用结束后自动释放。</p>
<h4 id="程序运行时内存区域">程序运行时内存区域</h4>
<ol type="1">
<li>栈区 Stack
栈区用于存储函数调用的局部变量、函数的参数值以及函数调用的返回地址。
栈区是<strong>自动管理</strong>的，函数的局部变量在函数被调用时分配内存，在函数结束时自动释放内存。
<strong>栈区的大小通常较小</strong>，且生命周期短暂，用于管理函数的执行和调用。</li>
<li>堆区 Heap 堆区用于动态分配内存，例如使用 new 和 malloc 来分配内存。
堆区的内存分配和释放需要程序员<strong>手动管理</strong>，使用 delete 和
free 来释放内存。
<strong>堆区的大小通常较大</strong>，用于存储动态分配的数据结构，如动态数组、对象等。</li>
<li>静态存储区域 Static Storage
静态存储区域用于<strong>存储全局变量、静态变量和常量</strong>(如静态分配的数组)。
这些变量在程序启动时分配内存，在程序结束时释放内存。
静态存储区域的变量具有全局可见性，并且在整个程序的生命周期内保持不变。</li>
<li>代码区 Code Segment 代码区包含程序的机器码指令，用于执行程序的逻辑。
代码区通常是只读的，不允许写入和修改。
代码区存储程序的执行指令，每个函数和方法的机器代码以及程序的静态数据。</li>
<li>常量区 Constant Area 常量区用于存储常量数据，如字符串文字（string
literals）和全局 const 变量。 常量区的数据是只读的，不允许修改。</li>
<li>栈帧区 Stack Frame</li>
</ol>
<h4 id="malloc-free-和-new-delete">malloc free 和 new delete</h4>
<p><strong>语言差异</strong>： malloc 和 free
是C语言中的函数，可以在C++中使用，但通常不推荐在C++代码中使用它们，因为C++提供了更强大的内存管理工具。
new 和 delete
是C++中的操作符，专门用于创建和销毁对象，并与类的构造函数和析构函数一起工作。</p>
<p><strong>类型安全性：</strong> new 和 delete
是类型安全的，它们会为对象的构造和销毁调用适当的构造函数和析构函数。这对于管理类对象非常重要。
malloc 和 free
不了解对象的类型，它们只是分配和释放内存块。如果你使用它们来分配和释放类对象，可能会绕过构造函数和析构函数，导致对象的行为不正常。</p>
<p>尽管 malloc 和 free
是C语言中的标准内存分配函数，但在C++中通常更推荐使用 new 和
delete，因为它们提供了更好的类型安全性、异常处理和对象生命周期管理。只有在特殊情况下，如与C库一起使用或需要更底层的内存分配控制时，才使用
malloc 和 free。</p>
<p>其中需要注意，malloc 函数返回的是 <code>void*</code>
类型的指针，也就是并没有规定它的类型，需要我们人为规定。所以我们一般写成这样的形式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* p = (char*)malloc(100);</span><br></pre></td></tr></table></figure> 其中，100 表示 100 个字节。</p>
<h4 id="c-对象构造">C++ 对象构造</h4>
<p>有四种方式创建对象： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">MyClass myClass = MyClass();</span><br><span class="line">MyClass* myClass = new MyClass();</span><br><span class="line">MyClass* myClass = new MyClass;</span><br></pre></td></tr></table></figure>
其中，前两种方式是在栈中分配内存，由操作系统进行内存的分配和管理。
后两种是在堆中分配内存，由管理者(程序员)进行内存的分配和管理，用完必须
delete，否则会造成内存的泄露。</p>
<h5 id="不使用-new">不使用 new</h5>
<p>对于第一种和第二种，一个隐式调用，一个显式调用。
<strong>第一种：</strong> -
如果有构造函数，默认使用构造函数来初始化对象。 -
如果没有默认的构造函数，编译器会报错。</p>
<p><strong>第二种：</strong> - 默认使用构造函数 -
如果没有构造函数，编译器会报错。 -
与第一种方法不同，这个是先创建一个对象，然后进行对象的复制。</p>
<p>虽然上面两种那么说，但是如果我们没有显式定义构造函数，编译器会自动生成一个默认构造函数的。这个默认构造函数会对类中的一些基本数据类型的数据进行初始化，就是随机赋值。</p>
<p>所以，通常情况下，前两种方式相比较，第一种方式直接
<code>MyClass myClass;</code>
是更加直接高效的方法，一般使用这种方式。</p>
<h5 id="使用-new">使用 new</h5>
<p>在使用 new
创建对象的时候。对于有构造函数的类，不论有没有括号，都用构造函数进行初始化。如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。</p>
<p>对于 new
创建对象，可以作为函数的返回值和参数，因为如果不用new，函数中不能返回该对象的指针，因为函数结束后，该对象的内存就被释放了(函数是栈空间嘛，如果是
new 则在堆空间，由我们人为决定其寿命)。</p>
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/new%E6%9E%84%E9%80%A0.png" class>
<p>上面是两种new构造的区别，其实不是很大，一般加个括号就好了。</p>
<p>使用 new 创建对象的实际步骤是： 1. 分配内存：new
会在堆上动态分配足够的内存来存储对象的数据成员，包括对象的成员变量和虚函数表（如果有的话）。</p>
<ol start="2" type="1">
<li><p>调用构造函数：一旦内存分配完成，C++会调用对象的构造函数来初始化这块内存。构造函数是类的特殊成员函数，用于初始化对象的状态。如果你没有显式定义构造函数，编译器会为你生成一个默认的构造函数来执行默认的初始化操作。</p></li>
<li><p>返回指针：new
表达式返回指向分配的内存的指针，该指针指向一个已经构造完成的对象。</p></li>
</ol>
<h4 id="csv-文件comma-separated-values">CSV 文件(Comma-Separated
Values)</h4>
<p>CSV 格式是处理和存储数据的常用格式之一。 1.
简单易懂：CSV文件使用纯文本格式，数据之间使用逗号或其他分隔符分隔。 2.
跨平台兼容性：CSV文件是纯文本文件，几乎所有操作系统和应用程序都可以处理它们。
3. 轻量级。 4. 广泛支持：几乎所有类型的编程语言都支持 CSV
格式文件操作。</p>
<h4 id="codecs">codecs</h4>
<p>"codecs" 是 Python
编程语言中的一个标准库模块，用于处理各种字符编码和解码操作。 codecs
的名称来自
<code>code and decode</code>，提供了一种在不同字符码之间进行转换的方式，这在处理文本数据的时候非常有用。
下面是一个简单的示例，将 UTF-8 的编码转换为 ASCII 编码。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import codecs</span><br><span class="line"></span><br><span class="line"># 要转换的文本</span><br><span class="line">text = &quot;Hello, 你好&quot;</span><br><span class="line"></span><br><span class="line"># 将文本从UTF-8编码转换为ASCII编码</span><br><span class="line">ascii_text = codecs.encode(text, &#x27;ascii&#x27;, &#x27;ignore&#x27;)  # ignore 是一种错误处理，&quot;ignore&quot; 表示在转换时忽略不能被目标字符编码表示的字符。还有 replace 等</span><br><span class="line"></span><br><span class="line"># 输出转换后的文本</span><br><span class="line">print(ascii_text)</span><br></pre></td></tr></table></figure></p>
<h4 id="python-列表推导list-comprehension">Python 列表推导(List
Comprehension)</h4>
<p>列表推导是一种简洁的方式来创建新的列表。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[expression for item in iterable if condition]</span><br></pre></td></tr></table></figure> 其中
<code>expression</code> 是生成新列表中元素的表达式，<code>item</code>
是可迭代对象 <code>iterable</code> 中的元素. 下面是一些例子：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个包含1到10的平方的列表</span><br><span class="line">squares = [x**2 for x in range(1, 11)]</span><br><span class="line"></span><br><span class="line"># 将字符串列表中的所有字符串转换为大写</span><br><span class="line">words = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]</span><br><span class="line">uppercase_words = [word.upper() for word in words]</span><br><span class="line"></span><br><span class="line"># 筛选出一个列表中的偶数元素</span><br><span class="line">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">even_numbers = [x for x in numbers if x % 2 == 0]</span><br></pre></td></tr></table></figure></p>
<h4 id="python-赋值">Python 赋值</h4>
<p>在 Python 中，赋值分为两种情况： 1. 不可变对象(Immutable Objects)
包括数字、字符串、元组等不可修改的对象。对不可变对象的赋值是值传递（Pass
by
Value），意味着在赋值时会创建一个新的对象，并将其值赋给新的变量，而不是将原始对象的引用传递给新的变量。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 5</span><br><span class="line">y = x  # 这是值传递，y 拥有一个新的 5 的副本</span><br></pre></td></tr></table></figure> 2. 可变对象(Mutable Objects)
包括列表、字典、集合等可以修改的对象。对可变对象的赋值是地址传递（Pass
by
Reference），意味着在赋值时不会创建新的对象，而是将原始对象的引用传递给新的变量。因此，如果修改一个可变对象，会影响到所有引用它的变量。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1, 2, 3]</span><br><span class="line">list2 = list1  # 这是地址传递，list2 和 list1 引用同一个列表对象</span><br></pre></td></tr></table></figure></p>
<h4 id="python-切片">Python 切片</h4>
<p>切片是 Python 中非常强大的功能，可以用于许多不同的场景。 1.
提取子序列 可以提取列表、字符串或元组中的特定元素子集。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">subset = my_list[1:4]  # 提取索引1到索引3的元素，得到[2, 3, 4]</span><br></pre></td></tr></table></figure>
2. 复制切片 我们上面说了，Python
序列是址传递的，所以我们想复制序列的话不可以简单的
<code>list2 = list1</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">original_list = [1, 2, 3, 4, 5]</span><br><span class="line">copy_list = original_list[:]  # 创建一个原始列表的副本，修改 copy_list 不会影响到 original_list</span><br></pre></td></tr></table></figure> 3. 步进切片
我们可以指定一个步进值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">every_other = my_list[::2]  # 每隔一个元素提取，得到[1, 3, 5]</span><br></pre></td></tr></table></figure> 4. 字符串反转 or 序列 反转
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_string = &quot;Hello, World!&quot;</span><br><span class="line">substring = my_string[0:5]  # 提取前五个字符 &quot;Hello&quot;</span><br><span class="line">reversed_string = my_string[::-1]  # 字符串翻转</span><br></pre></td></tr></table></figure> 5. 删除元素 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">del my_list[1:3]  # 删除索引1到索引2的元素，my_list变为[1, 4, 5]</span><br></pre></td></tr></table></figure> 6. 替换元素 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">my_list[1:4] = [10, 20, 30]  # 替换索引1到索引3的元素，my_list变为[1, 10, 20, 30, 5]</span><br></pre></td></tr></table></figure> 7.
过滤数据 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">filtered_list = [x for x in my_list if x % 2 == 0]  # 过滤偶数，得到[2, 4]</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串面值的赋值">字符串面值的赋值</h4>
<p>字符串字面值是指在代码中直接以文本形式表示的字符串，通常用双引号括起来的一系列字符。字符串字面值在编程中用于表示固定的文本数据。例如，以下是一些字符串字面值的示例：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello, World!&quot;</span><br><span class="line">&quot;This is a string literal.&quot;</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure>
字符串面值通常是只读的，意味着我们不能对于它们的内容进行修改。
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%A2%E5%80%BC%E7%9A%84%E8%B5%8B%E5%80%BC.png" class></p>
<h4 id="关于-char-与-char">关于 char[] 与 char*</h4>
<h5 id="char">char[]</h5>
<ul>
<li>它是一个字符数组，它在栈上分配内存，并且为数组内的每个元素分配空间。</li>
<li>当您使用字符串字面值来初始化字符数组时，编译器会自动为数组分配足够的空间来存储字符串字面值的内容，包括字符串结束符
'\0'(与指针直接指向字符串字面值的地址不同，数组是新创建一个空间，然后相当于在新的字符串空间中将字符串字面值给复制过去)。</li>
</ul>
<h5 id="char-1">char*</h5>
<ul>
<li>char* 是一个字符指针，只是指向一个字符的内存地址。</li>
<li>当我们使用字符串字面值来初始化数组时，实际上是将字符串字面值的地址赋给了指针(但是我们知道，字符串字面值通常只是只读的，所以说我们指针指向了那个地址也是无法修改字符串的值的，因此一般不这么写，编译器也会报警告)。</li>
<li>如果我们想使用 char*</li>
</ul>
<p>并且对于 char* 和 char[]，C/C++ 有一种约定成俗的习惯，使用 cout
输出时，会自动识别数组或者指针指向的字符串，并且输出字符串的内容直到遇到空字符
<code>'\0'</code> 停止。</p>
<p>这种行为是通过C/C++标准库中的重载运算符和内置函数来实现的，它们会自动迭代字符数组或指针，并输出字符直到遇到空字符。这使得输出字符串变得方便，无需显式循环来逐个字符输出。</p>
<p>同样的，不仅仅是对于 <code>cout</code>，对于 char 的一些函数如
<code>strlen</code>、<code>strcpy</code>，参数为 char*
的时候，同样也是遇到 <code>'\0'</code>
时停止函数操作(一般来说，这些函数是操作 <code>char*</code>
的，我们如果操作 <code>char[]</code> 也是能操作的，因为
<strong>字符数组可以隐式转换为字符指针</strong>)。</p>
<p>如果我们实在想对于 <code>char*</code> 类型赋值，可以：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* str = new char[20]; // 使用 new 动态分配 20 个字符的内存</span><br><span class="line"></span><br><span class="line">// 将字符串常值赋值给 str</span><br><span class="line">strcpy(str, &quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">// 在不需要时记得释放内存</span><br><span class="line">delete[] str;</span><br></pre></td></tr></table></figure></p>
<h4 id="常见的-char-函数">常见的 char* 函数</h4>
<ol type="1">
<li>字符串长度函数 <code>strlen(const char* str)</code>:
返回字符串的长度，不包括空字符终止符。</li>
<li><code>strcpy(char* dest, const char* src)</code>:
将源字符串复制到目标字符串，包括空字符终止符。需要确保目标字符串有足够的空间来存储源字符串。
<code>strncpy(char* dest, const char* src, size_t n)</code>:
将源字符串的前 n 个字符复制到目标字符串，可以控制复制的字符数。</li>
<li><code>strcat(char* dest, const char* src)</code>:
将源字符串连接到目标字符串的末尾，需要确保目标字符串有足够的空间来容纳源字符串</li>
<li><code>strcmp(const char* str1, const char* str2)</code>:
比较两个字符串，返回值表示它们的字典顺序关系。
请注意，使用这些函数时应格外小心，确保正确处理内存和边界情况，以避免安全漏洞和未定义的行为。</li>
</ol>
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/strcpy%E5%92%8Cstrdup.png" class>
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/strdup%E4%BD%BF%E7%94%A8.png" class>
<h4 id="endl-与">endl 与 ""</h4>
<img src="/.com//08/31/%E6%9D%82%E8%AE%B0/endl%E4%B8%8En.png" class>
<h4 id="vector-创建二维数组">vector 创建二维数组</h4>
<p>一次性定义： 此种方法适用于每一行的列数都相等的二维数组定义(与初始化)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用vector一次性完成二维数组的定义（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br><span class="line"></span><br><span class="line">//以下是拆分理解</span><br><span class="line">//创建一维数组matirx，这个数组里有m个元素，元素是int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m);</span><br><span class="line">//除了定义数组类型及数组大小外，同时给数组中的元素赋值：将元素赋值为大小为n的int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n));</span><br><span class="line">//除了定义数组类型、数组大小、列的大小，同时给数组列中的元素（或者说，数组中的所有元素）赋值为-1。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br></pre></td></tr></table></figure></p>
<p>插入元素型定义：
此种方法适用于每一行的列数都相等或不相等的二维数组的定义（与初始化）。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//比较具有普遍性的写法（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;//创建一维数组matirx，这个数组里的元素是int型vector。</span><br><span class="line">int m = 3; //matrix有m行</span><br><span class="line">int n = 10; //matrix有n列</span><br><span class="line">int value = 1; //最终matrix成为二维数组后，其中每个元素的值为1（如果不需要进行初始化，此语句可以省略）</span><br><span class="line">for (int i = 0; i &lt; m; ++ i) &#123;</span><br><span class="line">    vector&lt;int&gt; tmp(n, value); //定义int型一维数组tmp，该数组有n个int型元素，且每个元素的初始值为value</span><br><span class="line">    matrix.push_back(tmp); //将一维数组tmp（小容器）加入matrix（大容器）中，使之成为matrix的元素，令matrix成为二维数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要每一行的列数不同（虽然一般很少这样做），也可以使用下面这种写法进行定义、初始化</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a(10, 1); //单独定义每个小容器的元素个数和元素初始值</span><br><span class="line">vector&lt;int&gt; b(5, 2);</span><br><span class="line">vector&lt;int&gt; c(10, 3);</span><br><span class="line"></span><br><span class="line">matrix.push_back(a); //将每个小容器加入matrix（大容器）中</span><br><span class="line">matrix.push_back(b);</span><br><span class="line">matrix.push_back(c);</span><br></pre></td></tr></table></figure></p>
<h4 id="assign-函数分配与初始化">assign 函数分配与初始化</h4>
<p>其实也可以使用 vector 的构造函数来初始化。</p>
<p>assign 函数主要用于重新分配 vector
元素并进行初始化。它的用法主要有两种： 1. 用迭代器范围进行分配： assign
可以结构两个迭代器参数，从另一个容器或者序列中复制元素到当前 vector 中。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">std::vector&lt;int&gt; anotherVec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">vec.assign(anotherVec.begin(), anotherVec.end());</span><br></pre></td></tr></table></figure> 2. 用大小和值进行分配： assign
函数也可以接受一个大小参数和一个值参数，用于将 std::vector
的大小更改为指定大小，并用指定的值填充所有新元素。这是一种用于重新分配
std::vector 并<strong>进行初始化的方法</strong>。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec(5, 42); // 就是将 vec 的大小设置为 5，每一项设置为 42</span><br><span class="line"></span><br><span class="line">std::vector&lt;vector&lt;int&gt;&gt; v(5, vector&lt;int&gt;(5, 0)); // 创建一个二维数组 v，其中是 5 行 5 列并且每一个元素都是 0</span><br></pre></td></tr></table></figure></p>
<h4 id="遍历-vector-的几种方式">遍历 vector 的几种方式</h4>
<ol type="1">
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; v.size(); ++i)</span><br></pre></td></tr></table></figure></li>
<li>使用迭代器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br></pre></td></tr></table></figure></li>
<li>使用 auto 关键字 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line"></span><br><span class="line">for (const auto&amp; element : v)</span><br></pre></td></tr></table></figure> 关于为什么写成
<code>const auto&amp;</code>
可以避免拷贝(加快速度)，保持元素的不可变性。</li>
</ol>
<h4 id="关于-vector-迭代器">关于 vector 迭代器</h4>
<p>vector
中迭代器是一个用于访问容器元素的抽象概念。它提供了一种通用的方式来遍历容器中的元素，而不依赖于容器的具体实现细节。
在 C++ 中，std::vector 提供了<strong>两种主要类型</strong>的迭代器： 1.
begin() 迭代器。这个迭代器指向容器中的第一个元素。 2. end()
迭代器。这个迭代器指向容器中<strong>最后一个元素的下一个位置</strong>。</p>
<h4 id="主存">主存</h4>
<p>主存指的是内存 RAM</p>
<h4 id="ssd">SSD</h4>
<p>SSD 是固态硬盘 (Solid State Drive)
的缩写。与传统的机械硬盘（HDD）不同，SSD不包含可移动的机械部件，而是使用闪存存储技术来存储数据。这使得SSD在许多方面都具有一些显著的优势，包括：
1.
更快的速度：SSD比HDD更快，因为它们不需要旋转磁盘和寻道操作来读取数据。这意味着计算机可以更快地启动、加载应用程序和执行文件传输等任务
2.
更低的能耗：由于没有旋转的机械部件，SSD消耗的能量较少，因此在笔记本电脑和移动设备中通常能够延长电池寿命。
3. 更高的可靠性与更轻便 但是价格比较高。 HDD (Hard Disk Drive)
硬盘驱动器，有时候也成为硬盘或者机械硬盘</p>
<h4 id="bios">BIOS</h4>
<p>BIOS（基本输入/输出系统，Basic Input/Output
System）是计算机系统中的一组固件程序，它们位于计算机的主板上的一个特殊芯片中，通常是闪存芯片。
1.
启动自检（POST）：在计算机启动时，BIOS会执行自检程序，检查计算机的硬件组件，如处理器、内存、硬盘、光驱等是否正常工作。如果发现问题，BIOS通常会发出蜂鸣声或显示错误信息，以指示问题的位置。
2.
引导操作系统：一旦自检完成，BIOS会寻找可引导的设备，通常是硬盘驱动器或其他存储设备。它会加载操作系统的引导加载程序（Boot
Loader），并将控制权转交给操作系统，使其能够继续启动过程。 3.
设置硬件参数：BIOS还包括一组用户可配置的硬件设置，这些设置通常可通过计算机的BIOS设置界面进行调整。用户可以在BIOS中设置硬盘启动顺序、系统时间、密码保护等选项。
4.
提供基本的输入/输出服务：BIOS提供了一些基本的输入/输出功能，以便在操作系统加载之前进行一些基本的操作，如键盘输入、显示输出和存储设备的读写。</p>
<h4 id="transistor-transistor-logic">Transistor-Transistor Logic</h4>
<p>在集成电路型号中，通常以 74 开头的数字代表它们属于标准的
Transistor-Transistor Logic 具体来说，"74" 表示了 TTL
系列中的特定子系列。TTL 门和触发器的型号通常以 "74" 开头，例如，"7400"
代表四输入 NAND 门，"74138" 代表 3-8 译码器/多路复用器，等等。</p>
<h4 id="vector-中的-find-函数">vector 中的 find 函数</h4>
<p><strong>find 函数是在 <code>algorithm</code>
中的，不写的话会报错，血的教训。</strong> C++ 标准库中的
<code>std::find()</code> 函数可以用来在容器 (包括 std::vector)
中查找特定值的位置。它的用法如下： <figure class="highlight plaintext"><figcaption><span><algorithm></algorithm></span><a href="//">必须包含这个头文件</a></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myVector = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int targetValue = 3;</span><br><span class="line"></span><br><span class="line">// 使用std::find查找特定值</span><br><span class="line">auto it = std::find(myVector.begin(), myVector.end(), targetValue);</span><br><span class="line"></span><br><span class="line">if (it != myVector.end()) &#123;</span><br><span class="line">    // 找到了目标值</span><br><span class="line">    // &#x27;it&#x27; 是一个迭代器，指向找到的元素的位置</span><br><span class="line">    // 在这里，它指向了值为3的元素</span><br><span class="line">    cout &lt;&lt; &quot;找到了目标值: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 没找到目标值</span><br><span class="line">    cout &lt;&lt; &quot;未找到目标值&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
std::find函数的返回类型是一个迭代器（iterator），它是一个指向容器中找到的元素的位置的指针。</p>
<h4 id="string">string</h4>
<p>string 中也是有着迭代器的</p>
<h4 id="电源适配器-power-adapter">电源适配器 power adapter</h4>
<p>提到电源适配器可能很多人都不知道这是什么东西，如果说笔记本电脑充电线上那个长方形的配件或者说手机充电器大家倒是常见，是的，那个就是电源适配器，电源适配器（Power
adapter）又叫外置电源，是小型便携式电子设备及电子电器的供电电压变换设备，常见于手机、液晶显示器和笔记本电脑等小型电子产品上。
它的作用是将家里的220伏高电压转换成这些电子产品能工作的5伏至20伏左右稳定的低电压，使他们能正常工作,一般由外壳、变压器、电感、电容、控制IC、PCB板等元器件组成，它的工作原理由交流输入转换为直流输出</p>
<h4 id="vscode-中-alt-加-上下键">vscode 中 alt 加 上下键</h4>
<p>可以将光标所在的位置的代码行直接进行移动，向上或者向下移动。</p>
<h4 id="栈帧">栈帧</h4>
<p>当一个函数被调用时，通常会创建一个包含该函数的局部变量、参数和执行上下文信息的数据结构，这个数据结构称为栈帧（也称为调用帧或执行帧）。栈帧用于存储函数执行期间的局部状态信息，包括局部变量、函数参数、返回地址等。在函数调用栈中，每个函数调用都对应一个栈帧，它们按照调用的顺序依次排列。</p>
<p>所以我们采取非递归算法，即使是在函数中模拟栈，但是我们并没有过多递归导致产生过多栈帧，所以通常是更加节省空间的。</p>
<h4 id="比较函数规则">比较函数规则</h4>
<p>通常情况下，比较函数的返回值为1表示前面的元素大于后面的元素，而返回-1ee或者0表示前面的元素小于或等于后面的元素。这是一种常见的约定，但也可以根据具体需求和实现来定义不同的比较规则。</p>
<h4 id="pair-模板类">pair 模板类</h4>
<p>std::pair 是 C++
标准库提供的一个模板类，用于将两个不同类型的值组合成一个单元。定位于头文件
<code>utility</code> 中。</p>
<p>std::pair
最常见的用法是在函数的返回值中返回多个值，或者在容器中存储多个类型的数据。pair
有两个公共成员 <code>first</code> 和 <code>second</code></p>
<h4 id="section">\0</h4>
<p>在C/C++中，\0 通常用作字符串的结束标志，标识字符串的结尾。</p>
<p>当你在一个以\0结尾的字符数组（C-Style字符串）中遇到\0字符时，它表示字符串的结束，告诉程序在这里停止处理字符串。例如：</p>
<h4 id="map-等容器创建">map 等容器创建</h4>
<p>在C++中，std::map对象的创建方式取决于它是如何声明的。std::map可以在栈上或堆上创建，具体取决于其声明方式。</p>
<h4 id="模块化">模块化</h4>
<p>将代码写成如下的形式： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> void insert(const T&amp; value) &#123;</span><br><span class="line">        insertNode(root, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 有下面的好处： 1.
代码模块化：将插入操作分为两个函数可以使得代码更加模块化，每个函数负责一个明确定义的任务。使得代码更加容易理解和维护。外部调用者著需要调用
insert 函数，而不需要了解内部的递归细节。 2. 可读性：使用 insert 和
insertNode
两个函数可以在外部接口提供更具描述性的函数名，使得代码更加容易理解。 3.
封装内部细节：insertNode
函数是一个内部的实现细节，不需要暴露给用户。这有助于隐藏内部数据结构和实现细节，提高了代码的封装性和安全性。</p>
<p>将插入操作拆分为两个函数是一种常见的编程实践，有助于提高代码的清晰度、可维护性和可读性。这种模块化设计方法可以应用于其他类似的操作，使代码更易于管理和扩展。</p>
<h4 id="stl-容器传递用于比较的函数对象类">STL
容器传递用于比较的函数对象类</h4>
<p>在C++的STL容器中（如std::map、std::set等），如果您想要自定义元素的比较行为，您可以传递一个用于比较的函数对象类，而不是传递一个函数对象的实例。这是因为STL容器需要在需要比较元素时创建比较器对象的实例，而不是在容器创建时就传递一个现成的比较结果。</p>
<p>因此，当您向std::map（或其他STL容器）传递一个自定义的比较函数对象时，STL容器会在内部创建该函数对象的实例，以便在需要时进行元素比较。这允许STL容器根据需要多次使用相同的比较器类的不同实例。</p>
<p>所以我们写为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">// 自定义的比较函数对象类</span><br><span class="line">struct MyComparator &#123;</span><br><span class="line">    bool operator()(int a, int b) const &#123;</span><br><span class="line">        return a &gt; b; // 比较a是否大于b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用自定义比较函数对象创建std::map</span><br><span class="line">    std::map&lt;int, std::string, MyComparator&gt; customMap; // 传递一个结构体，而不是它的实例对象，STL容器会自动创建实例对象来比较</span><br><span class="line"></span><br><span class="line">    // 插入一些元素</span><br><span class="line">    customMap[5] = &quot;Five&quot;;</span><br><span class="line">    customMap[2] = &quot;Two&quot;;</span><br><span class="line">    customMap[8] = &quot;Eight&quot;;</span><br><span class="line"></span><br><span class="line">    // 遍历并打印map的内容</span><br><span class="line">    for (const auto&amp; pair : customMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="struct-和-class">struct 和 class</h4>
<p>在C++中，struct和class都是用来定义用户自定义数据类型的关键字，它们之间的主要区别在于默认的访问控制和一些语法细节。下面是它们的主要区别和适用场景：</p>
<ol type="1">
<li>访问控制：</li>
</ol>
<p>struct：struct中的成员默认都是公共的（public），可以被外部代码直接访问。
class：class中的成员默认都是私有的（private），需要通过成员函数（方法）来访问。
2. 数据封装：</p>
<p>由于class默认成员是私有的，它更适合用于实现数据封装，即将数据隐藏在类的内部，通过公共接口提供访问和修改数据的方法，以维护数据的完整性和安全性。
struct通常用于轻量级的数据结构，其成员都是公开的，用于存储一组相关数据，不提供严格的封装。
继承：</p>
<ol start="3" type="1">
<li><p>struct和class都可以用于实现继承，但默认情况下，class的继承是私有的，而struct的继承是公共的。这意味着从class继承的成员在子类中默认是私有的，而从struct继承的成员在子类中默认是公共的。
适用场景：</p></li>
<li><p>使用class：当需要实现封装、数据隐藏、访问控制、继承以及更复杂的类层次结构时，通常使用class。
使用struct：当只需要一个简单的数据容器，没有需要隐藏的数据，或者需要与C语言交互时，通常使用struct。也可以将struct用于只包含数据而不包含成员函数的情况。
无论选择使用struct还是class，都可以在其中定义成员函数（方法）以提供对数据的操作，这取决于您的设计需求和数据封装的程度。在实际应用中，这两个关键字的选择通常是根据项目的需求和编码风格来确定的。</p></li>
</ol>
<h4 id="深入理解-c-stl-迭代器">深入理解 C++ STL 迭代器</h4>
<p>STL（Standard Template
Library）中的容器实现迭代器是通过将迭代器作为容器类的内部类来实现的。迭代器是一种用于遍历容器中元素的抽象概念，它提供了访问容器元素的接口，使得可以轻松地遍历容器的内容。</p>
<p>以下是关于STL容器中迭代器的一些一般性原则：</p>
<ol type="1">
<li><p>迭代器是容器的一部分：迭代器通常被定义为容器类的内部类，因此它们可以访问容器内部的数据结构，并提供访问和操作元素的方法。</p></li>
<li><p>迭代器的种类：不同类型的STL容器可以提供不同种类的迭代器，例如前向迭代器、双向迭代器和随机访问迭代器。迭代器的种类决定了迭代器的功能和效率，不同的容器支持不同种类的迭代器。</p></li>
<li><p>迭代器的操作：迭代器通常支持一组标准操作，如前进、后退、解引用等。这些操作允许您在容器中移动并访问元素。</p></li>
<li><p>Begin 和 End：STL容器通常提供 begin() 和 end()
成员函数，分别返回指向容器第一个元素和尾后位置（即不指向任何元素的位置）的迭代器。这些函数用于迭代容器的所有元素。</p></li>
<li><p>迭代器的使用：迭代器可以用于遍历容器的元素，从容器的开始（begin()）到结束（end()）。使用迭代器，您可以执行诸如遍历、查找、修改和删除元素等操作。</p></li>
<li><p>具体的实现细节和迭代器的性能特征取决于特定的容器类型。例如，std::vector
提供了随机访问迭代器，因此支持快速的随机访问，而 std::list
提供了双向迭代器，因此在列表中的元素上前进和后退较为高效。</p></li>
</ol>
<p>总之，STL容器通过定义迭代器来提供对容器元素的访问和遍历，这是STL的一个核心概念，使得STL容器在使用上非常灵活。</p>
<h4 id="红黑树和-avl-树实现差异">红黑树和 AVL 树实现差异</h4>
<ol type="1">
<li>AVL树的插入操作通常使用递归来实现，这是因为AVL树在插入后需要递归地重新平衡，以确保树保持平衡因子的性质。与AVL树不同，红黑树的平衡性质更容易通过迭代修复，因为它只涉及相邻节点之间的颜色变化和旋转操作，而不需要像AVL树那样严格的平衡因子维护。</li>
</ol>
<p>在红黑树中，使用迭代而不是递归的原因之一是它更简单且更高效。另一方面，AVL树的平衡因子维护涉及到更复杂的旋转和递归操作，因此递归更容易理解和实现。</p>
<p>总之，红黑树通常使用迭代插入操作，而AVL树通常使用递归插入操作。不同的数据结构有不同的性质和平衡要求，因此它们的插入和平衡策略也不同。</p>
<h4 id="类和结构体">类和结构体</h4>
<ol type="1">
<li><p>访问权限
类（class）的默认访问权限是私有（private）。这意味着类中的成员（数据成员和成员函数）默认情况下只能在类的内部访问，需要使用公有接口才能从外部访问。
结构体（struct）的默认访问权限是公共（public）。这意味着结构体中的成员在外部可以直接访问。</p></li>
<li><p>继承
类可以用于实现类的继承和多态，因为类支持访问控制符（如private、protected、public）来控制基类成员的可见性和访问权限。
结构体也可以用于继承，但默认的访问权限是公共，因此它们的成员在子类中具有相同的访问权限。</p></li>
<li><p>使用习惯
通常情况下，类用于表示具有私有成员和行为的抽象数据类型，用于封装数据和操作。
结构体通常用于表示简单的数据结构，其中成员通常是相关的数据字段而不包含复杂的行为。</p></li>
</ol>
<h4 id="宏定义-define">宏定义 define</h4>
<p>宏定义是在编译前由预处理器处理的，因此它们不会进行类型检查，可能会导致一些潜在的错误。
作用： 1.
宏替换：预处理器会根据宏定义将源代码中的标识符替换为相应的文本。这允许您创建常量、宏函数以及在代码中的其他地方重复使用文本片段。这提高了代码的可维护性和可读性。
2.
条件编译：通过使用条件指令（如#ifdef、#ifndef、#if、#elif、#else和#endif），您可以根据条件包含或排除代码段。这对于在不同的编译环境或配置下启用或禁用特定功能非常有用，例如调试模式或发布模式下的不同行为。
3.
包含文件：#include指令允许您在源代码中包含其他头文件，以便使用其中定义的函数、变量和类型。这有助于模块化代码并实现代码重用
4.
删除注释：预处理器可以删除注释，这样它们不会包含在编译后的代码中。这有助于减小可执行文件的大小，同时保留了代码的可读性。
5.
定义符号常量：通过#define指令，您可以定义符号常量，以便在代码中使用这些常量而不必硬编码它们的值。这有助于提高代码的可维护性，并减少代码中的魔法数字。</p>
<h4 id="数据库语言">数据库语言</h4>
<p>操作数据库经常使用特定的数据库查询语言(Database Query
Language)。最常见的数据库查询语言是 SQL(Structured Query Language,
结构化查询语言)。</p>
<p>DBMS(Database manage system) 数据库管理系统</p>
<p>绝大多数数据库软件都支持 SQL
语言，尤其是关系型数据库管理系统(RDBMS)</p>
<p><strong>MySQL 和 SQLite 的关系：</strong>
MySQL：MySQL是一个强大的关系型数据库管理系统，通常用于大型企业应用程序和高负载的网站。它可以处理大量数据和高并发访问。
SQLite：SQLite是一种轻量级的嵌入式数据库，适用于小型到中等规模的应用程序。它通常用于移动应用、桌面应用、嵌入
式系统等，不适用于大规模或高并发的场景。</p>
<p>其中，嵌入式指的是
<strong>运行方式和部署方式</strong>。这意味着它的数据库引擎以库（库文件或代码库）的形式直接嵌入到应用程序中，而不是作为一个独立的数据库服务器运行。(还记得如果使用
MySQL 的话，需要在电脑上开启它)</p>
<h5 id="redis">Redis</h5>
<p>Redis(Remote Dictionary Server)。Redis
是一种开源的<strong>内存数据库</strong>，可以用作缓存、消息代理、持久化存储以及多种数据结构的高效存储和检索。</p>
<p>内存数据库将数据存储在内存中，可以实现非常快的读取和写入操作。这使得内存数据库在需要快速响应的应用中有非常大的优势，例如实时数据分析、缓存和实时计算。</p>
<h5 id="stdstringnpos">std::string::npos</h5>
<p>std::string::npos
是C++标准库中的一个特殊常量值，通常用于表示字符串操作的无效或失败状态，特别是在查找子字符串或字符时。</p>
<p>常见的使用方式是在 <code>std::string</code> 的 <code>find</code>
函数中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string text = &quot;Hello, World!&quot;;</span><br><span class="line">    std::size_t found = text.find(&quot;foo&quot;); // 在字符串中查找&quot;foo&quot;</span><br><span class="line">    </span><br><span class="line">    if (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Substring found at position &quot; &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Substring not found.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="size_t">size_t</h4>
<p><code>size_t</code>
是C/C++标准库中定义的一种用于表示对象大小或索引的无符号整数类型。它通常被用于数组索引、容器大小、内存分配、字符串长度以及其他需要表示对象大小的上下文中。
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    for (size_t i = 0; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Miscellaneous</tag>
      </tags>
  </entry>
  <entry>
    <title>规划论模型</title>
    <url>/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>规划论模型也成为运筹与优化模型，在实际问题的建模中应用最为广泛，涉及面较广。</p>
<h4 id="线性规划">线性规划</h4>
<p>通常对于只有两个决策变量的情形，可以使用图解法加以求解。而对于大于两个决策变量的情形，需要借助单纯形方法加以求解。单纯形方法的基本思想是迭代思想的一种体现。首先找到初始可行解，并通过迭代逐步从可行域的一个顶点走向另一个顶点，最终走到最优解。
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/linprog.png" class> 下面的例题： <img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/problem1.jpg" class> 其中，求 max，所以我们把 z
的系数取反。第二个不等式是大于等于，我们也同样取反。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-1; -2; 3];</span><br><span class="line">A = [3 2 1; -4 -7 6];</span><br><span class="line">b = [6; -8];</span><br><span class="line">Aeq = [2 1 5];</span><br><span class="line">beq = [4];</span><br><span class="line">vlb = [0; 0; 0];</span><br><span class="line">vub= [];</span><br><span class="line">[x, fval] = linprog(f, A, b, Aeq, beq, vlb, vub)</span><br></pre></td></tr></table></figure> #####
运输问题 较为常见的运输模型叙述如下： &gt; 某物资有 m 个原产地 <span class="math inline">\(A_i\)</span>，产量为 <span class="math inline">\(a_i\)</span>；有 n 个销地 <span class="math inline">\(B_j\)</span>，销量关系为 <span class="math inline">\(b_j\)</span>，从 <span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_j\)</span> 之间的单位物资运价为 <span class="math inline">\(d_{ij}\)</span>，则产销平衡时有 <span class="math inline">\(\sum\limits_{i = 1}^{m}a_i = \sum\limits_{j =
1}^{n} b_j\)</span></p>
<h5 id="多目标规划问题">多目标规划问题</h5>
<p>在建立优化模型时有时追求的目标可能是多个，无论忽略其中的哪个因素可能都会降低优化结果的可信度。对于这类问题通常有下面的三种处理方式：
1. 为每个目标设置重要性权重。 当存在 n
个目标时，首先对目标函数进行归一化处理（就是消除量纲的影响，进行标准统一）后分别设置自己的权重，假设第
i 个目标的权重为 <span class="math inline">\(\alpha_i\)</span>，目标取值为 <span class="math inline">\(M_i\)</span>，则可以建立下面的优化模型：<span class="math inline">\(\max \alpha_1M_1 + \alpha_2M_2 + ... +
\alpha_nM_n\)</span> 2.
为各种目标设定优先权，并将模型转化为多个优化模型。 3.
分别求得个目标的最优值后，将主要目标设定为目标函数，而将次要目标适当调整后修改为约束条件。</p>
<h4 id="适度指标的线性处理">适度指标的线性处理</h4>
<p>适度指标是指该指标的他正是数据大了或者小了均不好，要充分地接近于某一事先给定的标准指标，比如水的
PH 值。 求 <span class="math inline">\(\min |x - D|\)</span>，D
为数据指标的理想取值。 例题： 一个富豪准备拿 10
万元买股票。经过他的筛选，有三种候选投资股票。这三种股票的价格、收益率以及风险系数如表所示：
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E8%82%A1%E7%A5%A8.png" class>
这是一个多规划问题，我们如果直接列两个不等式的话，可能存在无解的情况。所以我们可以采取上面所说的方法2，建立如下的两个不等式条件：
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E7%AD%89%E5%BC%8F.png" class> 如果我们优先考虑投资的风险，就可以建立下面的线性规划模型：
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B.png" class> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">Aeq = [1 3 5 1 -1 0 0; 2 5 8 0 0 1 -1; 10 20 30 0 0 0 0];</span><br><span class="line">beq = [15000; 25000; 100000];</span><br><span class="line">f = zeros(7, 1);</span><br><span class="line">f(5) = 1;</span><br><span class="line">vlb = zeros(7, 1);</span><br><span class="line">vub = [];</span><br><span class="line">a = [];</span><br><span class="line">b = [];</span><br><span class="line">[x, y] = linprog(f, a, b, Aeq, beq, vlb, vub);</span><br><span class="line">fx = x(1) + 3 * x(2) + 5 * x(3)</span><br><span class="line">lr = 2 * x(1) + 5 * x(2) + 8 * x(3)</span><br></pre></td></tr></table></figure></p>
<h4 id="整数规划">整数规划</h4>
<p>在线性规划模型中，如果各个决策变量的取值均为整数，则称此类模型为整数规划模型。
整数规划的解法主要有穷举法(变量维数较高时不可行)、舍入凑整法、分支定界法(比较可行)、割平面法(比较可行)等。
1. 舍入凑整法
感觉很是玄学，就是假装没有整数约束，求解出最优解后每个变量往下或者上取整比较一下。
2. 分支界定法
如果不满足整数条件，任选一个不满足整数条件的变量来构造新的约束，在原可行域中剔除部分非整数解。然后，再在缩小的可行域中求解新构造的线性规划的最优解（好抽象）。
步骤： 1. 解没有整数约束的问题。 2. 定界 3. 分支 4. 修改上下界 5.
比较与剪枝</p>
<h5 id="型整数规划">0-1 型整数规划</h5>
<p>约束条件为 <span class="math inline">\(0 \leq x_i \leq 1,x_i\)</span>
为整数。这样就和一般的整数规划问题统一了。</p>
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92.png" class title="整数规划求解函数">
<p>实例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-3; 2; -5];</span><br><span class="line">intcon = [1, 2, 3]; % 表示哪几个变量为整数</span><br><span class="line">A = [1 2 -1; 1 4 1; 1 1 0; 4 0 1];</span><br><span class="line">b = [2; 4; 3; 6];</span><br><span class="line">Aeq = [];</span><br><span class="line">beq = [];</span><br><span class="line">lb = [0; 0; 0]; % 如果下界为 0 上界为 1，其实就是 0-1 整数规划了。</span><br><span class="line">rb = [1; 1; 1];</span><br><span class="line">[x, val] = intlinprog(f, intcon, A, b, Aeq, beq, lb, rb)</span><br></pre></td></tr></table></figure></p>
<h5 id="指派问题">指派问题</h5>
<img src="/.com//08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98.png" class title="指派问题">
<p>当人数和任务的个数不同的时候，会出现某些人没有任务可做或者某些任务无人完成的情况。出现这两种情况的时候只需将约束条件中的某一个等于
1 的约束条件修改为小于等于 1
即可。有时也可以一对多（一个人多任务，一个任务多个人）。 2013
年碎纸片拼接复原问题 1： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cell&#123;1,1&#125;=imread(&#x27;000.bmp&#x27;);</span><br><span class="line">cell&#123;1,2&#125;=imread(&#x27;001.bmp&#x27;);</span><br><span class="line">cell&#123;1,3&#125;=imread(&#x27;002.bmp&#x27;);</span><br><span class="line">cell&#123;1,4&#125;=imread(&#x27;003.bmp&#x27;);</span><br><span class="line">cell&#123;1,5&#125;=imread(&#x27;004.bmp&#x27;);</span><br><span class="line">cell&#123;1,6&#125;=imread(&#x27;005.bmp&#x27;);</span><br><span class="line">cell&#123;1,7&#125;=imread(&#x27;006.bmp&#x27;);</span><br><span class="line">cell&#123;1,8&#125;=imread(&#x27;007.bmp&#x27;);</span><br><span class="line">cell&#123;1,9&#125;=imread(&#x27;008.bmp&#x27;);</span><br><span class="line">cell&#123;1,10&#125;=imread(&#x27;009.bmp&#x27;);</span><br><span class="line">cell&#123;1,11&#125;=imread(&#x27;010.bmp&#x27;);</span><br><span class="line">cell&#123;1,12&#125;=imread(&#x27;011.bmp&#x27;);</span><br><span class="line">cell&#123;1,13&#125;=imread(&#x27;012.bmp&#x27;);</span><br><span class="line">cell&#123;1,14&#125;=imread(&#x27;013.bmp&#x27;);</span><br><span class="line">cell&#123;1,15&#125;=imread(&#x27;014.bmp&#x27;);</span><br><span class="line">cell&#123;1,16&#125;=imread(&#x27;015.bmp&#x27;);</span><br><span class="line">cell&#123;1,17&#125;=imread(&#x27;016.bmp&#x27;);</span><br><span class="line">cell&#123;1,18&#125;=imread(&#x27;017.bmp&#x27;);</span><br><span class="line">cell&#123;1,19&#125;=imread(&#x27;018.bmp&#x27;);</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">level=graythresh(cell&#123;1,i&#125;);%选择灰度阈值</span><br><span class="line">cell1&#123;1,i&#125;=im2bw(cell&#123;1,i&#125;,level); %将图像二值化</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19                %循环19个图像</span><br><span class="line">    for k=1:19</span><br><span class="line">        xs(i,k)=0;</span><br><span class="line">        for j=1:1980</span><br><span class="line">            if (cell1&#123;1,i&#125;(j,72)==cell1&#123;1,k&#125;(j,1))%判断图像的边缘信息特征，求相似度矩阵</span><br><span class="line">                xs(i,k)=1+xs(i,k);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">    xs(i,i)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19 </span><br><span class="line">da(i)=max(xs(i,:));</span><br><span class="line">end</span><br><span class="line">wei=find(da==max(da));for i=1:19</span><br><span class="line">    k=find(xs(i,[1:19])==da(i));  %求两两相邻的矩阵</span><br><span class="line">    lian(i,1)=i;                  %前面一个</span><br><span class="line">    lian(i,2)=k;                  %后面一个</span><br><span class="line">end</span><br><span class="line">lian(wei,1)=0;</span><br><span class="line">tou=lian(wei,2);</span><br><span class="line">xu(1)=tou;</span><br><span class="line">for i=1:18</span><br><span class="line">    xu(i+1)=lian(xu(i),2);        %正确的排列顺序</span><br><span class="line">end</span><br><span class="line">%根据排出来顺序xu画图</span><br><span class="line">for i=1:19</span><br><span class="line">I(:,[72*(i-1)+1:72*i])=cell&#123;1,xu(i)&#125;;   %图像的整合</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">imwrite(I,&#x27;hanzi.jpg&#x27;,&#x27;quality&#x27;,100);</span><br><span class="line">imshow(&#x27;hanzi.jpg&#x27;)          %输出图像</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="选址问题">选址问题</h5>
<p>集合覆盖选址模型和最大覆盖选址模型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队算法</title>
    <url>/2023/08/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>莫队</strong>，是莫涛发明的一种解决区间查询等问题的
<strong>离线算法</strong>，基于 <strong>分块</strong> 思想，复杂度为
<span class="math inline">\(O(n\sqrt{n})\)</span></p>
<p>一般来说，如果可以在 <span class="math inline">\(O(1)\)</span> 内从
<span class="math inline">\([l, r]\)</span> 的答案转移到 <span class="math inline">\([l - 1, r]、[l + 1, r]、[l, r - 1]、[l, r +
1]\)</span> 这四个与之紧邻的区间的答案，则可以考虑使用莫队。</p>
<h4 id="例题">例题</h4>
<p><a href="https://www.luogu.com.cn/problem/SP3267">DQUERY - D-query -
洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>HH 的项链弱化版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, vis[M], bel[N], a[N], st[N], ed[N], cnt[M], ans[N];</span><br><span class="line"><span class="type">int</span> l, r, cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; q[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        st[i] = n / len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[len] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? bel[x.r] &lt; bel[y.r] : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --cnt[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>();</span><br><span class="line">        q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].num = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) </span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) </span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        ans[q[i].num] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队算法的扩展-带修莫队">莫队算法的扩展 —— 带修莫队</h3>
<p>前面说过，莫队算法是离线算法，不支持修改，强制在线需要另寻他法。但是对于某些允许离线的带修改区间查询来说，莫队还是能大展拳脚的。做法就是把莫队直接加上一维，变为带修莫队。</p>
<p>我们的做法是把修改操作编号，称为「时间戳」。</p>
<p>跑主算法时定义当前时间戳为
t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</p>
<p><strong>跑主算法时定义当前时间戳为
t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</strong></p>
<h4 id="例题-1">例题</h4>
<p>[P1903 <a href="https://www.luogu.com.cn/problem/P1903">国家集训队]
数颜色 / 维护队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">133335</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, bel[N], st[N], ed[N], a[N], len;</span><br><span class="line"><span class="type">int</span> cnt_1, cnt_2, vis[M], ans[N], cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_1</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q1[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">&#125; q2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    len = sqrt(n);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i) &#123;</span></span><br><span class="line"><span class="comment">        st[i] = n / len * (i - 1) + 1;</span></span><br><span class="line"><span class="comment">        ed[i] = n / len * i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ed[len] = n;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i)</span></span><br><span class="line"><span class="comment">        for (int j = st[i]; j &lt;= ed[i]; ++j)</span></span><br><span class="line"><span class="comment">            bel[j] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">ceil</span>((<span class="type">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        st[i] = len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question_1 x, Question_1 y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? (bel[x.r] == bel[y.r] ? x.time &lt; y.time : bel[x.r] &lt; bel[y.r]) : bel[x.l] &lt; bel[y.l]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++vis[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --vis[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q1[++cnt_1].l = x;</span><br><span class="line">            q1[cnt_1].r = y;</span><br><span class="line">            q1[cnt_1].time = cnt_2;</span><br><span class="line">            q1[cnt_1].id = cnt_1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q2[++cnt_2].col = y;</span><br><span class="line">            q2[cnt_2].pos = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;no error&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q1 + <span class="number">1</span>, q1 + <span class="number">1</span> + cnt_1, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q1[i].l)</span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q1[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q1[i].l)</span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q1[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q1[i].time) &#123;</span><br><span class="line">            ++t;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q1[i].time) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">            --t;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q1[i].id] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一道题目块的大小取得 $n^{} $ 时时间复杂度最小。如果还是 <span class="math inline">\(\sqrt{n}\)</span> 的话，会超时。</p>
<h3 id="莫队算法的扩展-树上莫队">莫队算法的扩展 —— 树上莫队</h3>
<p>前面我们所使用的莫队都是在一维的序列上进行，即使加了一维的时间轴，但是主题还是一维序列。那么树上统计问题能否用莫队来处理呢？答案是肯定的。</p>
<p>但是普通的 dfs 序没有办法确定一个对应区间</p>
<p>使用 <strong>欧拉序</strong>，可以解决许多普通 dfs
序无法解决的问题（就比如树上莫队）。</p>
<figure>
<img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230723182411099.png" alt="image-20230723182411099">
<figcaption aria-hidden="true">image-20230723182411099</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, cur, cnt, tot, date[N], a[N], dep[N], top[N], fa[N], bel[N &lt;&lt; <span class="number">1</span>], siz[N], son[N], head[N], st[N &lt;&lt; <span class="number">1</span>], ed[N &lt;&lt; <span class="number">1</span>], id[N], fir[N], las[N], use[N &lt;&lt; <span class="number">1</span>], ans[M], cot[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> lca;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">&#125; q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++cnt].nxt = head[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    fir[x] = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to, x);</span><br><span class="line">        siz[x] += siz[to];</span><br><span class="line">        <span class="keyword">if</span> (siz[to] &gt; Max) &#123;</span><br><span class="line">            Max = siz[to];</span><br><span class="line">            son[x] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    las[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[x] = tp;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == fa[x] || to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (++cot[pos] == 1) cur++;</span></span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cot[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (--cot[pos] == 0) cur--;</span></span><br><span class="line">    --cot[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;this is a test&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//use[pos] ? del(a[pos]) : add(a[pos]);</span></span><br><span class="line">    <span class="comment">//use[pos] ^= 1;</span></span><br><span class="line">    use[pos] ? <span class="built_in">del</span>(pos) : <span class="built_in">add</span>(pos);</span><br><span class="line">    use[pos] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = date[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> num = std::<span class="built_in">unique</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n) - date - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n, a[i]) - date;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i)</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int x, y;</span></span><br><span class="line">    <span class="type">int</span> ancestor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (fir[x] &gt; fir[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        ancestor = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        <span class="keyword">if</span> (ancestor == x) &#123;</span><br><span class="line">            q[i].l = fir[x]; <span class="comment">// 欧拉序中的位置</span></span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = las[x];</span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">            q[i].lca = ancestor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp2);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">        q[i].ans = cur;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;htih&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans[q[i].id] = q[i].ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队算法的扩展回滚莫队">莫队算法的扩展——回滚莫队</h3>
<figure>
<img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230724130521246.png" alt="image-20230724130521246">
<figcaption aria-hidden="true">image-20230724130521246</figcaption>
</figure>
<p>感觉细节有一些多，比较麻烦的</p>
<h4 id="例题-2">例题</h4>
<p><a href="https://www.luogu.com.cn/problem/AT_joisc2014_c">AT_joisc2014_c
歴史の研究</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll n, m, Max, tot, a[N], b[N], st[N], ed[N], bel[N], ans[N], cnt[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">    Max = std::<span class="built_in">max</span>(Max, cnt[a[pos]] * b[a[pos]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// split block </span></span><br><span class="line">    ll block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        st[i] = n / block * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / block * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[block] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort question </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(), q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mo</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> l;</span><br><span class="line">        <span class="type">int</span> r = ed[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span> (cnt));</span><br><span class="line">        Max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (bel[q[p].l] == i) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;sdasda&quot;;</span></span><br><span class="line">            <span class="comment">//Max = -1;</span></span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            l = ed[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bel[q[p].l] == bel[q[p].r]) &#123;</span><br><span class="line">                ll cur = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = q[p].l; j &lt;= q[p].r; ++j) &#123;</span><br><span class="line">                    ++cnt[a[j]];</span><br><span class="line">                    c[++tot] = a[j];</span><br><span class="line">                    Max = std::<span class="built_in">max</span>(Max, cnt[a[j]] * b[a[j]]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[q[p].id] = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">                    --cnt[c[j]];</span><br><span class="line">                ++p;</span><br><span class="line">                Max = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[p].r)</span><br><span class="line">                <span class="built_in">add</span>(++r);</span><br><span class="line">            ll cur = Max;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;cur: &quot; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[p].l)</span><br><span class="line">                <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[p].id] = Max;</span><br><span class="line">            Max = cur;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= ed[i]) </span><br><span class="line">                --cnt[a[l++]];</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure>
<img src="/.com//Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230725000620621.png" alt="image-20230725000620621">
<figcaption aria-hidden="true">image-20230725000620621</figcaption>
</figure>
<h3 id="参考">参考</h3>
<p><a href="https://www.cnblogs.com/WAMonster/p/10118934.html">莫队算法——从入门到黑题
- WAMonster - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/115243708">算法学习笔记(24):
莫队 - 知乎 (zhihu.com)</a></p>
<p>OIwiki</p>
]]></content>
  </entry>
  <entry>
    <title>随机数</title>
    <url>/2023/10/07/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h5 id="线性同余法">线性同余法</h5>
<p>线性同余法是目前应用广泛的<strong>伪随机数生成算法</strong>。基本思想是对于一个数进行线性运算并取模从而得到下一个数，递归公式为：<span class="math inline">\(x_{n+1}=(ax_n+c) \pmod{m}, y_{n + 1} =
x_{n+1}/m\)</span></p>
<p>线性同余法的最大周期是 m，但是一般情况下会小于
m，如果要使得周期达到最大，应该满足： 1. c 和 m 互质 2. m
所有质因子的积能整除 a-1 3. a c 初值都比 m 小 4. a c 是正整数</p>
<h5 id="梅森旋转法">梅森旋转法</h5>
<p>梅森旋转法也是一种伪随机数产生算法。</p>
<h5 id="密码学安全随机数生成器">密码学安全随机数生成器</h5>
<h5 id="硬件随机数生成器">硬件随机数生成器</h5>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="第一章">第一章</h4>
<p>计算机可以分成两个部分：硬件和软件。
软件的话，又分为<strong>系统软件</strong>和<strong>应用软件</strong>两种。</p>
<p>下层是硬件，硬件进行了相对的封装，它对软件提供了接口，比如说提供了指令集，软件可以利用这些指令集，编写完成一定功能的软件。</p>
<p>最早出现的语言是 <strong>机器语言</strong>(是由 01
代码构成的)，为了简化记忆，人们提出了汇编代码，符号化。汇编语言和机器语言之间一般是一一对应的，也就是一条汇编语言指令对应一条机器语言指令。</p>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95.png" class>
<h5 id="冯诺伊曼计算机">冯诺伊曼计算机</h5>
<p>冯诺依曼也被称为现代计算机之父。</p>
<h6 id="edvac">EDVAC</h6>
<p>EDVAC(Electronic Discrete Variable Automatic
Computer)是计算机科学史上一台著名的计算机，是早期计算机发展中的一个里程碑。下面是它的一些特点：
1.
存储程序。是世界上第一台真正的<strong>存储程序计算机</strong>。这意味着它可以存储和执行在存储器中的程序，而不仅仅是执行预先固定在硬件中的计算任务。<strong>这一概念成为现代计算机架构的基础</strong>
2. 二进制表示。EDVAC 使用了二进制表示法来处理数据和指令。 3.
使用了冯诺伊曼体系结构 4.
高度可编程。EDVAC的可编程性使得它可以执行各种计算任务，而不仅仅是用于特定目的的计算。</p>
<p>而ENIAC是一台<strong>固定程序计算机</strong>，它的计算任务是<strong>通过物理重新连接电路来更改的</strong>，而不是通过存储在内存中的程序。这使得ENIAC的重新配置非常耗时和繁琐，限制了它的通用性。</p>
<h6 id="冯诺依曼结构特点"><strong>冯诺依曼结构特点：</strong></h6>
<ol type="1">
<li>计算机由五大部件组成。</li>
<li>指令和数据以同等地位存储在存储器，可按地址访问。</li>
<li>指令和数据都是二进制表示。</li>
<li>指令由操作码和地址码组成，操作码就是表明这条指令干什么，地址码指明了<strong>操作数在哪里</strong>。</li>
<li><strong>存储程序。程序存储在存储器中(核心特征)。</strong></li>
<li>以运算器为中心。</li>
</ol>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6.png" class>
<h6 id="冯诺依曼结构的问题"><strong>冯诺依曼结构的问题：</strong></h6>
<ol type="1">
<li>TODO</li>
</ol>
<p>ALU 和 CU 合成了 CPU 存储器又被分为了 主存和辅存 CPU
和存储器构成了我们的主机(也就是运算器、存储器、控制器构成了我们的主机)</p>
<h5 id="存储器的基本组成">存储器的基本组成</h5>
<p>存储单元：存放一串二进制代码。存储单元构成存储体。
存储字：在存储单元中存放的二进制代码组合。
存储字长：存储单元中二进制代码的位数。</p>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E6%88%90.png" class>
<p>MAR
存储器地址寄存器，反应存储器的个数。这个寄存器的长度和存储单元的个数相关。
MDR
保存了要保存到存储体中的数据或者是刚刚从存储器中取出来的数据。所以，这个寄存器的长度是存储单元的长度。</p>
<h5 id="运算器基本组成及操作">运算器基本组成及操作</h5>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%90%E7%AE%97%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E5%8F%8A%E6%93%8D%E4%BD%9C.png" class>
<p>加法的操作过程 初态 ACC 中保存了被减数和被加数
下一个操作就是把内存单元中的内容 M 放入寄存器 X</p>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C.png" class>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C.png" class>
<h5 id="控制器基本结构">控制器基本结构</h5>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84.png" class>
<p>IR 中也就是指令的操作码，其中核心是 CU，来执行指令。</p>
<h5 id="主机">主机</h5>
<p>运算器、存储器、控制器构成了主机。
将上面我们各自讲解的结构组合在一起，就得到了
<strong>主机的架构</strong>。 <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%BB%E6%9C%BA%E6%9E%B6%E6%9E%84.png" class></p>
<p>对于取数操作： 1. 先获得取数指令。PC 中存储的是指令地址，传到
MAR，在内存单元中获得指令，然后将指令传到 MDR，再传给 IR(IR
中存储的是指令信息)。 2. IR 中拿到了指令，再交给 CU
对于指令进行分析。对于操作码分析是取数，将地址码传递到
MAR，在内存单元中寻找获得数值，然后传递给 MDR，再传递给
ACC(累加器)，完成取数操作。</p>
<h4 id="第二章">第二章</h4>
<p>这一章不是很重要。</p>
<h4 id="第三章">第三章</h4>
<h5 id="总线的基本概念">总线的基本概念</h5>
<p>为了解决分散连接的<strong>不易扩展性</strong>，我们采取了<strong>总线</strong>(bus)来连接各个部件的信息传出线，是各个部件共享的传输介质。总线的英文就是
BUS 其实很生动形象了。</p>
<p>传输方式有<strong>串行和并行</strong>两种。但是并行传输的话，线和线之间会有干扰，所以如果传输距离比较长的话信息会不准确。所以，对于并行传输一般仅用于距离较短的传输。</p>
<h5 id="总线的结构">总线的结构</h5>
<p>总线的结构有单总线、面向 CPU 的双总线和面向存储器的双总线</p>
<p>总线是信号的公共传输线。在任意时刻只能有一个部件来使用总线，对于单总线，会成为我们系统的一个瓶颈。
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class></p>
<p>为了改进这种问题，我们提出了 <strong>面向 CPU 的双总线结构</strong>。
容易看出，这种总线主存和I/O设备交互的时候，CPU执行任务还是会打断，所以我们提出了
<strong>面向存储器的总线结构</strong>。 <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class></p>
<p>面向存储器的总线结构： <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class></p>
<h5 id="总线的分类">总线的分类</h5>
<p>按照不同分类标准总线可以分为好多中。
如果按照在计算机内部的位置来分类有两大种： 1. 片内总线。芯片内部的总线
2. 系统总线。计算机各部件之间的信息传输线
系统总线又可以分为：数据总线、地址总线、控制总线</p>
<h5 id="总线特性及指标">总线特性及指标</h5>
<p>总线要想进行有效的连接，必须满足一些特性。 <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7.png" class></p>
<h5 id="总线的性能指标">总线的性能指标</h5>
<ol type="1">
<li>总线宽度</li>
<li>标准传输律：每秒传输的最大字节</li>
<li>时钟同步</li>
<li>总线复用
地址线和数据线共用。为什么复用？主要是为了减少芯片的管脚数，芯片的管脚数越少，芯片的封装性越好。</li>
<li>信号线数 地址线、数据线和控制线的总和。</li>
</ol>
<h5 id="总线的控制">总线的控制</h5>
<h4 id="第四章">第四章</h4>
<h5 id="存储器的分类">存储器的分类</h5>
<p>标准很多，所以分类也很多。 1. 按照介质分类 半导体存储器 TTL MOS 易失
磁表面存储器 磁头、载磁体 磁芯存储器 光盘存储器 2. 按照存取方式分类
存取时间和物理地址无关(随机访问) 存取时间和物理地址有关(串行访问)
如磁带、磁带 3. 按照在计算机种的作用分类</p>
<p>高速缓冲存储器 (Cache) 是在 CPU 与 主存之间的一块存储器。</p>
<h5 id="存储器的层次结构">存储器的层次结构</h5>
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1.png" class>
<p>主存和辅存之间通过软硬件相结合的方式连接在一起。他俩连接在一起如何定位存储地址呢？我们使用的是虚拟地址，就是我们以我们比较好理解的形式来写地址，比如
<code>0x7fff</code>
但是在执行的时候是有特定的机构去<strong>将虚拟地址转换为内存单元种的地址。</strong></p>
<h5 id="主存储器">主存储器</h5>
<h6 id="主存储器的地址分配">主存储器的地址分配</h6>
<p>高位字节地址为字地址称为「大端、大尾方式」
低位字节地址为字地址称为「小端、小尾方式」
这两种方式都有机器使用，但是这样的话两种机器进行通讯就会出现问题。</p>
<h6 id="主存的技术指标">主存的技术指标</h6>
<p>主要是速度和容量两个方面。</p>
<h5 id="半导体存储芯片">半导体存储芯片</h5>
<p>CS Chip Select 选择芯片 CE Chip Enable 芯片使能，和 CS 功能一样 WE
Write Enable 允许写入 OE Output Enable 允许输出 WR Write
允许写入的另一个形式?<br>
上面的一般都是低电位有效。</p>
<p>Column Address Select CAS 列选 Row Address Select RAS 行选 latency
time 延迟时间</p>
<p>双稳态触发器 珊极</p>
<h6 id="随机存取存储器">随机存取存储器</h6>
<p>有静态的和动态的。</p>
<p>动态 RAM 是利用电容存储电荷的方式来存储信息的。 如果不对于动态 RAM
进行刷新，电容就会漏电，原来内部保存的 1 就会变成 0。动态 RAM
的刷新与行地址有关。</p>
<p>动态 RAM 和静态 RAM 比价： <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8A%A8%E6%80%81RAM%E5%92%8C%E9%9D%99%E6%80%81RAM%E6%AF%94%E8%BE%83.png" class></p>
<p>DRAM 一般用来做主存，SRAM 一般用来做缓存</p>
<p>最初的 ROM
芯片是固定的，数据在制造时被写入并且无法更改。即使后来出现了
EPROM(Erasable Programmable Read-Only Memory) EEPROM(Electrically
Erasable Programmable Read-Only Memory)
和闪存，这种可擦除可编程的，也仍然用 ROM 来称呼他们。EPROM
使用紫外线来擦除，后者 EEPROM 使用电子来擦除。</p>
<h5 id="存储器和-cpu-的连接">存储器和 CPU 的连接</h5>
<p>存储器的两种扩展：位扩展(增加存储字长)和字扩展(增加存储字的数量)
<img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BD%8D%E6%89%A9%E5%B1%95.png" class> 其中字扩展是使用地址线最高位 是 1 或者是 0
来作为片选器(CS) <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97%E6%89%A9%E5%B1%95.png" class></p>
<p>还有字和位同时扩展： <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97%E5%92%8C%E4%BD%8D%E6%89%A9%E5%B1%95.png" class></p>
<p>MREQ 通常是计算机领域用来表示内存请求信号的缩写，其全称是 "Memory
Request"。这个信号通常用于微处理器（CPU）与计算机系统中的内存之间的通信，以请求对内存进行读取或写入操作。
当 CPU 需要访问内存中的数据或指令时，它会生成 MREQ
信号，该信号将传递给内存控制器或内存子系统。内存控制器将根据 MREQ
信号执行相应的操作，例如读取请求时，将数据从内存中读取并提供给
CPU，或者写入请求时，将数据写入内存。<strong>一般是低电平是存储器，高电平时访问IO</strong></p>
<h4 id="扩展">扩展</h4>
<p>计算机的多样性： <img src="/.com//09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7.png" class></p>
<p>HPC 是 <code>High-Performance-Computer</code>
的简称，一般指一些超级计算机。</p>
<p>MPI 消息传递接口 <code>Messag Passing Interface</code>
服务程序通常是指在高性能计算 (HPC)
环境中使用的一种通信库或协议，用于在分布式计算集群中的不同节点之间进行通信和数据交换(毕竟程序之间的并行运算必须有数据信息的交互)。</p>
<p>控制器负责译码。</p>
]]></content>
      <tags>
        <tag>ComputerScience</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表(skiplist)</title>
    <url>/2023/10/30/%E8%B7%B3%E8%A1%A8-skiplist/</url>
    <content><![CDATA[<h4 id="代码">代码：</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class SkipListNode &#123;</span><br><span class="line">    public:</span><br><span class="line">        int value;</span><br><span class="line">        std::vector&lt;SkipListNode*&gt; nxt;</span><br><span class="line">        SkipListNode(int val, int level)</span><br><span class="line">            : value(val)</span><br><span class="line">            , nxt(level, nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Skiplist &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxLevel = 32;</span><br><span class="line">    int level;</span><br><span class="line">    SkipListNode* head;</span><br><span class="line">    Skiplist() &#123;</span><br><span class="line">        level = 1;</span><br><span class="line">        head = new SkipListNode(0, maxLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    int randomLevel() &#123;</span><br><span class="line">        int level = 1;</span><br><span class="line">        while (level &lt; maxLevel &amp;&amp; (rand() % 2 == 0)) &#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return level;</span><br><span class="line">    &#125;</span><br><span class="line">    bool search(int target) &#123;</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        for (int i = level - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; target) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (current &amp;&amp; current-&gt;nxt[0] &amp;&amp; current-&gt;nxt[0]-&gt;value == target) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void add(int num) &#123;</span><br><span class="line">        std::vector&lt;SkipListNode*&gt; update(maxLevel, nullptr);</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        for (int i = level - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; num) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        int newLevel = randomLevel();</span><br><span class="line">        if (newLevel &gt; level) &#123;</span><br><span class="line">            for (int i = level; i &lt; newLevel; ++i) &#123;</span><br><span class="line">                update[i] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            level = newLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListNode* newNode = new SkipListNode(num, newLevel);</span><br><span class="line">        for (int i = 0; i &lt; newLevel; ++i) &#123;</span><br><span class="line">            newNode-&gt;nxt[i] = update[i]-&gt;nxt[i];</span><br><span class="line">            update[i]-&gt;nxt[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool erase(int num) &#123;</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        std::vector&lt;SkipListNode*&gt; update(maxLevel, nullptr);</span><br><span class="line">        for (int i = level - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            while (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; num) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!current || !current-&gt;nxt[0] || current-&gt;nxt[0]-&gt;value != num) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (current-&gt;nxt[0] &amp;&amp; current-&gt;nxt[0]-&gt;value == num) &#123;</span><br><span class="line">            SkipListNode* toRemove = current-&gt;nxt[0];</span><br><span class="line">            for (int i = 0; i &lt; level; ++i) &#123;</span><br><span class="line">                if (update[i]-&gt;nxt[i] != toRemove) &#123; // 不能直接判断 value 因为可能出现多个相同数值的情况</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                update[i]-&gt;nxt[i] = toRemove-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            delete toRemove;</span><br><span class="line">        &#125;   </span><br><span class="line">        // 更新 level</span><br><span class="line">        while (level &gt; 1 &amp;&amp; head-&gt;nxt[level - 1] == nullptr)</span><br><span class="line">            level--;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="参考">参考：</h4>
<p>https://github.com/youngyangyang04/Skiplist-CPP/blob/master/skiplist.h
https://www.luogu.com.cn/problem/solution/P3369?page=2 leetcode 跳表题解
https://yuerblog.cc/2019/02/13/skiplist-rank/ 实现 rank</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
</search>
