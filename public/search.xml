<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A Missing Semester of Your CS Education</title>
    <url>/2023/09/20/A-Missing-Semester-of-Your-CS-Education/</url>
    <content><![CDATA[<p>见 “E:\Notes\A Missing Semester of Your CS Education\关键记录.md”</p>
]]></content>
  </entry>
  <entry>
    <title>CSS记录</title>
    <url>/2023/09/01/CSS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h4><p><code>style</code> 是 CSS 的属性名<br>在 CSS 中名-值对中间用 <code>:</code><br><code>font-size: xx px;</code> 可以设置字体大小<br>一般不推荐使用行内样式，不能复用并且不利于维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 style=&quot;color: red; font-size: 50px;&quot;&gt;Hello World&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<h4 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h4><p>在 <code>&lt;head&gt;</code> 标签或者 <code>&lt;body&gt;</code> 标签中加一个 <code>&lt;style&gt;</code> 标签(不过一般都是写在 <code>head</code> 里面)。</p>
<h4 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h4><p>可以新建一个 <code>xxx.css</code> 文件，然后在 HTML 文件的 <code>&lt;head&gt;</code> 标签中加一个 <code>&lt;link&gt;</code> 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>rel</code> 是 <code>relation</code> 的缩写，就是说 <code>href</code> 的文件和当前 HTML 文件的关系。</p>
<h4 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h4><p>行内样式的优先级 &gt; 内部样式<br>对于内部样式和外部样式，它俩平级，但是后来者居上，也就是说，谁写在后面，就是展现谁的样式。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ol>
<li><p>通配选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器：在标签中添加属性 <code>class=&quot;xxx&quot;</code>，注意在 <code>style</code> 中的格式，需要在 <code>xxx</code> 前面加一个 <code>.</code>，来区分类名和标签名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要是一个标签属于两个 <code>class</code> 的话，写成 <code>class=&quot;xxx yyy&quot;</code> 的格式，而不是分开写两个 <code>class</code>，那样的话后一个 <code>class</code> 会被忽略。</p>
</li>
<li><p>ID 选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集选择器：<br>就是将两个选择器紧紧的写在一起。如果交集选择器中有元素，元素必须在开头(因为字母放在最后会引起单词的歧义)，并且我们交集的条件可以是多个。<br><code>id</code> 选择器理论上可以作为交集选择器，但是我们的 <code>id</code> 是唯一的，已经可以唯一定义了，所以一般就是 <code>class</code> 和标签一起写。<br>同时也不存在两个元素同时在标签选择器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并集选择器<br>就是在不同选择器之间加上逗号 <code>,</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,.beauty,.dog,.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这样写的话，逗号和点写在一起看起来有些乱，我们一般竖着写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,</span><br><span class="line">.beauty,</span><br><span class="line">.dog,</span><br><span class="line">.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代选择器<br>比如说 <code>ul</code> 中的所有 <code>li</code>，中间直接空格就可以。但是除了选择了儿子以外，孙子 <code>li</code> 也被选择了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子代选择器<br><code>div</code> 标签中的子代 <code>a</code> 标签(排除了孙子等标签，只有儿子)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&gt;a &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟选择器<br>用 <code>+</code> 连接，只有紧紧相邻的兄弟，如果 <code>div</code> 紧紧相邻的没有 <code>p</code>，但是有 <code>p</code> 中间隔了别的标签，也不不起作用的。(睡在我下铺的兄弟) 相邻兄弟选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div+p &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 <code>div~p &#123;&#125;</code> 就是 <code>div</code> 的所有兄弟 <code>p</code>，而不是紧紧相邻的了。</p>
</li>
<li><p>属性选择器<br><code>[title] &#123;&#125;</code> 选择具有 <code>title</code> 属性的标签<br><code>[title=&quot;xxx&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是 <code>xxx</code> 的标签。<br><code>[title^=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是以 <code>a</code> 开头的标签。<br><code>[title$=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是以 <code>a</code> 结尾的标签。<br><code>[title*=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容中含有 <code>a</code> 的标签</p>
</li>
</ol>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>可以理解为是对于元素的状态的一种描述。比如，已经访问过的超链接和未访问过的超链接，就是加一个冒号，后面就是元素的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a:visited &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ol>
<li>层叠性<br>如果样式发生了冲突，就会根据一定的规则(选择器优先级)，进行样式层叠(覆盖)。(当权重一样的时候，我们才考虑在代码中的顺序)</li>
<li>继承性<br>元素会自动拥有其父元素、或者祖先元素上设置的<strong>某些样式</strong>，优先继承离得最近的。<br>常见的可继承属性：<code>test-?? font-?? line-?? color</code></li>
<li>优先级<br><code>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样式</code></li>
</ol>
<h4 id="像素-Pixel"><a href="#像素-Pixel" class="headerlink" title="像素 Pixel"></a>像素 Pixel</h4><p>虽然 <code>cm</code> 和 <code>mm</code> 这两个单位也可以用在网页中，但是对于网页来说，这两个单位不够精细。所以我们就是用 <code>px</code> 这个单位(是 Pixel 的缩写)，因为它很小，所以很精细。</p>
<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%83%8F%E7%B4%A0.png" class="">
<p>可以看出来，虽然电脑屏幕一般大小，但是右边的像素多，所以每一个像素的大小就小。所以像素我们不确定多么大，需要看屏幕，它是一个相对单位。<br>像素点越小，呈现出来的图片就越细腻，越清晰</p>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ol>
<li>颜色名<br>但是它太有限了，并且不是很精确，所以开发的时候一般不用。</li>
<li>RGB 或者 RGBA<br>RGB 中三个字母分别是 RED GREEN BLUE(范围都是从 0 到 255)<br><code>rgb(xx, xx, xx);</code><br><code>rgba(xx, xx, xx, xx);</code> 前三位和 <code>rgb</code> 相同，最后一位是透明度，范围是 0 - 1。</li>
<li>HEX 或者 HEXA<br><code>#xxxxxx</code> 井号后面一共六位，每一位都是十六进制的数字，每两位组合起来分别表示红、绿、蓝<br>然后 HEXA 就像 RGBA，就是添加了一个透明度，它也是用两位十六进制来表示，也就是说一共八位。</li>
<li>HSL 或者 HSLA<br>这两个东西用的不是很多。<br><code>hsl(hue, saturation, lightness);</code> 色相、饱和度、亮度<br><code>Hue</code> 在这里是用角度表示的，写为 <code>xxdeg</code><br>HELA 就是 <code>hsl(hue, saturation, lightness, xx);</code> 最后一位 0 - 1 表示透明度。<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E8%89%B2%E7%9B%B8%E7%8E%AF.png" class=""></li>
</ol>
<h4 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h4><p><code>font-family: &quot;xxx&quot;;</code> 字体族，其实就是字体样式。通常情况下，把字体分为两大类。第一类是衬线字体，第二类是非衬线字体。衬线字体的横竖撇捺特别有棱角，目前写网页还是非衬线字体比较多。</p>
<p><code>font-style: xxx;</code> 字体风格。默认为 <code>normal</code>，斜体是 <code>italic</code></p>
<p><code>font-weight:xxx;</code> 字体粗细，参数为 <code>lighter normal bold bolder</code>，或者写 100 - 1000 的数字，数字越大越粗。</p>
<h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><code>letter-spacing:xxx px;</code> 字母间距(汉字被认为是字母)<br><code>word-spacing:xxx px;</code> 词间距<br><code>text-decoration:xxx;</code> 文本修饰 <code>overline underline line-through</code> 还可以改为波浪线等形式，并且也可以改颜色。<br><code>text-indent:xx;</code> 文本缩进<br><code>text-align:xxx;</code> <code>xxx</code> 可以是 <code>left center right</code> 就是靠哪里对齐。<br><code>line-height:xxx;</code> 调整行高，就是上下之间的距离变大，但是字体的大小不变。其中 <code>xxx</code> 可以为像素、也可以写一个数字，表示是 <code>font-size</code> 的多少倍，也可以写成百分比，表示是 <code>font-size</code> 的多少倍。<br><code>vertical-align:xxx;</code> <code>xxx</code> 可以是 <code>top baseline bottom middle</code> </p>
<h4 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h4><p><code>list-style-type:xxx;</code> <code>xxx</code> 可以是 <code>none square lower-roman upper-roman decimal</code><br><code>list-style-position:xxx;</code> 可以是 <code>inside outside</code><br><code>list-style-image:xxx;</code> 找一个图片，自定义前面的点。</p>
<h4 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h4><p><code>border-width:xxx px;</code> 宽度<br><code>border-color:xxx;</code> 颜色<br><code>border-style:xxx;</code> 样式<br>边框的相关属性，不仅仅是表格可以使用，其他元素如 <code>h1 p</code> 也可以使用。<br><code>table-layout:fixed;</code> 可以控制表格的列宽。<br><code>border-spacing:xxx px;</code> 控制单元格之间的距离。<br><code>borer-collapse: collapse;</code> 合并相邻单元格的标签。写了合并以后，上面的 <code>border-spacing:xxx;</code> 无论 <code>xx</code> 是多少都失效了。<br><code>empty-cells: show / hide;</code> 隐藏没有内容的单元格。<br><code>caption-side:xxx;</code> 设置表格标题的位置，可以是 <code>top bottom</code></p>
<h4 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h4><p><code>background-color:xxx;</code><br><code>background-repeat:repeat / no-repeat / repeat-y / repeat-x;</code> 如果图片较小，是否重复显示<br><code>background-image:xxx;</code><br><code>background-position:xxx;</code> 可以控制背景图片的位置。<code>xxx</code> 可以是 <code>left top / left bottom / left center / xx px xx px</code></p>
<h4 id="鼠标属性"><a href="#鼠标属性" class="headerlink" title="鼠标属性"></a>鼠标属性</h4><p><code>cursor:xxx;</code> 参数可以为 <code>pointer / move / wait / crosshair / help </code><br><code>cursor: url(&quot;xxx&quot;),pointer;</code> 其中 <code>xx</code> 是一个图片的地址，此时鼠标的样式就变为了图片的样子。</p>
<h4 id="CSS-常用的长度单位"><a href="#CSS-常用的长度单位" class="headerlink" title="CSS 常用的长度单位"></a>CSS 常用的长度单位</h4><ol>
<li><code>px</code></li>
<li><code>em</code> 相当于当前元素的 <code>font-size</code> 的倍数。如果自己没有就沿着父元素一直网上找，如果都没有，就是用默认的。</li>
<li><code>rem</code> r 是 root 的意思。相对于根元素的 <code>font-size</code> 的倍数，如果没有，就使用默认的。</li>
<li><code>%</code> 相对于父元素计算。</li>
</ol>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ol>
<li>块元素 block<br>在页面中独占一行，不会与任何元素共占一行，是从上到下排列的。<br>默认宽度就是撑满父级元素，高度由内容决定。</li>
<li>行内元素 inline<br>在页面中不是独占一行，一行中不能容下的行内元素，会在下一行继续从左到右排列。<br>默认宽度和高度都是由内容决定。<br>但是 <strong>无法通过 CSS 设置宽和高。</strong><br>最具有代表性的其实就是 <code>&lt;span&gt;</code></li>
<li>行内块元素 inline-block<br>又叫做内联块元素。在页面中不独占一行，会在下一行继续从左到右排列。<br>默认宽度和高度都是由内容决定。<br><strong>可以通过 CSS 设置宽和高。</strong><br>最具代表性的其实是 <code>&lt;img&gt;</code><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%90%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.png" class=""></li>
</ol>
<h5 id="修改元素的显示模式"><a href="#修改元素的显示模式" class="headerlink" title="修改元素的显示模式"></a>修改元素的显示模式</h5><p>上面是各种元素的默认显示形式，不过我们可以在 CSS 中修改 <code>display</code> 属性来调整它的显示形式。<br><code>display: block / inline-block / inline;</code> 如果是 <code>display: none;</code> 那么这个元素就直接不显示了，并且也不会占用网页的空间。</p>
<h5 id="盒子模型的组成部分"><a href="#盒子模型的组成部分" class="headerlink" title="盒子模型的组成部分"></a>盒子模型的组成部分</h5><p>我们设置的背景颜色会填充内边距区域，也会填充边框区域。<br>外边距不会影响盒子大小，只会影响其位置。</p>
<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%88%86%E5%8C%BA.png" class="">

<p><code>width-min width-max height-min height-max padding-left padding-top padding-bottom padding-right</code></p>
<p><code>border</code> 的属性同样也可以是 <code>border-left-width border-left-style ... </code></p>
<p><code>margin</code> 的属性可以同 <code>padding</code> 一样修改。</p>
<h4 id="处理溢出"><a href="#处理溢出" class="headerlink" title="处理溢出"></a>处理溢出</h4><p><code>overflow: hidden;</code> 直接隐藏，还可以写 <code>scroll auto</code> 默认是 <code>visible</code>，也可以 x y 方向分开处理，就是写成 <code>overflow-x</code> 和 <code>overflow-y</code></p>
<h4 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h4><ol>
<li>就是 <code>display: none;</code> 通过这种方式隐藏的元素不会再去占据页面的位置。</li>
<li>有一个属性专门控制元素的显示 <code>visibility: show;</code> 默认是 <code>show</code>，如果想隐藏就改为 <code>hidden</code>。不过通过这种方式隐藏的仍然会占位。</li>
</ol>
<p>一个关于开发者模式四个分区作用的说明。</p>
<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F.png" class="">
<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.png" class="">

<h4 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h4><p>浮动最早期设计出来是为了实现文字环绕图片或者说文字环绕文字。现在浮动是主流的页面布局方式之一。</p>
<ol>
<li>给第一个子元素设置 <code>margin-top</code> 会被父元素抢走，但是如果这个子元素浮动以后，就不会这样了。</li>
<li>浮动后的元素不会被当作文本处理了(行内和行内块都会被当作文本处理)</li>
<li>脱离文档流</li>
<li>不会独占一行，可以共用一行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a test.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .outer &#123;</span><br><span class="line">                background-color: gray;</span><br><span class="line">                border: black 1px solid;</span><br><span class="line">            &#125;</span><br><span class="line">            .box &#123;</span><br><span class="line">                margin: 10px;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: skyblue;</span><br><span class="line">                border: solid black 1px;</span><br><span class="line">            &#125;</span><br><span class="line">            .box1 &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;box box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>浮动之后，盒子因为脱离了标准文档流，它撑不起父盒子的高度，导致父盒子高度塌陷</p>
<h5 id="清除浮动带来影响的方式"><a href="#清除浮动带来影响的方式" class="headerlink" title="清除浮动带来影响的方式"></a>清除浮动带来影响的方式</h5><ol>
<li>父盒子设置固定高度<br>虽然，给父盒子设置了固定高度能暂时解决我们的问题，但是它的使用不灵活，如果未来子盒子的高度需求发生了改变(网页的多处地方)，那么我们得手动需要更改父盒子的高度。后期不易维护。</li>
<li>内墙法<br>所谓内墙法,有一个规则:在浮动元素的后面加一个空的块级元素(通常是div),并且该元素设置clear:both；属性。<br>clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。</li>
<li>伪元素清除法<br><a href="https://juejin.cn/post/6886247611318140942">https://juejin.cn/post/6886247611318140942</a><br>在最后补加一个没有实际意义的块元素 <code>div</code>，然后添加 <code>div</code> 的 CSS 属性 <code>clear: both;</code>，这个块元素没有高，没有宽，没有内容，就是专门用来撑起父元素。<br>或者更加优雅写成<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx::after &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中 <code>content: &#39;&#39;</code> 表示元素为空，<code>display: block</code> 才能撑起父元素(因为另起一行了)，<code>clear: both;</code> 就是消除之前的浮动带来的所有影响。</li>
<li><code>overflow: hidden;</code></li>
</ol>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>开启相对定位的元素并未脱离文档流。<br>如果一个元素开启了定位，那么它的层级就比普通元素的层级高。<br>相对定位：</p>
<ol>
<li>对于元素的位置进行微调。</li>
<li>配合绝对定位</li>
</ol>
<p>绝对定位：</p>
<ol>
<li>一旦开启绝对定位，就脱离了文档流。</li>
<li>绝对定位参考的点是它的包含块。<br> 对于没有脱离文档流的元素，它的父元素就是它的包含块。<br> 对于脱离文档流的元素，它的第一个开启定位的祖先元素就是它的包含块。</li>
<li>不论是块元素、行内元素还是行内块元素，只要进行了绝对定位，就变成了<strong>定位元素</strong><br> 定位元素：<ol>
<li>默认被内容撑开。</li>
<li>但是也是可以进行设置的。</li>
</ol>
</li>
</ol>
<p>固定定位：<br>就是直接对于视口定位。</p>
<ol>
<li>并且元素变成了定位元素。</li>
<li>脱离了文档流。</li>
</ol>
<p>粘性定位：<br><code>position: sticky;</code><br>参考点是离它最近的拥有滚动行为的祖先元素。包含粘性定位元素的父容器也不在视图上时，胶水就失效了。</p>
<p>这几个定位的层级是平等的。</p>
<h4 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h4><p>属性 <code>z-index</code>(纯数值，没有单位) 就相当于 <code>z</code> 轴上的坐标，<code>z</code> 越大，层级越高，所以在屏幕上显示的优先级越高。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>版心的大小一般是 900 - 1200 px</p>
<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%90%8D%E8%AF%8D.png" class="">

<h4 id="重置默认样式"><a href="#重置默认样式" class="headerlink" title="重置默认样式"></a>重置默认样式</h4><ol>
<li>使用全局选择器<br>在简单的案例中，我们可能使用这种方式，但是实际开发中我们不会使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123; padding: 0px; margin: 0px; &#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>reset.css</code> 可以是自己一直以来的一个标准模板，也可以是使用一些公司开源的自己的 <code>reset.css</code>(比如小米、阿里…)</li>
<li><code>Normalize.css</code> 是一种最新方案，它再清楚默认样式的基础上，保留了一些有价值的默认样式。<br>这是一个标准化的东西，有很多的网站和用户去维护这个东西。<br><a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></li>
</ol>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E7%BB%83%E4%B9%A01.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        .leftfix &#123;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .rightfix &#123;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .clearfix &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: 960px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        .top-header &#123;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 80px; </span><br><span class="line">        &#125;</span><br><span class="line">        .logo,</span><br><span class="line">        .banner1,</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 80px;</span><br><span class="line">            line-height: 80px;</span><br><span class="line">        &#125;</span><br><span class="line">        .logo &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner1 &#123;</span><br><span class="line">            width: 540px;</span><br><span class="line">            margin: 0 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .menu &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 30px;</span><br><span class="line">            margin: 10px auto;</span><br><span class="line">            line-height: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item1,</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            height: 198px;</span><br><span class="line">            width: 368px;</span><br><span class="line">            border: solid black 1px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item3,</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            width: 178px;</span><br><span class="line">            height: 198px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item7,</span><br><span class="line">        .item8,</span><br><span class="line">        .item9 &#123;</span><br><span class="line">            width: 198px;</span><br><span class="line">            height: 128px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">            line-height: 128px;</span><br><span class="line">        &#125;</span><br><span class="line">        .footer &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            line-height: 60px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;!--header--&gt;</span><br><span class="line">        &lt;div class=&quot;top-header clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;logo leftfix&quot;&gt;</span><br><span class="line">                logo</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner1 leftfix&quot;&gt;</span><br><span class="line">                banner1</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner2 leftfix&quot;&gt;</span><br><span class="line">                banner2</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--menu--&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            菜单</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--content--&gt;</span><br><span class="line">        &lt;div class=&quot;content clearfix&quot;&gt;</span><br><span class="line">            &lt;!--left--&gt;</span><br><span class="line">            &lt;div class=&quot;left-content leftfix&quot;&gt;</span><br><span class="line">                &lt;!--top--&gt;</span><br><span class="line">                &lt;div class=&quot;top-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item1 leftfix&quot;&gt;</span><br><span class="line">                        栏目一</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item2 leftfix&quot;&gt;</span><br><span class="line">                        栏目二</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;!--bottom--&gt;</span><br><span class="line">                &lt;div class=&quot;bottom-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item3 leftfix&quot;&gt;栏目三&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item4 leftfix&quot;&gt;栏目四&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item5 leftfix&quot;&gt;栏目五&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item6 leftfix&quot;&gt;栏目六&lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--right--&gt;</span><br><span class="line">            &lt;div class=&quot;right-content leftfix&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;item7&quot;&gt;栏目七&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item8&quot;&gt;栏目八&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item9&quot;&gt;栏目九&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--footer--&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">            页脚</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>调整背景图的位置用 <code>background-position:xxx;</code></p>
<p>布局里面，一堆东西横向排列一堆东西纵向排列，而且这一堆东西还很相似，往往我们都用 ul li</p>
<p>大多数情况都是给子元素开启固定定位，给父元素开启相对定位。</p>
<p>img 方式引入图片的话，我们不需要给出宽和高，就是图片默认的宽和高。但是 <code>div</code> 设置图片背景的时候，<code>div</code> 必须先有宽和高，才能显示图片。</p>
]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>变量的声明就是 <code>var name = xxx;</code>。其中 <code>var</code> 是 <code>variable</code> 的缩写（虽然和方差 variance 的缩写一样）。</p>
<p>在 JS 中使用 {} 来分块，同一个 {} 中的语句我们称之为一组语句，它们要么都执行，要么都不执行。</p>
<p>其实函数也是一个对象，可以如下定义一个函数：<code>f = new Function(&quot;console.log(&#39;this is a function. &#39;)&quot;)</code>。但是一般不这么使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;lys&#x27;,</span><br><span class="line">    age: 19,</span><br><span class="line">    address: &#x27;SDU&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj) &#123;</span><br><span class="line">    console.log(x); // 这样只是枚举的对象中的元素名字</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj)&#123;</span><br><span class="line">    console.log(obj[x]); // 不能直接 obj.x 来获得具体元素，应用 [] 的引用方式。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组创建 <code>var arr = new Array()</code> 或者 <code>var arr = []</code>。但是一般不使用 <code>new Array()</code> 的创建方式。并且数组中的元素类型也是不一定的，不一定非要是 Number 类型的。<br>其实数组也是一个对象，只不过索引方式是 []，所以对象有的东西数组也有。</p>
<p>数组既然是对象，就有方法，在 JS 中数组有一些常用的方法：</p>
<ol>
<li><code>push()</code> 向数组末尾添加一个或者多个元素，并且返回新的数组的长度。</li>
<li><code>pop()</code> 从数组末尾删除一个元素，并且返回删除的元素。</li>
<li><code>unshift()</code> 向数组的<strong>开头</strong>添加一个或者多个元素，并且返回新的数组的长度。</li>
<li><code>shift()</code> 从数组开头删除一个元素，并且返回删除的元素。</li>
<li><code>join()</code> 将所有的元素连接成一个字符串。</li>
<li><code>slice()</code> 返回数组的一部分，不修改原数组。</li>
</ol>
<p>建立函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function xxx() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br></pre></td></tr></table></figure>
<p>如果不写前面的 function 直接 new，会出现错误。</p>
<p>arr.forEach(xx) 中间 xx 都要传递一个函数，如果之前定义了 <code>function fun() &#123;&#125;</code> 就写为 <code>arr.forEach(fun)</code>，但是一般不这样，一般都是用匿名函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.forEach(function(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面就是输出 a，遍历的时候会将 arr 中的元素传递给 function。<br>会传递三个参数，第一个是数组当前遍历到元素 value，第二个是当前遍历到的索引 index，第三个是正在遍历的数组。</p>
<p>函数在调用的时候，浏览器会向里面传递两个隐含的参数</p>
<ol>
<li>上下文对象的 this</li>
<li>封装实参的类数组对象 arguments，在调用函数的时候，我们所传递的实参都会在 arguments 中保存。</li>
</ol>
<p>在 JS 中，对象有 3 类</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1.png" class="">
<p>DOM Document Object Model<br>JS 通过 DOM 对于 HTML 文档进行操作，只要理解了 DOM，就可以随心所欲操作 WEB 页面。</p>
<p>节点 Node 是构成 HTML 文档的最基本的单元，常用节点分为四类</p>
<ul>
<li>文档节点 整个 HTML 文档</li>
<li>元素节点 HTML 文档中的 HTML 标签</li>
<li>属性节点 元素的属性</li>
<li>文本节点 HTML 标签中的文本<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9.png" class=""></li>
</ul>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7.png" class="">
<p>上面的三个属性是每一个节点都有的三个属性。</p>
<p>innerHTML 可以获得到文字</p>
<p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。JavaScript 与 HTML 之间的交互是通过事件实现的。比如对于 Web 应用来说，有下面一些有代表性的事件：点击某个元素、将鼠标移动至某个元素上方、按下键盘上某个键等等。</p>
<p><code>onload</code> 事件会在整个页面加载完成之后发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onload= function() &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码是页面加载完成之后执行的。</p>
<p>标签就是元素，元素就是标签。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9.png" class="">

<p>innerHTML 对于「自结束标签」没有意义。如：</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%87%AA%E7%BB%93%E6%9D%9F%E6%A0%87%E7%AD%BE.png" class="">
<p>如果想读取元素的属性，直接 <code>元素.属性名</code>。但是读取元素的 <code>class</code> 属性的时候不能直接 <code>元素.class</code> 因为 class 是 JS 中的保留字，应该写为 <code>元素.className</code></p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%9F%A5%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9.png" class="">
<p>但是 <code>childNodes</code> 有个缺陷，此时如果我们使用 <code>children</code> 就不会出现这种问题了，它返回的是当前元素的所有子元素。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/childnodes%E7%BC%BA%E9%99%B7.png" class="">

<p><code>innerText</code> 和 <code>innerHTML</code> 类似，但是 <code>innerText</code> 获取的会将 html 标签去除。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9.png" class="">

<p><code>getElementsByName()</code> 一般用来操作一些表单项目。 </p>
<p>获取 <code>body</code> 标签的话有两种方式：</p>
<ol>
<li><code>var body = document.getElementsByTagName()[0];</code> 因为 <code>getElementsByTagName()</code> 返回的是一个集合 <code>Collection</code>，但是我们又只有一个 <code>body</code>，所以直接返回索引 0 就可以了。</li>
<li>其实在 <code>document</code> 中就有一个属性 <code>body</code>，我们直接 <code>var body = document.body;</code> 就可以了。</li>
</ol>
<p><code>html</code> 元素是 <code>document.documentElement;</code></p>
<p><code>document.all</code> 代表的是页面的所有元素。也可以写成 <code>document.getElementsByTagName(&quot;*&quot;)</code></p>
<p><code>document.getElementsByClassName();</code> 可以根据元素的 <code>class</code> 属性值获取一组节点对象。</p>
<p><code>document.querySelector();</code> 需要一个选择器字符串作为参数，可以根据一个 CSS 选择器来查询一个元素节点对象。但是使用这个方法只会返回唯一的一个元素，如果满足条件的元素有多个，但是只会返回第一个。如果需要多个就使用 <code>document.querySelectorAll();</code></p>
<p><code>父节点.insertBefore(新节点, 旧节点)</code> 是在旧节点前面添加新节点。</p>
<p>超链接点击以后会默认跳转页面，如果我们不希望出现此默认行为，我们可以在超链接的 <code>onclick = function() &#123;&#125;</code> 中写上 <code>return false;</code></p>
<p><code>confirm()</code> 函数会弹出一个带有确定和取消两个按键的提示框，并且如果我们点击确定，会返回 true，如果点击取消，会返回 false。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="">
<p>一个比较细节容易忽视的点，直观上我们认为 this 和 allA[i] 是一样的。<br>图中，我们的 <code>onclick = function() &#123;&#125;</code> 可以认为只是函数之间的一个赋值，里面的内容并没有执行。只有我们在点击按钮的时候，<code>function</code> 里面的内容才会执行。如果我们 <code>function</code> 里面使用 <code>allA[i]</code>，等到我们点击的时候 for 循环早就已经执行完毕，此时的 i 必然是 all 的length，所以就会出现错误。我们正确的做法应该是将 function 里面的 allA[i] 改为 this。</p>
<p>通过 JS 修改元素的样式：<code>元素.style.样式名 = 样式值</code> 其中样式值需要是一个字符串。<br>注意，如果 CSS 样式名称中含有 <code>-</code>，如 <code>background-color</code> 这种命名在 JS 中是不合法的，我们需要将这种命名改为驼峰命名法，去掉 <code>-</code>，然后将 <code>-</code> 的字母大写。</p>
<p>通过 JS 的 style 修改的往往是内联样式，而内联样式有较高的优先级，所以通过 JS 修改的样式往往会立即显示。</p>
<p>事件对象：<br>当事件的响应函数被触发的时候，浏览器每次会将一个事件对象作为实参传递进响应函数。在事件对象中封装了当前关于事件的一切信息，比如鼠标的坐标、键盘的哪一个按键被按下、鼠标滚轮的移动方向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a title.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                document.onmousemove = function(event) &#123;</span><br><span class="line">                    var clientX = event.clientX;</span><br><span class="line">                    var clientY = event.clientY;</span><br><span class="line">                    box1.style.left = clientX + &quot;px&quot;;</span><br><span class="line">                    box1.style.top = clientY + &quot;px&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;box id=&quot;box1&quot;&gt;&lt;/box&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>clientX</code> 和 <code>clientY</code> 是用于我们鼠标在当前可见窗口的坐标，所以对于有滚动条的窗口的话可能会出现一些错误。所以我们这时候使用 <code>pageX</code> 和 <code>pageY</code> 这两和属性是相对于整个页面的。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/document%E5%92%8Cwindow.png" class="">

<p>事件的冒泡(bubble)<br>所谓事件的冒泡就是事件的想上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在开发中，大部分情况冒泡是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。<br><code>event.cancelBubble = true;</code></p>
<p>我们希望只绑定一次事件，即可应用到多个元素之上，即使元素是后来添加的。我们可以尝试将元素绑定给其共同的祖先元素。然后通过冒泡来实现事件的发生。这其实就是事件的「委派」。</p>
<p><code>document.getElementsByTagName();</code> 返回的不是一个数组（一个NodeList对象，指定标签名的集合 collection），虽然我们可以遍历，它也有长度。</p>
<p>点击超链接时会自动默认跳转，我们把超链接的 <code>href</code> 修改为 <code>javascript:;</code> 就不会发生跳转了。</p>
<p>事件给谁绑定的，function 中的 this 就是谁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ul.onclick = function() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">    alert(&quot;我是一个响应函数。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像这一个，第一个 <code>alert</code> 输出的就是 <code>[object HTMLUListElement]</code>。<br>但是事件绑定对象不等于事件触发对象，我们如果想要获得事件<strong>触发对象</strong>需要使用 <code>event.target</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;this is a test.&lt;/title&gt;</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var btn1 = document.getElementById(&quot;btn1&quot;);</span><br><span class="line">                var ul = document.getElementsByTagName(&quot;ul&quot;)[0];</span><br><span class="line">                btn1.onclick = function() &#123;</span><br><span class="line">                    var li = document.createElement(&quot;li&quot;);</span><br><span class="line">                    li.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27; class=&#x27;link&#x27;&gt;新建的超链接&lt;/a&gt;&quot;</span><br><span class="line">                    ul.appendChild(li);</span><br><span class="line">                &#125;</span><br><span class="line">                ul.onclick = function(event) &#123;</span><br><span class="line">                    if (event.target.className == &#x27;link&#x27;) &#123;</span><br><span class="line">                        alert(&quot;这是一个响应函数&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;button id=&quot;btn1&quot;&gt;我是一个按钮&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>对象.事件 = 函数</code> 的形式绑定响应函数，它只能同时为一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，那么后面的就会覆盖掉前面的。<br>我们可以使用 <code>addEventListener(xxx, xxx, xxx)</code> 为元素绑定响应函数。<br>它的参数：</p>
<ol>
<li>事件的字符串，如果是 onclick 不要前面的 on</li>
<li>回调函数，当事件被触发时，该函数会被调用。</li>
<li>是否在捕获阶段触发，需要布尔值，一般是 false</li>
</ol>
<p>JavaScript中的call()函数是用于调用函数的方法之一，它允许你显式地指定函数内部的this关键字，并传递参数给该函数。call()方法的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionName.call(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure>
<p>总之，call()方法是JavaScript中用于在指定上下文对象上调用函数的强大工具，它允许你更灵活地控制函数的执行环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UFT-8&quot;&gt;</span><br><span class="line">        this is a test.</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                box1.onmousedown = function(event) &#123;</span><br><span class="line">                    var offsetX = event.clientX - box1.offsetLeft;</span><br><span class="line">                    var offsetY = event.clientY - box1.offsetTop;</span><br><span class="line">                    document.onmousemove = function(event) &#123;</span><br><span class="line">                        var x = event.clientX;</span><br><span class="line">                        var y = event.clientY;</span><br><span class="line">                        box1.style.left = x - offsetX + &quot;px&quot;;</span><br><span class="line">                        box1.style.top = y - offsetY + &quot;px&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    document.onmouseup = function() &#123;</span><br><span class="line">                        document.onmousemove = null;</span><br><span class="line">                        document.onmouseup = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>实现一个小方块位置的拖拽。</p>
<p>键盘事件一般都会绑定给可以获取到焦点的对象或者是 <code>document</code> 对象。对于 <code>onkeydown</code> 事件来说，如果我们一直按着某个按键不松手，则事件就会一直触发。当 <code>onkeydown</code> 连续触发时，第一次和第二次之间的间隔会长一点，其他后面的会非常快，这是为了防止我们误操作。</p>
<p>我们可以使用 <code>event</code> 的 <code>keyCode</code> 属性可以返回被按下键的 <code>Unicode</code> 编码。或者使用 <code>key</code> 属性直接返回被按键的按键。<br>如果判断 <code>alt</code> 或者 <code>ctrl</code> 或者 <code>shift</code> 和某个键是否同时被按下，可以同时使用 <code>event</code> 的 <code>altKey、shiftKey、ctrlKey</code> 属性和 <code>key</code> 属性。</p>
<p>BOM browser object model 浏览器对象模型<br>BOM 可以使我们通过 JS 来操作浏览器，DOM 可以使我们通过 JS 来操作网页。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/bom%E5%AF%B9%E8%B1%A1.png" class="">

<p><code>uerAgent</code> 用户代理，通常指的是浏览器，其中 <code>navigator</code> 的属性 <code>userAgent</code> 是一个字符串，包含用来描述浏览器的内容，不同的浏览器有着不同的 userAgent</p>
<p>Gecko CSS 渲染的一个引擎。</p>
<p><code>history</code> 对象 <code>length</code> 属性，返回浏览器历史列表中 url 数量。<br>方法：<code>back</code> 加载 <code>history</code> 列表中前一个 url，<code>forward</code> 加载 <code>history</code> 列表中下一个 url，<code>go(xx)</code> 加载列表中某一个具体的页面，xx 如果是正，就是前多少个，如果是负，就是加载后面第xx个页面。</p>
<p><code>location</code> 对象<br>如果直接打印 <code>location</code> 可以获取当前的地址栏，也就是网页的完整路径。如果直接将 <code>location</code> 修改为一个路径，就会直接跳转到那个页面。</p>
<p><code>window</code> 的 <code>setInterval</code> 方法。(Interval 是 间隔、中场休息、幕间休息、间隙 的意思)</p>
<ul>
<li>定时调用</li>
<li>可以将一个函数，每隔一段时间执行一次</li>
<li>参数：<ol>
<li>回调函数</li>
<li>每次调用的时间间隔，单位是毫秒</li>
</ol>
</li>
<li>返回值：<br>  返回一个 Number 类型的数据<br>  这个数字用来作为定时器的唯一标识(因为一个页面上可能有很多个定时器)<br>  比如我们的 <code>clearInterval(xx)</code> 方法，可以用来关闭一个定时器，其中的 <code>xx</code> 就需要我们的标识作为参数。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(function() &#123;</span><br><span class="line">    xxx.innerHTML = ++count;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>延时调用：一个函数不是马上执行，而是一段时间之后再执行(只会执行一次)。<br>用法和定时调用差不多 <code>setTimeout(xxx);</code><br><code>clearTimeout(xxx);</code> 是关闭延时调用。</p>
<p>延时调用其实和定时调用是可以互相代替的。</p>
<p>JSON(JavaScript Object Notation)<br>因为和 JavaScript 中对象的表示方法一样，只不过在 JSON 中属性名字必须加双引号。<br>JSON 分类：</p>
<ol>
<li>对象 <code>&#123;&#125;</code></li>
<li>数组 <code>[]</code></li>
</ol>
<p>在 JS 中，为我们提供了一个工具类就叫做 JSON，这个对象可以帮助我们将一个 JSON 转换为 JS 对象，也可以将一个 JS 对象转换为 JSON。<br><code>JSON.parse(xx);</code></p>
<ul>
<li>将字符串转换为 JS 对象</li>
<li>需要一个 JSON 字符串作为参数，返回一个 JS 对象</li>
</ul>
<p><code>JSON.stringfy();</code></p>
<ul>
<li>将 JS 对象转换为字符串</li>
<li>需要一个 JS 对象作为参数，但会一个 JSON 字符串。</li>
</ul>
<p><code>===</code> 是严格相等的意思，它用于比较两个值是否完全相等，包括值和数据类型。<br>使用严格相等运算符是 JavaScript 编程中的一种良好实践，因为它可以减少潜在的错误和不确定性，确保比较的值具有相同的类型和值。</p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Beamer学习</title>
    <url>/2023/11/22/Beamer%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ol>
<li><p>黄旭华老师的翻译文档<br> <a href="https://static.latexstudio.net/wp-content/uploads/2017/02/BeamerUserGuide_V3.24_zh-cn.pdf">https://static.latexstudio.net/wp-content/uploads/2017/02/BeamerUserGuide_V3.24_zh-cn.pdf</a></p>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>Beamer</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶</title>
    <url>/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h4><p>数据类型：</p>
<ol>
<li>基本类型<br> String Number boolean undefined null</li>
<li>对象(引用)类型<br> Object Function Array</li>
</ol>
<p>判断：</p>
<ol>
<li><code>typeof</code><br> 返回的数据类型的字符串表达</li>
<li><code>instanceof</code></li>
<li><code>===</code> 和 <code>==</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123; // 这是一个 **类型对象**，因为函数也是一个对象。</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(); // 这是一个实例对象。</span><br></pre></td></tr></table></figure>
<p><code>null</code> 和 <code>undefined</code><br><code>null</code> 定义了并且赋值了，只是值为 <code>null</code>，而 <code>undefined</code> 是定义了但是没有赋值。初始赋值为 <code>null</code> 表示将要是一个对象。程序的最后赋值为 <code>null</code> 可以释放内存。</p>
<p>栈：全局变量 &#x2F; 局部变量<br>堆：对象<br>(对象本身在栈里面，而表示对象的变量在栈空间，比如函数和函数名的关系)</p>
<p>JS 在调用函数传递变量的时候是 <strong>值传递</strong>（理解可能不同）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">function add(a) &#123;</span><br><span class="line">    a = a + 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 程序输出为 3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    var b = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数执行完以后 <code>b</code> 这个局部变量会自动释放，而后面对应的对象因为没有再被指向，被认为是垃圾对象，是在后面的某个时刻由垃圾回收器回收，释放空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">b = null;</span><br></pre></td></tr></table></figure>
<p><code>b=null;</code> 以后，<code>b</code> 所指向的对象没有被任何其他变量指向，所以会被标记为垃圾对象，由 <code>JS</code> 引擎在一定时间后回收，而 <code>b</code> 这个全局变量仍然存在。<br>在<code>JavaScript</code>中，全局变量通常在整个应用程序的生命周期内存在，不会自动释放内存。<code>JavaScript</code> 引擎会负责管理全局变量的内存，而不需要手动释放。当全局变量不再被引用时，<code>JavaScript</code>引擎会自动将其标记为可回收，并在适当的时候进行垃圾回收以释放内存。<br><code>JavaScript</code> 的垃圾回收机制主要处理对象的内存释放，而不负责释放变量的内存。变量的生命周期通常由其作用域决定。在全局作用域中声明的变量通常会在整个应用程序的生命周期内存在，除非您显式删除它们或应用程序终止。在局部作用域中声明的变量在离开作用域时会被销毁，相应的内存也会被释放。</p>
<p>什么时候必须使用 <code>[&#39;属性名&#39;]</code> 的方式？</p>
<ol>
<li>属性名包含特殊字符：如<code>-</code> 和 <code> </code>。</li>
<li>使用表达式来动态访问属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;John&quot;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var propertyName = &quot;name&quot;;</span><br><span class="line">console.log(person[propertyName]); // 使用方括号来访问属性</span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>test.call/apply(obj);</code> 这个意思是把 <code>test</code> 函数临时作为 <code>obj</code> 内部的函数来调用。<code>obj</code> 内部可以没有 <code>test</code> 函数。</p>
<p><code>JavaScript</code> 中的回调函数是一种常见的编程概念，它允许您将一个函数作为参数传递给另一个函数，并在需要时执行该函数。这通常用于处理异步操作，例如处理文件读取、网络请求、定时器等等，因为在这些情况下，不能立即得到结果，而需要在操作完成后执行特定的代码。</p>
<p>IIFE(Immediately-Invoked Function Expression)</p>
<p><code>this</code> 是什么？</p>
<ul>
<li>任何函数本质上都是通过某个对象来调用，如果我们没有直接指定，就是 <code>window</code> 来调用。</li>
<li>所有函数内部都以一个变量 <code>this</code>。</li>
<li>这个 <code>this</code> 的值是当前调用函数的对象。</li>
</ul>
<p>在<code>JavaScript</code>中声明的全局函数通常是<code>window</code>对象的一部分，而不是<code>document</code>对象的一部分，这是因为<code>JavaScript</code>最初是为浏览器环境设计的，并且全局作用域在浏览器中通常与<code>window</code>对象关联。</p>
<p>在浏览器环境中，<code>window</code>对象代表整个浏览器窗口，它包含了全局<code>JavaScript</code>作用域的所有内容，包括全局变量和函数。当您声明一个全局函数时，它实际上是<code>window</code>对象的一个属性。这意味着您可以在全局范围内访问这个函数，无需任何其他前缀。</p>
<h4 id="JS-原型和原型链"><a href="#JS-原型和原型链" class="headerlink" title="JS 原型和原型链"></a>JS 原型和原型链</h4><p>JS 的复杂类型都是对象类型(<code>Object</code>)，而 JS 不是一门完全面向对象的编程语言，所以如何涉及继承机制，这是一个问题。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>因为 JS 中没有类(<code>Class</code>)这个概念，所以 JS 的设计者使用了 <strong>构造函数</strong> 来实现继承机制。</p>
<blockquote>
<p>ES6 中的 <code>Class</code> 可以看成一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>Class</code> 写法只是让原型的写法更加清晰、更像面向对象编程的语言而已。</p>
</blockquote>
<p>在构造函数中，通过 <code>this</code> 赋值的属性或者方法，是每个实例的 <strong>实例属性</strong> 和 <strong>实例方法</strong>，<strong>无法共享公共属性</strong>。所以就又设计出了一个<strong>原型对象</strong>，来存储这个<strong>构造函数的公共属性以及方法</strong>。</p>
<h5 id="函数的-prototype-原型"><a href="#函数的-prototype-原型" class="headerlink" title="函数的 prototype(原型)"></a>函数的 <code>prototype</code>(原型)</h5><ul>
<li>每一个函数都有一个 <code>prototype</code> 属性，它默认指向一个 <code>Object</code> 空实例对象(即称为：原型对象，但是 <code>Object</code> 不满足)。<blockquote>
<p>为什么要有这个空对象？<br>它可以方便我们对于一个函数添加个性化的属性和方法，如果没有这个空对象而是直接链接到 Obejct，那么不同函数之间的个性化操作都会添加到 Obejct 下，会产生很多不必要的冲突和麻烦。</p>
</blockquote>
</li>
<li>原型对象中有一个属性 <code>constructor</code>，它指向函数对象。</li>
<li>给原型对象添加属性(一般是方法) -&gt; 实例对象可以访问使用。（感觉和类与对象的关系很像）<br>构造函数和它的原型对象相互引用。<br>每一个函数 <code>function</code> 都有一个 <code>prototype</code>，即显式原型(属性)<br>每一个对象都有一个 <code>__proto__</code> 可以称为隐式原型(属性)<br>对象隐式原型的值就是函数显式原型的值。</li>
</ul>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><ul>
<li>访问一个对象的属性时，现在自身属性中查找，找到返回。</li>
<li>如果没有，再沿着 <code>__proto__</code> 这条链向上查找，找到返回。</li>
<li>如果最终没有找到，返回 <code>undefined</code>。</li>
<li>一直是沿着隐式原型找的，所以我们的原型链本质上是一个 <strong>隐式原型链</strong><img src="/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B.png" class="">
<img src="/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class="">
所有函数的隐式原型都是相同的，<code>fun = new Function()</code> 都是 <code>Function</code> 的实例对象。</li>
<li>在读取对象的属性时，会自动到原型链中查找。</li>
<li>设置对象的属性时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。</li>
</ul>
<p>To do:<br>利用js快速完成大学生新生安全教育课程<br><a href="https://blog.csdn.net/m0_38072683/article/details/118878085">https://blog.csdn.net/m0_38072683/article/details/118878085</a></p>
]]></content>
      <tags>
        <tag>Web</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX学习</title>
    <url>/2023/11/22/LaTeX%20%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX 伪代码书写</title>
    <url>/2023/11/25/LaTeX-%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99/</url>
    <content><![CDATA[<h3 id="伪代码书写规范"><a href="#伪代码书写规范" class="headerlink" title="伪代码书写规范"></a>伪代码书写规范</h3><p>伪代码是一种接近自然语言的算法描述形式，目的是在不涉及具体编程语言的情况下将算法的流程和含义清楚的表达出来，因此没有一个统一的规范。</p>
<p>一般来说：</p>
<ol>
<li><p>有一个标题和编号</p>
</li>
<li><p>明确输入和输出</p>
</li>
<li><p>赋值一般使用 <code>&lt;-</code> 来表示</p>
</li>
<li><p><code>A[i]</code> 表示 A 的第 i 个元素，<code>A[1...j]</code> 表示从下标 1 到 j 的子数组</p>
</li>
<li><p>返回值使用 <code>return</code> 关键字</p>
</li>
<li><p>函数的调用使用函数名 + 传入参数的形式</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://shuzang.github.io/2021/pseudocode-specification/">https://shuzang.github.io/2021/pseudocode-specification/</a></p>
<h3 id="algorithm-包"><a href="#algorithm-包" class="headerlink" title="algorithm 包"></a>algorithm 包</h3><h4 id="简单的语句"><a href="#简单的语句" class="headerlink" title="简单的语句"></a>简单的语句</h4><p>在 <code>.tex</code> 文件中，先引入宏包</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithmic&#125;</span><br></pre></td></tr></table></figure>

<p>然后写入</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以创建一个伪代码环境，如下如所示</p>
<img src="/2023/11/25/LaTeX-%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99/image-20231125152134665.png" class="" title="image-20231125152134665">

<p>此时伪代码是空的，我们在 <code>algorithm</code> 模块中嵌入一个 <code>algorithmi</code> 块，可以发现我们是在代码块中内嵌数学公式：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，伪代码是一个赋值语句，一行普通语句以 <code>\STATE</code> 开头：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>y<span class="keyword">\gets</span><span class="keyword">\sqrt</span>&#123;x&#125;+1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>z<span class="keyword">\gets</span><span class="keyword">\dfrac</span>&#123;x&#125;&#123;y&#125;<span class="built_in">$</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h4><p>一个简单的判断结构：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\IF</span> &#123;<span class="built_in">$</span>x<span class="keyword">\leq</span> 0<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> x+1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\ENDIF</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>我们不需要手动缩进，只需要用 <code>\IF</code> 和 <code>\ENDIF</code> 限制范围即可。此外，<code>IF</code> 后面的条件外面需要加上 <code>&#123;&#125;</code> 。类似的，加上 <code>\ELSE</code> 就可以实现一个完整的 <code>if-else</code> 子句。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\IF</span> &#123;<span class="built_in">$</span>x<span class="keyword">\leq</span> 0<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> x+1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\ELSE</span></span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> x-1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\ENDIF</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>除了 <code>while</code>，<code>algorithmic</code> 还支持四种循环方法：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% for循环</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">    <span class="keyword">\FOR</span> &#123;&lt;condition&gt;&#125;</span><br><span class="line">    <span class="keyword">\STATE</span> &lt;text&gt;</span><br><span class="line">    <span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% forall循环</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">    <span class="keyword">\FORALL</span> &#123;&lt;condition&gt;&#125;</span><br><span class="line">    <span class="keyword">\STATE</span> &lt;text&gt;</span><br><span class="line">    <span class="keyword">\ENDFOR</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repeat循环</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">    <span class="keyword">\REPEAT</span> &lt;text&gt;</span><br><span class="line">    <span class="keyword">\UNTIL</span> &#123;&lt;condition&gt;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% loop循环</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">    <span class="keyword">\LOOP</span> &lt;text&gt;</span><br><span class="line">    <span class="keyword">\ENDLOOP</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithmic&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><p>在算法为代码中，我们常常需要说明算法的输入和输出，帮助读者更好的阅读代码。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\ENSURE</span>&#123;<span class="built_in">$</span>x<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\REQUIRE</span>&#123;<span class="built_in">$</span>y<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\IF</span>&#123;<span class="built_in">$</span>x<span class="keyword">\leq</span>0<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span>&#123;<span class="built_in">$</span>y<span class="keyword">\gets</span>-1<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\ELSE</span></span><br><span class="line">        <span class="keyword">\STATE</span>&#123;<span class="built_in">$</span>y<span class="keyword">\gets</span>1<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\ENDIF</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>其中，输入对应 <code>\REQUIRE</code>，输出对应 <code>\ENSURE</code></p>
<p>如果喜欢使用 <code>INPUT</code> 表示输入，<code>OUTPUT</code> 表示输出，可以对于关键字进行重新定义：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicrequire</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Input:&#125;&#125;</span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\algorithmicensure</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;Output:&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h4><h5 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h5><p>在 <code>\begin&#123;algorithmic&#125;</code> 后面加上 <code>[1]</code>，算法伪代码会显示行号：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;[1]</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\IF</span> &#123;<span class="built_in">$</span>x<span class="keyword">\leq</span>1<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> x+1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\ENDIF</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：[1] 表示每一行都显示行号，如果是 [2]，表示每两行显示一个行号</p>
</blockquote>
<h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p><code>\COMMENT</code> 命令会在算法伪代码中加上注释：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Example Pseudocode&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;algorithmic&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span>0<span class="built_in">$</span><span class="keyword">\COMMENT</span>&#123;This is a comment&#125;</span><br><span class="line">        <span class="keyword">\IF</span> &#123;<span class="built_in">$</span>x<span class="keyword">\leq</span>1<span class="built_in">$</span>&#125;</span><br><span class="line">        <span class="keyword">\STATE</span> <span class="built_in">$</span>x<span class="keyword">\gets</span> x+1<span class="built_in">$</span></span><br><span class="line">        <span class="keyword">\ENDIF</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 <code>IF</code>、<code>FOR</code> 这些语句，则需要这样写注释：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\IF</span>[This is a comment]&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样的显示效果不是很好，注释和代码之间的距离太小，我们可以使用 <code>\Comment</code> 来注释（这一次只有首字母是大写）。</p>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p><a href="https://welts.xyz/2022/01/17/pseudocode/">https://welts.xyz/2022/01/17/pseudocode/</a></p>
<h3 id="algorithm2e-包"><a href="#algorithm2e-包" class="headerlink" title="algorithm2e 包"></a>algorithm2e 包</h3><p>在 <code>beamer</code> 中，一般更经常使用 <code>algorithm2e</code>，并且它们的语法也有着挺大的不同。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><img src="/2023/11/25/LaTeX-%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99/image-20231125191211512.png" class="" title="image-20231125191211512">

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\def</span><span class="keyword">\SetClass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;<span class="keyword">\SetClass</span>&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>[ruled,linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\caption</span>&#123;Simulation-optimization heuristic&#125;<span class="keyword">\label</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\KwData</span>&#123;current period <span class="built_in">$</span>t<span class="built_in">$</span>, initial inventory <span class="built_in">$</span>I<span class="built_in">_</span>&#123;t-1&#125;<span class="built_in">$</span>, initial capital <span class="built_in">$</span>B<span class="built_in">_</span>&#123;t-1&#125;<span class="built_in">$</span>, demand samples&#125;</span><br><span class="line"><span class="keyword">\KwResult</span>&#123;Optimal order quantity <span class="built_in">$</span>Q<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="built_in">_</span>&#123;t&#125;<span class="built_in">$</span>&#125;</span><br><span class="line"><span class="built_in">$</span>r<span class="keyword">\leftarrow</span> t<span class="built_in">$</span><span class="keyword">\;</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="keyword">\leftarrow</span> -<span class="keyword">\infty</span><span class="built_in">$</span><span class="keyword">\;</span></span><br><span class="line"><span class="keyword">\While</span>&#123;<span class="built_in">$</span><span class="keyword">\Delta</span> B<span class="keyword">\leq</span> <span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="built_in">$</span> and <span class="built_in">$</span>r<span class="keyword">\leq</span> T<span class="built_in">$</span>&#125;&#123;<span class="built_in">$</span>Q<span class="keyword">\leftarrow</span><span class="keyword">\arg</span><span class="keyword">\max</span><span class="built_in">_</span>&#123;Q<span class="keyword">\geq</span> 0&#125;<span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;Q&#125;<span class="built_in">_</span>&#123;t,r&#125;(I<span class="built_in">_</span>&#123;t-1&#125;,B<span class="built_in">_</span>&#123;t-1&#125;)<span class="built_in">$</span><span class="keyword">\;</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span> B<span class="keyword">\leftarrow</span> <span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;Q&#125;<span class="built_in">_</span>&#123;t,r&#125;(I<span class="built_in">_</span>&#123;t-1&#125;,B<span class="built_in">_</span>&#123;t-1&#125;)/(r-t+1)<span class="built_in">$</span><span class="keyword">\;</span></span><br><span class="line"><span class="keyword">\If</span>&#123;<span class="built_in">$</span><span class="keyword">\Delta</span> B<span class="keyword">\geq</span> <span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="built_in">$</span>&#125;&#123;<span class="built_in">$</span>Q<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="keyword">\leftarrow</span> Q<span class="built_in">$</span><span class="keyword">\;</span></span><br><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span> B<span class="built_in">^</span>&#123;<span class="keyword">\ast</span>&#125;<span class="keyword">\leftarrow</span> <span class="keyword">\Delta</span> B<span class="built_in">$</span><span class="keyword">\;</span>&#125;</span><br><span class="line"><span class="built_in">$</span>r<span class="keyword">\leftarrow</span> r+1<span class="built_in">$</span><span class="keyword">\;</span>&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.zhihu.com/tardis/zm/art/166418214?source_id=1003">https://www.zhihu.com/tardis/zm/art/166418214?source_id=1003</a></p>
]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo blog instructions list</title>
    <url>/2023/08/23/hexo-blog-instruction-list/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>hexo n “我的博客” &#x2F; hexo new “我的博客”</td>
<td>新建文章</td>
</tr>
<tr>
<td>hexo p &#x2F; hexo publish</td>
<td>发表草稿文章</td>
</tr>
<tr>
<td>hexo g &#x2F; hexo generate</td>
<td>生成</td>
</tr>
<tr>
<td>hexo s &#x2F; hexo server</td>
<td>启动本地预览服务</td>
</tr>
</tbody></table>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>1.<br>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。<br>在 hexo 中使用 <strong>文章资源文件夹</strong> 需要在 <code>config.yaml</code> 文件中更改一下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>当该配置被应用后，使用 hexo new 命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。<br>但是若干原因，需要使用 <code>&#123; %asset_image xxx.jpg 这是一张图片% &#125;</code> 来引用。<br>2.<br>另一种方法是，在 <code>source</code> 文件夹下建立一个文件夹 <code>_pic</code> 专门用来存放图片，此时在 md 文件中 <code>![img](/_pic/xxx.jpg)</code> 的格式引用就可以了。<br>(不知道为啥这种没成功)</p>
<h3 id="搭建参考"><a href="#搭建参考" class="headerlink" title="搭建参考"></a>搭建参考</h3><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/94038688#:~:text=hexo">https://zhuanlan.zhihu.com/p/94038688#:~:text=hexo</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/44213627">https://zhuanlan.zhihu.com/p/44213627</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000002632530">https://segmentfault.com/a/1190000002632530</a> hexo 常用命令笔记</p>
</li>
<li><p><a href="https://blog.csdn.net/as480133937/article/details/100138838">https://blog.csdn.net/as480133937/article/details/100138838</a> hexo 博客美化配置</p>
</li>
<li><p><a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
</li>
<li><p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
</li>
<li><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/552639819">https://zhuanlan.zhihu.com/p/552639819</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_34243930/article/details/103994419#2_65">https://blog.csdn.net/qq_34243930/article/details/103994419#2_65</a> 关于 hexo 创建文章的讲解</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a> hexo 博客插入图片</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>log</title>
    <url>/2023/09/18/log/</url>
    <content><![CDATA[<h4 id="2023年9月18日"><a href="#2023年9月18日" class="headerlink" title="2023年9月18日"></a>2023年9月18日</h4><ol>
<li>多种计算逆元的方式：扩展欧几里得、费马小定理、递推、阶乘</li>
<li>扩展欧几里得推导：先假设一组解 <code>x^&#123;&#39;&#125; y^&#123;&#39;&#125;</code>，然后找到和原来的解 <code>x y</code> 之间的对应关系 或者 非递归实现</li>
<li>组合数的各种公式和基础二项式反演了解：<br><a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a><br><a href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a></li>
</ol>
<h4 id="2023年9月21日"><a href="#2023年9月21日" class="headerlink" title="2023年9月21日"></a>2023年9月21日</h4><ol>
<li>矩阵加速递推<br>Fibonacci 数列的项公式推导。<br>不动点法？求解微分方程？</li>
<li>康托展开与康托逆展开 直接看 OI-Wiki 就行<br>全排列 next_permutation 函数</li>
<li>Hanoi 问题的数学方法求解(无需开辟新空间，直接输出移动方式)<br>对于 最小块的移动 是隔一个移动一次，而且是有规律的<br>lowbit 函数可以知道移动哪一个块<br>根据最小块的移动规律和lowbit函数就可以直接计算出哪一块移动到哪一个地方了</li>
</ol>
<h4 id="2023年9月27日"><a href="#2023年9月27日" class="headerlink" title="2023年9月27日"></a>2023年9月27日</h4><ol>
<li>二叉树中序遍历和前序或者中序和后序可以确定二叉树的结构</li>
<li>二叉树的层序遍历、中序遍历、前序遍历、后序遍历的非递归实现</li>
<li>二叉树的括号形式解析和输出二叉树的括号形式，当然是非递归形式。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>hexo博客食用指北</title>
    <url>/2023/11/12/hexo%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h4 id="字体的配置"><a href="#字体的配置" class="headerlink" title="字体的配置"></a>字体的配置</h4><p>参见 </p>
<p><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/">https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E5%AD%97%E4%BD%93%E8%AE%BE%E7%BD%AE/</a></p>
<p>对于字体大小的设置：</p>
<p><a href="https://marshzero.github.io/2021/12/09/Hexo%20NexT%20%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96%20%E7%B1%BBMeme/">https://marshzero.github.io/2021/12/09/Hexo%20NexT%20%E5%AD%97%E4%BD%93%E7%BE%8E%E5%8C%96%20%E7%B1%BBMeme/</a></p>
<h4 id="数学公式的配置"><a href="#数学公式的配置" class="headerlink" title="数学公式的配置"></a>数学公式的配置</h4><p>使用 mathjax 渲染，卸载掉之前的插件。</p>
<p>具体参见：</p>
<ol>
<li><p><a href="https://blog.csdn.net/weixin_45073562/article/details/120289648">https://blog.csdn.net/weixin_45073562/article/details/120289648</a></p>
</li>
<li><p><a href="https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E9%85%8D%E7%BD%AEMathJax/">https://hexo-next.readthedocs.io/zh-cn/latest/next/advanced/%E9%85%8D%E7%BD%AEMathJax/</a></p>
</li>
</ol>
<h4 id="评论系统的配置"><a href="#评论系统的配置" class="headerlink" title="评论系统的配置"></a>评论系统的配置</h4><p>有两种评论区配置方式。</p>
<p>第一种是配置 <code>Waline</code>，下面是参考博客：</p>
<ol>
<li><p><a href="https://blog.csdn.net/weixin_48927364/article/details/123321038">https://blog.csdn.net/weixin_48927364/article/details/123321038</a></p>
</li>
<li><p><a href="https://qianfanguojin.top/2022/01/20/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0-Waline-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/">https://qianfanguojin.top/2022/01/20/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%EF%BC%9A%E4%B8%BA-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0-Waline-%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</a></p>
</li>
</ol>
<p>第二种方式比较常见，但是需要科学上网才能使用，使用 disqus 评论系统</p>
<p>参考：</p>
<p><a href="https://bambrow.com/20211130-hexo-comment-disqus/">https://bambrow.com/20211130-hexo-comment-disqus/</a></p>
<h4 id="侧边-menu-的配置"><a href="#侧边-menu-的配置" class="headerlink" title="侧边 menu 的配置"></a>侧边 menu 的配置</h4><p><a href="https://qianfanguojin.top/tags/Hexo/">https://qianfanguojin.top/tags/Hexo/</a></p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p>之前版本的 <code>hexo-asset-image</code> 已经过时了，不更新了。先 <code>npm uninstall hexo-asset-image</code>，再 <code>npm install hexo-asset-img</code>，使用这个新的包。</p>
<p>然后了，打开 hexo 下的 <code>_config.yml</code>，更改 <code>post_asset_folder</code> 为 <code>true</code>。此时，我们已经可以使用 <code>asset_img xxx.png xxx</code> 或者 <code>![](xxx/xxx.jpg)</code></p>
<img src="/2023/11/12/hexo%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/image-20231117222747974.png" class="" title="image-20231117222747974">

<h4 id="配置标签-tags-页面"><a href="#配置标签-tags-页面" class="headerlink" title="配置标签(tags)页面"></a>配置标签(tags)页面</h4><p>先使用 <code>hexo new page tags</code> 命令创建 tags 页面，然后修改 <code>front-matter</code>，在其中添加 <code>type: &quot;tags&quot;</code> 和 <code>layout: &quot;tags&quot;</code></p>
<h4 id="hexo-deploy-报错"><a href="#hexo-deploy-报错" class="headerlink" title="hexo deploy 报错"></a>hexo deploy 报错</h4><p>当执行 <code>hexo d</code> 报错 <code>error: spawn failed...</code> 的时候</p>
<h4 id="修改-sidebar-以及页面主题颜色"><a href="#修改-sidebar-以及页面主题颜色" class="headerlink" title="修改 sidebar 以及页面主题颜色"></a>修改 sidebar 以及页面主题颜色</h4><p>参考：</p>
<ol>
<li><p><a href="https://www.jianshu.com/p/2a8d399f1266">https://www.jianshu.com/p/2a8d399f1266</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_44543463/article/details/119749738">https://blog.csdn.net/weixin_44543463/article/details/119749738</a></p>
</li>
</ol>
<p>不过有些时候还是需要自己打开开发者工具寻找一下，自己修改。因为网上查到的资料使用的 hexo 版本差异很大。</p>
<h4 id="封面图片配置"><a href="#封面图片配置" class="headerlink" title="封面图片配置"></a>封面图片配置</h4><p>参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/1964392">https://cloud.tencent.com/developer/article/1964392</a></p>
<p>但是这种方式插入图片，使用的 CSS 格式和文章中的格式一致，所以感觉可能不是很好修改样式，就先不搞这个了。</p>
<h4 id="段落间距配置"><a href="#段落间距配置" class="headerlink" title="段落间距配置"></a>段落间距配置</h4><p>直接开发者工具找到 <code>h</code> 的配置 CSS 地址，然后修改即可。</p>
<h4 id="配置文章标题悬浮下划线"><a href="#配置文章标题悬浮下划线" class="headerlink" title="配置文章标题悬浮下划线"></a>配置文章标题悬浮下划线</h4><p>此处是受到 Menci 的博客启发，网上找了很久没有找到如何操作。只得查看 Menci 博客源码，直接摘了过来。</p>
<p>Menci 的 OI 博客：<a href="https://oi.men.ci/">https://oi.men.ci/</a></p>
<h4 id="文章首页预览"><a href="#文章首页预览" class="headerlink" title="文章首页预览"></a>文章首页预览</h4><p>如果不使用 description，文章将会全文显示在主页。如果我们想将文章截断，只需要在文章原文中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以只在首页显示这行代码上方的内容。</p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>参考：</p>
<ol>
<li><p><a href="https://cloud.tencent.com/developer/article/1964349">https://cloud.tencent.com/developer/article/1964349</a></p>
</li>
<li><p><a href="https://ioaol.github.io/hexo-github%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE.html">https://ioaol.github.io/hexo-github%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E9%85%8D%E7%BD%AE.html</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab记录</title>
    <url>/2023/08/26/matlab%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/matlab%E7%82%B9%E4%B9%98%E7%82%B9%E9%99%A4.png" class="" title="matlab">

<p>x:y:z 一般表示 x 初值 y 步长 z 终值</p>
<p>if - end 和 if - else - end</p>
<p>x(i) 访问 x 数组中下标为 i 的元素</p>
<p>meshgrid 函数是MATLAB中用于生成网格采样点数的函数，通常进行2D、3D图形的绘制。</p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/meshgrid%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = -10:0.5:10;</span><br><span class="line">y = -10:0.5:10;</span><br><span class="line">[xx, yy] = meshgrid(x, y);</span><br><span class="line">z = xx .^2 - yy .^2;</span><br><span class="line">mesh(xx, yy, z);</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/qq_54186956/article/details/127274462">https://blog.csdn.net/qq_54186956/article/details/127274462</a> sym syms 函数应用</p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/subs%E5%87%BD%E6%95%B0.png" class="">

<p>在命令行输入 <code>format rat</code> 后，输出为分数格式，不再约成小数。</p>
<p>在命令行输入 <code>doc xxx</code> 可以直接查看官方解释 <code>xxx</code> 函数的文档。</p>
<p><code>num2str(xxx)</code> 其中 xxx 是一个数，转换一个行向量，每个字符代表向量的一个元素</p>
<p><code>result = [s1, s2]</code> 进行字符串拼接</p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.jpg" class="">

<p>提取矩阵的行数：$length(A(:,1))$<br>提取矩阵的列数：$length(A(1,:))$</p>
<p>matlab 中读取图片和显示图片函数 <code>imread</code> 和 <code>imshow</code> <a href="https://blog.csdn.net/dp327264/article/details/105087849">https://blog.csdn.net/dp327264/article/details/105087849</a></p>
<p><code>subplot</code> 函数是将多个图片画到一个画面上的工具 <code>subplot(m,n,p)</code> 表示 m 行 n 列从左到右 从上到下第 p 个</p>
<p>灰度图像二值化：图像二值化（ Image Binarization）就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。<br>在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p>
<p>matlab 中关于数字图像处理的工具箱是 IPT(Image Processing Toolbox) </p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/%E7%81%B0%E5%BA%A6%E5%9B%BE.png" class="">
<p>对于汉字处理的话，灰度图会引入误差，所我们转化为二值图。</p>
<p><code>find(xx)</code> 函数可以返回满足 xx 条件的下标组成的行向量。<br>例如 <code>x=[1 2 3 4 5 6 7]; find(x &gt;= 5)</code> 返回的就是：<code>5     6     7</code></p>
<p><code>max(A)</code> A 可以是矩阵或者向量，就是返回其中最大的元素</p>
<p>元组是matlab的数据类型之一，其元胞中可存储文本，数值，矩阵等等不同的数据类型，因此应用较为方便。因此，在采用matlab进行数据处理时，对元组的创建、读取、写入、转化函数的掌握尤为重要。<br><code>cell(dim)</code> 是创建 dim$\times$dim维的空元组，下标必须是正整数，不能是 0.</p>
]]></content>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>nonebot2 配置</title>
    <url>/2023/11/19/nonebot2-%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ol>
<li><p><a href="https://juejin.cn/post/7177022630204014653#heading-17">https://juejin.cn/post/7177022630204014653#heading-17</a></p>
</li>
<li><p><a href="https://www.p0ise.cn/open-source/nonebot2go-cqhttp-build-qqbot.html">https://www.p0ise.cn/open-source/nonebot2go-cqhttp-build-qqbot.html</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/2215226">https://cloud.tencent.com/developer/article/2215226</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/liuzhongkun/p/16716123.html#nonebot2-%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B">https://www.cnblogs.com/liuzhongkun/p/16716123.html#nonebot2-%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B</a></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>nonebot2</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2023/09/04/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h4 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h4><p>B 站：<a href="https://www.bilibili.com/video/BV1Db4y1m7Ho/?p=70&share_source=copy_web&vd_source=ca842ea19ddf18fb9427fb4d903d435a">https://www.bilibili.com/video/BV1Db4y1m7Ho/?p=70&amp;share_source=copy_web&amp;vd_source=ca842ea19ddf18fb9427fb4d903d435a</a></p>
<h4 id="识别网页所用技术"><a href="#识别网页所用技术" class="headerlink" title="识别网页所用技术"></a>识别网页所用技术</h4><p>构建网站所用的技术类型会对我们如何爬取信息产生影响。有一个十分有用的工具可以检查网站构建的技术类型–detectem 模块，该模块需要 python3.5+ 环境以及 Docker</p>
<h4 id="python-读写文件"><a href="#python-读写文件" class="headerlink" title="python 读写文件"></a>python 读写文件</h4><ol>
<li>open() + close()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先打开文件：</span><br><span class="line">f = open(&#x27;C:\\Users\\Administrator\\Desktop\\测试文件.txt&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">#再使用read()方法，查看文件里的内容：</span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line">$关闭文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
注意如果使用 <code>open</code>，结尾一定要使用close（）来关闭文件。原因主要是：</li>
</ol>
<ul>
<li>节约资源和内存耗损；</li>
<li>可以释放所占用的系统资源并尽早将文件置于更安全的状态，只有关闭文件后，文件内容才能同步到磁盘。</li>
</ul>
<ol start="2">
<li><code>with open</code> 推荐使用<br>with 的作用相当于调用close（）方法，因此当我们使用with open( )在对文件操作完成后，无需通过close()关闭文件，文件会自动关闭，这种方法的安全系数更高，同时也避免了有些时候忘记关闭文件的毛病。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;file_name&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;) as f:</span><br></pre></td></tr></table></figure>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class="">
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class=""></li>
</ol>
<h4 id="python-requests-模块"><a href="#python-requests-模块" class="headerlink" title="python requests 模块"></a>python requests 模块</h4><p>python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response = requests.get(url=url, headers=headers)</span><br></pre></td></tr></table></figure>
<p>返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头(200 OK 404 NotFound)、响应内容等。<br>对于其中的content 和 text 属性(通过输出我们可以看到，content 的输出最开始有一个字母 b，表示输出的格式为二进制，所以我们需要重新编码)</p>
<blockquote>
<p>content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 发送GET请求</span><br><span class="line">url = &#x27;https://example.com/some-page&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"># 尝试获取内容的编码方式</span><br><span class="line">encoding = response.apparent_encoding ## 来尝试获取爬取内容的编码方式。这个属性会尝试根据响应内容来猜测编码方式，通常用于解决服务器没有显式提供编码信息的情况。</span><br><span class="line"></span><br><span class="line"># 设置编码方式并解码内容</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line"></span><br><span class="line"># 打印内容</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们一般可以爬取网页的 <code>html</code> 代码。</p>
<h4 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h4><p>其中有三个参数，url，params 和 kwargs，params 传递 get 卸载 URL 中的参数即可。kwargs 我们常写请求头。</p>
<h4 id="python-标准库-os-模块"><a href="#python-标准库-os-模块" class="headerlink" title="python 标准库 os 模块"></a>python 标准库 os 模块</h4><p>Python的os模块是一个用于与操作系统交互的内置模块。它提供了许多功能，允许你执行各种文件和目录操作，例如创建、删除、移动和重命名文件和目录，以及检查文件和目录的属性。下面是一些os模块的常见用法和功能：</p>
<ol>
<li>获取当前工作目录(current work directory)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current_directory = os.getcwd()</span><br><span class="line">print(current_directory)</span><br></pre></td></tr></table></figure></li>
<li>列出目录中的文件和子目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">files_and_dirs = os.listdir(&#x27;/path/to/directory&#x27;)</span><br><span class="line">print(files_and_dirs)</span><br></pre></td></tr></table></figure></li>
<li>创建目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.mkdir(&#x27;/path/to/new_directory&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>删除目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.rmdir(&#x27;/path/to/directory_to_delete&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>检查文件或者目录是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if os.path.exists(&#x27;/path/to/file_or_directory&#x27;):</span><br><span class="line">    print(&quot;存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不存在&quot;)</span><br></pre></td></tr></table></figure>
其他 os 模块<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/os%E6%A8%A1%E5%9D%97.png" class=""></li>
</ol>
<h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath（XML Path Language）是一种用于在XML文档中定位和选择元素的查询语言。它是一种重要的标准，广泛用于XML文档的解析和数据提取。XPath不仅可以用于XML文档，还可以用于HTML文档，因此它在Web开发和数据抓取中也非常有用。 (感觉可能类似于正则表达式？只是另一种不同的方式)</p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/xpath.png" class="">
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E6%9C%AA%E7%9F%A5%E8%8A%82%E7%82%B9.png" class="">

<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><code>Regular Expression</code> 或者简称 <code>regex, RE</code>.<br>它的设计思想是用一种<strong>描述性的语言</strong>来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<h4 id="RE-库"><a href="#RE-库" class="headerlink" title="RE 库"></a>RE 库</h4><p>RE 库就是正则表达式库，通过 RE 库我们可以匹配某些特定字符串的一些内容，比如爬虫爬取网页的时候，通过 RE 库可以获取网页内容中的某些特定标签内容。<br>量词：</p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%87%8F%E8%AF%8D.png" class="">
<p>字符类：</p>
<ul>
<li><code>[]</code>: 匹配括号内的任意一个字符。例如 <code>[abc]</code> 匹配字符 a、b 或者 c</li>
<li><code>[^ ]</code>: 匹配括号内字符以外的任意一个字符。例如 [^abc] 就是除了 a、b或者c以外的任意字符。 <img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png" class=""></li>
</ul>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><ul>
<li><code>re.search(pattern, string, flags=0)</code> 在字符串中搜索第一个匹配的模式，并返回一个匹配对象。</li>
<li><code>re.match(pattern, string, flags=0)</code> 在字符串的开头匹配模式，并返回一个匹配对象。</li>
<li><code>re.findall(pattern, string, flags=0)</code> 返回一个包含所有匹配项的列表。</li>
<li><code>re.sub(pattern, repl, string, count=0, flags=0)</code> 用指定的替换字符串替换匹配的文本。</li>
<li><code>re.split(pattern, string, maxsplit=0, flags=0)</code> 根据模式拆分字符串。<br>其中 <code>flags</code> 是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。<blockquote>
<p>在Python中，前缀r表示一个原始字符串（raw string）。原始字符串中的反斜杠字符\会被当作普通字符处理，而不会被解释为转义字符。这在处理正则表达式等包含大量反斜杠的字符串时非常有用，因为正则表达式模式本身通常包含许多反斜杠，这些反斜杠需要被保留而不被解释为转义字符。</p>
</blockquote>
</li>
</ul>
<h4 id="url-的组成"><a href="#url-的组成" class="headerlink" title="url 的组成"></a>url 的组成</h4><p>http 协议的端口号一般是 80，https 是 443</p>
<p>分别是 协议、主机、端口号、路径、参数和锚点</p>
<p>User Agent 简称 UA，中文名位用户代理，是一个特殊的字符串头，使得服务器识别用户使用的操作系统及版本、CPU 类型、浏览器版本、浏览器内核、浏览器渲染引擎、浏览器语言和浏览器插件。</p>
<p>我们可以直接百度 UA 大全获得常用的 UA</p>
<p>为了添加 UA，我们可以定制一个 Request</p>
<h4 id="python-urllib-库"><a href="#python-urllib-库" class="headerlink" title="python urllib 库"></a>python urllib 库</h4><p>urrlib 中常用的方法</p>
<p>先创建一个 response 类 <code>response = urrlib.request.urlopen(url)</code></p>
<ol>
<li>reponse.read() 返回按照字节读取的结果，如果我们想改变编码方式加上一个 decode 就可以<br> 如果是写 <code>reponse.read(5)</code> 就是读取了前 5 个字节</li>
<li>reponse.readline() 读取一行、</li>
<li>reponse.readlines() 返回一个 list，包含所有的行</li>
<li>reponse.getcode() 返回状态码，如果是 200 表示没有问题</li>
<li>reponse.geturl() 返回的是 url 地址</li>
<li>reponse.headers() 获得的响应头，包含很多状态信息</li>
<li>urllib.request.urlretrieve(url&#x3D;url, filename&#x3D;’xxx’) 可以下载 url 地址的文件下来</li>
</ol>
<p>其中，urllib.request.urlopen(xxx) 函数，其中的 xxx 可以是一个 url（也就是一串字符串），也可以是一个 Request 对象（包含 url，headers 等一些其余的参数）</p>
<p>如果我们使用协议为 https，但是不加 UA，返回的内容会很少，因为有反爬机制，但是如果使用 http 协议就没有问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">url = &#x27;https://www.baidu.com&#x27;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(url=url, headers=headers)</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line"></span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<p>我们可以使用 urllib.parse.quote(‘xxx’) 来将一段文字转换为 url 中的格式。如果我们需要同时转换多个属性或者说文字，可以使用 urllib.parse.urlencode(‘xxx’)。其中，xxx 是一个参数的字典。</p>
<p>注意使用 GET 方法和 POST 方法时，传递参数的不同</p>
<h4 id="URLError-HTTPError"><a href="#URLError-HTTPError" class="headerlink" title="URLError&#x2F;HTTPError"></a>URLError&#x2F;HTTPError</h4><p>两个异常类，URLError 和 HTTPError</p>
<p>因为我们知道在 URL 结构中包括 HTTP 协议，所以这里的异常类，HTTPError 其实是 URLError 的一个子类。</p>
<h4 id="Handler-处理器"><a href="#Handler-处理器" class="headerlink" title="Handler 处理器"></a>Handler 处理器</h4><p>Handler 可以定制更高级的请求头（相比直接的 headers），比如说动态 cookie 和代理</p>
<h5 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h5><p>代理的常用功能：</p>
<ol>
<li>突破自身 ip 限制，访问国外的一些站点</li>
<li>访问一些单位或者团体内部的资源</li>
<li>提高访问速度，通常代理服务器有一个较大的硬盘缓冲区，当其他用户访问相同信息的时候，则从缓冲区中直接取出信息，提高访问速度。</li>
<li>隐藏真实 ip，上网者可以通过这种方式隐藏自己的 ip，免受攻击</li>
</ol>
<h4 id="python-爬取图片简单示例"><a href="#python-爬取图片简单示例" class="headerlink" title="python 爬取图片简单示例"></a>python 爬取图片简单示例</h4><p>我们打开一个下载图片的网址 <a href="https://pic.netbian.com/new/">https://pic.netbian.com/new/</a><br>我们向这个网站发送请求以后获得的 <code>text</code> 就是网站的 <code>html</code> 代码。我们分析一下其中的 <code>html</code> 代码</p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/html%E4%BB%A3%E7%A0%81.png" class="">
<p>其中的 <code>/uploads/allimg/xxx</code> 就是我们的图片的具体地址。<br>我们可以使用正则表达式(re 库)来获取 <code>html</code> 代码中所有符合图片格式的地址，然后存储到 <code>img</code> 中。再向图片的具体地址发送请求，此时我们使用 python 的文件读写(二进制模式)，就可以批量地将图片下载下来了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url = &quot;https://pic.netbian.com/&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encoding = response.apparent_encoding</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line">parr = re.compile(&#x27;src=&quot;(/u.*?)&quot;.alt=&quot;(.*?)&quot;&#x27;) # 匹配图片链接和图片名字 使用正则表达式</span><br><span class="line">image = re.findall(parr, text) # 所有的图片链接</span><br><span class="line">path = &quot;photos&quot;</span><br><span class="line">if not os.path.isdir(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">for i in image:</span><br><span class="line">    link = i[0]</span><br><span class="line">    name = i[1]</span><br><span class="line">    with open(path+&quot;/&#123;name&#125;.jpg&quot;.format(name),&quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https://pic.netbian.com&quot; + link)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(name+&quot;.jpg 获取成功......&quot;)</span><br></pre></td></tr></table></figure>
<p>爬取王者荣耀头像，感觉写的很丑很傻。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">url = &quot;https://pvp.qq.com/web201605/herolist.shtml&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, &quot;</span><br><span class="line">                  &quot;like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encode = response.apparent_encoding</span><br><span class="line">text = response.content.decode(encode)</span><br><span class="line">pattern = re.compile(r&#x27;(//game.+\.jpg)&#x27;)</span><br><span class="line">pattern1 = re.compile(r&#x27;alt=&quot;(.+?)&quot;&#x27;)</span><br><span class="line">images = re.findall(pattern, text)</span><br><span class="line">names = re.findall(pattern1, text)</span><br><span class="line">path = &quot;heroes&quot;</span><br><span class="line">if not os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">cnt = 0</span><br><span class="line">for element in images:</span><br><span class="line">    cur = element</span><br><span class="line">    with open(path + &quot;/&#123;&#125;.jpg&quot;.format(names[cnt]), &quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https:&quot; + cur)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(&quot;捕获成功&quot;)</span><br><span class="line">    cnt = cnt + 1</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>上面我们都是对于一个接口或者一个网页进行 request 操作。但是有时候我们想得到网页上的若干内容，这就需要我们对于网页进行解析。</p>
<p>市场中，比较主流的解析方式有三种，Xpath、Jsonpath 和 BeautifulSoup。正则的话是比较少用的，因为使用正则表达式解析复杂的HTML或XML结构可能会变得笨拙和容易出错。</p>
<h4 id="lxml-库"><a href="#lxml-库" class="headerlink" title="lxml 库"></a>lxml 库</h4><p>lxml 库是一个使用 python 编写的库，可以迅速、灵活地处理 XML 和 HTML。</p>
<p>其中 lxml.etree 模块是最常用的 HTML、XML 文档解析模块。其中lxml.etree.Element是处理xml的一个核心类，Element对象可以直观的理解为是XML中的节点。使用Element类，可以实现对XML节点、节点属性、节点内文本的操作。</p>
<p><a href="https://blog.csdn.net/weixin_57440207/article/details/116363166">https://blog.csdn.net/weixin_57440207/article/details/116363166</a> lxml 库的基本使用。</p>
<p>示例代码 <code>zhanzhangsucai_jpg.py</code></p>
<h4 id="Jsonpath"><a href="#Jsonpath" class="headerlink" title="Jsonpath"></a>Jsonpath</h4><p>JsonPath 可以解析 json 格式的内容，帮助我们快速定位到特定的节点或值。</p>
<p>JsonPath 只可以解析本地的 json 文件，但是 XPath 可以解析网络上获取的内容或者本地的 HTML，这一方面两者有一些区别</p>
<h4 id="BeautifulSoup-示例、"><a href="#BeautifulSoup-示例、" class="headerlink" title="BeautifulSoup 示例、"></a>BeautifulSoup 示例、</h4><p>相比直接使用 XPath，bs4 的接口更加人性化，我们使用更加方便。但是相比其他的解析库如 lxml，BeautifulSoup 的速度可能会比较慢，因为它是纯用 python 编写的，而不是 C 语言。</p>
<p>所以说，很多时候我们并不选择使用 bs4，即使它比较简单，但是比较慢</p>
<p>上面的都是比较基础的，对于一些动态的网页结构还是无能为力的。<br>我们可以使用 python <code>bs4</code> 库的 <code>BeautifulSoup</code> 库来对于请求后获得的 <code>html</code> 文本进行解析。<br>这是一段爬取豆瓣网站上<code>电影top250</code>的电影名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                  &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for page_num in range(0, 250, 25):</span><br><span class="line">    url = f&quot;https://movie.douban.com/top250?start=&#123;page_num&#125;&amp;filter=&quot;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    encode = response.apparent_encoding</span><br><span class="line">    content = response.content.decode(encode)</span><br><span class="line">    html = BeautifulSoup(content, &#x27;lxml&#x27;)</span><br><span class="line">    titles = html.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)</span><br><span class="line">    for title in titles:</span><br><span class="line">        if &#x27;/&#x27; not in title.string:</span><br><span class="line">            print(title.string)</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>BeatifulSoup(content, &#39;lxml&#39;)</code> 获取的是一个 BeatifulSoup 解析得到的结构。<br>其中 content 就是我们请求网站获得的 html 代码，后面的 <code>lxml</code> 是一个 html 的解析器，我们需要手动指定解析器，因为 BeautifulSoup 不仅仅可以解析 html。<br><code>html = BeautifulSoup(content, &#39;lxml&#39;)</code> 获得到的 html，有许多的方法。<br>其中如果我们想获得哪一元素，比如说段落，就可以直接 <code>html.findAll(&quot;p&quot;)</code> 返回的是一个可以迭代的对象。如果直接写 <code>html.find(&quot;p&quot;)</code> 则是获得的第一个段落元素。<br>如果我们仍想要对于段落进一步细化，我们可以在后面加上参数，其中的格式是若干组键值。比如，我们想获取类名为<code>title</code>的span，就可以写为 <code>titles = html.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)</code><br>对于提取到的元素，我们会获得一个 <code>bs4.element.Tag</code> 就是一个 bs4 中的 Tag 对象，比如说我们有一个 <code>cur</code> 是 <code>bs4.elemnt.tag</code> 对象。<br><code>cur.name</code> 就是输出标签的名字，比如 <code>p</code> <code>img</code> <code>div</code><br>如果我们想要获得里面的单个属性值，就直接 <code>cur[&#39;xx&#39;]</code> 或者 <code>cur.get(&#39;xx&#39;)</code>，如果我们想获取全部的属性值，就是 <code>cur.attrs</code><br>获得标签内的文本，<code>cur.get_text()</code></p>
<h4 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h4><p>前面都是模拟发送一个 <code>request</code> 获得返回，下面是真是模拟我们打开浏览器后进行操作。<br>Python 中的 Selenium 是一个用于自动化网页操作和测试的强大工具。它提供了一种方式来模拟用户在浏览器中的操作，例如打开网页、填写表单、点击按钮、抓取数据等。<br>Selenium 的核心之一就是 WebDriver，它是一个接口，允许我们与不同的浏览器进行交互。我们需要下载与我们所使用浏览器相对应的 WebDriver 驱动程序。将 WebDriver 的路径指定为您的 Python 脚本中。</p>
<p>下面是一段打开百度首页并且搜索「你好」的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line">from selenium.webdriver.common.by import By # 使用 find_element by=xxx 一定要引入这个</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;kw&#x27;).send_keys(&#x27;你好&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;su&#x27;).click()</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure>
<p>下面是查找元素的 by 赋值情况，后面的 <code>value</code> 就是目标的索引值。这是新版本的 <code>find</code> 操作，之前的 <code>find_element_by</code> 方法现在已经弃用。</p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/selenium%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0.png" class="">

<p>对于查找后，如果是 <code>find_elements</code> 得到的是一个链表，如果是 <code>find_element</code> 得到的是一个 <code>&lt;class &#39;selenium.webdriver.remote.webelement.WebElement&#39;&gt;</code>，后面对于这个类元素，我们可以 <code>xxx.click()</code> 点击<br><code>xxx.send_keys(&quot;xxx&quot;)</code> 发送信息<br><code>xxx.text</code> 获取文本<br><code>xxx.clear()</code> 清除元素内容 如 input 中的内容<br><code>get_attribute(&quot;value&quot;)</code> 获得<code>value</code>的属性值<br><code>current_url</code> 可以获取当前页面的 url</p>
<p>下面是更深入的对于鼠标和键盘<br>模拟鼠标操作需要读入类 <code>ActionChains</code><br><code>from selenium.webdriver.common.action_chains import ActionChains</code></p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C.png" class="">

<p>模拟键盘操作的话，也需要导入键盘的类<br><code>from selenium.webdriver.common.keys import Keys</code></p>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C.png" class="">

<h5 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h5><p>遇到使用ajax加载的网页，页面元素可能不是同时加载出来的，这个时候尝试在get方法执行完成时获取网页源代码可能并非浏览器完全加载完成的页面。所以，这种情况下需要设置延时等待一定时间，确保全部节点都加载出来。<br>有三种方式：</p>
<ol>
<li>强制等待<br>直接 <code>time.sleep(xx)</code>(记得先导入包 <code>import time</code>)</li>
<li>隐式等待<br><code>implicitly_wait(xx)</code> 设置等待时间，如果到时间还有元素没有加载出来就会抛出异常。</li>
<li>显式等待<br>设置一个等待时间和等待条件，在规定时间内，每隔一段时间查看下条件是否成立，如果成立那么程序就继续执行，否则就抛出一个超时异常。</li>
</ol>
<h5 id="对-Cookie-的操作-亦称为-Http-Cookie"><a href="#对-Cookie-的操作-亦称为-Http-Cookie" class="headerlink" title="对 Cookie 的操作(亦称为 Http Cookie)"></a>对 Cookie 的操作(亦称为 Http Cookie)</h5><p>Cookie 通常用于在客户端（浏览器）和服务器之间存储一些小型数据，以便在用户与网站进行交互时进行识别、跟踪和状态管理。</p>

<p>爬虫中常常使用 selenium + requests 实现 cookie持久化，即先用 selenium 模拟登陆获取 cookie ，再通过 requests 携带 cookie 进行请求。<br><code>webdriver</code> 提供 cookie 的几种操作：读取、添加和删除。</p>
<ol>
<li>get_cookies：以字典的形式返回当前会话中可见的 cookie 信息。</li>
<li>get_cookie(name)：返回 cookie 字典中key &#x3D;&#x3D; name 的 cookie 信息</li>
<li>dd_cookie(cookie_dict)：将 cookie 添加到当前会话中</li>
<li>delete_cookie(name)：删除指定名称的单个 cookie</li>
<li>delete_all_cookies()：删除会话范围内的所有cookie</li>
</ol>
<p><a href="https://blog.csdn.net/kobepaul123/article/details/128796839">https://blog.csdn.net/kobepaul123/article/details/128796839</a><br><a href="https://blog.csdn.net/weixin_50835854/article/details/117170894">https://blog.csdn.net/weixin_50835854/article/details/117170894</a> selenium 爬取图片<br><a href="https://zhuanlan.zhihu.com/p/270391233">https://zhuanlan.zhihu.com/p/270391233</a><br><a href="https://blog.csdn.net/qq_37267676/article/details/111667266">https://blog.csdn.net/qq_37267676/article/details/111667266</a><br><a href="https://zhuanlan.zhihu.com/p/366773104">https://zhuanlan.zhihu.com/p/366773104</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">for index in range(0, 250, 25):</span><br><span class="line">    driver.get(f&#x27;https://movie.douban.com/top250?start=&#123;index&#125;&amp;filter=&#x27;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    list = driver.find_elements(by=By.XPATH, value=&#x27;//div[@class=&quot;pic&quot;]/a/img&#x27;)</span><br><span class="line">    for cur in list:</span><br><span class="line">        print(cur.get_attribute(&#x27;alt&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="selenium-和-splinter"><a href="#selenium-和-splinter" class="headerlink" title="selenium 和 splinter"></a>selenium 和 splinter</h4><p>splinter和selenium都是用于测试网页的程序，可以模拟浏览器操作，进行自动化测试，可以用于爬虫，自动抢票，网页自动化处理等。Selenium是Splinter的底层，Splinter是Selenium的一个上层封装。使用splinter和selenium时也会用到和html，css相关的使用。</p>
<h4 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h4><p><code>Scrapy</code> 是一个异步网络 python 爬虫框架，可以高效地处理大量的请求和响应。它能够并行发送HTTP请求，从而加快数据抓取速度。异步处理允许我们同时处理多个请求而无需等待每一个请求的完成，这对于大规模的数据抓取任务十分有用。<br>它的优势：</p>
<ol>
<li>内置选择器(Selector)，使用 XPath 或者 CSS 选择器语法，使我们可以轻松获取 HTML 文档中的数据(我们不需要再去使用 bs4 ?)。</li>
<li>模块化和可扩展性<br>允许我们将爬虫任务分解为多个模块，包括爬虫、中间件、管道等，使代码易于维护和扩展。</li>
<li>自动化处理<br>Scrapy提供了强大的自动化功能，包括请求的调度、URL跟踪、重试失败的请求等。它还支持自动限速，以避免过度请求目标网站，从而遵守网站的使用政策。</li>
<li>内置 HTTP 请求处理<br>Scrapy可以处理HTTP请求和响应的所有细节，包括Cookies、User-Agent、重定向、状态码处理等。这减轻了用户的负担，让你专注于爬取和数据处理。</li>
</ol>
<p><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">https://www.runoob.com/w3cnote/scrapy-detail.html</a> 上面讲解了 Scrapy 的爬行流程，感觉还是挺形象的。只有当调度器中不存在任何 request 的时候，整个程序才会停止，又因为对于下载失败的 url 会再次进入 scheduler(调度器)，所以对于下载失败的 url，Scrapy 会重新进行下载。</p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 连接</title>
    <url>/2024/01/31/ssh-%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h4 id="SSH-原理"><a href="#SSH-原理" class="headerlink" title="SSH 原理"></a>SSH 原理</h4><p>SSH 全称是 Secure Shell，是一种网络安全协议，用于在不安全的网络上安全地进行网络服务。传统的登陆或者文件传输方式，例如 Telnet、FTP，使用明文传输数据，存在很多的安全隐患。</p>
<p>SSH 由客户端和服务器组成，默认的端口号是 22。</p>
<p>关于 SSH 的身份认证，可以是密码(passWord)认证、密钥(publicKey)认证，对于密码认证很好理解，就是输入对方的密码看是否正确。对于 SSH 的密钥认证：</p>
<ul>
<li>在进行 SSH 连接之前，SSH 客户端先生成自己的公钥私钥对，将自己的公钥存放在 SSH 服务器上。</li>
<li>SSH 客户端发送登陆请求，SSH 服务器根据请求中的用户名等信息搜索客户端的公钥，并且使用这个公钥加密随机数发送给客户端</li>
<li>客户端使用自己的私钥对于返回的信息解密，返回给服务器</li>
<li>服务器验证客户端解密的信息是否正确，如果正确则认证通过</li>
</ul>
<p>详细的解释与图片可以看：<a href="https://www.51cto.com/article/706122.html">https://www.51cto.com/article/706122.html</a></p>
<h4 id="SSH-客户端"><a href="#SSH-客户端" class="headerlink" title="SSH 客户端"></a>SSH 客户端</h4><p>SSH 客户端是一种允许用户连接到远程计算机或服务器的程序或工具。这些客户端使用 SSH 协议。常见的客户端有 OpenSSH、PuTTY、Termius。</p>
<h4 id="SSH-密钥生成"><a href="#SSH-密钥生成" class="headerlink" title="SSH 密钥生成"></a>SSH 密钥生成</h4><p>SSH 支持多种密钥生成算法，常见的有：RSA、DSA、ECDSA 和 Ed25519。</p>
<ol>
<li><p>RSA（Rivest-Shamir-Adleman）： RSA是一种非对称加密算法，广泛用于SSH密钥对的生成。它基于两个大素数的乘积，其中一个用于私钥，另一个用于公钥。</p>
</li>
<li><p>DSA（Digital Signature Algorithm）： DSA也是一种非对称加密算法，用于数字签名和密钥交换。在SSH中，DSA密钥通常用于数字签名和身份验证。</p>
</li>
<li><p>ECDSA（Elliptic Curve Digital Signature Algorithm）： ECDSA是一种基于椭圆曲线的非对称加密算法。相对于RSA和DSA，它在相同的安全级别下使用更短的密钥，提供了更高的性能。</p>
</li>
<li><p>Ed25519： Ed25519是基于椭圆曲线的签名算法，提供了更高的安全性和性能。在SSH中，Ed25519密钥对通常用于签名和身份验证。</p>
</li>
</ol>
<h4 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h4><p>我们生成 SSH 密钥以后，一般会存储在 <code>~/.ssh/</code> 下面。其中，我们可以创建一个 <code>config</code> 文件，调整一些 SSH 连接时的信息。如果我们有 <code>authorized_keys</code> 文件，里面存储着其余设备的公钥，表示他们可以直接免密连接我们。</p>
<h4 id="Windows-配置-SSH"><a href="#Windows-配置-SSH" class="headerlink" title="Windows 配置 SSH"></a>Windows 配置 SSH</h4><p>关于 Windows 配置 SSH 的文章 </p>
<p><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?source=recommendations&tabs=gui">https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse?source=recommendations&amp;tabs=gui</a></p>
<p><a href="https://www.cnblogs.com/LiTry/p/16943665.html">https://www.cnblogs.com/LiTry/p/16943665.html</a></p>
<p><a href="https://blog.csdn.net/HL477/article/details/122045324">https://blog.csdn.net/HL477/article/details/122045324</a></p>
]]></content>
  </entry>
  <entry>
    <title>tmux 使用</title>
    <url>/2024/02/01/tmux-%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li><p><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/98384704">https://zhuanlan.zhihu.com/p/98384704</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>shell</title>
    <url>/2024/02/11/shell/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一个命令行解释器，相当于是包在内核外面的一个外壳，是底层操作系统核心和外部应用的一个接口，可以进行一些翻译和解释。</p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>最初的 Shell 来自 Unix 的 Bourne Shell，但是这一个版本和用户的交互比较差。后来基于它，发展出来了 Bash Shell，目前大部分 Linux 的发行版默认的 Shell 都是 Bash Shell（红帽系都是 Bash Shell，但是 Debian 系下面的使用的是 Dash Shell）。我们可以使用命令 <code>echo $SHELL</code> 来查看当前的解释器。</p>
<p>对于 Shell 脚本文件，一般是 <code>.sh</code> 结尾，但是其实对于 Shell 解析的过程，我们对于文件名字没有要求，只不过约定俗称加一个 <code>.sh</code> 后缀。</p>
<h4 id="常见的-Shell-版本"><a href="#常见的-Shell-版本" class="headerlink" title="常见的 Shell 版本"></a>常见的 Shell 版本</h4><p>Bash（Bourne Again Shell）、C Shell、Korn Shell 还有一些其他的 Shell 变体和实现，例如 Zsh、Fish Shell、Dash 等。</p>
<h4 id="常见执行方式"><a href="#常见执行方式" class="headerlink" title="常见执行方式"></a>常见执行方式</h4><ol>
<li><p>采用 bash 或者 sh 加上脚本的相对路径或者绝对路径（不用赋予脚本 +x 权限）</p>
</li>
<li><p>采用输入脚本的绝对路径或者相对路径执行脚本（必须具有可执行权限+x）（采用相对路径和绝对路径来执行的话是重新打开了一个子 bash 来执行）</p>
</li>
<li><p>在路径前面加上 <code>source</code> 或者 <code>.</code> 来执行脚本（这两种方法是直接在当前的 bash 环境中执行）。</p>
</li>
</ol>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>Shell 中的变量可以分为两大类，一大类就是系统给我们直接定义好的所有系统变量；另一大类就是用户自定义的变量。还有一种划分维度是，Shell 变量可以分为全局环境变量（对于当前的 Shell 和它里面的子对话，这个变量都是可见的）和局部环境变量（只针对当前的 Shell 是可见的，对于子 Shell 不可见）。</p>
<p>可以使用 set 指令来查看所有的变量。</p>
<h5 id="系统预定义变量"><a href="#系统预定义变量" class="headerlink" title="系统预定义变量"></a>系统预定义变量</h5><p>常用系统变量 $HOME $PWD $SHELL $USER</p>
<h5 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h5><h6 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h6><ol>
<li><p>基本语法：变量名&#x3D;变量值（注意，「&#x3D;」前后不可以有空格，因为 shell 中，空格表示命令和参数之间的间隔）（类型并不是静态的，我们不关心变量类型）</p>
</li>
<li><p>可以使用 <code>unset 变量名</code> 来撤销变量，但是 readonly 的变量不可以直接 unset</p>
</li>
<li><p>我们可以使用 <code>readonly</code> 关键字来定义只读变量，<code>readonly b=5</code>，但是 b 是我们定义的一个常量，不可以直接 unset</p>
</li>
</ol>
<p>我们定义的变量在 env 中找不到，但是在 set 中可以找到。因为 env 中可以看到的是系统帮我们定义好的全局变量，set 是包含了所有的系统定义的、用户定义的全局变量和局部变量。</p>
<p>我们这样直接定义的就是局部变量，可以使用 <code>export 变量名</code> 来提升为全局变量</p>
<h6 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h6><ol>
<li><p>不能以数字开头，环境变量名建议大写</p>
</li>
<li><p>在 bash 中，变量默认都是字符串类型，无法直接进行数值计算</p>
</li>
<li><p>变量的值如果有空格，需要使用双引号或者单引号括起来</p>
</li>
</ol>
<h5 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h5><ol>
<li><p>$n<br> n 为数字，$0 表示该脚本的名称（带有路径的名字），$1-9 表示第一到第九个参数，十以上的参数，需要使用大括号包含，如 ${10}<br> 单引号中，不会认为 <code>$n</code> 是一个变量，但是双引号就会</p>
</li>
<li><p>$#<br> 获取我们当前输入参数的个数，常用语循环操作，判断参数的个数是否正确及增强程序的健壮性</p>
</li>
<li><p>$* 和 $@<br> 两个变量比较类似，都是获取当前脚本的所有参数。<br> 但是 $* 是把所有的参数看成一个整体；$@ 是把所有的参数看成一个集合，类似于数组，可以使用 for 循环来遍历</p>
</li>
<li><p>$?<br> 当前最后一次执行命令的返回状态<br> 如果为 0，表示正常执行结束；一般的错误是返回 1</p>
</li>
</ol>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>Linux Shell 中有一个专门用于计算的表达式 <code>expr 1 + 2</code>，必须有空格，相当于把 1、+、2 作为 <code>expr</code> 的参数传递进去。但是这样过于麻烦了，于是就设计了一种加上 <code>$</code> 的方法。</p>
<p>基本语法：<code>$((运算式))</code> 或者 <code>$[运算式]</code>，比起 expr 来讲就会简单很多，其中的运算式可以是数字和变量的任意组合。</p>
<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p>一个编程语言少不了对于流程的控制</p>
<p>可以使用 <code>[ condition ]</code> 来判断，但是前后必须有空格。判断相等的时候等号两边也必须有空格，比如说 <code>[ $a = hello ]</code>。因为如果我们不加空格的话，就会把中间的 condition 认为是一体。</p>
<p>Linux Shell 中没有使用 <code>&lt;</code> 或者 <code>&gt;</code> 来进行数值判断功能的，因为 <code>&gt;</code> 表示的是输出重定向，<code>&lt;</code> 表示的是输入重定向。</p>
<h5 id="常用判断条件"><a href="#常用判断条件" class="headerlink" title="常用判断条件"></a>常用判断条件</h5><ol>
<li><p>两个整数之间的比较<br> -eq 等于<br> -ne 不等于<br> -lt 小于<br> -le 小于等于<br> -gt 大于<br> -ge 大于等于</p>
</li>
<li><p>字符串之间使用 &#x3D; 和 !&#x3D; 来判断</p>
</li>
<li><p>对文件权限的判断<br> -r 有读的权限<br> -w 有写的权限<br> -x 有执行的权限</p>
</li>
<li><p>对文件类型进行判断<br> -e 文件存在（existence）<br> -f 文件存在并且是一个常规的文件 file<br> -d 文件存在并且是一个目录 directory</p>
</li>
</ol>
<p>多条件判断：使用 &amp;&amp; 和 || 来分别表示「且」和「或」，一个比较常用的写法，例如 <code>[ $a -lt 20] &amp;&amp; echo &quot;$a &lt; 20&quot; || echo &quot;$a &gt;= 20&quot;</code></p>
<p>并且对于一个中括号内的多个条件判断，我们可以在中间加 -a 表示 and，-o 表示 or</p>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>是整个写一个程序的重点，程序结构主要是三大流程：顺序、分支、循环</p>
<h5 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h5><ol>
<li><p>单分支</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ condition ]; then</span><br><span class="line">    程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">    程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p> 别的语言一般都是使用括号来表示 if 后面的逻辑，但是在 Shell 中花括号都是有着自己的用途，所以我们不能再使用了，就是用这种 then、fi 的结构来表示 if。<br> 其中，第一种表示方法中的 <code>;</code> 表示的是把两个命令分开来。在 Shell 本身中，分号就是这个作用，并不是因为 if 而特殊处理。</p>
</li>
<li><p>多分支</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">    程序</span><br><span class="line">elif [ condition ]</span><br><span class="line">then</span><br><span class="line">    程序</span><br><span class="line">else</span><br><span class="line">    程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h5><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>1.<br>    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">then</span><br><span class="line">    程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<pre><code>在 `(())` 中，我们可以直接书写一些数学运算式

一种方式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=100;i++ ))</span><br><span class="line">do</span><br><span class="line">        sum=$[ $sum + $i ]</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><pre><code> for 变量 in 值1 值2 值3
 do
     程序
 done
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Linux 的 Shell 里面有一个内部运算符，表达式就是 `&#123;&#125;`，表示一个序列，这也是为什么我们不能使用它来写 if 结构和 for 结构。</span><br><span class="line"></span><br><span class="line">如果表示 1 到 100 的一个序列：`&#123;1..100&#125;`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 for i in &#123;1..100&#125;; do sum=$[$sum + $i]; done; echo $sum
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### while 循环</span><br><span class="line"></span><br></pre></td></tr></table></figure>
while [ condition ]
do
 程序
done
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### read 读取控制台输入</span><br><span class="line"></span><br><span class="line">基本语法：read 选项 参数</span><br><span class="line"></span><br><span class="line">其中，选项：</span><br><span class="line">    -p: 指定读取值时的提示符</span><br><span class="line">    -t: 指定读取值时的时间（秒），如果不 -t 表示一直等待</span><br><span class="line"></span><br><span class="line">参数：指定读取值的变量名</span><br><span class="line"></span><br><span class="line">#### 函数</span><br><span class="line"></span><br><span class="line">Linux 中有很多系统函数，我们也可以做自定义的函数</span><br><span class="line"></span><br><span class="line">##### basename</span><br><span class="line"></span><br><span class="line">basename [string/pathname] [suffix] basename 命令会删除所有的前缀包括最后一个 / 字符，然后将字符串显示出来。</span><br><span class="line"></span><br><span class="line">suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname/string 中的 suffix 去掉。</span><br><span class="line"></span><br><span class="line">##### dirname</span><br><span class="line"></span><br><span class="line">与 basename 相反，截取最后一个 / 字符前面的路径</span><br><span class="line"></span><br><span class="line">##### 自定义函数</span><br><span class="line"></span><br><span class="line">上面的两个函数是两个系统函数，下面介绍一下自定义函数。</span><br><span class="line"></span><br><span class="line">基本语法：</span><br></pre></td></tr></table></figure>
 [ function ]funname[()] &#123;
     Action;
     [return int;]
 &#125;
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">经验技巧：</span><br><span class="line"></span><br><span class="line">    1. 必须在函数调用之前先声明函数，shell 脚本是逐行运行，不会像其他语言一样先进行编译</span><br><span class="line"></span><br><span class="line">    2. 函数返回值只可以由系统变量 $? 获得，return 后跟数值 n(0-255)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>function add() {<br>        sum&#x3D;$[$1 + $2]<br>        echo “sum is $sum”<br>}</p>
<p>read -p “enter the first number: “ a</p>
<p>read -p “enter the second number: “ b</p>
<p>add $a $b</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 综合应用</span><br><span class="line"></span><br><span class="line">一个归档脚本</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>if [ $# -ne 1 ]<br>then<br>        echo “the number of para is wrong”<br>        exit<br>fi</p>
<p>if [ -d $1 ]<br>then<br>        echo<br>else<br>        echo<br>        echo “the directory is not exist”<br>        exit<br>fi</p>
<p>DIR_NAME&#x3D;$(basename $1)<br>DIR_PATH&#x3D;$(cd $(dirname $1); pwd)</p>
<p>DATE&#x3D;$(date +%y%m%d)</p>
<p>FILE_NAME&#x3D;archive_$DIR_NAME_$DATE.tar.gz</p>
<p>DEST&#x3D;&#x2F;home&#x2F;miraclys&#x2F;$FILE_NAME</p>
<p>tar -czf $DEST $DIR_PATH&#x2F;$DIR_NAME</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 正则表达式</span><br><span class="line"></span><br><span class="line">特殊字符：</span><br><span class="line"></span><br><span class="line">    1. `^` 可以匹配一行的开头，</span><br></pre></td></tr></table></figure>
<pre><code>    cat /etc/passwd | grep ^a 
    ```
    表示匹配以 a 开头的一行

2.`$` 匹配一行的结束

3. `^$` 可以匹配空行

4. `.` 可以匹配任意一个字符（除了换行符 \n）

5. .* 可以用来表示任意字符出现任意多次

6. [] 来表示一个字符区间 [6,8] 匹配 6 或者 8
</code></pre>
<h4 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h4><h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><h5 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h5>]]></content>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2023/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>具体的更多可以参见代码 <code>GetTreeOrderNor.cpp</code> 和 <code>ParseTreeSequence.cpp</code></p>
<p>这是一段输入先序遍历和中序遍历输出后序遍历的代码。</p>
<figure class="highlight plaintext"><figcaption><span><iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    public:</span><br><span class="line">        char value;</span><br><span class="line">        TreeNode* leftChild;</span><br><span class="line">        TreeNode* rightChild;</span><br><span class="line">        TreeNode(char val) : value(val), leftChild(nullptr), rightChild(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* buildTree(std::vector&lt;char&gt; preOrder, std::vector&lt;char&gt; inOrder) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;char, int&gt; vis;</span><br><span class="line">    for (int i = 0; i &lt; inOrder.size(); ++i) &#123;</span><br><span class="line">        vis[inOrder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = new TreeNode(preOrder[0]);</span><br><span class="line">    s.push(root);</span><br><span class="line">    for (int i = 1; i &lt; preOrder.size(); ++i) &#123;</span><br><span class="line">        TreeNode* curNode = new TreeNode(preOrder[i]);</span><br><span class="line">        TreeNode* parent = nullptr;</span><br><span class="line">        while (!s.empty() &amp;&amp; vis[s.top()-&gt;value] &lt; vis[preOrder[i]]) &#123;</span><br><span class="line">            parent = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent) &#123;</span><br><span class="line">            parent-&gt;rightChild = curNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            s.top()-&gt;leftChild = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(curNode);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPostOrder(TreeNode* root) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;TreeNode*, bool&gt; tag;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    while (!s.empty() || cur) &#123;</span><br><span class="line">        if (cur) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;leftChild;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (tag[s.top()] == 1) &#123;</span><br><span class="line">                std::cout &lt;&lt; s.top()-&gt;value;</span><br><span class="line">                s.pop();</span><br><span class="line">                cur = nullptr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tag[s.top()] = 1;</span><br><span class="line">                cur = s.top()-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string pre, in;</span><br><span class="line">    while (std::cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">        std::vector&lt;char&gt; preOrder(pre.begin(), pre.end());</span><br><span class="line">        std::vector&lt;char&gt; inOrder(in.begin(), in.end());</span><br><span class="line">        TreeNode* root = buildTree(preOrder, inOrder);</span><br><span class="line">        getPostOrder(root);</span><br><span class="line">        std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python 数学建模与实验</title>
    <url>/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>虽然列表 list 可以完成数组操作，但不是真正意义上的数组，当数据量很大时，其速度很慢，故提供了 NumPy 扩展库完成数组操作。很多高级扩展库也依赖于它，比如 Scipy, Pandas 和 Matplotlib 等。</p>
<p>数组创建的几种方式：</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA.png" class="">

<p>NumPy 中的数组 array 和 list 的区别是：列表中可以是数据类型不同的元素，而 array 数组只允许存储相同数据类型。</p>
<p>二维数组中的索引 list 为 a[i][j] 而 array 为 a[i, j]</p>
<p>一般索引：<br>感觉有的地方还是和 matlab 很相似的。</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%B8%80%E8%88%AC%E7%B4%A2%E5%BC%95.png" class="">

<p>文本文件读取：</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E6%9C%AC%E8%AF%BB%E5%8F%96.png" class="">
<p>二进制文件读取：</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" class="">
<p>另外，如果我们使用 NumPy 专用的二进制存取函数 <code>load() save() savez()</code> 会自动处理元素的类型和形状等信息。</p>
<p>open 打开文件的时候，如果打开的文件不在当前的目录，需要指定完整路径。注意，此时文件路径中的 <code>\</code> 要改为 <code>\\</code>，例如 <code>e:\mypython\test.txt</code> 应该改为 <code>e:\\mypython\\test.txt</code>.</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F.png" class="">

<p>join 函数：</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/join%E5%87%BD%E6%95%B0.png" class="">

<h4 id="数据处理工具-Pandas"><a href="#数据处理工具-Pandas" class="headerlink" title="数据处理工具 Pandas"></a>数据处理工具 Pandas</h4><p>Pandas(Panel data, 面板数据) 是在 NumPy 的基础上开发的，是 Python 最强大的数据分析和探索工具之一。</p>
<h4 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h4><p>Matplotib 是 Python 强大的数据可视化工具，类似于 MATLAB 语言。</p>
<p>pie 绘制饼状图 bar 绘制柱状图 hist 绘制二维直方图 scatter 绘制散点图</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%E9%A2%9C%E8%89%B2.png" class="">

<h4 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h4><p>scipy 包含各种专用于科学计算常见问题的工具箱。其中 scipy.stats 则是统计和随机数的专门的库。<br>NumPy 能生成一定概率分布的随机数，但是如果需要更具体的概率密度、分布函数等，就用到 scipy.stats 模块了。Python 做简单的统计分析也可以用 scipy.stats 模块。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>二维线段树</title>
    <url>/2023/11/27/%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>二维线段树是一类算法竞赛中不常用的用来维护二维平面上的一个矩阵中的信息（如矩阵和、矩阵中的最大值）的数据结构，主流的二位线段树有两种写法：</p>
<ul>
<li>四叉树写法</li>
<li>树套树写法</li>
</ul>
<p>两种写法的时间复杂度理论上都是 $n\log^{2}n$ 。其中，第一种写法的用途更加广泛，也更好理解，但是时间复杂度经常假到 $n^{2}$ 并且还有比较大的常数。</p>
<p><strong>区间修改 - 区间查询</strong></p>
<p><strong>单点修改 - 区间查询</strong></p>
<h4 id="四叉树写法"><a href="#四叉树写法" class="headerlink" title="四叉树写法"></a>四叉树写法</h4><p>这种方式比较亲民，我们先看这种方式。</p>
<p>类比一维线段树，我们二维线段树将几个区间分割为四个部分，如下图：</p>
<img src="/2023/11/27/%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91/image-20231127103222950.png" class="" title="image-20231127103222950">

<h4 id="树套树写法"><a href="#树套树写法" class="headerlink" title="树套树写法"></a>树套树写法</h4><p>我们要讲的二维线段树，就是运用的线段树套线段树。</p>
<p>其中，需要使用永久标记。</p>
<h5 id="一维线段树永久标记"><a href="#一维线段树永久标记" class="headerlink" title="一维线段树永久标记"></a>一维线段树永久标记</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, lazy;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125; t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">    t[cur].sum = t[cur &lt;&lt; <span class="number">1</span>].sum + t[cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    t[cur].l = l; t[cur].r = r;</span><br><span class="line">    t[cur].lazy = <span class="number">0</span>; t[cur].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        std::cin &gt;&gt; t[cur].sum;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(cur &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">push_up</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// t[cur].sum += k * (t[cur].r - t[cur].l + 1);</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">min</span>(t[cur].r, r) &gt;= std::<span class="built_in">max</span>(t[cur].l, l)) &#123;</span><br><span class="line">        t[cur].sum += k * (std::<span class="built_in">min</span>(t[cur].r, r) - std::<span class="built_in">max</span>(t[cur].l, l) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r) &#123;</span><br><span class="line">        t[cur].lazy += k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (t[cur].l + t[cur].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">add</span>(cur &lt;&lt; <span class="number">1</span>, l, r, k);</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) <span class="built_in">add</span>(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[cur].l &gt;= l &amp;&amp; t[cur].r &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[cur].sum + sum * (t[cur].r - t[cur].l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (t[cur].l + t[cur].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) res += <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span>, l, r, sum + t[cur].lazy);</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= mid + <span class="number">1</span>) res += <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, sum + t[cur].lazy);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="type">int</span> x, y, k, opt;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        std::cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">1</span>, x, y, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, x, y, <span class="number">0</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记永久化可以用于各种树套树上，同样的，二位线段树也适用。</p>
<p>我们此时再看题目：</p>
<img src="/2023/11/27/%E4%BA%8C%E7%BB%B4%E7%BA%BF%E6%AE%B5%E6%A0%91/image-20231127140825836.png" class="" title="image-20231127140825836">

<p>首先是内层的线段树，内层的线段树的定义要写在外层线段树之前，因为后者会调用前者。内层线段树和普通的线段树是一样的，是否标记永久化都可以：</p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://www.cppblog.com/menjitianya/archive/2015/10/06/211956.html">https://www.cppblog.com/menjitianya/archive/2015/10/06/211956.html</a></li>
</ol>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Segment tree</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h4 id="参考见"><a href="#参考见" class="headerlink" title="参考见"></a>参考见</h4><p><a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a> 组合式公式<br><a href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a> 笔记</p>
<p>一共有两种情况</p>
<p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu">炫酷反演魔术 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a> 介绍了反演的来历、各种反演</p>
<p><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html">二项式反演及其应用 - GXZlegend - 博客园 (cnblogs.com)</a> 有几个题目讲解</p>
<img src="/2023/09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/%E5%BC%95%E7%90%86.png" class="">

<p><a href="https://www.cnblogs.com/GDOI2018/p/14491894.html">二项式反演 - __allenge - 博客园 (cnblogs.com)</a></p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>二项堆</title>
    <url>/2023/10/09/%E4%BA%8C%E9%A1%B9%E5%A0%86/</url>
    <content><![CDATA[<p>二项堆是二项树的集合。</p>
<p>二项树是一种递归定义的有序树，定义如下：</p>
<ol>
<li><p>二项树 B0 只有一个节点</p>
</li>
<li><p>二项树 Bk 由两颗二项树 B(k-1) 组成，其中一棵树是另一棵树的最左孩子。</p>
</li>
</ol>
<h4 id="二项堆的性质"><a href="#二项堆的性质" class="headerlink" title="二项堆的性质"></a>二项堆的性质</h4><ol>
<li>$B_k$ 一共有 $2_k$ 个节点</li>
<li>$B_k$ 的高度为 k</li>
<li>$B_k$ 在深度为 i 处恰好有 $C_k^{i}$ 个节点</li>
<li>根的度数为 k，大于任何其他节点的度数。</li>
</ol>
<h4 id="二项堆的优势和劣势"><a href="#二项堆的优势和劣势" class="headerlink" title="二项堆的优势和劣势"></a>二项堆的优势和劣势</h4><p>其实就是比二叉堆支持了合并操作？<br><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231018140027829.png" alt="image-20231018140027829"></p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinomialHeapNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        <span class="type">int</span> degree;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* sibling;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* child;</span><br><span class="line">        BinomialHeapNode&lt;T&gt;* parent;</span><br><span class="line">        <span class="built_in">BinomialHeapNode</span>(T val)</span><br><span class="line">            : <span class="built_in">value</span>(val)</span><br><span class="line">            , <span class="built_in">degree</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">sibling</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">child</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinomialHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">topNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">top</span>(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unionHeap</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">decrease</span><span class="params">(BinomialHeapNode&lt;T&gt;*, <span class="type">int</span>)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">BinomialHeap</span>() &#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">extractMin</span><span class="params">()</span></span>;  </span><br><span class="line">        BinomialHeapNode&lt;T&gt;* head;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">top</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">linkNode</span><span class="params">(BinomialHeapNode&lt;T&gt;*&amp;, BinomialHeapNode&lt;T&gt;*&amp;)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">mergeTopLink</span><span class="params">(BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function">BinomialHeapNode&lt;T&gt;* <span class="title">getTopLink</span><span class="params">(BinomialHeapNode&lt;T&gt;*, BinomialHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">insert</span>(T val) &#123;</span><br><span class="line">    <span class="built_in">Insert</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">Insert</span>(T val) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">BinomialHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* newNode = <span class="keyword">new</span> <span class="built_in">BinomialHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">    <span class="comment">// BinomialHeapNode&lt;T&gt;* newHead = getTopLink(head, newNode);</span></span><br><span class="line">    newNode-&gt;sibling = head;</span><br><span class="line">    head = newNode;</span><br><span class="line">    head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T BinomialHeap&lt;T&gt;::<span class="built_in">top</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">top</span>(head)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">top</span>(BinomialHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* ans = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ans) ans = cur;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;value &lt; ans-&gt;value) ans = cur;</span><br><span class="line">        cur = cur-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">extractMin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">extractMin</span>() &#123;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* minNode = <span class="built_in">top</span>(head);</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* cur = head;</span><br><span class="line">    <span class="keyword">if</span> (cur == minNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;sibling) &#123;</span><br><span class="line">            head = head-&gt;sibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;sibling != minNode)</span><br><span class="line">            cur = cur-&gt;sibling;</span><br><span class="line">        cur-&gt;sibling = cur-&gt;sibling-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;BinomialHeapNode&lt;T&gt;*&gt; v;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* curNode = minNode-&gt;child;</span><br><span class="line">    <span class="keyword">if</span> (curNode) &#123;</span><br><span class="line">        <span class="keyword">while</span> (curNode) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(curNode);</span><br><span class="line">            curNode = curNode-&gt;sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (BinomialHeapNode&lt;T&gt;* element : v)</span><br><span class="line">            element-&gt;sibling = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            std::<span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">            <span class="comment">// 获取 minNode 的 pre，和 后面连接</span></span><br><span class="line">            <span class="comment">// 取反 v 然后再合并两个根链 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">                v[i]-&gt;sibling = v[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BinomialHeapNode&lt;T&gt;* newHead = getTopLink(head, v[0]);</span></span><br><span class="line">        <span class="comment">// head = mergeTopLink(newHead);</span></span><br><span class="line">        head = <span class="built_in">getTopLink</span>(head, v[<span class="number">0</span>]);</span><br><span class="line">        head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">unionHeap</span>(BinomialHeapNode&lt;T&gt;* h2) &#123;</span><br><span class="line">    head = <span class="built_in">getTopLink</span>(head, h2);</span><br><span class="line">    head = <span class="built_in">mergeTopLink</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">decrease</span>(BinomialHeapNode&lt;T&gt;* cur, <span class="type">int</span> key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur || !head) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;illegal decreasing!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;value -= key;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* parent = cur-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; cur-&gt;value &lt; parent-&gt;value) &#123;</span><br><span class="line">        T temp = cur-&gt;value;</span><br><span class="line">        cur-&gt;value = parent-&gt;value;</span><br><span class="line">        parent-&gt;value = temp;</span><br><span class="line">        cur = parent;</span><br><span class="line">        parent = cur-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> BinomialHeap&lt;T&gt;::<span class="built_in">linkNode</span>(BinomialHeapNode&lt;T&gt;*&amp; cur, BinomialHeapNode&lt;T&gt;*&amp; newNode) &#123;</span><br><span class="line">    newNode-&gt;parent = cur;</span><br><span class="line">    newNode-&gt;sibling = cur-&gt;child;</span><br><span class="line">    cur-&gt;child = newNode;</span><br><span class="line">    ++cur-&gt;degree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">getTopLink</span>(BinomialHeapNode&lt;T&gt;* p1, BinomialHeapNode&lt;T&gt;* p2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* newHead = <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (p1-&gt;degree &lt;= p2-&gt;degree) &#123;</span><br><span class="line">        newHead = p1;</span><br><span class="line">        p = p1;</span><br><span class="line">        p1 = p1-&gt;sibling;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = p2;</span><br><span class="line">        p = p2;</span><br><span class="line">        p2 = p2-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;degree &lt;= p2-&gt;degree) &#123;</span><br><span class="line">            p-&gt;sibling = p1;</span><br><span class="line">            p1 = p1-&gt;sibling;</span><br><span class="line">            p = p-&gt;sibling;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;sibling = p2;</span><br><span class="line">            p2 = p2-&gt;sibling;</span><br><span class="line">            p = p-&gt;sibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1) p-&gt;sibling = p1;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;sibling = p2;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">BinomialHeapNode&lt;T&gt;* BinomialHeap&lt;T&gt;::<span class="built_in">mergeTopLink</span>(BinomialHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* prev = <span class="literal">nullptr</span>;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* x = cur;</span><br><span class="line">    BinomialHeapNode&lt;T&gt;* nxt = x-&gt;sibling;</span><br><span class="line">    <span class="keyword">while</span> (nxt) &#123;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;a&quot;;</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;degree != nxt-&gt;degree || (nxt-&gt;sibling &amp;&amp; nxt-&gt;sibling-&gt;degree == x-&gt;degree)) &#123;</span><br><span class="line">            prev = x;</span><br><span class="line">            x = nxt; <span class="comment">// 连续三个一样的，并且现在的 x 指向了第一个位置 或者 当前不一样和下一个</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;value &lt;= nxt-&gt;value) &#123;</span><br><span class="line">            x-&gt;sibling = nxt-&gt;sibling;</span><br><span class="line">            <span class="built_in">linkNode</span>(x, nxt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur = nxt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev-&gt;sibling = nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">linkNode</span>(nxt, x);</span><br><span class="line">            x = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        nxt = x-&gt;sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>公共关系实务</title>
    <url>/2023/09/18/%E5%85%AC%E5%85%B1%E5%85%B3%E7%B3%BB%E5%AE%9E%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="第二章-公共关系产生与发展"><a href="#第二章-公共关系产生与发展" class="headerlink" title="第二章 公共关系产生与发展"></a>第二章 公共关系产生与发展</h4><p>古代时期–公共关系思想的萌芽</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>公共关系确实有一段黑暗的历史，我们不否认，正视历史。</p>
]]></content>
  </entry>
  <entry>
    <title>割点、割边、缩点、点双和边双</title>
    <url>/2023/11/13/%E5%89%B2%E7%82%B9%E3%80%81%E5%89%B2%E8%BE%B9%E3%80%81%E7%BC%A9%E7%82%B9%E3%80%81%E7%82%B9%E5%8F%8C%E5%92%8C%E8%BE%B9%E5%8F%8C/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>先介绍几个概念：</p>
<p><strong>连通分量</strong>：无向图中，满足任意两点之间都有路径相连的极大连通子图。也就是说，抽离出一些点以及它们之间的边，满足这些点任意两点之间，可以直接或间接到达对方，在这个前提下，满足抽离出的图越大越好，把抽离出的图叫做连通分量。</p>
<p><strong>割点</strong>：无向图中，删除该点及与其相连的边后，图的连通分量数量增加，则称其为割点。换而言之，删除一个割点及相关边后，图中原来连通的两点不再连通，从而使得一个连通分量分裂成两个（或多个）连通分量。</p>
<p><strong>点双连通</strong>：若对于一个无向图，其任意一个节点对于这个图本身而言都不是割点，则称其点双连通。也就是说，删除任意点及其相关边后，整个图仍然属于一个连通分量。</p>
<p><strong>点双连通分量</strong>：无向图中，极大的点双连通子图。与连通分量类似，抽离出一些点及它们之间的边，使得抽离出的图是一个点双连通图，在这个前提下，使得抽离出的图越大越好。</p>
<p>关于tarjan算法，一直有一个很大的争议，就是low[u]&#x3D;min(low[u],dfn[v]);</p>
<p>这句话，如果改成low[u]&#x3D;min(low[u],low[v])就会wa掉，但是在求强连通分量时却没有问题</p>
<p>根据许多大佬的观点，我想提出自己的一点看法，在求强连通分量时，如果v已经在栈中，那么说明u，v一定在同一个强连通分量中，所以到最后low[u]&#x3D;low[v]是必然的，提前更新也不会有问题，但是在求割点时，low的定义有了小小的变化，不再是最早能追溯到的祖先，（因为是个无向图）没有意义，应该是最早能绕到的割点，为什么用绕到，是因为是无向边，所以有另一条路可以走，如果把dfn[v]改掉就会上翻过头，可能翻进另一个环中，所以wa掉，仅是本人的一些个人看法，不知道讲的对不对，请各位指教</p>
<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230401164415969.png" alt="image-20230401164415969"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>割点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt, head[N];</span><br><span class="line"><span class="type">int</span> cot, siz[N], bel[N], dfn[N], low[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">		c = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cot;</span><br><span class="line">	<span class="type">int</span> child = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">		<span class="type">int</span> to = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to]) &#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(to, f);	</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[to]);</span><br><span class="line">			<span class="keyword">if</span> (x == f) ++child;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (low[to] &gt;= dfn[x]) vis[x] = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[to]);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (x == f &amp;&amp; child &gt;= <span class="number">2</span>) vis[x] = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[++cnt].to = y;</span><br><span class="line">	e[cnt].nxt = head[x];</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">add</span>(x, y);</span><br><span class="line">		<span class="built_in">add</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i, i);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (vis[i]) ++ans;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (vis[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缩点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, cnt, m, cot, size, head[N], in[N], bel[N], a[N], low[N], dfn[N], sta[N], vis[N], f[N];</span><br><span class="line"><span class="type">int</span> tot, Head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, next, from;</span><br><span class="line">&#125;e[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EDGE</span> &#123;</span><br><span class="line">	<span class="type">int</span> to, next;</span><br><span class="line">&#125;E[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">		c = <span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	e[++cnt].to = y;</span><br><span class="line">	e[cnt].from = x;</span><br><span class="line">	e[cnt].next = head[x];</span><br><span class="line">	head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	E[++tot].to = y;</span><br><span class="line">	E[tot].next = Head[x];</span><br><span class="line">	Head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++cot;</span><br><span class="line">	sta[++size] = x;</span><br><span class="line">	vis[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> to;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].next) &#123;</span><br><span class="line">		to = e[i].to;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[to]) &#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(to);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[to]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (vis[to]) low[x] = <span class="built_in">min</span>(low[x], dfn[to]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cur;</span><br><span class="line">	<span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">		<span class="keyword">while</span> (size) &#123;</span><br><span class="line">			cur = sta[size--];</span><br><span class="line">			vis[cur] = <span class="number">0</span>;</span><br><span class="line">			bel[cur] = x;</span><br><span class="line">			<span class="keyword">if</span> (cur == x) <span class="keyword">break</span>;</span><br><span class="line">			a[x] += a[cur];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), <span class="built_in">add</span>(x, y);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">Tarjan</span>(i);</span><br><span class="line">	<span class="type">int</span> fx, fy;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		fx = bel[e[i].from], fy = bel[e[i].to];</span><br><span class="line">		<span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">Add</span>(fx, fy);</span><br><span class="line">		++in[fy];</span><br><span class="line">	&#125;</span><br><span class="line">	queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!in[i] &amp;&amp; bel[i] == i) q.<span class="built_in">push</span>(i), f[i] = a[i];</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = Head[top]; i ; i = E[i].next) &#123;</span><br><span class="line">			<span class="type">int</span> to = E[i].to;</span><br><span class="line">			f[to] = <span class="built_in">max</span>(f[to], f[top] + a[to]);</span><br><span class="line">			<span class="keyword">if</span> (--in[to] == <span class="number">0</span>) q.<span class="built_in">push</span>(to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> Max = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) Max = <span class="built_in">max</span>(Max, f[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Max);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="点双"><a href="#点双" class="headerlink" title="点双"></a>点双</h3><p>点双连通：若对于一个无向图，其任意一个节点对于这个图本身而言都不是割点，则称其点双连通。也就是说，删除任意点及其相关边后，整个图仍然属于一个连通分量。</p>
<p>点双连通分量：无向图中，极大的点双连通子图。与连通分量类似，抽离出一些点及它们之间的边，使得抽离出的图是一个点双连通图，在这个前提下，使得抽离出的图越大越好。</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol>
<li>除了仅包含两个点一条边的点双以外，其他点双都满足：任意两点之间都存在至少两条点不重复的路径。</li>
<li>图中任意一个割点都在至少两个点双。</li>
<li>两个点双至多存在一个公共点 – 割点</li>
<li>任意一个不是割点的点只存在一个点双中，割点也一定属于两个及以上的点双。</li>
</ol>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ol>
<li>可以用定义解释，因为点双连通分量之中没有割点。</li>
<li>因为删去割点后图会不连通，所以割点至少连接着图的两部分，而由于点双中不能有割点，所以这两部分肯定不在同一个点双中，所以割点至少存在于两个点双中。</li>
<li>用反证法，假设存在两个及以上的公共点，那这两个点双就可以通过两条及以上的边相连，那么这就变成一个点双了，与定义矛盾，故假设不成立。如果这个公共点不是割点，那么说明两个点双还有别的边相连，同样变成一个点双，所以公共点一定是割点。</li>
<li>若点在两个及以上点双中，那么删去它就可以分成两个及以上的点双，它就一定是割点；而割点如果只属于一个点双，删去它后图依然连通，这个点就不是割点了，所以割点一定属于两个及以上的点双。</li>
</ol>
<h4 id="性质：P8435-【模板】点双连通分量-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="#性质：P8435-【模板】点双连通分量-洛谷-计算机科学教育新生态-luogu-com-cn" class="headerlink" title="性质：P8435 【模板】点双连通分量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"></a>性质：<a href="https://www.luogu.com.cn/problem/solution/P8435">P8435 【模板】点双连通分量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><h4 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h4><p><code>v-DCC</code> 表示<strong>点双连通分量</strong></p>
<p>除了孤立点以外，点双连通分量的大小至少为 2。</p>
<p>根据 <code>v-DCC</code> 定义中的 “极大性”，虽然桥（割边）不属于任何 <code>e-DCC</code>（边双连通分量），但是割点可能属于多个 <code>v-DCC</code>。</p>
<p>下面的无向图中共有 2 个割点，4 个点双连通分量</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0m1veoit.png" alt="img"></p>
<p>我们考虑使用  $dfn$ 和 $low$ 来求点双连通分量</p>
<p>我们深度优先遍历时遇到的所有边加入到栈里面，当找到一个割点的时候，就将这个割点往下走到的所有边弹出，而这些边所连接的点就是一个点双了。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> +<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt, head[N];</span><br><span class="line"><span class="type">int</span> cot, tot, root, top, low[N], dfn[N], sta[N], vis[N];</span><br><span class="line"><span class="type">bool</span> cut[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">&#125;e[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to = y;</span><br><span class="line">    e[cnt].nxt = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    low[x] = dfn[x] = ++tot;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">if</span> (x == root &amp;&amp; head[x] == <span class="number">0</span>) &#123;</span><br><span class="line">        v[++cot].<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[to]) &#123;</span><br><span class="line">            <span class="built_in">Tarjan</span>(to);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[to]);</span><br><span class="line">            <span class="keyword">if</span> (low[to] &gt;= dfn[x]) &#123;</span><br><span class="line">                ++flg;</span><br><span class="line">                <span class="keyword">if</span> (x != root || flg &gt; <span class="number">1</span>)</span><br><span class="line">                    cut[x] = <span class="literal">true</span>;</span><br><span class="line">                ++cot;</span><br><span class="line">                <span class="type">int</span> cur;</span><br><span class="line">                <span class="keyword">while</span> (top) &#123;</span><br><span class="line">                    cur = sta[top--];</span><br><span class="line">                    v[cot].<span class="built_in">push_back</span>(cur);</span><br><span class="line">                    <span class="keyword">if</span> (cur == to) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                v[cot].<span class="built_in">push_back</span>(x); <span class="comment">// 至于为什么不是在上面的循环中到 x 跳出</span></span><br><span class="line">                <span class="comment">// 一种可能是 x 的孩子有多个点是割点</span></span><br><span class="line">                <span class="comment">// 另一种情况是，x 的一个孩子是一个叶子节点，所以此时 to 与 x 在栈中相隔了那个叶子节点，而那个叶子节点不是属于这个点双连通分量的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[to]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">        root = i;</span><br><span class="line">        <span class="built_in">Tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cot);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cot; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i].<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; v[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, v[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论及其应用</title>
    <url>/2023/10/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>博弈论的<strong>精髓在于</strong>：博弈中的一个理性决策者必须在考虑其它局中人行动的基础上来选择自己最理想的行动方案。</p>
<h4 id="囚徒困境-prisoners’-dilemma"><a href="#囚徒困境-prisoners’-dilemma" class="headerlink" title="囚徒困境 prisoners’ dilemma"></a>囚徒困境 prisoners’ dilemma</h4><p>两个嫌疑犯被分别关在两个房间由警察审讯，警察告诉每个嫌疑犯：如果两个人都不承认，每人将被判为1年；如果两个人都坦白，各判8年；如果其中一人坦白，另一人抵赖，坦白者释放，抵赖者判10年。每个囚徒将面临四种可能结果，被判0年、1年、8年、10年。</p>
<p>但在上述例子中，一个人的最优选择并不依赖于他人的选择。这样的最优战略，被称为“占优战略”(dominant strategy)。由所有参与人的占优战略构成的战略组合被称为“占优均衡”。<br>占优战略均衡的出现只要求所有人都是理性的，但不要求每个参与人知道其他参与人是否理性.</p>
<p>「囚徒困境」表明<strong>个人理性和集体理性之间的冲突</strong>。<br>这样的例子有：寡头竞争、军备竞赛、团队生产中的劳动供给、公共产品的供给。</p>
<h4 id="博弈的划分"><a href="#博弈的划分" class="headerlink" title="博弈的划分"></a>博弈的划分</h4><p>有合作博弈和非合作博弈，其中非合作博弈按照参与人的先后顺序又可以分为<strong>静态博弈和动态博弈</strong></p>
<p>非合作博弈按照参与人对其他人(对手)的特征、战略空间以及支付函数的知识可以划分为：<strong>完全信息博弈和不完全信息博弈</strong></p>
<img src="/2023/10/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/%E9%9D%9E%E5%90%88%E4%BD%9C%E5%8D%9A%E5%BC%88%E5%88%92%E5%88%86.png" class="">

<p>垄断最优产量小于非垄断的情况，但是对于垄断企业的利润大于非垄断情况下两个企业的利润和。</p>
]]></content>
      <tags>
        <tag>GameTheory</tag>
      </tags>
  </entry>
  <entry>
    <title>回归分析与时间序列方法</title>
    <url>/2023/08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>统计推断的另一类重要问题是假设检验问题。在总体的分布函数未知或者只知道其形式、但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对于所提出的假设做出是接受还是拒绝的决策，<strong>假设检验</strong>就是做出这一决策的过程。</p>
<p>这种只对于第一种错误的概率进行控制，而不考虑第二种错误的概率的检验，称为显著性检验。对应的还有双边假设检验、右边检验和左边检验。</p>
<img src="/2023/08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C.png" class="">

<h4 id="一元线性回归方程的检验"><a href="#一元线性回归方程的检验" class="headerlink" title="一元线性回归方程的检验"></a>一元线性回归方程的检验</h4><p>根据样本数据算出的回归可能有一定的抽样误差。为了考察这两个变量在同体内是否是存在线性关系以及回归方程对估计预测因变量的有效性如何，首先进行的就是显著性检验。</p>
<h5 id="t-检验"><a href="#t-检验" class="headerlink" title="t 检验"></a>t 检验</h5><p>t 检验又称学生 t 检验，是统计推断中一种非常常见的检验方法，<strong>用于统计量服从正态分布</strong>但是方差未知(如果知道方差，我们可以直接 Z 检验，或者叫做 U 检验，就是正态检验)的情况。</p>
<p>t检验的前提是要求样本服从正态分布或近似正态分布，不然可以利用一些变换（取对数、开根号、倒数等等）试图将其转化为服从正态分布是数据，如若还是不满足正态分布，只能利用非参数检验方法。</p>
<p>t 检验最常见的四个用途：</p>
<ol>
<li>单样本均值检验（One-sample t-test）<br> 用于检验 总体方差未知、正态数据或近似正态的 单样本的均值 是否与 已知的总体均值相等</li>
<li>两独立样本均值检验（Independent two-sample t-test）<br> 用于检验 两对独立的 正态数据或近似正态的 样本的均值 是否相等，这里可根据总体方差是否相等分类讨论</li>
<li>配对样本均值检验（Dependent t-test for paired samples）<br> 用于检验 一对配对样本的均值的差 是否等于某一个值</li>
<li>回归系数的显著性检验（t-test for regression coefficient significance）<br> 用于检验 回归模型的解释变量对被解释变量是否有显著影响</li>
</ol>
<p>具体内容见 <a href="https://zhuanlan.zhihu.com/p/138711532">https://zhuanlan.zhihu.com/p/138711532</a></p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>左偏树</title>
    <url>/2023/10/11/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
    <content><![CDATA[<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/skywang12345/p/3638327.html">https://www.cnblogs.com/skywang12345/p/3638327.html</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3377">https://www.luogu.com.cn/problem/solution/P3377</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B7%A6%E5%81%8F%E6%A0%91">https://zh.wikipedia.org/wiki/%E5%B7%A6%E5%81%8F%E6%A0%91</a></p>
<p><a href="https://oi-wiki.org/ds/leftist-tree/">https://oi-wiki.org/ds/leftist-tree/</a></p>
<p><a href="https://www.jvruo.com/archives/343/">https://www.jvruo.com/archives/343/</a></p>
<h5 id="TO-DO"><a href="#TO-DO" class="headerlink" title="TO DO"></a>TO DO</h5><p>左偏树实现删除任意节点？而不只是根节点。（其实就是从删除的节点一直向上递归，直到 cur.npl &#x3D;&#x3D; cur.rightChild.npl + 1）</p>
<p>其实我们可以从左偏树的 merge 操作中看出来，左偏树的子树也是一个左偏树</p>
<p>好像如果想实现左偏树减小任意一个节点的值，可以先删除那个节点，再添加减小后的值。</p>
<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231018233914144.png" alt="image-20231018233914144"></p>
<h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LEFTISTHEAP_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFTISTHEAP_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftistHeapNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        T value;</span><br><span class="line">        <span class="type">int</span> npl;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* leftChild;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* rightChild;</span><br><span class="line">        <span class="built_in">LeftistHeapNode</span>()</span><br><span class="line">            : <span class="built_in">npl</span>(<span class="number">-1</span>)</span><br><span class="line">            , <span class="built_in">leftChild</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">rightChild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LeftistHeapNode</span>(T val)</span><br><span class="line">            : <span class="built_in">npl</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">value</span>(val)</span><br><span class="line">            , <span class="built_in">leftChild</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">rightChild</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeftistHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* root;</span><br><span class="line">        <span class="built_in">LeftistHeap</span>()</span><br><span class="line">            : <span class="built_in">root</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LeftistHeap</span>(T val) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="built_in">LeftistHeapNode</span>&lt;T&gt;(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(LeftistHeap&lt;T&gt;)</span></span>;</span><br><span class="line">        <span class="comment">// void remove(LeftistHeapNode&lt;T&gt;*);</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function">LeftistHeapNode&lt;T&gt;* <span class="title">merge</span><span class="params">(LeftistHeapNode&lt;T&gt;*, LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(LeftistHeap&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(LeftistHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">postOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">postOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">postOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">postOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    <span class="built_in">postOrder</span>(cur-&gt;rightChild);</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">inOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">inOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">inOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">inOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(cur-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">preOrder</span>() &#123;</span><br><span class="line">    <span class="built_in">preOrder</span>(root);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">preOrder</span>(LeftistHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cur) <span class="keyword">return</span> ;</span><br><span class="line">    std::cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preOrder</span>(cur-&gt;leftChild);</span><br><span class="line">    <span class="built_in">preOrder</span>(cur-&gt;rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">insert</span>(T value) &#123;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="keyword">new</span> <span class="built_in">LeftistHeap</span>&lt;T&gt;(value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">insert</span>(LeftistHeap&lt;T&gt;* heap) &#123;</span><br><span class="line">    root = <span class="built_in">merge</span>(root, heap-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">merge</span>(LeftistHeap&lt;T&gt; heap) &#123;</span><br><span class="line">    root = <span class="built_in">merge</span>(root, heap.root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LeftistHeapNode&lt;T&gt;* LeftistHeap&lt;T&gt;::<span class="built_in">merge</span>(LeftistHeapNode&lt;T&gt;* x, LeftistHeapNode&lt;T&gt;* y) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;value &gt; y-&gt;value) &#123;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* temp = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;rightChild = <span class="built_in">merge</span>(x-&gt;rightChild, y);</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;leftChild == <span class="literal">nullptr</span> || x-&gt;leftChild-&gt;npl &lt; x-&gt;rightChild-&gt;npl) &#123;</span><br><span class="line">        LeftistHeapNode&lt;T&gt;* temp = x-&gt;leftChild;</span><br><span class="line">        x-&gt;leftChild = x-&gt;rightChild;</span><br><span class="line">        x-&gt;rightChild = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;rightChild == <span class="literal">nullptr</span> || x-&gt;leftChild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        x-&gt;npl = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x-&gt;npl = (x-&gt;leftChild-&gt;npl &gt; x-&gt;rightChild-&gt;npl) ? (x-&gt;rightChild-&gt;npl + <span class="number">1</span>) : (x-&gt;leftChild-&gt;npl + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void LeftistHeap&lt;T&gt;::remove(LeftistHeapNode&lt;T&gt;* removeNode) &#123;</span></span><br><span class="line"><span class="comment">//     if (!root) &#123;</span></span><br><span class="line"><span class="comment">//         throw std::runtime_error(&quot;the heap is empty!&quot;);</span></span><br><span class="line"><span class="comment">//         return ;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LeftistHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;the heap is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    LeftistHeapNode&lt;T&gt;* l = root-&gt;leftChild;</span><br><span class="line">    LeftistHeapNode&lt;T&gt;* r = root-&gt;rightChild;</span><br><span class="line">    root = <span class="built_in">merge</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>差分方程模型</title>
    <url>/2023/08/24/%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>在连续系统里，我们用常微分方程表示时域；<br>而在离散系统里，由于输入 | 输出都是离散信号，微分失去了意义，所以用差分计算。</p>
</blockquote>
<p>设有未知序列 ${x_n}$，称 $F(n;x_n,x_{n + 1}, …, x_{n + k}) &#x3D; 0$ 为 k 阶差分方程。</p>
<p>关于差分方程的解，可以参考文章 <a href="https://zhuanlan.zhihu.com/p/385787482">https://zhuanlan.zhihu.com/p/385787482</a> </p>
<h4 id="金融问题中的差分方程模型"><a href="#金融问题中的差分方程模型" class="headerlink" title="金融问题中的差分方程模型"></a>金融问题中的差分方程模型</h4><p>现在有一笔 p 万元的贷款，贷款期是 n 年，月利率是 r，采用等额还款的方式逐月偿还，计算每月的还款数。<br>设 k 个月后，欠额为 $A_k$，每月还款 m 元，则有 $A_{k + 1} &#x3D; (1 +r)A_k - m$</p>
<h4 id="养老保险模型"><a href="#养老保险模型" class="headerlink" title="养老保险模型"></a>养老保险模型</h4><p>设 k 个月后所交资金以及利息总和为 $F_k$，则有 $F_k &#x3D; (1 + r)F_{k - 1} + p, k &lt;&#x3D; N$ 和 $F_k &#x3D; (1 +r)F_{k - 1} - q, N &lt; k &lt;&#x3D; M$，N 个月后，不再交钱，只拿钱。</p>
<h4 id="市场经济中的蛛网模型"><a href="#市场经济中的蛛网模型" class="headerlink" title="市场经济中的蛛网模型"></a>市场经济中的蛛网模型</h4><p>在自由竞争的社会中，很多领域会出现 <strong>循环波动</strong> 的现象，比如说自由市场上商品的价格。<br>将时间离散化为时段，一个时期相当于商品的一个生产周期。设 k 时段商品数量为 $x_k$，商品价格为 $y_k$</p>
<p>同一时段商品的价格取决于该段商品的数量，$y_k &#x3D; f(x_k)$，称为需求函数，我们自然地认为这个函数是单调下降函数。</p>
<p>下一段商品的数量取决于上一个时段的商品价格，$x_{k + 1} &#x3D; g(y_k)$，称为供应函数，假设为单调上升函数。</p>
<p>在进行市场经济分析中，f 取决于消费者对于某种产品的需求程度以及消费水平，g 取决于生产能力和管理水平。</p>
<p>两个曲线的交点 $P(x_0, y_0)$ 处，$|f’(x_0)| &lt; |g’(x_0)|$ 时，P 点稳定，反之不稳定。</p>
<p>设 $|f’(x_0)| &#x3D; \alpha, |g’(y_0)| &#x3D; \frac{1}{\beta}$，在 P 点附近取 $y_k - y_0 &#x3D; -\alpha(x_k - x_0), x_{k + 1} - x_0 &#x3D; \beta(y_k - y_0)$，消去 $y_k$，得到 $x_k$ 的递推式，可以求出通项，求极限和上面的条件等价。</p>
<h4 id="简单的种群增长模型"><a href="#简单的种群增长模型" class="headerlink" title="简单的种群增长模型"></a>简单的种群增长模型</h4><p>利用了矩阵的特征方程求解。对角化或者化为若尔当标准型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>决策分析方法</title>
    <url>/2023/08/25/%E5%86%B3%E7%AD%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>策略集、状态集和溢损函数是构成一个决策问题的三项最基本要素。</p>
<h4 id="风险型决策"><a href="#风险型决策" class="headerlink" title="风险型决策"></a>风险型决策</h4><p>风险型决策也称作随机决策，是在状态概率已知的条件下进行的决策。</p>
<h5 id="最大可能准则"><a href="#最大可能准则" class="headerlink" title="最大可能准则"></a>最大可能准则</h5><p>在若干种自然状态发生的概率相差很大，而相对应的益损值又相差不大时，这种决策准则效果较好。但是如果若干种自然状态发生的概率都很小，而且相互很接近时，使用这种决策准则的效果不会好，甚至会引起很严重的错误。</p>
<h5 id="期望值准则"><a href="#期望值准则" class="headerlink" title="期望值准则"></a>期望值准则</h5><p>期望值准则就是选择期望益损值最大（或者最小）的方案作为最优方案。</p>
<h4 id="决策树法"><a href="#决策树法" class="headerlink" title="决策树法"></a>决策树法</h4><p>采用决策树法的步骤：</p>
<ol>
<li>画出决策树。一般是从左往右画，先画出决策点，再画出由决策点引起的方案分支。</li>
<li>计算方案的期望益损值。</li>
<li>根据期望益损值进行决策，将期望益损值小的舍去，而期望益损值大的方案则保留，这就是最优策略。</li>
</ol>
<h4 id="不确定型决策"><a href="#不确定型决策" class="headerlink" title="不确定型决策"></a>不确定型决策</h4><p>不确定型决策是在只有几种自然状态可能发生，但是这些状态发生的概率并不知道时做出的决策。<br>由于不确定型问题不知道状态的概率，所以无法计算每种方案的益损值，于是这类问题在理论上没有一个最优决策准则提供决策者决策，它存在着几种不同的决策分析方法，每种都有合理性。</p>
<h5 id="乐观准则"><a href="#乐观准则" class="headerlink" title="乐观准则"></a>乐观准则</h5><p>从最乐观状态出发，每种方案都按照最有利状态来考虑。$R^{*} &#x3D; \max\limits_i {\max\limits_j r_{ij}}$</p>
<h5 id="悲观准则"><a href="#悲观准则" class="headerlink" title="悲观准则"></a>悲观准则</h5><p>从最悲观的观点出发对每个方案按最不利的状态来考虑，然后从中选取最优方案。$R^{*} &#x3D; \max\limits_{i} {\min\limits_{j} r_{ij}}$</p>
<h5 id="折衷准则"><a href="#折衷准则" class="headerlink" title="折衷准则"></a>折衷准则</h5><p>引入一个表达乐观程度的乐观系数。$R^{*} &#x3D; \max\limits_i {\lambda \max\limits_j r_{ij} +(1 - \lambda) \min\limits_{j} r_{ij}}$</p>
<h5 id="等可能准则"><a href="#等可能准则" class="headerlink" title="等可能准则"></a>等可能准则</h5><p>假定每种自然状态发生的概率总是相同的。</p>
<h5 id="后悔值准则"><a href="#后悔值准则" class="headerlink" title="后悔值准则"></a>后悔值准则</h5><p>后悔值准则是从后悔值考虑，希望能找到一个这样的策略，以使在实施这个策略时能产生较少的后悔。所谓后悔就是指每种状态下最大收益值与此状态下其他益损值之差。在所有方案的最大后悔值中选最小者，此时对应的方案为最优策略。 $R^{*}  &#x3D;\min\limits_{i} {\max\limits_{j} RV_{ij}}$，其中 $RV_{ij} &#x3D; \max\limits_{i} r_{ij} - r_{ij}$</p>
<h4 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h4><p>层次分析法是对一些较为复杂、模糊的问题做出决策的多准则决策方法，它特别适用于难以完全定量分析的问题。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>大学物理2关键记录</title>
    <url>/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="第十章-电荷和静电场"><a href="#第十章-电荷和静电场" class="headerlink" title="第十章 电荷和静电场"></a>第十章 电荷和静电场</h3><p>电荷量的单位是 C（库伦）</p>
<p>库仑定律：<strong>真空中</strong>两个相对于观察者<strong>静止</strong>的<strong>点电荷</strong>之间的相互作用力<br>$$<br>F &#x3D; \dfrac{1}{4\pi\varepsilon_0} \dfrac{q_1q_2}{r^2}<br>$$<br>其中，$\varepsilon_0$ 表示真空电容率。</p>
<p>电场强度的单位可以是 $N \cdot C^{-1}$ 也可以是 $V \cdot m$</p>
<h5 id="高斯定理"><a href="#高斯定理" class="headerlink" title="高斯定理"></a>高斯定理</h5><p>在与电场强度垂直的单位面积上，穿过曲线的条数与该处电场强度的大小成正比。</p>
<p>电场线的性质：</p>
<ol>
<li>起于正电荷（或者无穷远处），止于负电荷处（或者无穷远）</li>
<li>不闭合，也不在没有电荷的地方中断</li>
<li>两条电场线不会在没有电荷的地方相交</li>
</ol>
<p>电通量大于 0，表示电场线从曲面内部穿出，小于 0，表示电场线传入曲面内部</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212212006558.png" class="" title="image-20231212212006558">

<p><strong>高斯面外部的电荷，只对高斯面上的电场强度有贡献，但是对于高斯面的电通量没有贡献。</strong></p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212212336956.png" class="" title="image-20231212212336956">

<p>均匀带电球体在空间中各点产生的电场强度随到球心距离的变化情况。</p>
<h5 id="电势及其与电场强度的关系"><a href="#电势及其与电场强度的关系" class="headerlink" title="电势及其与电场强度的关系"></a>电势及其与电场强度的关系</h5><p>电场强度反应了静电场力的性质，静电场的另一方面的性质，即能的性质，<strong>是由电势这个量来反映或者描述的。</strong></p>
<p>静电场属于保守场</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212212800289.png" class="" title="image-20231212212800289">

<p><strong>静电场的环路定理</strong>：<br>由保守场，可以得到 $\oint_LF\cdot\mathrm{d}\boldsymbol{l}&#x3D;0$ 所以 $\oint_Lq_0\boldsymbol{E}\cdot\mathrm{d}\boldsymbol{l}&#x3D;0$，有 $\oint_L\boldsymbol{E}\cdot\mathrm{d}\boldsymbol{l}&#x3D;0$，最后一个式子就是静电场的环路定理。</p>
<p>如果选择无穷远处的电势为 0，那么可以得到电势的公式为：<br>$$<br>V_p &#x3D; V_p - V_{\infty} &#x3D; \int_p^{\infty} \boldsymbol{E} \cdot \mathrm{d}\boldsymbol{l}<br>$$</p>
<h5 id="等势面"><a href="#等势面" class="headerlink" title="等势面"></a>等势面</h5><p>等势面处处与电场线正交。</p>
<h5 id="静电场中的金属导体"><a href="#静电场中的金属导体" class="headerlink" title="静电场中的金属导体"></a>静电场中的金属导体</h5><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212214139093.png" class="" title="image-20231212214139093">

<p>静电平衡下的金属导体的性质：</p>
<ol>
<li>整个导体是一个等势体，导体的表面是等势面（静电平衡状态下内部电场强度为 0）</li>
<li>导体表面的场强处处与表面垂直</li>
<li>导体内部不存在净电荷，所有过剩净电荷都分布在导体表面上</li>
</ol>
<h5 id="电容和电容器"><a href="#电容和电容器" class="headerlink" title="电容和电容器"></a>电容和电容器</h5><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212220413878.png" class="" title="image-20231212220413878">

<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212220422142.png" class="" title="image-20231212220422142">

<p>电容串联的时候电荷量一样，并联的时候电压一样。</p>
<h5 id="极化强度"><a href="#极化强度" class="headerlink" title="极化强度"></a>极化强度</h5><p>存在有极分子电介质和无极分子电介质。</p>
<p> 对于电偶极子，从负电荷到正电荷所引的有向线段 l 称为电偶极子的轴，电荷 q 与电偶极子的轴 l 的乘积，定义为电偶极子的电矩，用 p 表示，即 $\bold{p} &#x3D; q \bold{l}$</p>
<p><strong>极化强度：</strong>为了表征电介质的极化状态，引入极化强度这个概念，定义为，在电介质的单位体积中分子电矩的矢量和，以 P 表示 $\bold{P} &#x3D; \dfrac{\sum p}{\Delta \tau}$</p>
<p>关于极化电荷和极化强度关系的推导，参见课本 P311 页。此处，有结论：$\sigma^{‘}&#x3D;P\cdot n$</p>
<p>其中，$\sigma$ 是极化电荷的面密度，$P$ 是极端强度向量，$n$ 是面的法向量。</p>
<p><strong>关于这一块的推导：</strong></p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229162855089.png" class="" title="image-20231229162855089">

<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229163007530.png" class="" title="image-20231229163007530">

<p>其中，$\mathrm{d}q’$ 表示取的一个柱体内部，传出表面的电荷数量。</p>
<h5 id="极化电荷对电场的影响"><a href="#极化电荷对电场的影响" class="headerlink" title="极化电荷对电场的影响"></a>极化电荷对电场的影响</h5><p>极化电荷在空间中也会产生电场，我们叫做「附加电场」。</p>
<h5 id="静电场中的电介质"><a href="#静电场中的电介质" class="headerlink" title="静电场中的电介质"></a>静电场中的电介质</h5><p>绝缘体都属于电介质，在这种物质中，不存在自由电荷，所有电荷都被束缚在分子的范围内，所以，电解质在静电场中将表现出与导体根本不同的行为和性质。</p>
<p>为了表征电介质的极化状态，我们引入了极化强度这个物理量，定义为，在电介质的单位体积重分子电矩的矢量和，$P&#x3D;\frac{\sum p}{\Delta\tau}$</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212223815536.png" class="" title="image-20231212223815536">

<p>对于各向同性的电介质，极化强度 P 与作用于电介质内部的实际电场 E 成正比，并且两者方向相同。<br>$$<br>P&#x3D;\chi_{e}\varepsilon_{0}E<br>$$<br>其中，$\chi_e$ 表示极化率，引入电介质的相对电容率 $\varepsilon_{<em>r}&#x3D;1+\chi</em>{_e}$</p>
<p>所以，真实的电场强度为：<br>$$<br>E &#x3D; \dfrac{E_0}{\varepsilon_r} &#x3D; \dfrac{\sigma}{\varepsilon_0 \varepsilon_r} &#x3D; \dfrac{\sigma}{\varepsilon}<br>$$</p>
<h5 id="电介质存在时的高斯定理"><a href="#电介质存在时的高斯定理" class="headerlink" title="电介质存在时的高斯定理"></a>电介质存在时的高斯定理</h5><p>$$<br>D &#x3D; \varepsilon_0 E + P &#x3D; \varepsilon_0 \varepsilon_r E &#x3D; \varepsilon E<br>$$</p>
<p>其中，D 叫做电位移。</p>
<p>总结一下这一部分的公式，感觉比较杂：<br>$$<br>D &#x3D; \varepsilon_0 \varepsilon_r E &#x3D; \varepsilon E \<br>E &#x3D; \dfrac{E_0}{\varepsilon_r} &#x3D; \dfrac{\sigma}{\varepsilon_0 \varepsilon_r} &#x3D; \dfrac{\sigma}{\varepsilon} \<br>E_0 &#x3D; \dfrac{\sigma}{\varepsilon_0}<br>$$<br>其中，$E &#x3D; E_0 - E’ &#x3D; \dfrac{1}{\varepsilon_0}(\sigma - \sigma’) &#x3D; \dfrac{1}{\varepsilon_0}(E_0\varepsilon_0 - \chi_e \varepsilon_0E) &#x3D; E_0 - \chi_eE$</p>
<p>最后得到，$E &#x3D; \dfrac{E_0}{\varepsilon_r}$<br>$$<br>\oiint_sD\cdot\mathrm{d}S&#x3D;\sum_iq_{0i}<br>$$</p>
<h5 id="静电场的能量"><a href="#静电场的能量" class="headerlink" title="静电场的能量"></a>静电场的能量</h5><blockquote>
<p>一个带电体系所具有的静电能就是该体系所具有的电势能，它等于把各电荷元从无限远离的状态聚集成该带电体系的过程中，外界所作的功.</p>
</blockquote>
<p>$$<br>\mathrm{d}A&#x3D;\mathrm{d}qu_{AB}&#x3D;\frac{1}{C}q\mathrm{d}q<br>$$</p>
<p>元功的定义，所以对它进行积分，我们可以得到：<br>$$<br>A&#x3D;\int_{0}^{Q}\frac{1}{C}q\mathrm{d}q&#x3D;\frac{1}{2}\frac{Q^{2}}{C}<br>$$<br>如果，电容器所带的电荷量为 Q 时两极板之间的电势差为 $U_{AB}$，那么平行板电容器极板间的电场能量还可以表示为：<br>$$<br>\begin{aligned}W_{<em>e}&amp;&#x3D;\frac{1}{2}QU</em>{<em>{AB}},\\W</em>{<em>e}&amp;&#x3D;\frac{1}{2}CU</em>{<em>{AB}}^2.\end{aligned}<br>$$<br>经典能的能量密度：<br>$$<br>w</em>{_e}&#x3D;\frac{W_e}{Sd}&#x3D;\frac{1}{2}\varepsilon E^2&#x3D;\frac{1}{2}DE<br>$$<br>这个公式不仅仅适用于各向同性电介质中的静电场，也适用于真空中的静电场。</p>
<h3 id="第十一章-电流和恒磁场"><a href="#第十一章-电流和恒磁场" class="headerlink" title="第十一章 电流和恒磁场"></a>第十一章 电流和恒磁场</h3><h4 id="恒定电流条件和导电规律"><a href="#恒定电流条件和导电规律" class="headerlink" title="恒定电流条件和导电规律"></a>恒定电流条件和导电规律</h4><p>在导体中可以存在大量<strong>可以自由运动的带电粒子</strong>，带电粒子的定向运动形成电流，提供电流的带电粒子就被称为<strong>载流子</strong>。（比如金属导体中就是自由电子，电解液中就是正负离子）。</p>
<p>电流 $I &#x3D; \dfrac{\mathrm{d}Q}{\mathrm{d}t}$，只是反应了单位时间内载流子通过整个界面的状况，不涉及载流子穿过横截面时各处的细节。为了描述分布，引入了 <strong>电流密度。</strong><br>$$<br>j &#x3D; \dfrac{\mathrm{d}I}{\mathrm{d}S} e_n<br>$$<br>导体电阻：$R &#x3D; \dfrac{U}{I} &#x3D; \rho \dfrac{l}{S}$</p>
<h4 id="磁场和磁感应强度"><a href="#磁场和磁感应强度" class="headerlink" title="磁场和磁感应强度"></a>磁场和磁感应强度</h4><p>磁感应强度单位为 $T$ 特斯拉。（是按照<strong>试探电荷在磁场中所受磁力的大小和方向</strong>来定义的，不过这个试探电荷是运动的，而不是静止的。）</p>
<h4 id="毕奥萨法尔定律"><a href="#毕奥萨法尔定律" class="headerlink" title="毕奥萨法尔定律"></a>毕奥萨法尔定律</h4><p>磁场是由电路产生的，为了求得任意形状的载流导线所产生的磁场，我们可以将导线分为许多的电流元 $I \mathrm{d}l$.</p>
<p>对于一个电流元产生的磁感应强度：<br>$$<br>\mathrm{d}\bold{B} &#x3D; \dfrac{\mu_0}{4\pi}\dfrac{I \mathrm{d}\bold{l} \times \bold{r}}{r^{3}}<br>$$<br>满足右手定则。</p>
<p>推导可以得到结论，对于直导线，距离导线为 r 的地方的磁感应强度为：<br>$$<br>B &#x3D; \dfrac{\mu_0}{4\pi} \dfrac{2 I}{r}<br>$$</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231218193622906.png" class="" title="image-20231218193622906">



<h4 id="磁场的高斯定理和安排环路定理"><a href="#磁场的高斯定理和安排环路定理" class="headerlink" title="磁场的高斯定理和安排环路定理"></a>磁场的高斯定理和安排环路定理</h4><p>磁场的高斯定理：<br>$$<br>\oiint_{s}\bold{B}\cdot\mathrm{d}\bold{S}&#x3D;0<br>$$<br>这是一个 <strong>恒定电流磁场</strong> 的普遍性质。</p>
<h4 id="安培环路定理"><a href="#安培环路定理" class="headerlink" title="安培环路定理"></a>安培环路定理</h4><p>$$<br>\oint_{\iota}B\cdot\mathrm{d}l&#x3D;\mu_{0}\sum_{i}I_{i}<br>$$</p>
<p>表示， 在<strong>恒定电流磁场</strong>中，磁感应强度沿任意闭合环路的积分等于此闭合环路所包围的电流代数和的 $\mu_0$ 倍。</p>
<p>借此，我们可以推导出<strong>密集螺线管内部的磁感应强度大小</strong>，见课本 P344，最后得到 $B &#x3D; \mu_0 n I$</p>
<h4 id="磁场对电流的作用"><a href="#磁场对电流的作用" class="headerlink" title="磁场对电流的作用"></a>磁场对电流的作用</h4><p>磁场的<strong>基本属性</strong>就是对于其中的运动电荷<strong>要传递力的作用</strong>。载流导线处于磁场中，作定向运动的自由电子所受的洛伦兹力，传递给金属晶格，宏观上就表现为磁场对于载流导线的作用。(其中对于 $I \mathrm{d}\bold{l}$ 我们还是看作是一个<strong>电流元</strong>。)</p>
<p>安培定律：<br>$$<br>\mathrm{d}\bold{F} &#x3D; I \mathrm{d}\bold{l} \times \bold{B}<br>$$</p>
<h4 id="带电粒子在磁场中的运动"><a href="#带电粒子在磁场中的运动" class="headerlink" title="带电粒子在磁场中的运动"></a>带电粒子在磁场中的运动</h4><p>我们可以<strong>由安培定律推导得到洛伦兹力</strong>的表达式。</p>
<p>由安培定律和 $I &#x3D; nqSv$ 所以可以表示为 $I \mathrm{d}\bold{l} &#x3D; nqSdl \bold{v} &#x3D; Nq\bold{v}$ 可以得到，$\mathrm{d}\bold{F} &#x3D; Nq\bold{v} \times \bold{B}$，所以对于单个载流子，受到的力就是 $F_L &#x3D; q \bold{v} \times \bold{B}$</p>
<p>（其中，n 表示单位体积内载流子的数密度为 n，N 是电流元所包含的载流子的总数。）</p>
<p><strong>这里还是有一些跟高中距离很近的题目的。</strong></p>
<h4 id="磁介质的磁化"><a href="#磁介质的磁化" class="headerlink" title="磁介质的磁化"></a>磁介质的磁化</h4><p>磁介质的概述：凡是处于磁场中能够<strong>对于磁场发生影响</strong>的物质都属于磁介质。实验表明，一切由原子、分子构成的物质都能够对于磁场发成影响，所以都是磁介质。（物质的磁性可以从其电结构中得到解释）</p>
<p>类比电极化强度，磁介质的磁化强度可以定义为：单位体积内分子磁矩的矢量和，可以表示为：<br>$$<br>\bold{M} &#x3D; \dfrac{\sum \bold{m}}{\Delta \tau}<br>$$</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231218205410546.png" class="" title="image-20231218205410546">

<p>对于如图的柱形导体，外面绕着很多圈螺线管，于是，任意点的磁感应强度 B 等于该点的外磁场 $B_0$ 与磁介质的磁化电流产生的附加磁感应强度 $B’$ 的矢量和，即 $B &#x3D; B_0 + B’$</p>
<p>如果是顺磁质，$B_0$ 与 $B’$ 同向，如果是抗磁质，$B_0$ 与 $B’$ 反向。</p>
<p>最后可以得到：$B &#x3D; B_0 + \mu_0M$<br>$$<br>\oint_LM\cdot\mathrm{d}l&#x3D;\sum_{(Lits)}I^{\prime}<br>$$<br>这是磁化强度 M 和磁化电流 $I’$ 之间的普遍关系。</p>
<h4 id="有磁介质存在时的安培环路定理"><a href="#有磁介质存在时的安培环路定理" class="headerlink" title="有磁介质存在时的安培环路定理"></a>有磁介质存在时的安培环路定理</h4><p>$$<br>\oint_{L}\boldsymbol{B}\cdot\mathrm{d}\boldsymbol{l}&#x3D;\mu_{0}\left(\sum_{i}I_{0i}+\sum_{i}I_{i}^{\prime}\right)<br>$$</p>
<p>整理可以得到：<br>$$<br>\oint_{L}\Big(\frac{\boldsymbol{B}}{\boldsymbol{\mu}<em>{0}}-\boldsymbol{M}\Big)\cdot\mathrm{d}\boldsymbol{l}&#x3D;\sum</em>{i}I_{0i}<br>$$<br>然后，我们定义 H 为磁场强度矢量，表示为：<br>$$<br>H&#x3D;\frac{B}{\mu_{0}}-\boldsymbol{M}<br>$$<br>所以就有<br>$$<br>\oint_LH\cdot\mathrm{d}l&#x3D;\sum_iI_{0i}<br>$$<br>对于各相同性的顺磁质和抗磁质，磁化强度和磁场强度成正比<br>$$<br>B &#x3D; \mu_0 (1 + \chi_m)H<br>$$<br>定义 $\mu_r &#x3D; 1 + \chi_m$</p>
<p>所以，$B &#x3D; \mu_0\mu_r H&#x3D; \mu H$</p>
<h4 id="磁矩与力矩"><a href="#磁矩与力矩" class="headerlink" title="磁矩与力矩"></a>磁矩与力矩</h4><p>磁场对于载流线圈的作用：</p>
<p>磁矩定义为：$\bold{m} &#x3D; I S e_n$</p>
<p>力矩可以表示为：$\bold{M} &#x3D; \bold{m} \times \bold{B}$</p>
<h4 id="抗磁性"><a href="#抗磁性" class="headerlink" title="抗磁性"></a>抗磁性</h4><h4 id="铁磁性"><a href="#铁磁性" class="headerlink" title="铁磁性"></a>铁磁性</h4><h3 id="第十二章-电磁感应和麦克斯韦电磁理论"><a href="#第十二章-电磁感应和麦克斯韦电磁理论" class="headerlink" title="第十二章 电磁感应和麦克斯韦电磁理论"></a>第十二章 电磁感应和麦克斯韦电磁理论</h3><h4 id="电磁感应及其基本规律"><a href="#电磁感应及其基本规律" class="headerlink" title="电磁感应及其基本规律"></a>电磁感应及其基本规律</h4><p>法拉第电磁感应定律：<br>$$<br>{\mathscr{E}}&#x3D;-\frac{\mathrm{d}\Phi}{\mathrm{d}t}<br>$$</p>
<p>$$<br>E_\mathrm{D}&#x3D;\frac F{-e}&#x3D;v\times B<br>$$</p>
<p>其中，$E_D$ 表示非静电力所对应的非经典性电场 $E_D$，所以动生电动势又可以表示为：<br>$$<br>\mathscr{E}<em>{\mathrm{D}}&#x3D;\int</em>{-}^{+}\mathbf{E}<em>{\mathrm{D}}\cdot\mathrm{d}\boldsymbol{l}&#x3D;\int</em>{-}^{+}(\boldsymbol{v}\times\boldsymbol{B})\cdot\mathrm{d}\boldsymbol{l}<br>$$<br>所以关于动生电动势，有结论：</p>
<ol>
<li>动生电动势的产生并不要求构成闭合回路，闭合回路仅仅是可以形成电流，而不是产生动生电动势的必要条件。</li>
<li>只有磁场中运动的导体才可以产生动生电动势。</li>
</ol>
<p>变化的磁场可以激发一种电场，叫做 <strong>感生电场</strong>（又名涡电场）</p>
<p>与静电场不同的是，感生电场是闭合的，不是一个保守场。</p>
<p>对于感生电动势，可以得到：<br>$$<br>\mathscr{E}_\mathbf{w}&#x3D;\oint_L\boldsymbol{E}_\mathrm{w}\cdot\mathrm{d}\boldsymbol{l}<br>$$<br>其中，$E_w$ 表示感生电场强度。</p>
<p>将此式带入法拉第电磁感应定律可以得到：<br>$$<br>\oint_L\boldsymbol{E}_\mathrm{w}\cdot\mathrm{d}\boldsymbol{l}&#x3D;-\frac{\mathrm{d}\boldsymbol{\Phi}}{\mathrm{d}t}&#x3D;-\iint_s\frac{\partial\boldsymbol{B}}{\partial t}\cdot\mathrm{d}\boldsymbol{S}<br>$$<br>一般情况下，空间中可能同时存在静电场 $E_c$ 和感生电场 $E_w$，总电场是两个的<strong>矢量和</strong>。$E &#x3D; E_w + E_c$ 称为全电场。</p>
<p>那么，对于全电场的环路积分有：<br>$$<br>\oint_L\mathbf{E}\cdot\mathrm{d}\boldsymbol{l}&#x3D;\oint_L\left(\mathbf{E}_\mathrm{c}+\mathbf{E}_\mathrm{w}\right)\cdot\mathrm{d}\boldsymbol{l}&#x3D;\oint_L\mathbf{E}_\mathrm{w}\cdot\mathrm{d}\boldsymbol{l}&#x3D;-\iint_\mathrm{s}\frac{\partial\boldsymbol{B}}{\partial t}\cdot\mathrm{d}\boldsymbol{S}<br>$$</p>
<h4 id="带电粒子比荷的测定"><a href="#带电粒子比荷的测定" class="headerlink" title="带电粒子比荷的测定"></a>带电粒子比荷的测定</h4><ol>
<li>电子比荷测定：磁聚焦法</li>
<li>离子比荷测定：质谱仪</li>
</ol>
<h4 id="互感和自感"><a href="#互感和自感" class="headerlink" title="互感和自感"></a>互感和自感</h4><h5 id="互感现象"><a href="#互感现象" class="headerlink" title="互感现象"></a>互感现象</h5><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219190537981.png" class="" title="image-20231219190537981">

<p>其中，线圈二的磁通量正比于磁感应强度 $B_1$ 的大小，而 $B_1$ 的大小又正比于电流 $I_1$，所以 $\Phi_{12}$ 一定正比于 $I_1$，也就是 $\Phi_{12} &#x3D; M_{12} I_1$，其中 $M_{12}$ 为线圈 1 对于线圈 2 的互感系数，简称 <strong>互感</strong></p>
<p>对于线圈 2 产生的感应电动势，有：<br>$$<br>\mathscr{E}<em>2&#x3D;-\frac{\mathrm{d}\boldsymbol{\Phi}</em>{12}}{\mathrm{d}t}&#x3D;-\frac{\mathrm{d}}{\mathrm{d}t}(M_{12}I_1)<br>$$<br>所以有：<br>$$<br>\mathscr{E}<em>2&#x3D;-M</em>{12}\frac{\mathrm{d}I_1}{\mathrm{d}t}<br>$$<br>在求解 $M$ 的时候，我们可以使用 $M &#x3D; \dfrac{\Phi}{I}$ 或者 $\mathscr{E} &#x3D; -M \dfrac{\mathrm{d}I}{\mathrm{d}t}$</p>
<h5 id="自感现象"><a href="#自感现象" class="headerlink" title="自感现象"></a>自感现象</h5><p>一个线圈中的电流变化的时候，激发的变化磁场引起了线圈自身的磁通量的变化，从而在线圈内部产生感应电动势，叫做 <strong>自感现象</strong>。<br>$$<br>\Phi &#x3D; L I<br>$$<br>所以对于感应电动势有：<br>$$<br>\mathscr{E} &#x3D; -\dfrac{\mathrm{d}\Phi}{\mathrm{d}t} &#x3D; -\dfrac{\mathrm{d}(LI)}{\mathrm{d}t} &#x3D; -L\dfrac{\mathrm{d}I}{\mathrm{d}t}<br>$$</p>
<h4 id="麦克斯韦电磁理论"><a href="#麦克斯韦电磁理论" class="headerlink" title="麦克斯韦电磁理论"></a>麦克斯韦电磁理论</h4><h5 id="对于位移电流的得出"><a href="#对于位移电流的得出" class="headerlink" title="对于位移电流的得出"></a>对于位移电流的得出</h5><p>$$<br>\oiint_Sj_0\cdot\mathrm{d}\mathbf{S}&#x3D;-\frac{\mathrm{d}q}{\mathrm{d}t}&#x3D;-\frac{\mathrm{d}}{\mathrm{d}t}\iiint_V\rho_0\mathrm{d}\tau<br>$$</p>
<p>将右式中的 q 替换为高斯定理，可以得到：<br>$$<br>\oiint_{\mathrm{S}}j_0\cdot\mathrm{d}\mathbf{S}&#x3D;-\frac{\mathrm{d}}{\mathrm{d}t}\oiint_{\mathrm{S}}\mathbf{D}\cdot\mathrm{d}\mathbf{S}<br>$$<br>所以有：<br>$$<br>\oiint_{\mathrm{s}}\left(j_0+\frac{\partial D}{\partial t}\right)\cdot\mathrm{d}S&#x3D;0<br>$$<br>所以说 $j_0+\frac{\partial D}{\partial t}$ 是连续的，麦克斯韦把 $\frac{\partial D}{\partial t}$ 称为 <strong>位移电流密度</strong>，把 $j_0+\frac{\partial D}{\partial t}$ 称为 <strong>全电流密度</strong>。</p>
<p>所以，在原来的安培环路定理中，原先的传导电流应以全电流替代，就有：<br>$$<br>\oint_LH\cdot\mathrm{d}l&#x3D;\iint_S\left(j_0+\frac{\partial D}{\partial t}\right)\cdot\mathrm{d}S<br>$$</p>
<h4 id="电磁波的产生和传播"><a href="#电磁波的产生和传播" class="headerlink" title="电磁波的产生和传播"></a>电磁波的产生和传播</h4><h5 id="LC-电路"><a href="#LC-电路" class="headerlink" title="LC 电路"></a>LC 电路</h5><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219200502496.png" class="" title="image-20231219200502496">

<p>电路如图，我们可以列出下面的方程：</p>
<p>以LC并联电路为例，电容两端的电压 $V_\mathrm{C}$ 等于电感两端的电压 $V_\mathrm{L}:$</p>
<p>$$<br>V_{C}&#x3D;V_{L}.<br>$$</p>
<p>流入电容的电流等于流出电感的电流：</p>
<p>$$<br>i_{C}&#x3D;-i_{L}.<br>$$</p>
<p>从电路元件的本构关系可知</p>
<p>$$<br>V_L(t)&#x3D;L\frac{\mathrm{d}i_L}{\mathrm{d}t}<br>$$</p>
<p>并且</p>
<p>$$<br>i_{C}(t)&#x3D;C\frac{\mathrm{d}V_{C}}{\mathrm{d}t}.<br>$$<br>后面就是求解微分方程组：</p>
<p>移项并代换得到二阶微分方程</p>
<p>$$<br>\frac{\mathrm{d}^2i_L(t)}{\mathrm{d}t^2}+\frac{1}{LC}i_L(t)&#x3D;0.<br>$$</p>
<p>参数 $\omega_0$, 谐振角频率定义为：</p>
<p>$$<br>\omega_0&#x3D;\frac{1}{\sqrt{LC}}<br>$$<br>要想这样的振荡电路作为波源向空间发射电磁波，还需要具备两个条件</p>
<ol>
<li>振荡频率要高，可以减小 L 或者 C</li>
<li>电路要开放</li>
</ol>
<h4 id="电磁场的能量和动量"><a href="#电磁场的能量和动量" class="headerlink" title="电磁场的能量和动量"></a>电磁场的能量和动量</h4><h5 id="电磁场的能量密度和能流密度"><a href="#电磁场的能量密度和能流密度" class="headerlink" title="电磁场的能量密度和能流密度"></a>电磁场的能量密度和能流密度</h5><p>电磁波是物质的一种特殊形态，必定遵从能量守恒定律。我们考虑一个由带电体和电磁场组成的体积为 $\tau$、边界面积为 $\Sigma$ 的封闭系统。 </p>
<p>看课本的推导，见 P46</p>
<p>最后，可以得到：<br><strong>平均能流密度</strong>：<br>$$<br>\overline{S} &#x3D; \dfrac{1}{2}E_0H_0<br>$$<br>其中，$E_0$ 和 $H_0$ 分别是电磁波的电矢量和磁矢量的峰值。</p>
<p><strong>平均能量密度</strong>：<br>$$<br>\overline{w} &#x3D; \dfrac{1}{2}\varepsilon E_0^{2} &#x3D; \dfrac{1}{2} \mu H_0^{2}<br>$$</p>
<h3 id="第十四章-光学"><a href="#第十四章-光学" class="headerlink" title="第十四章 光学"></a>第十四章 光学</h3><p>这一章将会涉及两个部分，几何光学和波动光学。以光的直线传播性质为基础，研究光在透明介质中的传播问题，而不涉及光的波动本性的光学分支，称为 <strong>几何光学</strong>。</p>
<p>衍射和干涉一样也是波动所具有的固有性质。</p>
<p>如果波长为 $\lambda$ 的光，经过孔径为 $d$ 的小孔的时候，衍射角（偏离角）的大小为：<br>$$<br>\alpha \approx \dfrac{\lambda}{d}<br>$$<br>所以说，波长越大，偏离角越明显，越容易观察到衍射现象。</p>
<h4 id="全反射"><a href="#全反射" class="headerlink" title="全反射"></a>全反射</h4><p>当光线从光密介质射向光疏介质的时候，可能会发生一种称为全反射的现象。</p>
<blockquote>
<p>激光光导纤维通讯就是利用全反射的原理实现的.光导纤维是由大量玻璃纤维并成的纤维束，其中每一根都是折射率较高的玻璃纤维，其外包敷一层折射率较低的玻璃介质.讯号光线从玻璃纤维的一端射入，经多次全反射后从另一端射出，将讯号携带到另一端，从而达到传输光讯号的目的。</p>
</blockquote>
<h4 id="光在球面上的折射"><a href="#光在球面上的折射" class="headerlink" title="光在球面上的折射"></a>光在球面上的折射</h4><p>我们讨论的光线都是 <strong>近轴光线</strong></p>
<p>近轴光线的球面折射公式：<br>$$<br>\frac{n_2}{l_2}-\frac{n_1}{l_1}&#x3D;\frac{n_2-n_1}R<br>$$</p>
<ol>
<li>凸面镜的情况下，曲率半径为正值，凹面镜的情况下，曲率半径为负值。</li>
<li>处于左侧，物距或者像距取负值，处于右侧，物距或者像距取正值。</li>
</ol>
<h4 id="高斯公式"><a href="#高斯公式" class="headerlink" title="高斯公式"></a>高斯公式</h4><p>近轴光线的折射公式还可以写成另一种形式，这种形式之下我们需要引入焦距和焦点的概念。<br>$$<br>\frac{f_1}{l_1}+\frac{f_2}{l_2}&#x3D;1<br>$$<br>这就是<strong>高斯公式</strong>，与近轴光线的球面折射公式完全等效。</p>
<h4 id="球面折射成像的作图法"><a href="#球面折射成像的作图法" class="headerlink" title="球面折射成像的作图法"></a>球面折射成像的作图法</h4><p>光出三条光线：</p>
<ol>
<li>平行于主光轴的光线折射后经过第二焦点。</li>
<li>通过第一主焦点的光线折射后平行于主光轴。</li>
<li>通过球面曲率中心的光线沿原路径传播。</li>
</ol>
<h4 id="球面折射的横向放大率"><a href="#球面折射的横向放大率" class="headerlink" title="球面折射的横向放大率"></a>球面折射的横向放大率</h4><p>如果物体的高度为 $y_1$，像的高度为 $y_2$，那么定义横向放大率为：<br>$$<br>m &#x3D; \dfrac{y_2}{y_1}<br>$$<br>当 m 为正值的时候表示为 <strong>正像</strong>，反之表示为 <strong>倒像</strong>。</p>
<p>进一步推广，放大率可以写为：<br>$$<br>m &#x3D; \dfrac{y_2}{y_1} &#x3D; \dfrac{n_1 l_2}{n_2 l_1}<br>$$</p>
<h4 id="光在球面上的反射"><a href="#光在球面上的反射" class="headerlink" title="光在球面上的反射"></a>光在球面上的反射</h4><p>令球面近轴光线的折射公式中的 $n_2 &#x3D; -n_1$，我们可以得到近轴光线的球面反射公式：<br>$$<br>\dfrac{1}{l_1} + \dfrac{1}{l_2} &#x3D; \dfrac{2}{R}<br>$$<br>对于反射镜，$f &#x3D; f_1 &#x3D; f_2 &#x3D; \dfrac{R}{2}, m &#x3D; - \dfrac{l_2}{l_1}$</p>
<p>如果令 $R &#x3D; \infty$，就可以得到 <strong>平面镜</strong> 的反射规律。</p>
<p>此时有 $l_2 &#x3D; -l_1, m &#x3D; 1$</p>
<h4 id="薄透镜"><a href="#薄透镜" class="headerlink" title="薄透镜"></a>薄透镜</h4><p>薄透镜就是两个球面镜拼接在一起，并且两个球面顶点之间的距离相比曲率半径很小。</p>
<p>薄透镜成像公式：<br>$$<br>n_1\left(\frac{1}{l_2}-\frac{1}{l_1}\right)&#x3D;(n-n_1)\left(\frac{1}{R_1}-\frac{1}{R_2}\right)<br>$$<br>如果薄透镜位于空气中，则 $n_1 &#x3D; 1$，就有：<br>$$<br>\frac1{l_2}-\frac1{l_1}&#x3D;(n-1)\Big(\frac1{R_1}-\frac1{R_2}\Big)<br>$$<br>横向放大率为：<br>$$<br>m &#x3D; \dfrac{y_2}{y_1} &#x3D; \dfrac{l_2}{l_1}<br>$$</p>
<h4 id="放大镜"><a href="#放大镜" class="headerlink" title="放大镜"></a>放大镜</h4><p>人眼对于某物体感觉到的大小是决定于它在视网膜上所成像的大小，而视网膜上像的大小又与物体对眼所张的角度有关。我们在观察一个微小的物体的时候，经常把物体移进眼睛，就是为了增大物体对眼的张角。</p>
<p>关于放大镜的原理，可以看课本的 P96</p>
<p>有关于放大率的近似公式：<br>$$<br>M &#x3D; \dfrac{D}{f}<br>$$<br>其中，f 是放大镜的焦距，D 是物体距离眼睛的距离。</p>
<h4 id="光波及其相干条件"><a href="#光波及其相干条件" class="headerlink" title="光波及其相干条件"></a>光波及其相干条件</h4><p>我们曾经使用下式来表示一列沿 x 轴传播的平面简谐波函数：<br>$$<br>y &#x3D; A\cos(\omega t - kx + \varphi)<br>$$<br>当然，这也可以表示光波，代表了一系列无限延伸的平面<strong>单色光波</strong>。</p>
<p>对于沿 $\vec{r}$ 方向传播的平面电磁波波函数电场分量：<br>$$<br>E &#x3D; E_0 \cos (\vec{k} \cdot \vec{r} - \omega t - \varphi_0)<br>$$<br>写成复数的形式，则为：<br>$$<br>\widetilde{E}(r,t)&#x3D;E_{0}\mathrm{e}^{\mathrm{i}(k\cdot r-\omega t-\varphi_{0})}<br>$$<br>这个式子可以化为：<br>$$<br>\overset{\sim}{E}\left(\boldsymbol{r},t\right)&#x3D;E_0\mathrm{e}^{\mathrm{i}\left(\boldsymbol{k}\cdot\boldsymbol{r}-\varphi_0\right)}\mathrm{e}^{-\boldsymbol{i}\omega t}&#x3D;\widetilde{E}\left(\boldsymbol{r}\right)\mathrm{e}^{-\boldsymbol{i}\omega t}<br>$$<br>其中，$\overset{\sim}E(\bold{r}) &#x3D; E_0 e^{i(\bold{k}\cdot \bold{r} - \varphi_0)}$ 称为 <strong>复振幅</strong>。在考察单色简谐波的光场时，各场点复波函数中的时间因子e$^{\mathrm{i}wt}$都是相同的，可以将它舍去，而只讨论复振幅.在复振幅中包含了我们感兴趣的所有信息：复振幅的模代表光强，复振幅的辐角就是相位. 光矢量的复振幅也可以写成复矢量的形式。</p>
<p>这里说的是平面波，对于发散球面波，波函数可以表示为：<br>$$<br>E &#x3D; \dfrac{E_0}{r} \cos (\vec{k} \cdot \vec{r} - \omega t - \varphi_0)<br>$$</p>
<h5 id="光程"><a href="#光程" class="headerlink" title="光程"></a>光程</h5><p>光在传播时候的相位变化：<br>$$<br>\Delta \varphi &#x3D; \dfrac{2\pi l }{\lambda} &#x3D; \dfrac{2\pi x}{\lambda’}<br>$$<br>其中，第一个等号表示在真空中的传播，第二个表示在折射率为 $n$ 的介质中的传播，x 表示在介质中传播的长度，$\lambda’$ 表示介质中的光的波长。</p>
<p>又有 $n &#x3D; \dfrac{\lambda}{\lambda’}$，所以 $l &#x3D; nx$</p>
<p>表示，如果在真空中和介质中，光的波长变化相同的相位，通过的路程之间的关系。</p>
<h5 id="相干条件"><a href="#相干条件" class="headerlink" title="相干条件"></a>相干条件</h5><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227111008644.png" class="" title="image-20231227111008644">

<p>这个式子表明，两列光波相遇，相遇处的光强并不等于两列波光强单独在该处引起的光强之和，而是与它们之间的相位差 $\delta$ 有关。这种由于光波的叠加而引起的光强重新分配的现象，称为「光的干涉」。</p>
<p>两列光波相干的条件表示为：</p>
<ol>
<li>频率相同</li>
<li>存在互相平行的振动分量</li>
<li>具有相对固定的相位关系</li>
</ol>
<p>前两个条件是比较容易满足的，对于第三个条件，我们可以通过分解光波的方法，有三种：</p>
<ol>
<li>分波前法</li>
<li>分振幅法</li>
<li>分振动面法</li>
</ol>
<h4 id="分波前干涉"><a href="#分波前干涉" class="headerlink" title="分波前干涉"></a>分波前干涉</h4><p>杨氏干涉实验是利用 <strong>分波前法</strong> 获得相干光束。</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219153703219.png" class="" title="image-20231219153703219">

<p>几何关系可以得到</p>
<p>$$<br>\begin{aligned}r_{2}^{2}&#x3D;D^{2}+(x+a)^{2},\quad r_{1}^{2}&#x3D;D^{2}+(x-a)^{2}.\end{aligned}<br>$$</p>
<p>将两式相减，得</p>
<p>$$<br>\left.r_{2}^{2}-r_{1}^{2}&#x3D;\left(\begin{matrix}{r_{2}+r_{1}}\\end{matrix}\right.\right)\left(\begin{matrix}{r_{2}-r_{1}}\\end{matrix}\right)&#x3D;4ax.<br>$$</p>
<p>因为狭缝$S_1$ 和$S_2$之间的距离 2a 很小，并且 $x$ 也必须很小，才能观察到干涉条</p>
<p>纹，所以可以近似认为$r_2+r_1&#x3D;2D$,上式变为</p>
<p>$$<br>2D\Delta&#x3D;4ax,<br>$$<br>$\Delta &#x3D; r_2 - r_1 &#x3D; \dfrac{2a}{D}x$，带入 $r_2 - r_1$ 分别为亮、暗条纹的条件，得到：<br>$$<br>\begin{aligned}<br>x &amp;&#x3D; \dfrac{D}{2a}2k\dfrac{\lambda} {2} \<br>x &amp;&#x3D; \dfrac{D}{2a}(2k + 1)\dfrac{\lambda}{2}<br>\end{aligned}<br>$$<br>分别表示亮、暗条纹 x 的值。</p>
<h4 id="分振幅干涉"><a href="#分振幅干涉" class="headerlink" title="分振幅干涉"></a>分振幅干涉</h4><h5 id="薄膜干涉"><a href="#薄膜干涉" class="headerlink" title="薄膜干涉"></a>薄膜干涉</h5><p>薄膜反射是采取分振幅法获得干涉光的。薄膜干涉一般有两类，即等倾干涉和等厚干涉</p>
<h6 id="等倾干涉"><a href="#等倾干涉" class="headerlink" title="等倾干涉"></a>等倾干涉</h6><img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227140108908.png" class="" title="image-20231227140108908">

<p>（书上的图片不是很完整，实际上还应该有一个凸透镜，折射后的两个光波汇聚发生干涉，产生条纹，我们来观察现象）</p>
<p>a 光和 b 光的光程差可以表示为：<br>$$<br>\Delta &#x3D; n(AB + AC) - (AD - \lambda &#x2F; 2)<br>$$<br>（因为 a 光会在反射的时候发生半波损失（光疏射向光密的时候发生），b 光在介质中的波长变短）</p>
<p>最后得到：<br>$$<br>\Delta &#x3D; 2ne \cos r + \dfrac{\lambda}{2}<br>$$</p>
<p>其中，n 表示折射率，e 表示膜的长度，$r$ 表示折射角。</p>
<h6 id="等厚干涉"><a href="#等厚干涉" class="headerlink" title="等厚干涉"></a>等厚干涉</h6><blockquote>
<p>注意，使用的是单色光，等厚干涉的时候通常是考虑垂直入射的光线。</p>
</blockquote>
<p>薄膜的厚度不均匀，同时光源离开薄膜比较远，观察干涉条纹的范围又比较小，以至于入射角 i 可以认为不变，所以反射光的光程差只取决于薄膜的厚度，所以处于同一干涉条纹上的反射光，所在位置厚度相同。</p>
<p>这种干涉称为 <strong>等厚干涉</strong>。</p>
<p>等厚干涉中，干涉条纹不再呈现于无限远处，而是呈现在薄膜表面附近，如图，点 P 可能存在于薄膜的下方，也可能是薄膜的上方，只要薄膜很薄，光的入射角不大，我们总可以认为干涉条纹呈现在薄膜的表面。（这里不同于等倾干涉，等倾干涉需要使用一个凹透镜聚焦光线成像）</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219164024359.png" class="" title="image-20231219164024359">

<p>如果两个平板玻璃的一端相接触，另一端夹一薄纸片，则在这两块平板玻璃之间就形成了劈形气隙</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219161700528.png" class="" title="image-20231219161700528">

<p>这时，上下两个表面的反射光 a 和 b 的光程差可以表示为：<br>$$<br>\Delta &#x3D; 2e + \dfrac{\lambda}{2}<br>$$<br>e 为在光的入射点处，气隙的厚度。</p>
<p>可以得到，相邻亮条纹或者暗条纹所对应的气隙厚度差为：<br>$$<br>e_{k + 1} - e_k &#x3D; \dfrac{1}{2}(k + 1)\lambda - \dfrac{1}{2}k\lambda &#x3D; \dfrac{\lambda}{2}<br>$$<br>我们可以手动测得相邻亮条纹或者暗条纹之间的距离 l，则两块平板玻璃之间的夹角可以表示为：<br>$$<br>\theta &#x3D; \dfrac{\lambda &#x2F; 2}{l} &#x3D; \dfrac{\lambda}{2l}<br>$$<br>根据玻璃板的长度，还可以测得纸片的厚度：<br>$$<br>h &#x3D; \theta L &#x3D; \dfrac{\lambda}{2l}L<br>$$<br>我们可以利用等厚干涉检测物体是否平整，因为平整的话，亮暗条纹之间的间距是相等的。</p>
<h6 id="牛顿环"><a href="#牛顿环" class="headerlink" title="牛顿环"></a>牛顿环</h6><p>第 k 级暗环的半径为：<br>$$<br>r &#x3D; \sqrt{kR\lambda}<br>$$</p>
<h4 id="迈克耳孙干涉仪"><a href="#迈克耳孙干涉仪" class="headerlink" title="迈克耳孙干涉仪"></a>迈克耳孙干涉仪</h4><p>迈克耳孙干涉仪是利用光的干涉精确测量长度和长度变化的仪器。</p>
<p>是采用分振幅的方法获得的相干光（分<strong>振幅的具体含义</strong>就是，光穿过了玻璃片，有反射和折射，能量变小，所以振幅变小，叫做分振幅）</p>
<p>实验具体内容看课本 P111</p>
<h4 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h4><p>可见光的波长在 $400-780$ nm 或者说 $0.4 - 0.78 \mu m$</p>
<p>其中，长度单位有：$1\mu m &#x3D; 10^{-6}m, 1 nm &#x3D; 10^{-9} m$  </p>
<h4 id="惠更斯-菲涅尔原理和衍射现象分类"><a href="#惠更斯-菲涅尔原理和衍射现象分类" class="headerlink" title="惠更斯-菲涅尔原理和衍射现象分类"></a>惠更斯-菲涅尔原理和衍射现象分类</h4><blockquote>
<p>惠更斯-菲涅尔原理：</p>
<p>同一波前上各点都可以认为是发射球面子波的波源，空间任一点的光振动是所有这些子波在该点的相干叠加。</p>
</blockquote>
<p>惠更斯-菲涅尔原理是<strong>波动光学的基本原理</strong>，是分析和处理衍射问题的理论基础。</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227195843801.png" class="" title="image-20231227195843801">

<p>这只是菲涅尔自己的直觉和猜想，缺乏严格的数学物理证明，后来，基尔霍夫平面屏衍射理论验证了这个猜想，并且得到了倾斜因子 F 和比例系数 C 的具体表达式。</p>
<h4 id="衍射的分类"><a href="#衍射的分类" class="headerlink" title="衍射的分类"></a>衍射的分类</h4><p>衍射可以分为菲涅尔衍射和夫琅禾费衍射</p>
<p>具体区别，见课本 P115</p>
<p>大致是一个是平行光，一个不是</p>
<h4 id="单缝和圆孔的弗琅禾费衍射"><a href="#单缝和圆孔的弗琅禾费衍射" class="headerlink" title="单缝和圆孔的弗琅禾费衍射"></a>单缝和圆孔的弗琅禾费衍射</h4><h5 id="单缝的弗朗禾费衍射"><a href="#单缝的弗朗禾费衍射" class="headerlink" title="单缝的弗朗禾费衍射"></a>单缝的弗朗禾费衍射</h5><p>单缝弗朗禾费衍射的光强分布公式：<br>$$<br>I_p &#x3D; I_0 (\dfrac{\sin \alpha}{\alpha})^{2}<br>$$<br>其中，$\alpha &#x3D; \dfrac{1}{2}\delta &#x3D; \dfrac{\pi a}{\lambda} \sin \varphi$</p>
<h5 id="圆孔的弗朗禾费衍射"><a href="#圆孔的弗朗禾费衍射" class="headerlink" title="圆孔的弗朗禾费衍射"></a>圆孔的弗朗禾费衍射</h5><p>艾里斑</p>
<p>艾里斑的大小和衍射孔的孔径 D 成正比。</p>
<h4 id="衍射光栅"><a href="#衍射光栅" class="headerlink" title="衍射光栅"></a>衍射光栅</h4><p>由大量等宽度、等间距的平行狭缝构成的光学系统，称为衍射光栅。</p>
<p>下面分析光栅的弗朗禾费衍射。</p>
<h4 id="衍射规律的应用"><a href="#衍射规律的应用" class="headerlink" title="衍射规律的应用"></a>衍射规律的应用</h4><p>光的衍射现象限制了光学系统的分辨能力，这是光学系统普遍存在的问题。</p>
<blockquote>
<p>分辨极限（瑞利判据）：</p>
<p>$A_1$ 的衍射图样的中央亮斑和 $A_2$ 的衍射图样的第一级暗纹相重合的情形。</p>
</blockquote>
<h4 id="光的偏振性态"><a href="#光的偏振性态" class="headerlink" title="光的偏振性态"></a>光的偏振性态</h4><p>像<strong>太阳、电灯和烛光</strong>这类普通光源中<strong>包含了大量各自独立发光的原子或分子</strong>，在由它们发出的光波中，与传播方向相垂直的平面内，所有可能的方向上，E 的振幅都相等，这样的光就是 「自然光」。</p>
<h4 id="偏振光的检测和获取"><a href="#偏振光的检测和获取" class="headerlink" title="偏振光的检测和获取"></a>偏振光的检测和获取</h4><h4 id="旋光效应和电磁场的光效应"><a href="#旋光效应和电磁场的光效应" class="headerlink" title="旋光效应和电磁场的光效应"></a>旋光效应和电磁场的光效应</h4><h4 id="光的吸收、色散和散射"><a href="#光的吸收、色散和散射" class="headerlink" title="光的吸收、色散和散射"></a>光的吸收、色散和散射</h4><p>光的色散、吸收和散射是光波在物质中传播时发生的普遍现象，是光与物质相互作用的表现。</p>
<h5 id="光的吸收"><a href="#光的吸收" class="headerlink" title="光的吸收"></a>光的吸收</h5><p>光传播时，一部分能量转变为物质的内能。</p>
<p>任何物质都会对于光有一定程度的吸收。</p>
<blockquote>
<p>朗伯定律：</p>
<p>由于物质对于光的吸收,随着光进入物质的深度的增加,光的强度按指数方式衰减。</p>
<p>具体体现为：<br>$$<br>I&#x3D;I_0 e^{-\alpha x}<br>$$</p>
</blockquote>
<p>因为光强的衰弱 $-\mathrm{d}I$ 和进入的深度成和光强正比。</p>
<p>溶液对于光的吸收和溶液的浓度有关，可以用来测量溶液的浓度。</p>
<h6 id="选择吸收和吸收光谱"><a href="#选择吸收和吸收光谱" class="headerlink" title="选择吸收和吸收光谱"></a>选择吸收和吸收光谱</h6><p>物质对于光的吸收有两种情况，一种是与光的波长 $\lambda$ 无关，称为「普遍吸收」。</p>
<p>另一种情形是，对于某些波长的光的吸收特别强烈，称为「选择吸收」。</p>
<p>原子吸收光谱，产生暗条纹，并且很敏感，所以我们可以用来推断元素、鉴别分子种类、测定分子振动频率、分析分析结构等等。</p>
<h5 id="光的色散"><a href="#光的色散" class="headerlink" title="光的色散"></a>光的色散</h5><p>光在物质中传播速度（或者折射率）随着波长 $\lambda$ 变化而变化的现象，称为「色散」。</p>
<p>与光的吸收类似，光的色散在普遍吸收波段内物质表现出「正常色散」，但是在选择吸收波段附近和选择吸收波段内物质表现出「反常色散」。</p>
<h5 id="光的散射"><a href="#光的散射" class="headerlink" title="光的散射"></a>光的散射</h5><p>与光的吸收一样，光的散射也会使通过物质的光强度减弱，如果同时考虑吸收和散射，光通过厚度为 $x$ 的物质以后，光强 I 可以表示为：<br>$$<br>I &#x3D; I_0 e^{-(\alpha + \beta)x}<br>$$<br>其中，$\alpha$ 称为吸收系数，$\beta$ 称为散射系数，$\alpha + \beta$ 称为消光系数。</p>
<h6 id="瑞利散射"><a href="#瑞利散射" class="headerlink" title="瑞利散射"></a>瑞利散射</h6><h6 id="拉曼散射"><a href="#拉曼散射" class="headerlink" title="拉曼散射"></a>拉曼散射</h6><h3 id="第十五章-波与粒子"><a href="#第十五章-波与粒子" class="headerlink" title="第十五章 波与粒子"></a>第十五章 波与粒子</h3><p>普朗克首先引入了能量子的概念，成功解释了黑体辐射的规律；爱因斯坦提出光子的理论，圆满地解释了光电效应和康普顿效应的实验规律；波尔引进的量子化概念，在解释氢原子光谱的规律性上取得了极大的成功。</p>
<p>这些新的假说和概念将 <strong>经典概念中的粒子和波联系起来了，从而为量子力学的建立奠定了基础</strong>。</p>
<h4 id="黑体辐射"><a href="#黑体辐射" class="headerlink" title="黑体辐射"></a>黑体辐射</h4><h5 id="热辐射"><a href="#热辐射" class="headerlink" title="热辐射"></a>热辐射</h5><p>分子中都包含带电粒子，做分子热运动的时候会向外辐射电磁波，这种电磁波和温度有关，所以被称为<strong>热辐射</strong>。</p>
<p>为了定量描述辐射，我们首先引入 <strong>辐射出射度</strong>（简称 辐出度），表示 <strong>单位时间内</strong> 从 <strong>单位面积</strong> 上发射出的 <strong>各种波长</strong> 的电磁波能量的平和，显然这个量和 T 温度有关，记为 $M(T)$。</p>
<p>如果是波长在 $\lambda \sim \lambda + \mathrm{d}\lambda$ 区间内，就记为 $M_\lambda(T) &#x3D;\dfrac{\mathrm{d} M(T)}{\mathrm{d}\lambda}$ 为 <strong>单色辐出度</strong>。</p>
<p>物体不仅仅能辐射电磁波，还可以<strong>吸收和反射</strong>电磁波，其中吸收和反射的情况也和自身的温度有关。</p>
<p><strong>黑体：</strong>一个物体在<strong>任何温度</strong>下对<strong>任何波长</strong>的入射入射能的吸收比都等于 1，即 $\alpha_0(\lambda, T) &#x3D; 1$ 就称这种物体为 <strong>绝对黑体</strong>，简称 <strong>黑体</strong>。</p>
<p>基尔霍夫辐射定律：<br>$$<br>\dfrac{M_\lambda(T)}{\alpha(\lambda, T)} &#x3D; M_{\lambda0}(T)<br>$$<br>任何物体的单色辐出度与单色吸收比之比，等于同一温度下绝对黑体的<strong>单色辐出度</strong>。</p>
<h5 id="黑体辐射的基本规律"><a href="#黑体辐射的基本规律" class="headerlink" title="黑体辐射的基本规律"></a>黑体辐射的基本规律</h5><p>斯特藩-玻尔兹曼定律：黑体的辐射出射度与黑体温度的四次方成正比 $M_0(T) &#x3D; \sigma T^{4}$</p>
<p>维恩位移定律：随着黑体温度的升高，单色辐出度的最大值所对应的波长 $\lambda_m$ 应按照 $T^{-1}$ 的规律向短波方向移动，即 $\lambda_m T &#x3D; b$</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212193542859.png" class="" title="image-20231212193542859">

<p>这两个定律经常用于测量高温物体的温度，也是遥感和红外跟踪技术的依据。</p>
<h5 id="普朗克辐射公式和能量子的概念"><a href="#普朗克辐射公式和能量子的概念" class="headerlink" title="普朗克辐射公式和能量子的概念"></a>普朗克辐射公式和能量子的概念</h5><p><strong>普朗克辐射公式</strong>：<br>$$<br>M_{\lambda0}(T)&#x3D;\frac{2\pi hc^{2}}{\lambda^{5}}\Big(\frac1{\mathrm{e}^{hc&#x2F;\lambda kT}-1}\Big).<br>$$<br>其中 h 为普朗克常量。</p>
<p>普朗克公式对于波长 $\lambda$ 进行积分就是得到了<strong>斯特凡玻尔兹曼</strong>定律。</p>
<h4 id="光电效应"><a href="#光电效应" class="headerlink" title="光电效应"></a>光电效应</h4><h5 id="光电效应的实验规律"><a href="#光电效应的实验规律" class="headerlink" title="光电效应的实验规律"></a>光电效应的实验规律</h5><ol>
<li>光强增大，饱和电流增大（光强影响光子的个数，进而影响可以激发的电子的个数，所以影响饱和电流大小）</li>
<li>光子的频率决定是否可以激发电子，使其冲出金属。<br>电子在金属中，可以是在金属表面，也可以是更内部，其中，逸出功的对象是 <strong>金属表面的电子</strong>。<br>这说明，对于不同位置的电子，再加上光子碰撞的角度不同，获得的能量是不一样的，有大有小，这就是为什么同一光强下，我们施加的电压<strong>可以影响电流的大小</strong>（不是饱和电流）。</li>
<li>光电效应几乎是瞬间发生的</li>
</ol>
<h5 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h5><p>光子的能量：$\varepsilon&#x3D;h\nu$</p>
<p>光速运动的光子的质量：$m_r &#x3D; \dfrac{\varepsilon}{c^{2}} &#x3D; \dfrac{h\nu}{c^{2}}$</p>
<p>光子的动量：$p &#x3D; m_r c &#x3D; \dfrac{h\nu}{c} &#x3D; \dfrac{h}{\lambda}$</p>
<p>光电效应的爱因斯坦方程：$h\nu &#x3D; \dfrac{1}{2}mu^{2} + A$，其中 A 表示逸出功</p>
<p>我们令 $\dfrac{1}{2}mu^{2} &#x3D; 0$ 就得到了光子的频率 <strong>红限</strong>，$\nu_0 &#x3D; \dfrac{A}{h}$</p>
<p>又有<br>$$<br>\begin{aligned}<br>\dfrac{1}{2}mu^{2} &#x3D; eU_a \<br>U_a &#x3D; K\nu - V_0<br>\end{aligned}<br>$$<br>至于第二个式子，是因为实验证明了 <strong>遏止电压和光子的频率呈线性关系</strong></p>
<p>得到：<br>$$<br>K &#x3D; \dfrac{h}{e}, V_0 &#x3D; \dfrac{A}{e}<br>$$</p>
<h4 id="康普顿效应"><a href="#康普顿效应" class="headerlink" title="康普顿效应"></a>康普顿效应</h4><p>X 射线经过金属、石墨等物质散射后不仅有与入射光波长相同的射线，还有波长大于入射光线的射线，这就是 <strong>康普顿效应</strong></p>
<p>推导见课本 P150</p>
<p>波长改变公式：$\Delta\lambda &#x3D; \lambda - \lambda_0 &#x3D; \dfrac{h}{m_0c} (1 - \cos \varphi)$，其中，$m_0$ 是静电子的质量，$\varphi$ 是散射角度。所以，我们可以发现，散射 X 涉嫌波长的该变量只和散射角有关，$\varphi$ 越大，$\Delta \lambda$ 就越大。</p>
<p>在散射角相同的情况下，所有的散射物质，波长的该变量都相同。</p>
<h4 id="氢原子光谱和玻尔的量子论"><a href="#氢原子光谱和玻尔的量子论" class="headerlink" title="氢原子光谱和玻尔的量子论"></a>氢原子光谱和玻尔的量子论</h4><p>金属受热、光或电场的作用会发射电子。</p>
<p>研究原子光谱的规律性是认识原子结构的重要手段，在所有原子中，氢原子是最简单的，其光谱也是最简单的。</p>
<p>通常，氢原子是处于能量最低的状态，这个状态被称为「基态」或者「正常态」。对应主量子数 n&#x3D;1。各个 $n &gt; 1$ 的稳定状态的能量均大于基态的能量，称为「激发态」。处于激发态的原子会自动跃迁到能量较低的激发态或者基态，同时释放一个能量等于两个状态能量差的光子，这就是原子发光的道理。</p>
<h4 id="微观粒子的波动性"><a href="#微观粒子的波动性" class="headerlink" title="微观粒子的波动性"></a>微观粒子的波动性</h4><p>德布罗意指出，一个质量为 $\mu$，以速率 $u$ 作匀速运动的实物粒子，<strong>从粒子性来看</strong>，可以用能量 E 和动量 p 来描述它，从波动性来看，可以用频率 $v$ 和波长 $\lambda$ 来描述它，这两个关系可以列为：<br>$$<br>E &#x3D; h\nu \<br>p &#x3D; \dfrac{h}{\lambda}<br>$$<br>这就是「德布罗意关系」。</p>
<p>根据这个关系，对于一个静质量为 $\mu_0$ 的粒子而言，当它以速率 $u$ 运动的时候，它相当于单色平面波，波长为：<br>$$<br>\lambda &#x3D; \dfrac{h}{p} &#x3D; \dfrac{h}{\mu u} &#x3D; \dfrac{h}{\mu_0u}\sqrt{1 - \left(\dfrac{u}{c}\right)^{2}}<br>$$<br>这种波就叫做「德布罗意波」。</p>
<p>静质量为 $\mu$ 以速率为 $u$ 作匀速运动的实物粒子，波长为：<br>$$<br>\lambda &#x3D; \dfrac{h}{p} &#x3D; \dfrac{h}{\mu_0u}\sqrt{1 - (\frac{u}{c})^{2}}<br>$$<br>这种波称为 <strong>德布罗意波</strong></p>
<p>后来证实了不仅仅是电子具有波动性，其他微观粒子比如原子、中子和质子等也都有波动性。</p>
<h4 id="不确定关系"><a href="#不确定关系" class="headerlink" title="不确定关系"></a>不确定关系</h4><p>在经典物理学中，描述一个确定质点的运动状态需要两个物理量，即<strong>位置和动量</strong>，并且这两个物理量在任何瞬间都具有可以确认的确定的值。但是对于拥有波粒二象性的微观粒子来说，<strong>其位置和动量是不可能同时准确测定的</strong>。</p>
<p>具体表示为：<br>$$<br>\Delta x \Delta p \geq \dfrac{\hbar}{2}<br>$$<br>所以，这个意思是，当一个测的越准确的时候，另一个就越不准确。</p>
<h3 id="第十六章-量子力学基础"><a href="#第十六章-量子力学基础" class="headerlink" title="第十六章 量子力学基础"></a>第十六章 量子力学基础</h3><p>在德布罗意关于微观粒子的波动性的推断基础上，薛定谔和海森堡几乎同时分别提出了波动力学和矩阵力学理论，后来这两个理论融合形成了量子力学，称为描述微观粒子的基本理论。</p>
<h4 id="波函数及其统计诠释"><a href="#波函数及其统计诠释" class="headerlink" title="波函数及其统计诠释"></a>波函数及其统计诠释</h4><h5 id="经典物理学中的波函数"><a href="#经典物理学中的波函数" class="headerlink" title="经典物理学中的波函数"></a>经典物理学中的波函数</h5><p>经典物理中，我们可以通过<strong>位置矢量和动量</strong>来描述一个被看为质点的宏观物体的运动状态。但是对于微观粒子，由于其有波动性，根据不确定关系，位置和动量是不可能同时准确确定的。</p>
<p>微观粒子的运动状态称为 <strong>量子态</strong>，是用波函数 $\psi\left(\vec{r},t\right)$ 来描述的，这个波函数所反映的微观粒子的波动性，就是德布罗意波。</p>
<h5 id="量子力学中波函数的统计意义"><a href="#量子力学中波函数的统计意义" class="headerlink" title="量子力学中波函数的统计意义"></a>量子力学中波函数的统计意义</h5><p>波函数不代表实际物理量的波动，而是描述粒子在空间的概率分布的概率波。</p>
<p>量子概念中的粒子性是具有一定能量、动量和质量等粒子属性，但是不具有确定的运动轨道，运动规律不遵从牛顿运动定律；</p>
<p>量子概念中的波动性是指不是一个实在物在空间的波动，而是指用波函数的模的平方表示粒子在空间某处被发现的概率。</p>
<h4 id="薛定谔方程"><a href="#薛定谔方程" class="headerlink" title="薛定谔方程"></a>薛定谔方程</h4><h5 id="含时薛定谔方程"><a href="#含时薛定谔方程" class="headerlink" title="含时薛定谔方程"></a>含时薛定谔方程</h5><p>薛定谔方程是波函数<strong>随时间和空间变化</strong>所普遍遵从的规律，是量子力学中的基本方程式。（是量子力学原理的一个基本假设，并不是直接证明或者推导的，正确性需要实验来检验）</p>
<p>推导见课本 P181</p>
<p>最后可以得到，如果粒子是自由的，没有力场，那么自由粒子满足：<br>$$<br>\mathrm{i}\hbar\frac{\partial\psi}{\partial t}&#x3D;-\frac{\hbar^2}{2\mu}\nabla^2<br>$$<br>如果粒子不是自由的，而是处于立场之中，势能为 $U(r)$，那么这是粒子的总能量为 $E &#x3D; \dfrac{p^{2}}{2\mu} + U(r)$</p>
<p>此时，一般形式的薛定谔方程（含时薛定谔方程）就是：<br>$$<br>\mathrm{i}\hbar:\frac{\partial\psi(\boldsymbol{r},t)}{\partial t}&#x3D;\left[-\frac{\hbar^{2}}{2\mu}\nabla^{2}+U(\boldsymbol{r}):\right]\psi(\boldsymbol{r},t)<br>$$</p>
<h5 id="定态薛定谔方程"><a href="#定态薛定谔方程" class="headerlink" title="定态薛定谔方程"></a>定态薛定谔方程</h5><p>如果所处的势场只是关于坐标的函数，而与时间无关，也就是可以写为 $U(r)$ 的形式，那么此时可以将薛定谔方程的一个特解写为坐标函数和时间函数的乘积，即：<br>$$<br>\psi(r,t)&#x3D;\psi(r)f(t)<br>$$<br>（具体推导见课本 P183）</p>
<p>可以得到一个关于 $\psi(r)$ 的方程：<br>$$<br>\left[-\dfrac{\hbar^{2}}{2\mu}\nabla^{2} + U(r)\right]\psi(r) &#x3D; E\psi(r)<br>$$<br> 这就是「薛定谔定态方程」，求解这一个方程就可以得到定态波函数 $\psi(r)$</p>
<p>最后，可以得到特解可以表示为：<br>$$<br>\psi(r,t)&#x3D;\psi(r)\mathrm{e}^{-\mathrm{i}Et&#x2F;\hbar}<br>$$<br>这个波函数所描述的粒子的各种状态，称为「定态」。处于定态中的粒子，在空间中概率密度函数的分布为：<br>$$<br>\rho(\boldsymbol{r},t)&#x3D;\psi^{<em>}(\boldsymbol{r},t)\psi(\boldsymbol{r},t)&#x3D;\psi^{</em>}\left(\boldsymbol{r}\right)\psi(\boldsymbol{r})<br>$$<br>可见，和时间无关。</p>
<h4 id="本征函数、本征值和平均值"><a href="#本征函数、本征值和平均值" class="headerlink" title="本征函数、本征值和平均值"></a>本征函数、本征值和平均值</h4><p>若将一个力学量的算符 $\hat{A}$ 作用于波函数，正好等于一个常量 A 乘以波函数，即：<br>$$<br>\hat{A}\psi &#x3D; A\psi<br>$$<br>这类方程，就称为力学量 $\hat{A}$  的本征值方程，满足本征值方程的常量 A 称为力学量 $\hat{A}$ 的本征值，满足本征值方程的波函数称为力学量 $\hat{A}$ 的与本征值 A 对应的本征函数。</p>
<p>引入哈密顿算符以后，定态薛定谔方程可以简化为：<br>$$<br>\hat{H}\psi(r) &#x3D; E\psi(r)<br>$$<br>在一定边界条件以下，定态薛定谔方程一般只对一些特定的 E 值有解，这些特定的 E 值就是「哈密顿算符」的本征值，也就是量子系统的能量本征值，<strong>量子系统能量的整套本征值，就是该系统的能谱</strong>。</p>
<p>不同的能量系统有不同的哈密顿算符，因而有不同的能谱和不同形式的定态波函数。</p>
<p>在量子力学中，任何一个力学量 $\hat{A}$ 的平均值都可以用下式计算：<br>$$<br>\langle A\rangle &#x3D; \overline{A} &#x3D; \int \psi^{*}(r)\hat{A}\psi(r) \mathrm{d}\tau<br>$$</p>
<h4 id="一维势阱和势垒问题"><a href="#一维势阱和势垒问题" class="headerlink" title="一维势阱和势垒问题"></a>一维势阱和势垒问题</h4><p>一维无限深方势阱是金属中自由电子的一种简化模型，是解释金属物理性质的基础；</p>
<h5 id="一维无限深方势阱"><a href="#一维无限深方势阱" class="headerlink" title="一维无限深方势阱"></a>一维无限深方势阱</h5><p>所谓一维无限深方势阱，就是粒子在势阱中的势能为 0，而在势阱外的势能无限大。<br>$$<br>\begin{aligned}<br>U(x) &#x3D; \begin{cases}<br>0 \ (0 &lt; x &lt; a) \<br>\infty \ (0 \leq x, x \geq a)<br>\end{cases}<br>\end{aligned}<br>$$<br>这样粒子就被限制在 $x &#x3D; 0$ 和 $x &#x3D; a$ 两点之间的无限深的平底深谷中运动。</p>
<p>因为势能 $U(x)$ 和时间无关，所以这是定态问题，可以使用定态薛定谔方程求解。</p>
<h5 id="势垒穿透和隧道效应"><a href="#势垒穿透和隧道效应" class="headerlink" title="势垒穿透和隧道效应"></a>势垒穿透和隧道效应</h5><p>我们上面可以看到，无限高的势垒把粒子完全束缚在阱区内，我们看一下，有限高的势垒是否也可以把粒子束缚住。</p>
<p>粒子能够穿透比其动能高的势垒的现象，称为「隧道效应」。</p>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><h4 id="电荷和静电场"><a href="#电荷和静电场" class="headerlink" title="电荷和静电场"></a>电荷和静电场</h4><p>课件 P76：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229112913103.png" class="" title="image-20231229112913103">

<p>课件 P99：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229113910299.png" class="" title="image-20231229113910299">

<p>课件 P102：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229133503252.png" class="" title="image-20231229133503252">

<ul>
<li>在理论计算中，通常选择无穷远处的电势为 0</li>
<li>在实际工作中，通常选择地面的电势为 0</li>
<li>但是对于<strong>无限大或者无限长的带电体</strong>，只能在有限的范围内选取某点的电势</li>
</ul>
<p>课件 P117：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229135542603.png" class="" title="image-20231229135542603">

<p>课件 P123：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229140206087.png" class="" title="image-20231229140206087">

<p>表明，当电荷分布扩展到无穷远处时，我们电势零点不能再选在无穷远处。</p>
<p>课件 P145：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229144419949.png" class="" title="image-20231229144419949">

<p><strong>很很很重要的一个题目，十分有助于理解这一块的内容。</strong></p>
<p>课件 P195：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229154622301.png" class="" title="image-20231229154622301">

<p>10-23：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231218162005950.png" class="" title="image-20231218162005950">

<p>10-28：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226150157427.png" class="" title="image-20231226150157427">

<p>10-32：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226151738672.png" class="" title="image-20231226151738672">

<p>10-34：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226152113570.png" class="" title="image-20231226152113570">

<p>10-35：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226153329242.png" class="" title="image-20231226153329242">

<p>注意在真空中和电介质中，E 的公式不一样。</p>
<p>所以我们计算电势的时候也要考虑全面。</p>
<p>10-40：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226160257465.png" class="" title="image-20231226160257465">

<p>注意能量的公式，微分形式和整体形式。</p>
<h4 id="电流和恒磁场"><a href="#电流和恒磁场" class="headerlink" title="电流和恒磁场"></a>电流和恒磁场</h4><p>电阻的微分定义：<br>$$<br>\rho &#x3D; \dfrac{E}{j}<br>$$<br>欧姆定律的微分形式：<br>$$<br>j &#x3D; \sigma E &#x3D; \dfrac{1}{\rho}E<br>$$</p>
<p>$$<br>\vec{M} &#x3D; \vec{m} \times \vec{B}<br>$$</p>
<p>其中，$m &#x3D; IS$ 表示<strong>磁矩</strong>，如果是多匝，应该表示为 $nIS$，M 表示力矩。</p>
<p>磁化强度 M 和磁感应强度 B 之间的关系：<br>$$<br>M &#x3D; \dfrac{\chi_m}{\mu_0 \mu_r} B &#x3D; \dfrac{\chi_m}{\mu}B<br>$$<br>其中 $\chi_m$ 是磁介质的磁化率，取决于磁介质自身的性质。对于顺磁质，$\chi_m &gt; 0$，对于抗磁质 $\chi_m &lt; 0$</p>
<p>课件 P56：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229220710320.png" class="" title="image-20231229220710320">

<p>课件 P89：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229223757297.png" class="" title="image-20231229223757297">

<p>磁场对于载流线圈的作用，感觉磁矩和力矩的公式还是比较常用的。</p>
<p>尽量记住吧。</p>
<p>课件 P91：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229225745545.png" class="" title="image-20231229225745545">

<p>判断力的方向的时候，尽量不要找过于特殊的点，不然会对于判断产生一些影响。</p>
<p>或者我们可以多选几个点判断一下。</p>
<p>课件 P108：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229231719821.png" class="" title="image-20231229231719821">

<p>霍尔系数的定义 $K_H &#x3D; \dfrac{1}{nq}$，所以和载流子的浓度和电量的乘积成反比。</p>
<p>课件 P135：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231229233153807.png" class="" title="image-20231229233153807">

<p>例题 11-3：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226184527424.png" class="" title="image-20231226184527424">

<p>例题 11-6：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231218201526053.png" class="" title="image-20231218201526053">

<p>11-4：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226190911235.png" class="" title="image-20231226190911235">

<p>11-15：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226192856273.png" class="" title="image-20231226192856273">

<p>11-22：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226194412192.png" class="" title="image-20231226194412192">

<p>11-29：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226195509594.png" class="" title="image-20231226195509594">

<p>11-32：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226211649278.png" class="" title="image-20231226211649278">

<h4 id="电磁感应和麦克斯韦电磁理论"><a href="#电磁感应和麦克斯韦电磁理论" class="headerlink" title="电磁感应和麦克斯韦电磁理论"></a>电磁感应和麦克斯韦电磁理论</h4><p>互感自感的单位是亨 H</p>
<p>微元的能量：<br>$$<br>w_m &#x3D; \dfrac{1}{2}BH<br>$$<br>对于一个螺线管，如果又因为自感可以表示为 $L &#x3D; \mu n^{2}LS$，所以，也有 $W_m &#x3D; \dfrac{1}{2}LI^{2}$</p>
<p>课件 P33：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230001845409.png" class="" title="image-20231230001845409">

<p>课件 P35：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230002003949.png" class="" title="image-20231230002003949">

<p>也可以使用积分求解，不过比较麻烦。</p>
<p>随便手写的</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230003437033.png" class="" title="image-20231230003437033">



<p>课件 P37：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230005118937.png" class="" title="image-20231230005118937">

<p>需要同时考虑磁感应强度变化和面积变化的一道题目。</p>
<p>其实就是考察的动生电动势加感生电动势。</p>
<p>课件 P60：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230010107846.png" class="" title="image-20231230010107846">

<p>使用自感电动势计算 <strong>螺绕环</strong> 能量的方法，感觉还是需要掌握的。</p>
<p>课件 P71：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230011357637.png" class="" title="image-20231230011357637">

<p>关于位移电流的一点公式。</p>
<p>课件 P96：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230012110011.png" class="" title="image-20231230012110011">

<p>注意，是单位时间穿过的单位面积</p>
<p>并且我们定义的 $w_e$ 和 $w_m$ 也是基于体积的，所以能流密度就可以使用体积乘能量密度得到了。</p>
<p>课件 P101：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231230012243517.png" class="" title="image-20231230012243517">

<p>例题 12-3：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226214929569.png" class="" title="image-20231226214929569">

<p>例题 12-4：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226215311257.png" class="" title="image-20231226215311257">

<p>例题 12-1：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226223248427.png" class="" title="image-20231226223248427">

<p>例题 12-2：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226224025758.png" class="" title="image-20231226224025758">

<p>12-7：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226230608685.png" class="" title="image-20231226230608685">

<p>注意，第二问有一个 <strong>静电场和非经典性电场平衡</strong></p>
<p>12-9：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226230836808.png" class="" title="image-20231226230836808">

<p>外力所做的功，就是外力矩所做的功。</p>
<p>12-13：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226231939116.png" class="" title="image-20231226231939116">

<p>互感和自感之间关系？？</p>
<p>12-14：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226232248907.png" class="" title="image-20231226232248907">

<h4 id="光学"><a href="#光学" class="headerlink" title="光学"></a>光学</h4><p>记住，在衍射的时候，光的偏离角大致可以表示为：<br>$$<br>\alpha &#x3D; \dfrac{\lambda}{d}<br>$$<br>所以，光的波长越大，衍射现象越明显；孔越小，衍射现象越明显。</p>
<p>例题 14-3：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227120110517.png" class="" title="image-20231227120110517">

<p>注意介质中，光程的关系！！$l &#x3D; nx$</p>
<p>例题 14-5：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227192804529.png" class="" title="image-20231227192804529">

<p>注意，油膜呈现的颜色就是 <strong>干涉加强的光波的颜色</strong>。</p>
<p>同时，可见光的范围是 300nm - 760nm</p>
<p>例题 14-7：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231227194153763.png" class="" title="image-20231227194153763">

<p>使得某一个光反射最小，就是干涉相消。</p>
<p>和上一个题目正好是一个增强，一个相消。</p>
<h4 id="波与粒子"><a href="#波与粒子" class="headerlink" title="波与粒子"></a>波与粒子</h4><p>注意，方程中的 $\dfrac{1}{2}mu^{2}$ 表示的是<strong>最大初动能</strong>，也就是从金属<strong>表面逸出</strong>的电子的动能。</p>
<p>例题 15-7：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228114722322.png" class="" title="image-20231228114722322">

<p>注意动能和动量之间的关系，注意中子的静质量也是一个常数。</p>
<h4 id="量子力学基础"><a href="#量子力学基础" class="headerlink" title="量子力学基础"></a>量子力学基础</h4><p>例题 16-2：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228174958910.png" class="" title="image-20231228174958910">

<p>并不是概率的简单相加</p>
<p>例题 16-3：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228191150965.png" class="" title="image-20231228191150965">

<p>例题 16-1：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228195744581.png" class="" title="image-20231228195744581">

<p>就是记住这一个求解平均值的式子，感觉和概率论中求解平均值很像。</p>
<p>16-3：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228202755782.png" class="" title="image-20231228202755782">

<p>16-4：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228202932058.png" class="" title="image-20231228202932058">

<p>16-5：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228203203720.png" class="" title="image-20231228203203720">

<p>16-8：</p>
<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228212019688.png" class="" title="image-20231228212019688">



<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231228211850286.png" class="" title="image-20231228211850286">

<img src="/2023/12/04/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%862%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/5b4d3aa103eebabbf3043da0c86238c9.png" class="" title="img">]]></content>
      <tags>
        <tag>Physics</tag>
      </tags>
  </entry>
  <entry>
    <title>插值与拟合建模</title>
    <url>/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<p>插值方法实数值分析中的一种古老而重要的方法。在实际生产和科学实验中，有时候仅仅能获得函数 f(x) 在若干点的函数值或者微商值，即只能给出 f(x) 的一张数据表。如果根据这张数据表构造一个函数 $\varphi(x)$ ，使之满足这张表中的数据，这样的函数 $\varphi(x)$ 就是函数 f(x) 的逼近函数。这种逼近问题称为插值问题。</p>
<h4 id="插值多项式的存在性和唯一性"><a href="#插值多项式的存在性和唯一性" class="headerlink" title="插值多项式的存在性和唯一性"></a>插值多项式的存在性和唯一性</h4><p>设 $p_n(x) &#x3D; a_0 + a_1x + a_2x^{2} + … + a_nx^n$，由插值条件可以得到非齐次线性方程组：</p>
<img src="/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E6%9D%A1%E4%BB%B6%E9%9D%9E%E9%BD%90%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%BB%84.png" class="" title="插值条件非齐次方程组">
<p>可以由 $\text{Vandermonde}$ 行列式，各个点是互异的来得到系数矩阵的行列式 $D \neq 0$。由 $\text{Cramer}$ 法则知道，方程有唯一的解，所以多项式存在且唯一。 </p>
<p><strong>几何解释：</strong> 一个 n 次的多项式一定可以由 n + 1 个点唯一确定。</p>
<h4 id="Lagrange-插值公式"><a href="#Lagrange-插值公式" class="headerlink" title="Lagrange 插值公式"></a>Lagrange 插值公式</h4><img src="/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%85%AC%E5%BC%8F.png" class="" title="拉格朗日插值公式">

<h4 id="Newton-插值公式"><a href="#Newton-插值公式" class="headerlink" title="Newton 插值公式"></a>Newton 插值公式</h4><p><a href="https://www.zhihu.com/question/22320408/answer/141973314">https://www.zhihu.com/question/22320408/answer/141973314</a> 马同学关于牛顿插值的解释<br>牛顿插值法的特点在于：每增加一个点，不会导致之前的重新计算，只需要算和新增点有关的就可以了（这里不同于拉格朗日插值法）。</p>
<h4 id="两种插值的比较"><a href="#两种插值的比较" class="headerlink" title="两种插值的比较"></a>两种插值的比较</h4><p>也不是很懂，给出 ChatGPT 的解释</p>
<ol>
<li><p>数值稳定性： 牛顿插值通常在数值上更稳定，特别是在高次插值中。高次的拉格朗日插值多项式的系数可能会变得非常大，导致数值计算问题，这在计算机中可能会引发数值溢出或不稳定性。牛顿插值使用分裂差分形式，这种形式在数值计算上通常更可靠。</p>
</li>
<li><p>数据更新效率： 如果您需要在运行时动态添加新的数据点并更新插值多项式，牛顿插值更为高效。因为在牛顿插值中，您可以通过添加一个新的数据点来更新插值多项式，而不需要重新计算整个多项式。</p>
</li>
<li><p>分布不均匀的数据： 如果您的数据点分布不均匀，拉格朗日插值可能会导致插值多项式的阶数变得非常高，这会增加计算的复杂性和开销。牛顿插值在这种情况下通常更具优势。</p>
</li>
</ol>
<p>然而，需要注意的是，即使在大数据集的情况下，牛顿插值也不是绝对适用的。在一些特定情况下，如数据点的数量非常大或插值多项式的次数非常高，都可能导致数值计算问题。在这种情况下，考虑使用更高级的插值技术，例如分段插值（如样条插值）或基于快速傅里叶变换的方法，以提高数值稳定性和计算效率。选择合适的插值方法需要综合考虑数据的性质、计算需求和数值稳定性。</p>
<h4 id="三次样条插值函数"><a href="#三次样条插值函数" class="headerlink" title="三次样条插值函数"></a>三次样条插值函数</h4><p>三次样条插值在科学和工程计算中起到重要作用，它只在插值区间的断点比 Lagrange 插值多两个边界条件，但是却在内节点处二阶导数连续。<br>样条一词来源于工程制图。绘图员为了将一些指定点（称作样点）连接成一条光滑的曲线，往往把富有弹性的细长木条（称为样条）固定在样点上，然后画下木条表示的曲线所形成的样条曲线。</p>
<p>有三种边界条件：</p>
<ol>
<li>自然边界(Natural Spline) 指端点处二阶导数为 0.</li>
<li>固定边界(Clamped Spline) 指定端点一阶导数，这里分别定为 A 和 B，即 $S_0’(x_0) &#x3D; A, S_{n - 1}^{x_n} &#x3D; B$</li>
<li>非扭结边界(Not-A-Knot Spline) 强制第一个插值点的三阶导数等于第二个点的三阶导数，最后一个点的三阶导数等于倒数第二个点的三阶导数。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/62860859?utm_medium=social&utm_oi=1127691903852081152&utm_psn=1678405306240057344&utm_source=qq">https://zhuanlan.zhihu.com/p/62860859?utm_medium=social&amp;utm_oi=1127691903852081152&amp;utm_psn=1678405306240057344&amp;utm_source=qq</a> 关于三次样条的具体推导和最终求解矩阵方程。</p>
<h4 id="最小二乘法拟合"><a href="#最小二乘法拟合" class="headerlink" title="最小二乘法拟合"></a>最小二乘法拟合</h4><p>$r_i &#x3D; y_i - \varphi(x_i)$ 称为残量，$\boldsymbol{r} &#x3D; (r_0, r_1, …, r_m)^{T}$ 称为<strong>残向量</strong>。所以用 $\varphi(x)$ 去拟合 $f(x)$ 的问题就变成了残量的大小问题。<br>我们用 $\sum\limits_{i &#x3D; 0}^{m} r_i^{2} &#x3D; \boldsymbol{r^{T}}\boldsymbol{r}$ 去度量残量的大小。<br>后面的具体推导可以参考：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/128083562">https://zhuanlan.zhihu.com/p/128083562</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109986821">https://zhuanlan.zhihu.com/p/109986821</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38128785">https://zhuanlan.zhihu.com/p/38128785</a></li>
</ol>
<p>最终结果就是参数向量 $\widehat{w} &#x3D; \boldsymbol{(X^{T}X)^{-1}X^{T}Y}$</p>
<p>内积表示？？？</p>
<h4 id="最佳平方逼近"><a href="#最佳平方逼近" class="headerlink" title="最佳平方逼近"></a>最佳平方逼近</h4>]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的几种实现</title>
    <url>/2023/09/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="双指针前移法"><a href="#双指针前移法" class="headerlink" title="双指针前移法"></a>双指针前移法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 5;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int partition(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	int pre = left;</span><br><span class="line">	int cur = pre + 1;</span><br><span class="line">	int key = v[left];</span><br><span class="line">	while (cur &lt;= right) &#123;</span><br><span class="line">		if (v[cur] &lt; key &amp;&amp; ++pre != cur) swap(v[cur], v[pre]);</span><br><span class="line">		++cur;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(v[left], v[pre]); // 将基准元素放回正确的位置</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line">	s.push(left);</span><br><span class="line">	s.push(right);</span><br><span class="line">	while (!s.empty()) &#123;</span><br><span class="line">		int r = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		int l = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		if (l &gt;= r) continue;</span><br><span class="line">		int boundary = partition(v, l, r);</span><br><span class="line">		s.push(l);</span><br><span class="line">		s.push(boundary - 1);</span><br><span class="line">		s.push(boundary + 1);</span><br><span class="line">		s.push(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; v;	</span><br><span class="line">	int x;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		v.push_back(x);</span><br><span class="line">	&#125;	</span><br><span class="line">	quickSort(v, 0, n - 1);</span><br><span class="line">	for (auto element : v) &#123;</span><br><span class="line">		cout &lt;&lt; element &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>抢课脚本</title>
    <url>/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>本质上就是模拟一个请求。<br>我们点击选课页面的时候，是将带有特定功能的数据包发送给对方，也就是服务器，然后得到服务器的反馈。</p>
<blockquote>
<p>之前 Github 上下载的学长写的选课脚本因为学校系统后台的更新没办法使用了，于是想为何不自己学习一下，自己写一个。</p>
</blockquote>
<h4 id="抓包-capture-packet"><a href="#抓包-capture-packet" class="headerlink" title="抓包 capture packet"></a>抓包 capture packet</h4><p>因为Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。<br>使用 F12 开发者工具找了一圈也没找到 Github 上下载的 SDU 抢课脚本的路径，搜索了一下感觉就是运用了抓包。</p>
<h5 id="抓包工具的原理"><a href="#抓包工具的原理" class="headerlink" title="抓包工具的原理"></a>抓包工具的原理</h5><p>那 Fiddler 举例，Fiddler 相当于一个「代理」，浏览器访问服务器页面时，就会先把 HTTP 请求先发送给 Fiddler，Fiddler 再把请求转发给服务器，当服务器返回数据时，Fiddler 拿到返回数据，再把数据交给浏览器。<br>因此 Fiddler 对于浏览器和服务器之间的交互细节是非常清楚的，进而可以帮助我们完成相应的抓包工作(其实后来感觉浏览器自带的开发者工具中的「网络」就够用了)。</p>
<img src="/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/fiddler.png" class="">

<h4 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h4><p>这段文字中，<code>https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/xsxkGgxxkxk</code> 是 URL 基本部分，用于定位服务器上的特定资源或者页面。<br><code>?</code> 表示查询字符串的开始。然后在 <code>?</code> 后面，通常会带有一个或者多个参数，每个参数都有一个名称和一个对应的值，它们之间用等号<code>=</code>连接，并且多个参数之间使用和号<code>&amp;</code>分隔。<br>其中，参数的值是根据 <code>url</code> 编码的，因此需要 <code>url decoding</code> 来将他们还原为原始文本。<br>可以直接使用 python</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib.parse import unquote</span><br><span class="line"></span><br><span class="line">encoded_value = &quot;%E6%96%87%E5%AD%A6&quot;</span><br><span class="line">decoded_value = unquote(encoded_value, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">print(decoded_value)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在计算机编程领域，特别是在处理字符串时，”quote” 通常表示在文本中添加引号或对特殊字符进行编码，而 “unquote” 则表示将文本中的引号或编码解除，还原为原始的形式。</p>
</blockquote>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>Referer（也写作”referrer”，拼写时不包括第二个 “e”）是一个HTTP头部字段，通常在Web请求中使用。这个字段用于指示请求的来源或引用页面的URL。当您从一个网页点击链接跳转到另一个页面时，浏览器通常会在请求中包含Referer字段，以告知目标页面是从哪个页面链接过来的。<br>Referer字段对于网站分析、统计和跟踪用户流量非常有用，因为它可以帮助网站所有者了解访问者是如何到达其网站的。例如，如果您运营一个电子商务网站，您可以使用Referer字段来确定哪些外部网站或广告渠道为您带来了最多的流量和销售。<br>需要注意的是，虽然Referer字段通常包含有用的信息，但它并不是100%可信的，因为用户可以通过浏览器设置或浏览器插件来修改或禁用Referer字段。因此，在进行任何安全性或敏感性操作时，不应仅依赖于Referer字段来验证请求的来源。</p>
<h4 id="Network-栏"><a href="#Network-栏" class="headerlink" title="Network 栏"></a>Network 栏</h4><p>这一栏通常会用来监视和分析与当前网页加载和网络请求相关的信息。下面是它的一些常见用途：</p>
<ol>
<li>查看网络请求。<code>Network</code> 栏显示了当前页面加载期间发出的所有网络请求，包括HTML、CSS、JavaScript、图像、API请求等。</li>
<li>查看请求头和响应头。我们可以通过 <code>Network</code> 来查看 <code>RequestHeaders</code> 和 <code>ResponseHeaders</code>，这对于检查服务器返回的信息、设置请求头来模拟不同的客户端环境或者调试跨域问题很有帮助。</li>
<li>筛选和搜索请求。<code>Network</code> 栏通常提供了筛选和搜索功能，使你可以根据请求类型（XHR、Fetch、Document等）或关键字来查找特定的请求，从而更轻松地定位问题或查找特定资源。</li>
</ol>
<h4 id="request-具体操作"><a href="#request-具体操作" class="headerlink" title="request 具体操作"></a>request 具体操作</h4><p>打开 F12，选择 <code>Network</code> 一栏。<br>然后在找到上搜索自己想选择的课程，点击右侧的「选课」按键(即使课程已经被选满了也无所谓，我们需要的是课程数据包的来源信息)，此时观察 <code>Network</code> 栏目，最下方应该会出现一个 <code>ggxxkxk</code> 开头的文件，点击后会出现它的具体信息。<br>如图：</p>
<img src="/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/selectCourseInfo.png" class="">
<p>其中 <code>Request Url</code> 就是我们获得数据包的地址，<code>kcid</code> 和 <code>jx0404id</code> 后面的数字感觉没有什么实际意义，不过可以在 HTML 代码中「选课」按键的属性值中找到，也可以查看 HTML 代码对应一下而不需要点击「选课」按键。<br><code>Cookie</code> 代表的是我们的身份信息，是服务器辨识我们身份的信息，和 <code>User-Agent</code> 还有 <code>referer</code> 一起设置在请求头中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def selectCourse():</span><br><span class="line">    cur_num = 0</span><br><span class="line">    url = &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/ggxxkxkOper?kcid=xxxxxx&#x27; \</span><br><span class="line">          &#x27;&amp;cfbs=null&amp;jx0404id=xxxxxxx&amp;xkzy=&amp;trjf=&#x27;</span><br><span class="line">    cookie = &#x27;你的 Cookie&#x27;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                      &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#x27;cookie&#x27;: cookie,</span><br><span class="line">        &#x27;referer&#x27;: &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/getGgxxk&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    while True:</span><br><span class="line">        response = requests.get(url=url, headers=headers)</span><br><span class="line">        data = json.loads(response.content.decode(response.apparent_encoding))</span><br><span class="line">        cur_num = cur_num + 1</span><br><span class="line">        print(f&quot;&#123;cur_num&#125; &#123;data[&#x27;message&#x27;]&#125;&quot;)</span><br><span class="line">        if data[&#x27;message&#x27;] != &#x27;选课失败：此课堂选课人数已满！&#x27;:</span><br><span class="line">            break</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    selectCourse()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.cnblogs.com/xubin97/p/10331558.html">https://www.cnblogs.com/xubin97/p/10331558.html</a> 抢课脚本链接<br><a href="https://blog.csdn.net/shenqueying/article/details/79426884">https://blog.csdn.net/shenqueying/article/details/79426884</a> referer 的作用<br><a href="https://blog.csdn.net/weixin_43314519/article/details/107095245">https://blog.csdn.net/weixin_43314519/article/details/107095245</a> 讲的挺好，还用到了多线程</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录2</title>
    <url>/2023/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>树状数组或二元索引树(Binary Indexed Tree)，又以其发明者命名为 Fenwick 树。其初衷是解决数据压缩里面的累计频率(Cumulative Frequency)的计算问题。</p>
<p>满足差分性质？</p>
<p>不满足差分性质的实现？</p>
<p>树状数组倍增？</p>
<p>多维树状数组</p>
<h4 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h4><p>有旋和非旋。一种弱平衡的二叉搜索树。</p>
<p>删除操作，可以找到后继以后交换值，然后向右删除？还是一直旋转操作？</p>
<p>无旋 splite 和合并</p>
<p>复杂度正确性证明？？</p>
<p><a href="https://www.luogu.com.cn/problem/solution/P3369?page=3">https://www.luogu.com.cn/problem/solution/P3369?page=3</a></p>
<h4 id="sqrt-tree"><a href="#sqrt-tree" class="headerlink" title="sqrt tree"></a>sqrt tree</h4><p>开方树</p>
<p>使用场合？复杂度证明？代码实现？同类之间的区别？</p>
<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>求解最大和子段？区间染色问题？<br>线段树的动态开点</p>
<p>主席树</p>
<p>是不是都能解决区间乘积 区间 min max gcd？</p>
<h4 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h4><p>AC 自动机(Aho-Corasick Automation)，命名是因为是 Alfred V. Aho 和 Margaret J. Corasick 提出的。</p>
<p>基数树 ？ </p>
<p>后缀树</p>
<h4 id="Boyer-Moore-字符串搜索算法"><a href="#Boyer-Moore-字符串搜索算法" class="headerlink" title="Boyer-Moore 字符串搜索算法"></a>Boyer-Moore 字符串搜索算法</h4><p>哈希？</p>
<h4 id="Rabin-Karp"><a href="#Rabin-Karp" class="headerlink" title="Rabin-Karp"></a>Rabin-Karp</h4><h4 id="RRT-Dijkstra"><a href="#RRT-Dijkstra" class="headerlink" title="RRT-Dijkstra"></a>RRT-Dijkstra</h4><p>RRT 算法（rapidly exploring random tree）是一种随机性算法。</p>
<p>本来就是寻找一个可行解，而不是寻找最优的或者是近似最优的。</p>
<p>B 样条算法？</p>
<p>RRT* 算法</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>微分方程模型</title>
    <url>/2023/08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="微分方程模型"><a href="#微分方程模型" class="headerlink" title="微分方程模型"></a>微分方程模型</h4><p>如果能得到解析解的形式固然便于分析和应用，但是大多数微分方程无法得到解析解，因此研究其稳定性和数值解法就十分重要。</p>
<ol>
<li><img src="/2023/08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/liuliangxishu.jpg" class="" title="流量系数">
 容器漏水问题。<br> 好像是 $Q &#x3D; Sv$ 流量前面一个系数，不是很懂。</li>
<li>导弹追踪问题<br> 列出关于斜率的微分方程，然后代入初值条件。</li>
</ol>
<h5 id="传染病模型"><a href="#传染病模型" class="headerlink" title="传染病模型"></a>传染病模型</h5><p>我们一开始不把所有的因素考虑在内，而是抓住主要因素，把问题简化，建立相应的数学模型。然后与实际比较，再做出修改。</p>
<ol>
<li>指数模型<br> 用 $i(t)$ 表示 t 时刻病人的数量，每个病人传染的人数为 k, 则有 $i(t + \Delta t) - i(t) &#x3D; ki(t)\Delta t$<br> 解得 $i(t) &#x3D; i_0e^{kt}$，随着时间增长，人数是无穷的，不符合实际，所以我们对于这个模型进行修改。</li>
<li>SI 模型<br> 设 t 时刻病人为 $i(t)$，健康人数为 $s(t)$，每个病人传染的人数和健康人数呈正比，比例系数为 k，则有 $i(t + \Delta t) - i(t) &#x3D; i(t)\Delta ks(t) &#x3D; ki(t)(n - i(t))$，解得 $i(t) &#x3D; \dfrac{n}{1 + (\frac{n}{i_0} - 1)e^{-kt}}$<br> 医学上一般称这个 $i(t)$ 曲线为传染病曲线。<br> 但是这个模型的缺点是，当 $t \to +\infty$ 的时候，人人都会生病，这是不符合实际的。</li>
<li>SIS 模型<br> 考虑到人们生病后是恢复的，或者说有人可能会感染多次。<br> 在上一个模型的基础上，添加日治愈率 $\mu$，和病人的数量呈正比。<br> 现在就有 $i(t + \Delta t) - i(t) &#x3D; (ks(t)i(t) - \mu i(t))\Delta t, i(0) &#x3D; i_0$。</li>
</ol>
<h4 id="捕鱼业的持续收获模型"><a href="#捕鱼业的持续收获模型" class="headerlink" title="捕鱼业的持续收获模型"></a>捕鱼业的持续收获模型</h4><h6 id="阻滞增长模型-Logistic-模型"><a href="#阻滞增长模型-Logistic-模型" class="headerlink" title="阻滞增长模型 (Logistic 模型)"></a>阻滞增长模型 (Logistic 模型)</h6><p>将增长率 r 修正为 r - sx 一个关于 x 的线性函数。自然资源和环境限制所能容纳的最大人数为 $x_m$，也就是 $x &#x3D; x_m$ 的时候，$r &#x3D;0$，所以有 $r(x) &#x3D; r(1 - \dfrac{x}{x_m})$，其实和上面传染病模型中的 SI 模型是差不多的。)</p>
<ol>
<li>产量模型<br> 记时刻 t 时渔场中的鱼量为 $x(t)$，由 Logistic 模型则有 $x’(t) &#x3D; f(x) &#x3D; rx(1 - \frac{x}{N})$，N 是环境允许的最大鱼量。<br> 设捕鱼强度为 E，也就是单位时间捕鱼量为 $Ex$，记 $F(x) &#x3D; f(x) - Ex$，则持续捕捞下，平衡的鱼量为 $x_0 &#x3D; N(1 - \frac{E}{r})$<br> $x_0 \times E$ 求二次函数的最值，就是最大的持续捕捞量了，此时 $E &#x3D; \dfrac{r}{2}$（好像和高中生物学的一样了）。<br> (其实和人口增长差不多)</li>
<li>效益模型</li>
<li>捕捞过度模型</li>
</ol>
<h4 id="战争模型"><a href="#战争模型" class="headerlink" title="战争模型"></a>战争模型</h4><p>「兰彻斯特平方定律」：作战部队的实力同投入战斗的士兵人数的平方成正比。</p>
<ol>
<li>正规战模型<br> 以 $x(t), y(t)$ 分别表示 t 时刻红军和蓝军的士兵人数，每队士兵的减员率和对方士兵的人数成正比，所以有方程 $\frac{\mathrm{d}x}{\mathrm{d}t} &#x3D; -ay, \frac{\mathrm{d}y}{\mathrm{d}t} &#x3D; -bx$，这两个式子相除，积分得到 $ay^2 - bx^2 &#x3D; ay_0^{2} - bx_0^{2} &#x3D; c$</li>
<li>混合战模型<br> 红军游击队，蓝军正规部队，但是游击队伍位于不易发现的有利位置，所以把红军的人员损失方程再乘一个 x，表示损失与自身规模大小有关。<br> $\frac{\mathrm{d}x}{\mathrm{d}t} &#x3D; -cxy + f(t)$，f(t) 表示红军的增援情况。</li>
<li>游击战模型<br> 双方都是游击队伍。就都变成上个模型红军的方程形式。</li>
</ol>
<p>恩格尔(Engel)将第二次世界大战时美军和日军争夺硫磺岛所进行的战斗资料进行分析，发现与兰彻斯特作战数学模型非常吻合，这说明兰彻斯特作战数学模型是可以来描述实际战争的。</p>
<h4 id="对药物剂量开处方"><a href="#对药物剂量开处方" class="headerlink" title="对药物剂量开处方"></a>对药物剂量开处方</h4><h4 id="捕食者——食饵模型"><a href="#捕食者——食饵模型" class="headerlink" title="捕食者——食饵模型"></a>捕食者——食饵模型</h4><p>感觉和战争模型比较相似，不过这里的捕食者和被捕食者是会自然增长的（其实等价于战争模型中的援助）。</p>
<h4 id="微分方程的数值解"><a href="#微分方程的数值解" class="headerlink" title="微分方程的数值解"></a>微分方程的数值解</h4><p>很多方程往往复杂且大多数情况下求不出解析解，因而在实际生产和科研中，常常是求满足精度要求的近似解。</p>
<ol>
<li>欧拉方法</li>
<li>梯形方法</li>
<li>龙格-库塔方法</li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录</title>
    <url>/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>TO DO</p>
<p>定义一个模板类 ? </p>
<p>如何判断链表是否有环？</p>
<ol>
<li><p>使用 map 对于地址打上标记，如果同一个地址被访问了两次就是有环的。</p>
</li>
<li><p>快慢指针(Floyd’s Cycle Detection Algorithm)，使用同余方程得到 $a + kp$ 和 $b + kq \pmod{n}$，其中 a b 分别是两个指针进入环的初始步长，k 是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 $b - a \equiv k(p - q)$ 它们的步长差值为 1 的时候可以始终保证同余。</p>
<p> 对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为 1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。<br> 下面是一段 Python 程序演示：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<h5 id="找出有环链表的入环点"><a href="#找出有环链表的入环点" class="headerlink" title="找出有环链表的入环点"></a>找出有环链表的入环点</h5><p>可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S 点，入环点是 T 点，绿色的部分是慢指针所走过的路程。</p>
<p>对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S 点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。</p>
<p>可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以 ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class="" title="入环点">

<h5 id="Floyd-判圈算法和-Brent-判圈算法"><a href="#Floyd-判圈算法和-Brent-判圈算法" class="headerlink" title="Floyd 判圈算法和 Brent 判圈算法"></a>Floyd 判圈算法和 Brent 判圈算法</h5><p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。</p>
<p>其实上面的快慢指针方法就是 Floyd 判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。<br>还有一种判圈的算法，比它更快，就是 <strong>Brent</strong> 判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第 n 轮，乌龟跳到兔子的位置，兔子走$2^{n-1}$步。</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>在申明类中的成员函数后面加上 <code>const</code> 函数就成了只读函数，如 <code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字”static”的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
</blockquote>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure>

<p>函数指针的应用：</p>
<ol>
<li>把函数作为参数传入另一个函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二个例子，排序上的应用</li>
</ol>
<p>使用 <code>ascending</code> 和 <code>descending</code> 两个函数代替大小判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda 函数的书写结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数指针应用？lambda 函数？ </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br></pre></td></tr></table></figure>

<p>STL 中的<strong>迭代子类</strong>？？</p>
<h4 id="分而治之-divide-and-conquer"><a href="#分而治之-divide-and-conquer" class="headerlink" title="分而治之 divide-and-conquer"></a>分而治之 divide-and-conquer</h4><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</p>
<blockquote>
<p>整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 <strong>性质滚性质</strong>，一直带动，所以可以达到加速的目标。</p>
</blockquote>


<p>TO DO:</p>
<p>？？非递归版本的归并排序</p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><!-- 快速排序时间复杂度
最坏 概率统计的意义下？ -->
<p>关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点…</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" class="">

<p>关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="">
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="">

<p>上面摘自知乎 <a href="https://zhuanlan.zhihu.com/p/341201904">https://zhuanlan.zhihu.com/p/341201904</a></p>
<h5 id="2-D-maxima-finding-problem"><a href="#2-D-maxima-finding-problem" class="headerlink" title="2-D maxima finding problem"></a>2-D maxima finding problem</h5><p>这是一个 maxima 问题，一般这种问题有两种解决方式。</p>
<ol>
<li>排序法</li>
</ol>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E6%8E%92%E5%BA%8F%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png" class="">

<ol start="2">
<li>分治法</li>
</ol>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%88%86%E6%B2%BB%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png" class="">

<p>摘自知乎 <a href="https://zhuanlan.zhihu.com/p/27850478">https://zhuanlan.zhihu.com/p/27850478</a></p>
<p>TO DO</p>
<!-- 平面极大点
分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 -->

<h5 id="the-closest-pair-problem"><a href="#the-closest-pair-problem" class="headerlink" title="the closest pair problem"></a>the closest pair problem</h5><p>感觉 OI-Wiki 讲解的很全面 <a href="https://oi-wiki.org/geometry/nearest-points/%EF%BC%8C%E8%BF%98%E6%9C%89%E6%8E%A8%E5%B9%BF%EF%BC%9A%E5%B9%B3%E9%9D%A2%E6%9C%80%E5%B0%8F%E5%91%A8%E9%95%BF%E4%B8%89%E8%A7%92%E5%BD%A2">https://oi-wiki.org/geometry/nearest-points/，还有推广：平面最小周长三角形</a> $\dfrac{d \times 2d}{\frac{1}{4} \times \pi \times (\frac{d}{2})^{2}}$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</p>
<!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）

时间复杂度？ -->

<p>TO DO</p>
<h5 id="the-convex-hull-problem"><a href="#the-convex-hull-problem" class="headerlink" title="the convex hull problem"></a>the convex hull problem</h5><p><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</a></p>
<p>TO DO</p>
<!-- ?
一个著名算法，礼物算法？ Jarvis March
首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着
不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了
但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去
找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 -->

<h5 id="matrix-multiplication"><a href="#matrix-multiplication" class="headerlink" title="matrix multiplication"></a>matrix multiplication</h5><!-- ?
P Q R S T U V?
时间复杂度大概是 $O(\log_2(7)) \approx O(n^{2.81})$?
但是仍然不是最优的，具体可以自己去搜索一下 -->

<p>使用类实现的矩阵的一些基础操作，可以看 <code>Fibonacci.cpp</code></p>
<p>TO DO</p>
<h5 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h5><p>分治做法，见 <code>FFT.md</code> 和 <code>FFT.cpp</code>(使用自带的 complex 类实现).其中，使用自己手写类实现的 FFT 在 <code>FFTClass.cpp</code>(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</p>
<h5 id="Medians-and-Order-Statistics"><a href="#Medians-and-Order-Statistics" class="headerlink" title="Medians and Order Statistics"></a>Medians and Order Statistics</h5><p>对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log{n})$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</p>
<p>每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</p>
<p>还有一种递归的算法，分为 5 个数，</p>
<p>nth_element() ?? 函数</p>
<p>TO DO</p>
<h5 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h5><p>尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。<br>只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。<br>为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</p>
<h5 id="Abstract-Data-Type-ADT"><a href="#Abstract-Data-Type-ADT" class="headerlink" title="Abstract Data Type(ADT)"></a>Abstract Data Type(ADT)</h5><p>抽象数据类型</p>
<h5 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h5><p>TO DO</p>
<p>Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</p>
<p>不想改变内部元素的时候记得加 const，如果不加的话，<code>void Func(const List&amp; l) &#123; l.print(); &#125;</code> 其中不允许调用，因为 Func 有修改成员变量的风险。</p>
<p><strong>常引用？</strong></p>
<p><strong>把函数当作函数的参数？</strong></p>
<p>派生类禁止父类的函数或者方法？ </p>
<p>括号匹配问题 Bracket Matching Problem</p>
<p>计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</p>
<p>双端队列 dequeue</p>
<p>环形数组</p>
<h4 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h4><h5 id="一般性消除办法"><a href="#一般性消除办法" class="headerlink" title="一般性消除办法"></a>一般性消除办法</h5><ul>
<li>利用堆栈，模拟栈来实现，见 <code>Hanoi.cpp</code></li>
</ul>
<p>汉诺塔问题 递归求解，如何去掉递归求解。$f_n &#x3D; 2 f_{n - 1} + 1$，所以 $(f_n + 1) &#x3D; 2(f_{n - 1} + 1)$</p>
<h5 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h5><p>这种任务方案其实挺多的。其实，背后对应的是<strong>辗转相除法</strong>。</p>
<p>我们可以倒出来的水的数量就是余数。</p>
<p>设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 <code>ax + by = c</code>，如果有解，就是 $\gcd{(a, b)} | c$</p>
<h5 id="求解组合数"><a href="#求解组合数" class="headerlink" title="求解组合数"></a>求解组合数</h5><p><a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a> 见 OI-Wiki各种组合数公式</p>
<p><a href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a> 二项式反演</p>
<h5 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h5><p>实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是<strong>过于耦合了</strong>。所以，对于一个类来说，接口是很重要的。</p>
<h5 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h5><h4 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h4><p>树中所有节点度数的最大值叫做整个树的度。</p>
<h5 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h5><p>一共有四种表示树的方式：</p>
<ol>
<li><p>树形结构。很直观、形象</p>
</li>
<li><p>文氏图表示法。使用集合以及集合的包含关系描述树结构。</p>
</li>
<li><p>凹入表示法。使用线段的伸缩描述树结构。</p>
</li>
<li><p>括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</p>
</li>
</ol>
<p>树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</p>
<p>按层次遍历二叉树，可能还是比较吃内存的。</p>
<p>DLR LDR LRD </p>
<p>前序 中序 后序 和 根的区别？</p>
<h5 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h5><p>对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 <code>GetTreeOrderNor.cpp</code> </p>
<p>递归形式参见 <code>GetTreeOrderRecursion.cpp</code> </p>
<p>给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 <code>ParseTreeSequence.cpp</code></p>
<h5 id="中序遍历的线索二叉树"><a href="#中序遍历的线索二叉树" class="headerlink" title="中序遍历的线索二叉树"></a>中序遍历的线索二叉树</h5><p>这样也可以充分利用空间</p>
<p>将叶子节点的右孩子指向下一个应改遍历的节点(因为一开始叶子节点的右孩子是 null，造成了浪费)，并且加一个 bool 类型的变量，表示这个节点的右孩子是不是进行了修改。</p>
<p>这样中序遍历的时候好像也会简单很多(在中序遍历的意义下，将二叉树变成了一个单链表)</p>
<p>这样二叉树的遍历就不再依赖于堆栈，并且产生了向前向后的两个方向，和双链表的行为是比较相似的。</p>
<h5 id="前序遍历的线索二叉树"><a href="#前序遍历的线索二叉树" class="headerlink" title="前序遍历的线索二叉树"></a>前序遍历的线索二叉树</h5><p>顺序建立就是修改右子树</p>
<p>但是如果反过来会出现左孩子已经被占用的问题，此时需要借助堆栈</p>
<h5 id="后序遍历的线索二叉树"><a href="#后序遍历的线索二叉树" class="headerlink" title="后序遍历的线索二叉树"></a>后序遍历的线索二叉树</h5><img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="">

<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h5><p>当我们谈论到堆(Heap)时，通常指的是二叉堆(Binary Heap)，它是一种特殊的树形结构，常用于实现优先队列和一些图算法(物理存储上是数组，但是逻辑结构上是二叉树，这也是为什么我们可以使用 vector 来模拟的原因)。</p>
<p>堆的性质：</p>
<ol>
<li><p>二叉树结构：堆是一种完全二叉树，除了最后一层，别的层的节点都是满的，最后一层的节点从左向右填充。</p>
</li>
<li><p>小根堆：任何父节点的值都小于等于其子节点的值。</p>
</li>
<li><p>不唯一性：对于给定的数据集，可能存在多个不同的最小堆或者最大堆。</p>
</li>
<li><p>只是保证了节点的权值大于两个儿子节点的权值，也就是说，堆维护的更是我们关注的相对大小关系，尤其是最顶部的元素大小，我们并不关心全序大小关系(也无法维护)。</p>
</li>
</ol>
<blockquote>
<p>  在实际中，实现堆（Heap）通常更倾向于使用向量（数组）来模拟二叉树的结构，而不是构建一个显式的二叉树数据结构。</p>
</blockquote>
<h5 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h5><h5 id="Fibonacci-堆"><a href="#Fibonacci-堆" class="headerlink" title="Fibonacci 堆"></a>Fibonacci 堆</h5><h5 id="lazy-机制"><a href="#lazy-机制" class="headerlink" title="lazy 机制"></a>lazy 机制</h5><p>上面的最简单的二叉堆做法呢，我们很好地利用了二叉树序号之间的关系(父子的序号有关系)，但是我们在更新的时候每一次都是 $\log{n}$ 的复杂度，不是很优，比如说有些元素我们以后根本用不到，而堆又本身不是关注全序关系的，所以我们可以利用 lazy 机制。</p>
<p>TODO </p>
<p>现在库里面的堆，基本上都不是基于 <strong>二叉堆</strong>(Binary Heap) 实现的。</p>
<p>Fibonacci 堆 也是希望我们去更多地了解一些堆。</p>
<p>堆的合并、二叉堆的合并？</p>
<p>二项堆</p>
<p>重载运算符</p>
<h4 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h4><p>结构光扫描中，我们如何马上知道这条光是第几条光？就要用到编码了</p>
<p>能不能发明一种序列，使得连续的几个在序列中是唯一的，longest ？ 是多长？3 个颜色的话，先画出 27 个节点。RRR 的话，连接 RRG RRB(它的后继节点)</p>
<p>寻找访问序列最长的，而且不能重复</p>
<p>深度遍历可以吗？最好不要写递归，可以队列、栈</p>
<h4 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h4><p>每一次找权值最小两个节点，变为 n - 1 个节点</p>
<ol>
<li><p>能不能构建出来</p>
</li>
<li><p>总体的最小代价</p>
</li>
</ol>
<p>可以搜索霍夫曼树的题目</p>
<p>实现持久化的最小两个数？手写优先队列？平衡树？</p>
<h4 id="左倾堆-左倾树-左偏堆-左偏树"><a href="#左倾堆-左倾树-左偏堆-左偏树" class="headerlink" title="左倾堆 &#x2F; 左倾树 &#x2F; 左偏堆 &#x2F; 左偏树"></a>左倾堆 &#x2F; 左倾树 &#x2F; 左偏堆 &#x2F; 左偏树</h4><p>虽然二叉堆的插入、删除操作挺好的，但是不支持合并。所以我们想寻找一种数据结构使得堆在合并的时候比较高效。</p>
<blockquote>
<p>Leftist Heap is a priority queue data structure that also supports merge of heaps in O(log n) time.</p>
</blockquote>
<p>FHQ Treap TODO</p>
<p><a href="https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji">https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji</a> TODO</p>
<p>最优传输理论</p>
<p>启发式合并堆</p>
<h4 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h4><p>可以证明平衡二叉树的高度为 $\log{n}$ 吗？</p>
<p>N(h) &#x3D; 1 + N(h - 1) + N(h - 2); AVL 树的高度推导 N(h) 表示高度为 h 时最不平衡时的节点个数。</p>
<p>我们是按照左右子树的树高度之差来定义的，这只是定义平衡的一种。但是还有很多别的方式，比如左右子树的节点。</p>
<p>维护平衡的机制有很多种，比如说典型的 B 树，2-3-4树，它所有的叶子都在同一个高度上面。它最不满的情况就是一个满二叉树，所以它可以保证高度在 $\log$ 级别。</p>
<p>AVL B树 红黑树 234树 Treap</p>
<p>红黑树的实际应用比较频繁，它的效率比较高一点。红黑树和 234树之间的关系？？ TODO</p>
<p>插入的时候常常面临三种情形。</p>
<p><a href="https://www.luogu.com.cn/blog/MashPlant/solution2-p3369">https://www.luogu.com.cn/blog/MashPlant/solution2-p3369</a> B 树代码</p>
<p>LCT问题？ Link Cut Tree</p>
<p>Treap 的高度 log 证明？</p>
<h4 id="the-mathematics-of-rubik’s-cube"><a href="#the-mathematics-of-rubik’s-cube" class="headerlink" title="the mathematics of rubik’s cube"></a>the mathematics of rubik’s cube</h4><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><p>正确性证明？</p>
<p>多边形</p>
<p>差分约束问题 线性规划问题 max \sum d 要求比 dijkstra 更加严苛？</p>
<p>Gorubi </p>
<p>最短路的话线性规划没有 dijkstra 更加优</p>
<p>A* 算法？</p>
<h4 id="二叉树在区间上？"><a href="#二叉树在区间上？" class="headerlink" title="二叉树在区间上？"></a>二叉树在区间上？</h4><p>维护直接的 Rank 感觉代价过于高，因为每一次删除和插入都要把其余元素都改变一次，所以我们不直接维护 Rank。</p>
<p>二叉树序列化？<a href="https://zhuanlan.zhihu.com/p/26418233">https://zhuanlan.zhihu.com/p/26418233</a></p>
<h4 id="线段相交的问题"><a href="#线段相交的问题" class="headerlink" title="线段相交的问题"></a>线段相交的问题</h4><p>两个结构：</p>
<ol>
<li><p>处理事件的优先队列(关键位置停下来，遇到了水平线段的左端点，遇到了水平线段的右端点，遇到了竖直线段)(需要使用一个二叉树维护水平线段，包括水平竖直关系)(水平线段的 y 高度使用二叉树维护了？树套树？)</p>
</li>
<li><p>维护扫描的每个关键位置的全序列表</p>
</li>
</ol>
<h4 id="kd-树"><a href="#kd-树" class="headerlink" title="kd 树"></a>kd 树</h4><p>grid 2d tree</p>
<p>quadtree(四叉树，每一个格子一分为 4) bsptree(每一次有一个平面，对于所在的平面二分，在二维的情况下就是直线)</p>
<p>上面的结构，除了 grid 的应用都是很多的。各自在不同的应用场景下使用。</p>
<p>kd 树其实是 bst 树的延申。可是很多时候一维数据是不够的，很多情况都是高维的东西。在机器学习中应用也很多。</p>
<p>ray tracing</p>
<p>2d range serach</p>
<p>从乱序中在 O(n) 的时间复杂度下找出中位数。</p>
<ol>
<li><p>每一刀下去，都是将矩形分为两个部分。</p>
</li>
<li><p>奇偶相间，第一层竖线划分，第二层就是水平划分。(优化就是把点很紧密的包在一块？)</p>
</li>
</ol>
<p>nth_element 严格 O(n) 查找中位数</p>
<h4 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h4><p>跳表是相对年轻的一个数据结构，1990 年由 Bill Pugh 提出。</p>
<p>我们需要区分一下数据域和指针域 <a href="https://www.cnblogs.com/bigsai/p/14193225.html">https://www.cnblogs.com/bigsai/p/14193225.html</a></p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>前缀和后缀的问题</p>
<p>BM 算法？</p>
<p>DFA</p>
<h4 id="并查集-Union-find"><a href="#并查集-Union-find" class="headerlink" title="并查集(Union-find)"></a>并查集(Union-find)</h4><p>虽然并查集的代码是最少的一个，但是确实非常有用的。它可以解决<strong>等价类</strong>相关的问题。</p>
<p>link-by-size 按照大小合并，此时最高高度不超过 log n，当然也有按照 rank(height)高度合并。</p>
<p>还有路径压缩(path compression)</p>
<p>无路径压缩的时候，复杂度是 $m \log n$</p>
<p>有路径压缩的时候，复杂度是 $m \alpha (m, n)$</p>
<p>其中，$\alpha$ 是反阿克曼函数。</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>每一个节点有 in 和 out 两个邻接表</p>
<p>矩阵的形式存储的时候，可能并行化运算的时候更加容易。</p>
<p>prim 求最小生成树</p>
<p>稠密图和稀疏图使用不同的堆复杂度还不一样？？</p>
<p>Kruskal 实现最小生成树</p>
<p>稀疏图 prim 和 kruskal 复杂度差不多，但是稠密图中似乎 prim 算法比较好。</p>
<p>cut 割</p>
<p>割中最小权值的边一定出现在最小生成树上 证明了 Prim 的正确性？</p>
<h5 id="欧拉回路问题"><a href="#欧拉回路问题" class="headerlink" title="欧拉回路问题"></a>欧拉回路问题</h5><p>桥 bridge 它的去除，影响了整个图的连通性</p>
<p>证明方式</p>
<p>如何找到欧拉回路(两种算法)?</p>
<p>Fleury’s Algorithm(佛罗莱)算法 此时经常有一种方法和它相提并论，Hierholzer(希尔霍尔策算法) 算法，后者实际上运行效率会更高一点(标记的注意事项？)，感觉有一个硬伤，并查集没有办法递增式构建？？。  </p>
<p>欧拉骰子？？</p>
<p>相联系的有一个哈密顿回路问题。</p>
<p>桥和割边的关系？</p>
<h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><p>大概有三种版本最短路，单源-单源、单源-多源、多源-多源。</p>
<p>并且单源-多源是其他两个版本的基础，Dijkstra 就是解决这个问题的一个优秀算法。实际上，对于单源-单源的最短路，很多人还是一样使用 Dijkstra 算法。</p>
<h5 id="Dijkstra-算法遇到负权边"><a href="#Dijkstra-算法遇到负权边" class="headerlink" title="Dijkstra 算法遇到负权边"></a>Dijkstra 算法遇到负权边</h5><p>后来人们想了很多种算法对于 Dijkstra 进行改进。其中 Bellman-Ford 就是一种。</p>
<h5 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h5><p>因为是简单路径，每一个顶点最多出现一次，所以最多 n - 1 条边。本质上，Bellman-Ford 算法更新一次，就是从 s 出发，经过边数不超过 k 的最短路(其中，k 是当前迭代到的次数)。</p>
<p>事实上，Bellman-Ford 算法遇到负环还是可能会绕圈的(TO DO)，所以人们想可不可以使用 Bellman-Ford 算法来判断是否有负环。</p>
<p>但是实际上，Bellman-Ford 算法是与 source 有关的算法。检测负环而又是和 source 无关的算法。所以，为什么要使用一个与 source 有关的算法来解决与 source 无关的问题呢？</p>
<h5 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h5><p>同样适用于负权重的图，并且解决的是多源-多源的问题。</p>
<p>Floyd 的最短路径估计？就是输出路径，记录最后一次 i、j 对更新的 k，然后递归输出路径即可。见 <code>FloydPath.cpp</code>。source 变多可以使得算法更快？</p>
<h4 id="Johnson-算法"><a href="#Johnson-算法" class="headerlink" title="Johnson 算法"></a>Johnson 算法</h4><h5 id="负环的检测"><a href="#负环的检测" class="headerlink" title="负环的检测"></a>负环的检测</h5><h4 id="图的闭包问题"><a href="#图的闭包问题" class="headerlink" title="图的闭包问题"></a>图的闭包问题</h4><p>无向图和有向图的算法，可以使用 bitset 优化？</p>
<h4 id="Graph-Traversal"><a href="#Graph-Traversal" class="headerlink" title="Graph Traversal"></a>Graph Traversal</h4><p>之前讲过并查集，可以做很多事情。查询次数越多越好？复杂度可以近似为 O(1) ？</p>
<p>dfs 一般来说要比 bfs 更加实用。bfs 遍历的时候，进栈的会越来越多，所以可能会出现一个内存问题。</p>
<p>无向图连通图：任何两个点之间都有路径</p>
<p>每一个节点都有两个编号，一个是进栈的编号，一个是出栈的编号。</p>
<p>tree edge back edge forward edge cross edge</p>
<p>深度搜索隐含了一个栈，所以每一个点都有入栈和出栈所以每一个点都有两个编号。我们能不能使用编号对于图上的点进行分类？</p>
<p>应用：垃圾回收、Mark-sweep algorithm</p>
<p>强联通分支(Strong Connected Component)：针对有向图</p>
<p>如何确定已经找到了所有的 SCC ？如果把已经找到的 SCC 抽象问一个点，那么再形成的新图一定是没有环的。</p>
<p>Kosaraju-Sharir algorithm</p>
<p>Tarjan algorithm</p>
<p>两个图是否是等价的？</p>
<p>一个图能不能摊为平面图？</p>
<h4 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h4><p>没有奇圈？</p>
<p>基于流量来解决二部图称为了一种标准的做法。这个时间是 O(mn) 的？</p>
<p>二部图可以关联到流，不过很多地方都是单独讲的，并不是基于流，不过我们以更加宏观和全局的视角来看待算法。</p>
<p>最大流等于最小割</p>
<p>可以写成一个线性规划问题？</p>
<p>线性规划问题的求解？线性规划的复杂度，一直到现在，它的复杂度还是一个谜，因为它的情况过于繁杂。</p>
<p>单纯形法</p>
<p>Ford-Fulkerson 算法</p>
<p>capacity-scaling 算法 增广的时候就不要增广很少，增广多一些？</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li><p>手写一个 List</p>
<p> 见 <code>List.cpp</code> <code>LinkList.h</code> <code>LinkList.cpp</code><br> 其中，<code>List.cpp</code> 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 <code>Node&lt;T&gt;*</code> 的形式。<br> 但是在 <code>LinkList.h</code> 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 <code>&lt;T&gt;</code> 了，这种形式也是我们更加推荐的。</p>
</li>
<li><p>手写一个面向对象的快速排序</p>
<p> <code>quick_sort.cpp</code> 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢<br> 其中，需要注意<code>函数对象</code>的写法。</p>
<p> 非递归版本：</p>
<p> <strong>双指针前移法</strong>，感觉很强，短小精悍，见 <code>QuickSortNor.cpp</code>，使用自己手写的栈，实现了对于类的非递归版本的快速排序。</p>
</li>
<li><!-- 基于自己写的链表
实现堆栈
放在不同的文件中
想规范一下大家写代码习惯 -->

<p>在这次的作业中，注意：</p>
<p>我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template<class E></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;class U&gt;</span><br><span class="line">friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LinkList&lt;U&gt;&amp; list);</span><br></pre></td></tr></table></figure>

<p>其中，ostream 是一种返回类型。</p>
</li>
<li></li>
</ol>
<ul>
<li><p>以非递归的形式实现汉诺塔，并且尽量少内存。<br>  见 <code>Hanoi.cpp</code></p>
</li>
<li><p>写最大公约数递推的程序。给定两个整数，写出最大公约数的标准形式，d &#x3D; ax + by，x y 可能是负数 我们规定 |x| &lt; |y| 此时取值是唯一的。<br>  见 <code>exgcd.cpp</code></p>
<p>  上面的扩展欧几里得是递归实现的，但是我们还是追求非递归版本，讲解参考下面的博客：</p>
<p>  <a href="https://www.cnblogs.com/zbhfz/p/11267438.html">https://www.cnblogs.com/zbhfz/p/11267438.html</a></p>
  </li>
</ul>
<ol start="5">
<li><p>非递归全排列</p>
<p> 康托展开</p>
<p> 非递归，根据排列规律输出所有的排列</p>
<p> 见 <code>CantorExpansion.cpp</code> <code>permutation.cpp</code> <code>next_permutation.cpp</code> </p>
</li>
<li><p>求斐波那契数列通项</p>
<p> 特征根法怎么来的呢？</p>
<p> 人们发现特征根对于分解递推式子是有帮助的</p>
<p> 对于一个具体的 n 输出 F_n</p>
<p> 矩阵加速递推，见 <code>Fibonacci.cpp</code></p>
</li>
<li><p>写一写二叉树的数据结构，支持几种遍历方式</p>
<p> 层次 先序 中序 后序 每一个节点都不保存父亲节点 可以使用堆栈来实现 不要递归</p>
<p> 如果给出了不同遍历方式得到的结果，如何获得原来树的结构？</p>
<p> 二叉树有一个函数，传入两个字符串序列，是不是都能恢复成原来的二叉树结构？最后输出括号表示方式的形式。</p>
<p> 见 <code>ParseTreeSequence.cpp</code> 和 <code>GetTreeOrderNor.cpp</code></p>
<p> 还有一种比较简洁的方式可以参考 于老师代码中的 <code>parseTree.cpp</code></p>
</li>
<li><p>如何形成中序遍历意义下的线索二叉树(双向的)</p>
<p> 并且用自己的线索二叉树再次实现双向遍历</p>
<p> 前序和后序不完美</p>
<p> 线索二叉树的必要？历史的产物？</p>
</li>
<li><p>自己搜索霍夫曼树的题目</p>
<p> 多叉树到二叉树的转化？</p>
<p> Weighted Path Length of Tree, WPL</p>
<p> 中位数寻找？TODO</p>
<p> 为什么需要将 友元函数的定义直接写进去 ？ TODO</p>
</li>
<li><p>了解一下 Fibonacci 堆，有精力的同学可以尝试实现。</p>
</li>
<li><p>实现一个左偏堆</p>
</li>
<li><p>写一个 AVL 维护平衡，支持插入删除查找</p>
</li>
<li><p>R G B 非递归扫描？搜索如何存储路径状态？(直接将一个 vector 作为参数传入)</p>
</li>
<li><p>实现 Treap Splay FHQTreap ?（附加）</p>
</li>
<li><p>魔方？rubik’s cube?</p>
</li>
<li><p>若干不相交的多边形，输出从多边形外面一点到外面另一点的最短路径。</p>
</li>
<li><p>尝试完善代码，为二叉树每一个节点添加 size，同时提供一个接口，返回一个节点的 rank。</p>
</li>
<li><p>写一个 kd 树代码，支持最近邻的查询，查找一个框框有多少点？输入 n 个点，输出就是求最近的点，维护一个 kd 树的类，需要的基本行为还是最好支持一下，不过我们最关心的还是最近点。</p>
</li>
<li><p>快速排序进阶。多种排序方式组合实现一个高效的快速排序。使用快速排序(在其函数上进行修改)实现线性查找元素第 k 小。荷兰旗问题？</p>
</li>
<li><p>给定若干竖直和水平的随机长度的线段，并且保证一个 y 坐标或者一个 x 坐标下只有一条线段，求这些线段的交点个数。</p>
</li>
<li><p>最长公共子序列</p>
</li>
<li><p>bitset 求解高维偏序问题</p>
</li>
<li><p>k 短路问题</p>
</li>
<li><p>完成 KMP 算法</p>
</li>
<li><p>并查集实现 鼓励大家实现基于 rank 的 union，希望并查集中有路径压缩的功能（不需要新写一个函数，只需要在 find 时顺便修改）。</p>
</li>
<li><p>实现 Prim 算法</p>
</li>
<li><p>实现 Kruskal 算法</p>
</li>
<li><p>教材以 Fleury 算法为主，但是老师更希望实现 希尔霍尔策算法，体会在桥边上有没有更好的策略。</p>
</li>
<li><p>实现无向图和有向图的闭包问题</p>
<p>Floyd 传递闭包、bitset 优化</p>
<p>Tarjan 传递闭包？</p>
<p>Floyd 输出任意 i 到 j 的最短路径？</p>
<p>Johnson 算法实现？</p>
</li>
<li><p>小根堆、胜者树、败者树</p>
</li>
<li><p>多路归并排序</p>
</li>
<li><p>实现一个函数，判断一个边是否是桥边。dfs 算法</p>
</li>
<li><p>矩阵加速递推</p>
</li>
<li><p>LCS 问题</p>
</li>
<li><p>基本的 01 背包问题</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录3</title>
    <url>/2024/01/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h4><p>存在环就说明链表的尾节点不是指向 null，而是指向了链表中的另外一个节点，只有这样才会构成环。</p>
<h5 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h5><p>如果不对于空间进行限制，我们可以采用哈希表来解决。</p>
<h5 id="快慢双指针法"><a href="#快慢双指针法" class="headerlink" title="快慢双指针法"></a>快慢双指针法</h5><p>上面介绍的哈希法用到了额外的空间，所以上面的空间复杂度是 O(n) 的，我们不想占用过多空间。</p>
<p>快慢指针的具体做法是：定义两个指针，一个 slow 指针，一次走一步；一个 fast 指针，一次走两步。如果存在某一点 slow &#x3D;&#x3D; fast，就说明存在环。</p>
<h5 id="如何判断链表中环的位置"><a href="#如何判断链表中环的位置" class="headerlink" title="如何判断链表中环的位置"></a>如何判断链表中环的位置</h5><p>采用哈希表的方法可以直接找到。</p>
<p>但是对于快慢指针的方法，两个指针相遇的位置不一定就是环的入口。详细讲解见参考 1</p>
<h5 id="Brent-算法"><a href="#Brent-算法" class="headerlink" title="Brent 算法"></a>Brent 算法</h5><p>上面的快慢指针的方法又叫做 Floyd 判圈法，下面介绍另外一种 Brent 算法，优点是缩短了判断是否有环的耗时，但是这个算法无法找到环的入口。</p>
<p>也是定义两个指针，但是这次是快指针每一次向前走 2n 步(n 为当前的回合数)。回合结束以后，慢指针直接传送到快指针的位置。在每一个回合快指针移动过程中判断是否与慢指针交会，如果交会，那么就判定存在环。</p>
<p>（正确性？）</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://www.cnblogs.com/lonely-wolf/p/15773656.html">https://www.cnblogs.com/lonely-wolf/p/15773656.html</a></li>
</ol>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>递归的方法和非递归的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1 package com.algorithm.sort.mergenonrecursive;</span><br><span class="line"> 2 </span><br><span class="line"> 3 import java.util.Arrays;</span><br><span class="line"> 4 </span><br><span class="line"> 5 /**</span><br><span class="line"> 6  * 归并排序（非递归）</span><br><span class="line"> 7  * Created by yulinfeng on 2017/6/24.</span><br><span class="line"> 8  */</span><br><span class="line"> 9 public class Merge &#123;</span><br><span class="line">10 </span><br><span class="line">11     public static void main(String[] args) &#123;</span><br><span class="line">12         int[] nums = &#123;6, 5, 3, 1, 7, 2, 4&#125;;</span><br><span class="line">13         nums = mergeSort(nums);</span><br><span class="line">14         System.out.println(Arrays.toString(nums));</span><br><span class="line">15     &#125;</span><br><span class="line">16 </span><br><span class="line">17     /**</span><br><span class="line">18      * 归并排序（非递归）</span><br><span class="line">19      * 从切分的数组长度为1开始，一次归并变回原来长度的2倍</span><br><span class="line">20      * @param nums 待排序数组</span><br><span class="line">21      * @return 排好序的数组</span><br><span class="line">22      */</span><br><span class="line">23     private static int[] mergeSort(int[] nums) &#123;</span><br><span class="line">24         int len = 1;</span><br><span class="line">25         while (len &lt;= nums.length) &#123;</span><br><span class="line">26             for (int i = 0; i + len &lt;= nums.length; i += len * 2) &#123;</span><br><span class="line">27                 int low = i, mid = i + len - 1, high = i + 2 * len - 1;</span><br><span class="line">28                 if (high &gt; nums.length - 1) &#123;</span><br><span class="line">29                     high = nums.length - 1; //整个待排序数组为奇数的情况</span><br><span class="line">30                 &#125;</span><br><span class="line">31                 merge(nums, low, mid, high);</span><br><span class="line">32             &#125;</span><br><span class="line">33             len *= 2;</span><br><span class="line">34         &#125;</span><br><span class="line">35         return nums;</span><br><span class="line">36     &#125;</span><br><span class="line">37 </span><br><span class="line">38     /**</span><br><span class="line">39      * 将切分的数组进行归并排序，同递归版</span><br><span class="line">40      * @param nums 带排序数组</span><br><span class="line">41      * @param low 左边数组第一个元素索引</span><br><span class="line">42      * @param mid 左边数组最后一个元素索引，mid + 1为右边数组第一个元素索引</span><br><span class="line">43      * @param high 右边数组最后一个元素索引</span><br><span class="line">44      */</span><br><span class="line">45     private static void merge(int[] nums, int low, int mid, int high) &#123;</span><br><span class="line">46         int[] tmpArray = new int[nums.length];</span><br><span class="line">47         int rightIndex = mid + 1;</span><br><span class="line">48         int tmpIndex = low;</span><br><span class="line">49         int begin = low;</span><br><span class="line">50         while (low &lt;= mid &amp;&amp; rightIndex &lt;= high) &#123;</span><br><span class="line">51             if (nums[low] &lt;= nums[rightIndex]) &#123;</span><br><span class="line">52                 tmpArray[tmpIndex++] = nums[low++];</span><br><span class="line">53             &#125; else &#123;</span><br><span class="line">54                 tmpArray[tmpIndex++] = nums[rightIndex++];</span><br><span class="line">55             &#125;</span><br><span class="line">56         &#125;</span><br><span class="line">57         while (low &lt;= mid) &#123;</span><br><span class="line">58             tmpArray[tmpIndex++] = nums[low++];</span><br><span class="line">59         &#125;</span><br><span class="line">60         while (rightIndex &lt;= high) &#123;</span><br><span class="line">61             tmpArray[tmpIndex++] = nums[rightIndex++];</span><br><span class="line">62         &#125;</span><br><span class="line">63         while (begin &lt;= high) &#123;</span><br><span class="line">64             nums[begin] = tmpArray[begin++];</span><br><span class="line">65         &#125;</span><br><span class="line">66     &#125;</span><br><span class="line">67 &#125;</span><br></pre></td></tr></table></figure>

<p>归并排序的非递归写法</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>关于快速排序的平均时间复杂度证明，见参考 1</p>
<p>关于递归方式实现的代码，可以看洛谷 1177 题目。</p>
<p>关于快速排序的改进方法：</p>
<ol>
<li><p>递归改为非递归程序</p>
</li>
<li><p>序列较短的时候，使用插入排序效率较高</p>
</li>
<li><p>三路快速排序，将快速排序和基数排序混合，算法思想是基于荷兰国旗问题</p>
</li>
<li><p>内省排序</p>
</li>
</ol>
<p>三路快速排序的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 模板的 T 参数表示元素的类型，此类型需要定义小于（&lt;）运算</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">// arr 为需要被排序的数组，len 为数组长度</span><br><span class="line">void quick_sort(T arr[], const int len) &#123;</span><br><span class="line">  if (len &lt;= 1) return;</span><br><span class="line">  // 随机选择基准（pivot）</span><br><span class="line">  const T pivot = arr[rand() % len];</span><br><span class="line">  // i：当前操作的元素下标</span><br><span class="line">  // arr[0, j)：存储小于 pivot 的元素</span><br><span class="line">  // arr[k, len)：存储大于 pivot 的元素</span><br><span class="line">  int i = 0, j = 0, k = len;</span><br><span class="line">  // 完成一趟三路快排，将序列分为：</span><br><span class="line">  // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素</span><br><span class="line">  while (i &lt; k) &#123;</span><br><span class="line">    if (arr[i] &lt; pivot)</span><br><span class="line">      swap(arr[i++], arr[j++]);</span><br><span class="line">    else if (pivot &lt; arr[i])</span><br><span class="line">      swap(arr[i], arr[--k]);</span><br><span class="line">    else</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">  // 递归完成对于两个子序列的快速排序</span><br><span class="line">  quick_sort(arr, j);</span><br><span class="line">  quick_sort(arr + k, len - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="线性寻找第-k-大的数"><a href="#线性寻找第-k-大的数" class="headerlink" title="线性寻找第 k 大的数"></a>线性寻找第 k 大的数</h5><p>我们按照快速排序的过程，但是在过程中，判断左边排序好的数组长度和 k 的关系，根据这个关系看是只进左侧数组还是右侧数组还是中间数组寻找第 k 大。</p>
<p>采取随机选取分解值的方式下，期望意义下，时间复杂度为 O(n)。证明可见参考 2</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序的英文名字是 Radix Sort，最早用于解决卡片排序的问题。</p>
<h4 id="Maxima-问题"><a href="#Maxima-问题" class="headerlink" title="Maxima 问题"></a>Maxima 问题</h4><p>常见解决 Maxima 问题的方法有两种，排序法和分治法</p>
<p>具体做法见参考 3</p>
<h4 id="最近点问题"><a href="#最近点问题" class="headerlink" title="最近点问题"></a>最近点问题</h4><p>可以使用分治的方法来解决，见洛谷平面最近点对题目</p>
<h5 id="推广：平面最小周长三角形"><a href="#推广：平面最小周长三角形" class="headerlink" title="推广：平面最小周长三角形"></a>推广：平面最小周长三角形</h5><p>可以推广到一个问题：在给定的一组点中，选择三个点，使得它们两两的距离的和最小。见参考 4</p>
<h4 id="凸包问题"><a href="#凸包问题" class="headerlink" title="凸包问题"></a>凸包问题</h4><p>一般有五种常用的凸包算法。</p>
<h5 id="斜率逼近法"><a href="#斜率逼近法" class="headerlink" title="斜率逼近法"></a>斜率逼近法</h5><p>这是一种比较容易想到的方法，但是不常用，因为时间复杂度过高。</p>
<p>就是先选中 y 值最小的点，然后旋转一个扫描线，时间复杂度为 O(nm)</p>
<h5 id="Jarvis-算法"><a href="#Jarvis-算法" class="headerlink" title="Jarvis 算法"></a>Jarvis 算法</h5><h5 id="Graham-算法"><a href="#Graham-算法" class="headerlink" title="Graham 算法"></a>Graham 算法</h5><p>扫描的时间是 O(n)，但是排序的时间是 O(nlogn)，所以合起来的时间复杂度是 O(nlogn)</p>
<h5 id="Andrew-算法"><a href="#Andrew-算法" class="headerlink" title="Andrew 算法"></a>Andrew 算法</h5><h5 id="使用分治？？？"><a href="#使用分治？？？" class="headerlink" title="使用分治？？？"></a>使用分治？？？</h5><h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/341201904">https://zhuanlan.zhihu.com/p/341201904</a></p>
</li>
<li><p><a href="https://oiwiki.org/basic/quick-sort/">https://oiwiki.org/basic/quick-sort/</a></p>
</li>
<li><p><a href="https://www.zhihu.com/column/p/27850478">https://www.zhihu.com/column/p/27850478</a></p>
</li>
<li><p><a href="https://oi-wiki.org/geometry/nearest-points/">https://oi-wiki.org/geometry/nearest-points/</a></p>
</li>
</ol>
<h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>一般用来矩阵加速递推。</p>
<h3 id="括号问题"><a href="#括号问题" class="headerlink" title="括号问题"></a>括号问题</h3><h3 id="三种表达式"><a href="#三种表达式" class="headerlink" title="三种表达式"></a>三种表达式</h3><h4 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h4><p>中缀表达式就是我们最常见的表达式，如 <code>(3+4)x5-6</code></p>
<h4 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h4><p>前缀表达式又被称为「波兰表达式」，运算符位于操作数之前</p>
<h5 id="中缀表达式转换为前缀表达式"><a href="#中缀表达式转换为前缀表达式" class="headerlink" title="中缀表达式转换为前缀表达式"></a>中缀表达式转换为前缀表达式</h5><p>参见参考 2</p>
<h5 id="前缀表达式求值过程"><a href="#前缀表达式求值过程" class="headerlink" title="前缀表达式求值过程"></a>前缀表达式求值过程</h5><ol>
<li><p>从<strong>右到左</strong>扫描表达式</p>
</li>
<li><p>遇到数字，将数字压入堆栈</p>
</li>
<li><p>遇到运算符，将栈顶的两个数字使用运算符运算以后压入堆栈（先弹出来的 运算符 后弹出来的）</p>
</li>
</ol>
<h4 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h4><p>后缀表达式又称为「逆波兰表达式」，与前缀表达式类似，只不过运算符位于操作数后面。求值过程和前缀表达式反着，很类似。</p>
<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ol>
<li><p><a href="https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/05/03.html">https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/05/03.html</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/2040680">https://cloud.tencent.com/developer/article/2040680</a></p>
</li>
</ol>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的几种表示方式"><a href="#树的几种表示方式" class="headerlink" title="树的几种表示方式"></a>树的几种表示方式</h4><ol>
<li><p>树形方式，很直观</p>
</li>
<li><p>文氏图表示法，使用集合之间的包含关系</p>
</li>
<li><p>凹入表示法</p>
</li>
<li><p>括号表示法，将树的根节点写在括号的左边，除根节点以外的其余节点都写在括号中，中间使用逗号隔开</p>
</li>
</ol>
<p>由括号表示法，反推出树的结构关系</p>
<h4 id="几种遍历方式"><a href="#几种遍历方式" class="headerlink" title="几种遍历方式"></a>几种遍历方式</h4><p>前序、中序、后序遍历，并且还有非递归的方式</p>
<p>还有从中序遍历和后序遍历或者中序遍历和前序遍历得到树的结构问题</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><h4 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h4><h4 id="Fibonacci-堆"><a href="#Fibonacci-堆" class="headerlink" title="Fibonacci 堆"></a>Fibonacci 堆</h4><h4 id="左偏堆"><a href="#左偏堆" class="headerlink" title="左偏堆"></a>左偏堆</h4><p>左偏树 &#x2F; 左偏堆是一种配对堆，具有堆的性质，并且可以快速合并。</p>
<p>左偏树是一颗二叉树，不仅仅具有堆的性质，并且是「左偏」的：每一个节点的左儿子的 dist 都大于等于右儿子的 dist，所以每一个节点的 dist 都等于其右儿子的 dist 加一</p>
<p>但是，dist 不是指深度，左偏树的深度没有保证。</p>
<p>时间复杂度证明</p>
<h3 id="三色编码问题"><a href="#三色编码问题" class="headerlink" title="三色编码问题"></a>三色编码问题</h3><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>哈夫曼树：带权路径长度 WPL 最短的多叉树（最优多叉树）。</p>
<p>对于 k 叉哈夫曼树，我们在构建之前应该加一些节点，满足 (n - 1) % (k - 1) &#x3D;&#x3D; 0</p>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>对于查搜索树节点的定义、遍历、搜索、插入、删除、求元素的排名、求排名为 k 的元素</p>
<h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><p>实际上，AVL 平衡树原理简单，实现也不复杂。</p>
<p>关于树高的证明，可以看参考一中，用到了斐波那契序列。</p>
<p>其中，OIWIKI 中还有使用 AVL 对于 Map 的实现，可以看看。</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h4 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h4><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h4><p>适用于任何图，不管有向还是无向，边权正负，但是不能有负环</p>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol>
<li><p>给定一个正权无向图，找一个最小权值的环</p>
</li>
<li><p>已知一个有向图中任意两点之间是否有连边，要求判断任意两点之间是否联通，可以使用 bitset 优化</p>
</li>
</ol>
<h4 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h4><p>Bellman-Ford 是一种基于松弛 relax 的算法，可以求出有负权的图的最短路，并且可以对于最短路不存在的情况进行判断。</p>
<p>对于 Bellman-Ford 的松弛操作，每一次松弛都会使最短路的边数至少加 1，又因为最短路的边数最多为 n - 1，所以整个算法运行 n - 1 次松弛操作，时间复杂度为 O(nm)</p>
<p>所以，当第 n 轮循环仍然存在可能被松弛的边的时候，说明从 S 出发存在负环</p>
<h5 id="队列优化-SPFA"><a href="#队列优化-SPFA" class="headerlink" title="队列优化 SPFA"></a>队列优化 SPFA</h5><p>显然，很多时候我们不需要那么多松弛，或者说松弛的发生是有规律可寻的。只有上一轮松弛过的边，才可能引起下一轮的松弛，所以我们用队列维护哪些节点可能引起松弛，就能只访问必要的边了。</p>
<p>SPFA 算法也可以用来判断 S 点是否可以抵达一个负环，只需要记录最短路经过了多少条边，如果经过了至少 n 条边，说明可以抵达一个负环。</p>
<h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><p>Dijkstra 算法是一种求解<strong>非负权</strong>图上单源最短路径的算法</p>
<p>使用不同的优化方案，Dijkstra 的时间复杂度是不同的。稠密图中，可能直接暴力更好</p>
<h5 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h5><p>可以使用数学归纳法证明。可见参考二</p>
<h4 id="Johnson-全源最短路径算法"><a href="#Johnson-全源最短路径算法" class="headerlink" title="Johnson 全源最短路径算法"></a>Johnson 全源最短路径算法</h4><p>Johnson 和 Floyd 一样，是一种能求出无负环图上任意两点间最短路径的算法。</p>
<p>对于任意两点之间的最短路，可以跑 n 次 Bellman-Ford，时间复杂度是 $O(n^{2}m)$ 的，也可以直接使用 Floyd 算法，时间复杂度是 $O(n^{3})$ 的。</p>
<p>如果我们跑 n 次堆优化的 Dijkstra 算法，时间复杂度会更优，但是不适用于负权路，所以我们需要进行一些预处理，保证所有的边的边权为非负。</p>
<p>具体讲解可以看参考 3 或者 OIWIKI 最短路那一块的讲解。</p>
<h4 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h4><p>差分约束问题可以转化为最短路或者最长路问题，所以两种转化也就形成了两种连边的方式。</p>
<h4 id="闭包传递"><a href="#闭包传递" class="headerlink" title="闭包传递"></a>闭包传递</h4><h5 id="负环-正环判断"><a href="#负环-正环判断" class="headerlink" title="负环 &#x2F; 正环判断"></a>负环 &#x2F; 正环判断</h5><p>若存在负环，不等式无解</p>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>Minimum Spanning Tree, MST</p>
<p>Kruskal 算法和 Prim 算法</p>
<p>Kruskal 的复杂度为 mlogm</p>
<p>稠密图尤其是完全图上，Prim 算法的复杂度比 Kruskal 更优</p>
<p>Prim 使用二叉堆是 (n + m)logn</p>
<h5 id="正确性证明-1"><a href="#正确性证明-1" class="headerlink" title="正确性证明"></a>正确性证明</h5><p>Kruskal：使用归纳法。</p>
<p>Prim：这种算法之所以可行，是基于这样一个判断：对于任意一个顶点vi，连接到该顶点的所有边中的一条最短边(vi, vj)必然属于最小生成树（该判断也可以扩展成：任意一个属于最小生成树的连通子图（子树），从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树）</p>
<h4 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h4><p>Fleury 算法和 Hierholzer 算法</p>
<p>可以看 <a href="https://www.zhihu.com/tardis/zm/art/108411618?source_id=1003">https://www.zhihu.com/tardis/zm/art/108411618?source_id=1003</a></p>
<h4 id="哈密顿回路"><a href="#哈密顿回路" class="headerlink" title="哈密顿回路"></a>哈密顿回路</h4><h4 id="桥-割-边双-点双"><a href="#桥-割-边双-点双" class="headerlink" title="桥 割 边双 点双"></a>桥 割 边双 点双</h4><h4 id="联通分量"><a href="#联通分量" class="headerlink" title="联通分量"></a>联通分量</h4><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><p>实际上，Ford–Fulkerson 增广的正确性和最大流最小割定理（The Maxflow-Mincut Theorem）等价。</p>
<p>Dinic 算法</p>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>超级源点与超级汇点，然后进行 Dinic 就可以</p>
<h3 id="KD-树"><a href="#KD-树" class="headerlink" title="KD 树"></a>KD 树</h3><p>K-D Tree 是 K-Dimension Tree 的缩写，可以高效处理 K 维空间信息。在节点数 n 远大于 $2^{k}$ 的时候，时间效率比较好。</p>
<p>关于 KD 树求解平面最近距离的代码，可以参见 <a href="https://blog.csdn.net/qq_43517189/article/details/105923098">https://blog.csdn.net/qq_43517189/article/details/105923098</a></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><h4 id="查询时间复杂度"><a href="#查询时间复杂度" class="headerlink" title="查询时间复杂度"></a>查询时间复杂度</h4><p>一共 logn 层，每一层的遍历个数不会超过 3，所以查询的时间复杂度是 logn</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>就是线性的</p>
<h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><p>插入的时候，我们对于跳表使用随机一个高度。删除的思路也是差不多的。详细可以看参考一</p>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://www.jianshu.com/p/9d8296562806">https://www.jianshu.com/p/9d8296562806</a></li>
</ol>
<h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p>给定一个文本 t 和一个字符串 s，尝试找出并展示 s 在 t 中的所有出现</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>关于并查集使用启发式合并和路径压缩的时间复杂度</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>0-1 背包</p>
<p>完全背包 区别在于一个物品可以选取无限次</p>
<p>多重背包 区别在于每一个物品的个数都是确定的，而不是无限的，注意直接转化或者二进制分组优化</p>
<p>混合背包 有的只能一次，有的无限次，有的 k 次</p>
<p>二维费用背包</p>
<p>分组背包 从所有物品中选择一件变为了从当前组中选择一件，于是对每一组进行一次 0-1 背包就行了</p>
<p>有依赖的背包</p>
<p>泛化物品的背包 这种背包没有固定的费用和价值，价值是随着分配给它的费用决定的</p>
<h5 id="背包问题变种"><a href="#背包问题变种" class="headerlink" title="背包问题变种"></a>背包问题变种</h5><p>求方案数 转移方程变成了求和</p>
<p>求最优方案数</p>
<p>第 k 优解 增加一维用于记录当前状态下的前 k 优解，可以看为普通背包的一个序列，可以使用双指针的方法</p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><p><a href="https://oi-wiki.org/ds/avl/">https://oi-wiki.org/ds/avl/</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/jiangshaoyin/p/9954937.html">https://www.cnblogs.com/jiangshaoyin/p/9954937.html</a></p>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/solution/P5905">https://www.luogu.com.cn/problem/solution/P5905</a></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>杂记2</title>
    <url>/2023/11/12/%E6%9D%82%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h4><p>Ubuntu 主要使用 apt(Advanced Package Tool)作为包管理工具。APT 是一套工具集，用于安装、更新、卸载和管理软件包。</p>
<p>下面是一些常见的 apt 指令：</p>
<p>sudo apt update: 用于更新本地包信息的命令，以确保系统知道可用的软件包和更新。<br>sudo apt upgrade: 用于升级已安装软件包的命令。<br>sudo apt install package_name: 用于安装特定软件包的命令。<br>sudo apt remove package_name: 用于卸载已安装的软件包。<br>sudo apt search search_term: 用于在存储库中搜索软件包的命令。<br>sudo apt list: 用于列出可用的软件包。</p>
<p>Ubuntu的软件存储库包含大量的开源软件包，而APT使得管理和安装这些软件包变得非常方便。APT还支持依赖解决，确保软件包安装时满足其所需的依赖项。</p>
<p>虽然 Ubuntu 使用 apt，但是我们也可以在 Ubuntu 上面安装其他的包管理工具。</p>
<h4 id="Arch-Linux"><a href="#Arch-Linux" class="headerlink" title="Arch Linux"></a>Arch Linux</h4><p>Arch Linux是一种面向Linux发烧友和高级用户的Linux发行版，以其<strong>极简的设计和强大的定制性</strong>而闻名。</p>
<p>Arch Linux采用滚动发布模型，这意味着它不会按照固定的版本发布，而是持续更新软件包以提供最新的功能和安全性修复。</p>
<p>Arch Linux的包管理系统使用称为”pacman”的工具，它允许用户轻松地安装、更新和删除软件包。用户可以通过Arch User Repository（AUR）来访问大量社区维护的软件包，这些软件包不包含在官方仓库中，从而增加了软件可用性。</p>
<p>由于Arch Linux的定制性，用户必须亲自配置和设置系统，包括桌面环境、窗口管理器和其他系统组件。这使得Arch Linux适合那些喜欢自定义自己的Linux系统的用户，但也可能对新手来说有一定的学习曲线。</p>
<h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p>一般数据库中有着不同的用户，不同用户下有着不同是数据库，并且不同数据库下有着不同的表格。</p>
<p>这是数据库管理的一种基本安全和隔离策略，有助于确保数据的完整性、安全性和隔离。</p>
<p>下面是一些应用情况：</p>
<ol>
<li><p><strong>不同用户访问不同的数据库</strong>：不同用户可以被授予访问不同数据库的权限。这意味着用户A可以访问数据库A，而用户B可以访问数据库B，但它们无法相互访问对方的数据库。</p>
</li>
<li><p><strong>不同用户访问相同数据库的不同表格</strong>：即使多个用户可以访问相同的数据库，也可以根据其权限来访问和操作不同的表格。例如，用户A可能只能访问表格X，而用户B可以访问表格Y。</p>
</li>
<li><p><strong>权限级别不同</strong>：用户的权限级别可以不同，例如只读用户、读写用户、管理员等。这决定了用户可以执行的操作和管理的范围。</p>
</li>
</ol>
<h4 id="GIS-系统"><a href="#GIS-系统" class="headerlink" title="GIS 系统"></a>GIS 系统</h4><h4 id="os-path-join-函数"><a href="#os-path-join-函数" class="headerlink" title="os.path.join 函数"></a>os.path.join 函数</h4><p><code>os.path.join</code> 函数用于构建文件和目录路径。<br>它可以接受任意数量的字符串参数，然后根据操作系统的规则构建有效的路径字符串。<br><strong>这对于创建跨平台的路径非常有用</strong>，因为不同操作系统使用不同的路径分隔符（例如，在Unix和Linux系统上是&#x2F;，在Windows系统上是\）。</p>
<h4 id="os-listdir-函数"><a href="#os-listdir-函数" class="headerlink" title="os.listdir() 函数"></a>os.listdir() 函数</h4><p><code>os.listdir()</code> 函数用于列出指定目录中的文件和子目录。</p>
<h4 id="Dos-命令"><a href="#Dos-命令" class="headerlink" title="Dos 命令"></a>Dos 命令</h4><h4 id="低代码平台"><a href="#低代码平台" class="headerlink" title="低代码平台"></a>低代码平台</h4><p>低代码平台(Low-Code Platform)是一种用于应用程序开发的软件开发工具或平台，它旨在简化和加速应用程序开发过程。这种平台允许开发人员使用图形用户界面、拖放式元素和少量的编程代码来创建应用程序，而不需要从头开始编写大量的传统编程代码。</p>
<h4 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h4><ol>
<li><p>Java开发工具包 (JDK): JDK 是用于开发Java应用程序的核心工具集。它包括Java编译器 (javac)、Java虚拟机 (JVM)、标准类库和各种开发工具。JDK是开发Java应用程序的必备组件，你需要安装它才能开始编写和运行Java代码。</p>
</li>
<li><p>Java运行时环境 (JRE): JRE 包含Java应用程序的运行时组件，包括Java虚拟机 (JVM) 和标准类库。如果你只需要运行Java应用程序而不是开发它们，你可以安装JRE而不是完整的JDK。</p>
</li>
</ol>
<p>它们的简写是：<br>JDK: Java Development Kit（Java开发工具包）<br>JRE: Java Runtime Environment（Java运行时环境）</p>
<p>javac 是 Java 编程语言中的编译器。它用于将 Java 源代码文件（以 .java 为扩展名）转换成 Java 字节码文件（以 .class 为扩展名），这些字节码文件可以由 Java 虚拟机（JVM）执行。编译器负责将源代码翻译成计算机可以理解的字节码，以便在运行时执行。</p>
<p>使用 javac 命令，你可以编译你的 Java 源代码文件，检查代码中是否有语法错误，以及生成可执行的字节码文件。</p>
<h4 id="使用-JVM-执行"><a href="#使用-JVM-执行" class="headerlink" title="使用 JVM 执行"></a>使用 JVM 执行</h4><p>使用 JVM 执行编译后的 java 代码，有很多重要作用。</p>
<ol>
<li><p>跨平台性：Java程序编译成字节码，而不是与特定操作系统或硬件相关的本地机器代码。这使得Java应用程序具有跨平台性，可以在支持Java的不同操作系统上运行，只要这些系统上安装了相应的JVM。这大大简化了跨平台开发和部署。</p>
</li>
<li><p>安全性：JVM提供了各种安全特性，包括字节码验证和安全沙箱，以确保Java应用程序在运行时不会执行危险的操作或访问系统资源。这有助于防止恶意代码的执行和对系统的潜在损害。</p>
</li>
<li><p>内存管理：JVM负责Java应用程序的内存管理，包括垃圾回收。这减轻了开发人员的负担，因为他们不必手动分配和释放内存，而是依赖JVM来自动处理内存管理。</p>
</li>
<li><p>性能优化：JVM具有即时编译器和其他优化技术，可以在运行时提高Java应用程序的性能。它可以根据应用程序的行为动态进行性能调整，以提供更高的执行效率。</p>
</li>
<li><p>多线程支持：JVM提供了多线程支持，允许Java应用程序轻松地创建和管理多个线程，以实现并行执行和并发操作。</p>
</li>
<li><p>异常处理：JVM提供了强大的异常处理机制，使开发人员能够更容易地检测和处理错误条件，从而增加应用程序的可靠性。</p>
</li>
</ol>
<h4 id="python-解释器"><a href="#python-解释器" class="headerlink" title="python 解释器"></a>python 解释器</h4><p>Python也使用了虚拟机的概念，具有跨平台性质。Python代码通常由Python解释器执行，这个<strong>解释器充当了Python虚拟机的角色</strong>。Python解释器负责将Python源代码转换为字节码，然后在Python虚拟机上执行这些字节码。</p>
<h4 id="Java-环境管理"><a href="#Java-环境管理" class="headerlink" title="Java 环境管理"></a>Java 环境管理</h4><p>构建工具(Apache Meaven \ Gradle):</p>
<ol>
<li><p><strong>项目构建自动化</strong>。构建工具可以自动化构建过程，包括编译 Java 源代码、打包 JAR 文件、运行单元测试、生成文档等。这大大减少了开发人员手动操作的负担。</p>
</li>
<li><p><strong>依赖管理</strong>。构建工具可以管理项目的依赖关系，包括第三方库、框架和插件。</p>
</li>
<li><p>多模块项目支持：构建工具允许你将项目分解为多个模块，每个模块可以有自己的构建配置。这有助于组织大型项目并提高代码的模块化性。</p>
</li>
</ol>
<p>依赖管理：</p>
<ol>
<li><p>引入第三方库：Java项目通常依赖于各种第三方库和框架，如数据库驱动程序、HTTP客户端库、日志库等。通过在项目配置文件中定义这些依赖关系，你可以告诉构建工具从中央仓库或其他位置下载这些库，然后将它们添加到你的项目中。</p>
</li>
<li><p>版本控制：依赖管理工具允许你指定依赖库的版本号，确保你使用的是特定版本，避免不同版本之间的冲突。</p>
</li>
<li><p>自动下载和更新：一旦依赖关系被定义，构建工具可以自动下载和更新这些依赖项，从而简化了维护过程。</p>
</li>
<li><p>可重用性：依赖管理使你的项目可以更容易地与其他项目共享，因为其他项目可以使用相同的依赖定义。</p>
</li>
</ol>
<h4 id="vector-赋值"><a href="#vector-赋值" class="headerlink" title="vector 赋值"></a>vector 赋值</h4><ol>
<li><p>使用赋值操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination;</span><br><span class="line">destination = source; // 使用赋值操作符</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用拷贝构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination(source); // 使用拷贝构造函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>assign</code> 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination;</span><br><span class="line">destination.assign(source.begin(), source.end()); // 使用 assign 函数</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用范围初始化 &#x2F; 范围构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; source = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">std::vector&lt;int&gt; destination(source.begin(), source.end()); // 范围初始化</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="vector-构造"><a href="#vector-构造" class="headerlink" title="vector 构造"></a>vector 构造</h4><ol>
<li><p>默认构造函数<br>其实也就是直接声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector; // 创建一个空的整数向量</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定大小的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector(5); // 创建一个包含5个默认构造的整数的向量</span><br></pre></td></tr></table></figure>

<p>默认值为 0</p>
</li>
<li><p>指定大小和初值的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector(5, 42); // 创建一个包含5个值为42的整数的向量</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造<br>有两种，一种是范围的拷贝构造，另一种是直接写另一个 vector 的拷贝构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; myVector(myIteratorBegin, myIteratorEnd); // 用迭代器范围初始化向量</span><br><span class="line"></span><br><span class="line">std::vector&lt;int&gt; myVector(otherVector); // 使用另一个向量初始化新向量</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><p>在命令行中，短横线(减号「-」)通常用于指定命令的选项(options)。选项通常以单个短横线「-m」或者两个短横线「–message」引导。 </p>
<h4 id="git-add-和-git-add-A-异同"><a href="#git-add-和-git-add-A-异同" class="headerlink" title="git add . 和 git add -A 异同"></a>git add . 和 git add -A 异同</h4><p>git add . </p>
<ul>
<li>通常会将目录下所有未追踪 (untracked) 和已修改的(modified) 的文件添加到暂存区。</li>
<li>但是并不会处理已经删除的文件。</li>
</ul>
<p>git add -A</p>
<ul>
<li>这个命令会递归处理当前目录下所有未追踪、已修改和已删除的文件添加到暂存区。</li>
</ul>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS 解析、DNS 服务器</p>
<p>DNS 解析就是指的是将人类可读的域名转换为计算机能够理解的 IP 地址的过程。</p>
<p>DNS 服务器，可以理解为我们将一个域名发送给 DNS 服务器来解析，它解析完再返回给我们 IP 地址。</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN（内容分发网络, Content Delivery Network）是一种网络架构，旨在提高互联网上的内容传输速度、可用性和性能。它通过在全球范围内部署多个服务器节点，将内容分发到离用户更近的位置，从而减少网络延迟和提高访问速度。</p>
<p>通俗来说就是将一个域名对应多个 IP 地址，这样用户访问这个域名的时候会分配一个最优的 IP 地址。</p>
<h4 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h4><p>VNC（Virtual Network Computing）是一种远程桌面协议，允许用户通过网络连接到远程计算机并控制其桌面。VNC登录指的是使用VNC协议进行远程连接，以访问和操作远程计算机的桌面环境。</p>
<p>这里的 Virtual 并不是指虚拟化技术，而是强调VNC通过网络传输用户输入和计算机的屏幕输出，使用户能够远程感觉就像他们坐在计算机前一样。</p>
<h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p>Command Line Interface 命令行界面。CLI 经常被用来封装和执行特定的操作，用户通过输入命令和参数来触发这些操作。</p>
<p>通常，CLI 具有下面的优势：</p>
<ol>
<li><p>简单和直观</p>
</li>
<li><p>自动化</p>
</li>
<li><p>轻量和高效</p>
</li>
</ol>
<p>在软件开发中，CLI也经常用于工具和框架，如Hexo中提到的命令行接口。这些工具通过提供一组命令，将复杂的操作封装起来，使用户能够通过简单的命令完成一系列任务，提高了工作效率。还比如 Vue 的脚手架。</p>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>SSH(Secure Shell)，SSH 是一种用于在不安全网络上安全地进行远程登陆或执行命令的协议。它通过加密通信的方式提供了对网络连接的安全性。</p>
<p>一般使用 <code>ssh username@hostname</code> 命令连接远程主机。</p>
<p>可以使用 <code>ssh-keygen -t rsa -b 2048 -c &quot;your_email@example.com&quot;</code> 生成密钥对。</p>
<ul>
<li><code>-t rsa</code>: 指定生成的密钥类型为 RSA</li>
<li><code>-b 2048</code>: 指定密钥的位数，2048 是一种常用的安全选择</li>
<li><code>-C &quot;your_email@example.com&quot;</code>: 添加一个注释，通常是电子邮件，以便于表示密钥</li>
</ul>
<p>默认情况下，密钥会保存在 <code>~/.ssh/</code> 目录中，其中 <code>~</code> 表示当前用户。</p>
<h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><p><code>wget</code> 主要用于从 Web 上下载文件，可以用于下载任何类型的文件，不仅仅限制于软件包。<code>wget</code> 不会自动解决软件包的依赖关系或进行安装进程，只是简单地下载文件。</p>
<p>对于 <code>pip</code> 或者 <code>npm</code>，<code>pip</code> 是从 Python Package Index(PyPI) 下载和安装 Python 包，并且会处理依赖关系。也提供了更高级的功能，比如说虚拟环境管理、升级和卸载包等。<code>npm</code> 是 Node.js 的包管理工具，用于安装和管理 JavaScript 包。也可以管理软件包的依赖关系，并且提供了一系列命令来管理包，如安装、省级、卸载等。也是有一个专门存储和管理 node.js 的网站，称为 npm Registry。</p>
<h4 id="GitHub-Gist"><a href="#GitHub-Gist" class="headerlink" title="GitHub Gist"></a>GitHub Gist</h4><p>GitHub Gist 可以用于方便地分享和存储代码片段、文本片段、Markdown 文档等小文件。是一个轻量级的版本控制系统。</p>
<h4 id="Bitbucket"><a href="#Bitbucket" class="headerlink" title="Bitbucket"></a>Bitbucket</h4><p>Bitbucket 是一个基于云的代码托管服务，主要用于协作开发和版本控制。它支持 Git 和 Mercurial 这两种分布式版本控制系统，并提供了一系列工具和功能，帮助团队协同开发软件项目。</p>
<p>和 GitHub 是比较相似的。</p>
<h4 id="nth-element-函数"><a href="#nth-element-函数" class="headerlink" title="nth_element 函数"></a>nth_element 函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);</span><br></pre></td></tr></table></figure>

<p>其中，<code>first</code> 是范围的起始迭代器，<code>nth</code> 是范围内指向第 n 个元素的迭代器，<code>last</code> 范围末尾的迭代器。</p>
<p>std::vector<int> numbers &#x3D; {5, 2, 8, 1, 6, 3, 7, 4};</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">std::<span class="built_in">nth_element</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + <span class="number">3</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;The fourth element is now: &quot;</span> &lt;&lt; numbers[<span class="number">3</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : numbers) &#123;</span><br><span class="line">   std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">The fourth element is now: <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">7</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>返回排名第四的数字，并且前后分别是小于它的数和大于它的数，因为是使用快速排序实现的。</p>
<h4 id="静态网站与动态处理"><a href="#静态网站与动态处理" class="headerlink" title="静态网站与动态处理"></a>静态网站与动态处理</h4><h5 id="静态网站-Static-Website"><a href="#静态网站-Static-Website" class="headerlink" title="静态网站(Static Website)"></a>静态网站(Static Website)</h5><ul>
<li><p>是由预先生成的 HTML、CSS 和 Javascript 文件组成的，这些文件在构建网站的时候就已经生成，并且在用户请求页面的时候直接传递给浏览器。</p>
</li>
<li><p>没有服务器端的动态处理，无需在服务器上进行实时的处理或者数据库查询。</p>
</li>
<li><p>静态网站通常加载更快，因为不需要服务器端生成内容。</p>
</li>
</ul>
<h5 id="服务器端的动态处理-Sever-side-Dynamic-Processing"><a href="#服务器端的动态处理-Sever-side-Dynamic-Processing" class="headerlink" title="服务器端的动态处理(Sever-side Dynamic Processing)"></a>服务器端的动态处理(Sever-side Dynamic Processing)</h5><ul>
<li><p>服务器会根据请求的参数、用户身份、数据库查询等动态生成页面内容，并且传递给用户的浏览器。</p>
</li>
<li><p>允许实时的交互、个性化内容但是也会增加服务器的负担和响应时间。</p>
</li>
<li><p>常见的动态处理技术包括使用脚本语言（PHP、Python、Ruby 等）、数据库查询和服务器端框架（如Django、Ruby on Rails 等）。</p>
</li>
</ul>
<h4 id="C-使用内存池"><a href="#C-使用内存池" class="headerlink" title="C++ 使用内存池"></a>C++ 使用内存池</h4><p>当代码中使用内存池时，是为了避免频繁地进行动态内存分配和释放，从而提高程序的运行效率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node mem_poor[MAXN]; <span class="comment">//内存池，直接分配好避免动态分配内存占用时间 </span></span><br><span class="line">Node *tail, *root, *null; <span class="comment">// 用null表示NULL的指针更方便，tail为内存分配指针，root为根 </span></span><br><span class="line">Node *bc[MAXN]; <span class="type">int</span> bc_top; <span class="comment">// 储存被删除的节点的内存地址，分配时可以再利用这些地址 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">      tail = mem_poor;</span><br><span class="line">      null = tail++;</span><br><span class="line">      null-&gt;ch[<span class="number">0</span>] = null-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">      null-&gt;cover = null-&gt;size = null-&gt;key = <span class="number">0</span>;</span><br><span class="line">      root = null; bc_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">NewNode</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">      Node * p = bc_top ? bc[--bc_top] : tail++;</span><br><span class="line">      p-&gt;ch[<span class="number">0</span>] = p-&gt;ch[<span class="number">1</span>] = null;</span><br><span class="line">      p-&gt;size = p-&gt;cover = <span class="number">1</span>; p-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">      p-&gt;key = key;</span><br><span class="line">      <span class="keyword">return</span> p;pp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h4><p>Stack Overflow 实际上是一个包含许多子社区（subcommunity）或者子站点（subsite）的平台。每个子社区都专注于特定的主题或技术领域，以满足不同用户群体的需求。</p>
<p>常见的子社区和标签包括：</p>
<ol>
<li><p>Stack Overflow： 这是最广泛使用的部分，涵盖了几乎所有编程和开发相关的主题。</p>
</li>
<li><p>Server Fault： 专注于系统管理员和网络管理的子社区。</p>
</li>
<li><p>Super User： 面向计算机爱好者和电脑用户的子社区。</p>
</li>
<li><p>Ask Ubuntu： 针对Ubuntu操作系统用户的子社区。</p>
</li>
<li><p>Mathematics Stack Exchange： 专注于数学问题的子社区。</p>
</li>
</ol>
<h4 id="PIN"><a href="#PIN" class="headerlink" title="PIN"></a>PIN</h4><p>PIN(Personal Identification Number)，通常是一个数字代码，用于验证个人身份。</p>
<h4 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h4><p>VPN 是 「Virtual Private Network」 的缩写，中文翻译为「虚拟私人网络」。VPN 是一种通过公用网络建立私密通信通道的技术。它通过在用户和目标服务器之间创建一条加密连接，使得数据在传输过程中更为安全。</p>
<h4 id="iff"><a href="#iff" class="headerlink" title="iff"></a>iff</h4><p>「iff」 是一个缩写，通常表示「if and only if」，在数学、逻辑学和计算机科学中经常被使用，用于强调两个条件在逻辑上是等价的。</p>
<h4 id="H-W"><a href="#H-W" class="headerlink" title="H.W."></a>H.W.</h4><p><code>H.W.</code> 一般是 <code>Homework</code> 的简写(abbreviation)。</p>
<h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><p><code>tuple</code> 是 C++11 标准引入的一个特性，它是一个固定长大小的不同类型元素的集合。<code>tuple</code> 可以包含任意数量的元素，并且每一个元素的类型可以不同。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个包含整数、浮点数和字符串的tuple</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; <span class="title">myTuple</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取tuple中的元素</span></span><br><span class="line">    <span class="type">int</span> intValue = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(myTuple);</span><br><span class="line">    <span class="type">float</span> floatValue = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(myTuple);</span><br><span class="line">    std::string stringValue = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(myTuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出元素的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Int value: &quot;</span> &lt;&lt; intValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Float value: &quot;</span> &lt;&lt; floatValue &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String value: &quot;</span> &lt;&lt; stringValue &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，C++17 引入的结构化绑定(structured bindings)也可以方便地用于访问 <code>tuple</code> 的元素。</p>
<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><p>PHP 是 Hypertext Preprocessor 的缩写。是一种通用的开源脚本语言，特别适用于在 Web 开发中嵌入 HTML 中使用。PHP 被广泛用于服务器编程，用于生成动态网页。</p>
<p>下面是 PHP 的一些关键特点：</p>
<ol>
<li><p>服务器端脚本语言。PHP 是一种服务器端脚本语言，意味着它在服务器上运行，生成并发送 HTML 到客户端浏览器。这使得 PHP 适用于处理服务器上的数据和执行服务器端的任务。</p>
</li>
<li><p>嵌入 HTML。PHP 可以直接嵌入到 HTML 代码中，使得在页面中混合 PHP 代码和 HTML 标记非常方便。这种混合使用的文件通常以 .php 或 .phtml 为扩展名。</p>
</li>
<li><p>动态网页生成。PHP 使得开发者能够动态生成网页内容，响应用户请求，并与数据库交互，因此适用于构建动态和交互性强的网站。</p>
</li>
<li><p>广泛的数据库支持。PHP 支持与多种数据库系统的集成，包括 MySQL、PostgreSQL、SQLite 等，使得开发者可以方便地进行数据库操作。</p>
</li>
</ol>
<h4 id="VPS-Virtual-Private-Server"><a href="#VPS-Virtual-Private-Server" class="headerlink" title="VPS(Virtual Private Server)"></a>VPS(Virtual Private Server)</h4><p>VPS 也称为虚拟专用服务器。VPS 是一种虚拟化技术，通过在物理服务器上创建多个虚拟服务器，每个都有自己的操作系统和资源。这使得多个用户可以共享一台物理服务器。</p>
<p>VPS 广泛用于托管网站、应用程序开发和测、数据备份等各种用途。</p>
<h4 id="b-s-c-s"><a href="#b-s-c-s" class="headerlink" title="b&#x2F;s c&#x2F;s"></a>b&#x2F;s c&#x2F;s</h4><p>以前的网页开发通常采用服务器端渲染 (Server-side Rendering, SSR) 的方式，即服务器端生成整个 HTML 页面，并将其发送给客户端浏览器。这种方式下，前端和后端的逻辑通常混合在一起。而现代网页开发倾向于客户端渲染 (Client-Side Rendering, CSR) 的方式，其中前端和后端的逻辑被明确地分离。</p>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>添加环境变量是为了能够在任何位置使用这些工具的命令，而不必每一次都切换到安装目录。通常在添加路径到环境变量时，您会添加可执行文件的所在目录，而不是直接添加可执行文件。</p>
<h4 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h4><ol>
<li><p>实对称矩阵A的不同特征值对应的特征向量是正交的；</p>
</li>
<li><p>n阶实对称矩阵A必可相似对角化，且对角阵上的元素即为特征值；</p>
</li>
<li><p>若A有k重特征值λ则必有k个线性无关特征向量或者说r(λE-A)&#x3D;n-k；</p>
</li>
<li><p>A的秩等于非零特征值的个数；</p>
</li>
<li><p>n阶实对称矩阵A有n个特征值的话（含重根），若r(A)&lt; n，则有n-r(A)个零特征值；</p>
</li>
<li><p>A的特征值均为实数，特征向量均为实向量</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>斐波那契堆</title>
    <url>/2023/10/09/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86/</url>
    <content><![CDATA[<p>斐波那契堆数据结构有两种用途。</p>
<ol>
<li>支持一系列操作，这些操作构成了所谓的「可合并堆」</li>
<li>斐波那契的一系列操作可以在常数时间内完成，这使得这种数据结构非常适合需要频繁调用这些操作的应用。</li>
</ol>
<h4 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h4><p>斐波那契堆有着更好的均摊时间复杂度，但是最坏情况下的时间复杂度会比较高。在一些很多条边的稠密图中，每一次调用 DECREASE-KEY 需要 O(1) 此时比普通的二项堆是要好一些的。</p>
<p>但是从实际角度出发，除了某些需要管理大量数据的应用以外，对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比普通的二项堆或者(K 项堆)并不那么适用。</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>斐波那契堆的根链表是「双向链表」，我们将 min 节点看作为双向链表的表头。后面插入节点的时候就是将节点插入到 min 节点之前，也就是双向链表的末尾。</p>
<h4 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h4><p>合并操作就是将一个堆的根链表插入到另一个堆的根链表上。</p>
<h4 id="减小节点值"><a href="#减小节点值" class="headerlink" title="减小节点值"></a>减小节点值</h4><p>难点在于，如果我们减小节点值后，破坏了「最小堆」的性质，应该如何维护呢？</p>
<ol>
<li>首先，将「被减小节点」它所在的最小堆剥离出来，然后将该节点或者其子树(如果有的话)关联到根链中。</li>
<li>对于「被减少节点」的原父节点进行「级联剪切」。所谓级联剪切，就是在被减小节点破坏了最小堆性质，并且被切下来以后，再从它的父节点递归进行级联剪切的操作。<br>级联剪切具体地：如果父节点的 marked 为 false，赋值为 true，然后退出。<br>否则，将父节点也从最小堆中切下来，继续递归。<br>marked标记的作用就是用来标记”该节点的子节点是否有被删除过”，它的作用是来实现级联剪切。而级联剪切的真正目的是为了防止”最小堆”由二叉树演化成链表。</li>
</ol>
<h4 id="增加节点值"><a href="#增加节点值" class="headerlink" title="增加节点值"></a>增加节点值</h4><p>​	</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIBONACCI_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIBONACCI_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciHeapNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    <span class="type">int</span> degree;</span><br><span class="line">    <span class="type">bool</span> marked;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* parent;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* child;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* nxt;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* prev;</span><br><span class="line">    <span class="built_in">FibonacciHeapNode</span>(T val)</span><br><span class="line">        : <span class="built_in">value</span>(val)</span><br><span class="line">        , <span class="built_in">degree</span>(<span class="number">0</span>)</span><br><span class="line">        , <span class="built_in">marked</span>(<span class="literal">false</span>)</span><br><span class="line">        , <span class="built_in">parent</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">child</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        , <span class="built_in">nxt</span>(<span class="keyword">this</span>)</span><br><span class="line">        , <span class="built_in">prev</span>(<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FibonacciHeap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        FibonacciHeapNode&lt;T&gt;* minNode; </span><br><span class="line">        <span class="comment">// 外部访问接口</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">FibonacciHeapNode&lt;T&gt;* <span class="title">extractMin</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="built_in">FibonacciHeap</span>()</span><br><span class="line">            : <span class="built_in">minNode</span>(<span class="literal">nullptr</span>)</span><br><span class="line">            , <span class="built_in">size</span>(<span class="number">0</span>)</span><br><span class="line">            , <span class="built_in">maxDegree</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>: <span class="comment">// 内部实现细节</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="type">int</span> maxDegree;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">consolidate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">decrease</span><span class="params">(FibonacciHeapNode&lt;T&gt;*, T)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">cutNode</span><span class="params">(FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">cascading</span><span class="params">(FibonacciHeapNode&lt;T&gt;*)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">insert</span>(T val) &#123;</span><br><span class="line">    <span class="built_in">insertNode</span>(<span class="keyword">new</span> <span class="built_in">FibonacciHeapNode</span>(val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">insertNode</span>(FibonacciHeapNode&lt;T&gt;* cur) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        minNode = cur;</span><br><span class="line">        maxDegree = <span class="number">1</span>; <span class="comment">// Initialize maxDegree</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur-&gt;prev = minNode-&gt;prev;</span><br><span class="line">        cur-&gt;nxt = minNode;</span><br><span class="line">        minNode-&gt;prev-&gt;nxt = cur;</span><br><span class="line">        minNode-&gt;prev = cur;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;value &lt; minNode-&gt;value) &#123;</span><br><span class="line">            minNode = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">linkAdd</span><span class="params">(FibonacciHeapNode&lt;T&gt;* x, FibonacciHeapNode&lt;T&gt;* y)</span> </span>&#123;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* temp;</span><br><span class="line">    temp = x-&gt;nxt;</span><br><span class="line">    x-&gt;nxt = y-&gt;nxt;</span><br><span class="line">    y-&gt;nxt-&gt;nxt = x;</span><br><span class="line">    y-&gt;nxt = temp;</span><br><span class="line">    temp-&gt;prev = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    <span class="built_in">extractMin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">removeNode</span>(FibonacciHeapNode&lt;T&gt;* x) &#123;</span><br><span class="line">    x-&gt;prev-&gt;nxt = x-&gt;nxt;</span><br><span class="line">    x-&gt;nxt-&gt;prev = x-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">FibonacciHeap&lt;T&gt;* <span class="title">heapUnion</span><span class="params">(FibonacciHeap&lt;T&gt;* h1, FibonacciHeap&lt;T&gt;* h2)</span> </span>&#123;</span><br><span class="line">    FibonacciHeap&lt;T&gt;* temp;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> h1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h2-&gt;maxDegree &gt; h1-&gt;maxDegree) &#123;</span><br><span class="line">        temp = h1;</span><br><span class="line">        h1 = h2;</span><br><span class="line">        h2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h1-&gt;minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        h1-&gt;minNode = h2-&gt;minNode;</span><br><span class="line">        h1-&gt;size = h2-&gt;size;</span><br><span class="line">        h1-&gt;maxDegree = h2-&gt;maxDegree;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (h2-&gt;minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">linkAdd</span>(h1-&gt;minNode, h2-&gt;minNode);</span><br><span class="line">        <span class="keyword">if</span> (h1-&gt;minNode-&gt;value &gt; h2-&gt;minNode-&gt;value)</span><br><span class="line">            h1-&gt;minNode = h2-&gt;minNode;</span><br><span class="line">        <span class="keyword">delete</span> h2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::<span class="built_in">extractMin</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (minNode == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* child = <span class="literal">nullptr</span>;</span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* Min = minNode;</span><br><span class="line">    <span class="keyword">while</span> (Min-&gt;child != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        child = Min-&gt;child;</span><br><span class="line">        <span class="built_in">removeNode</span>(child);</span><br><span class="line">        <span class="keyword">if</span> (child-&gt;nxt == child)</span><br><span class="line">            Min-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            Min-&gt;child = child-&gt;nxt;</span><br><span class="line">        <span class="built_in">linkAdd</span>(child, minNode);</span><br><span class="line">        child-&gt;parent = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">removeNode</span>(Min);</span><br><span class="line">    <span class="keyword">if</span> (Min-&gt;nxt == Min) &#123;</span><br><span class="line">        minNode = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        minNode = Min-&gt;nxt;</span><br><span class="line">        <span class="built_in">consolidate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    --size;</span><br><span class="line">    <span class="keyword">return</span> Min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> FibonacciHeap&lt;T&gt;::<span class="built_in">consolidate</span>() &#123;</span><br><span class="line">    <span class="type">int</span> maxDegreePossible = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">log2</span>(size)) + <span class="number">1</span>;</span><br><span class="line">    std::vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; <span class="built_in">degreeTable</span>(maxDegreePossible, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate through the root list and consolidate nodes with the same degree</span></span><br><span class="line">    FibonacciHeapNode&lt;T&gt;* cur = minNode;</span><br><span class="line">    std::vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; rootsToVisit;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        rootsToVisit.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        cur = cur-&gt;nxt;</span><br><span class="line">    &#125; <span class="keyword">while</span> (cur != minNode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FibonacciHeapNode&lt;T&gt;* node : rootsToVisit) &#123;</span><br><span class="line">        <span class="type">int</span> degree = node-&gt;degree;</span><br><span class="line">        <span class="keyword">while</span> (degreeTable[degree] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            FibonacciHeapNode&lt;T&gt;* other = degreeTable[degree];</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;value &gt; other-&gt;value) &#123;</span><br><span class="line">                <span class="comment">// Swap the nodes if necessary</span></span><br><span class="line">                FibonacciHeapNode&lt;T&gt;* temp = node;</span><br><span class="line">                node = other;</span><br><span class="line">                other = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Link other as a child of node</span></span><br><span class="line">            <span class="built_in">linkAdd</span>(node, other);</span><br><span class="line">            degreeTable[degree] = <span class="literal">nullptr</span>;</span><br><span class="line">            degree++;</span><br><span class="line">        &#125;</span><br><span class="line">        degreeTable[degree] = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebuild the root list with consolidated nodes</span></span><br><span class="line">    minNode = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxDegreePossible; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degreeTable[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minNode == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                minNode = degreeTable[i];</span><br><span class="line">                minNode-&gt;nxt = minNode;</span><br><span class="line">                minNode-&gt;prev = minNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">insertNode</span>(degreeTable[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::decrease(FibonacciHeapNode&lt;T&gt;* cur, T value) &#123;</span></span><br><span class="line"><span class="comment">//     FibonacciHeapNode&lt;T&gt;* parent;</span></span><br><span class="line"><span class="comment">//     if (minNode == nullptr || cur == nullptr) return ;</span></span><br><span class="line"><span class="comment">//     if (value &gt;= cur-&gt;value) &#123;</span></span><br><span class="line"><span class="comment">//         throw std::runtime_error(&quot;illegal decreasing.&quot;);</span></span><br><span class="line"><span class="comment">//         return ;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     cur-&gt;value = value;</span></span><br><span class="line"><span class="comment">//     if (parent != null &amp;&amp; cur-&gt;value &lt; parent-&gt;value) &#123;</span></span><br><span class="line"><span class="comment">//         cutNode(cur, parent);</span></span><br><span class="line"><span class="comment">//         cascading(parent);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if (cur-&gt;value &lt; minNode)</span></span><br><span class="line"><span class="comment">//         minNode = cur;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::cutNode(FibonacciHeapNode&lt;T&gt;* cur, FibonacciHeapNode&lt;T&gt;* parent) &#123;</span></span><br><span class="line"><span class="comment">//     removeNode(cur);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">// void FibonacciHeap&lt;T&gt;::cascading(FibonacciHeapNode&lt;T&gt;* parent) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://www.cnblogs.com/skywang12345/p/3659060.html">https://www.cnblogs.com/skywang12345/p/3659060.html</a><br>算法导论</p>
<p><a href="https://www.cnblogs.com/junyuhuang/p/4463758.html">https://www.cnblogs.com/junyuhuang/p/4463758.html</a></p>
<p><a href="https://wangkuiwu.github.io/2013/03/05/fabonacci-cpp/">https://wangkuiwu.github.io/2013/03/05/fabonacci-cpp/</a></p>
<p><a href="https://blog.csdn.net/u013148167/article/details/54236076">https://blog.csdn.net/u013148167/article/details/54236076</a></p>
]]></content>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/2023/08/31/%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="Auto-js"><a href="#Auto-js" class="headerlink" title="Auto.js"></a>Auto.js</h4><p>Auto.js 是一种基于 JavaScript 的自动化工具，它允许你编写和运行 JavaScript 脚本来自动化执行 Android 设备上的各种任务。因此，Auto.js 使用 JavaScript 作为其编程语言。</p>
<p>关于 Auto.js 和 JavaScript 的关系如下：</p>
<ol>
<li><p>Auto.js 使用 JavaScript：Auto.js 的脚本是用 JavaScript 编写的，因此你可以在 Auto.js 中编写标准的 JavaScript 代码。这使得 Auto.js 在编写和运行自动化脚本时非常灵活，因为你可以使用 JavaScript 的语法和功能。</p>
</li>
<li><p>Auto.js 扩展了 JavaScript：尽管 Auto.js 使用 JavaScript 作为其编程语言，但它还提供了一组额外的 API 和库，这些 API 和库允许你与 Android 设备的各种功能和资源进行交互，如模拟用户输入、操作屏幕、访问文件系统等。这些功能通常不是标准的 JavaScript 语言特性，而是 Auto.js 为 Android 自动化提供的功能扩展。</p>
</li>
<li><p>Auto.js 是 JavaScript 的运行环境：Auto.js 提供了一个运行 JavaScript 脚本的环境，这个环境专门设计用于在 Android 设备上执行脚本。它允许你使用 JavaScript 控制 Android 设备的各种操作，例如自动点击、滑动、截屏等等。</p>
</li>
</ol>
<p>总之，Auto.js 是一个工具，它使用 JavaScript 作为编程语言，并扩展了 JavaScript，以便在 Android 设备上执行自动化任务。这使得开发人员可以使用 JavaScript 的语法和功能，结合 Auto.js 提供的 Android 自动化 API，编写用于自动化控制和操作 Android 应用和设备的脚本。</p>
<h4 id="C-赋值"><a href="#C-赋值" class="headerlink" title="C++ 赋值"></a>C++ 赋值</h4><ul>
<li>对于函数的变量，我们可以使用值传递或者引用传递，取决于函数的参数类型。如果是带有 <code>&amp;</code>，此时就是引用传递，在函数中对于变量修改会影响到函数外部的值。对于数组，向函数传递的实际上是指向数组首元素的指针，这意味着参数的本质上是通过地址传递的，所以函数内部的修改可以影响到外部。</li>
<li>在C++中，当您将一个类对象赋值给另一个类对象时，默认情况下是使用复制构造函数来执行赋值操作，因此这也是一种值传递。这意味着目标对象会被复制为源对象的一个副本，两个对象之间是相互独立的，修改一个对象的属性不会影响另一个对象。</li>
</ul>
<h4 id="VSCode-重命名所有匹配项"><a href="#VSCode-重命名所有匹配项" class="headerlink" title="VSCode 重命名所有匹配项"></a>VSCode 重命名所有匹配项</h4><p>按住 <code>alt</code> + <code>shift</code><br><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a> VScode 的快捷键表</p>
<h4 id="ES5-和-ES6-含义"><a href="#ES5-和-ES6-含义" class="headerlink" title="ES5 和 ES6 含义"></a>ES5 和 ES6 含义</h4><p>ES6 和 ES5 是 JavaScript 的不同版本，它们代表了不同的 ECMAScript（简称 ES）标准。ECMAScript 是 JavaScript 语言的标准化规范，规定了 JavaScript 语法、特性和行为。</p>
<ol>
<li>ES5（ECMAScript 5）： ES5 是 JavaScript 的第五个主要版本，它在2009年发布。它引入了许多重要的新特性，例如严格模式（Strict Mode）、数组方法（如 forEach、map、filter 等）和更强大的对象属性定义（Object.defineProperty）。ES5被广泛支持，并且在早期的浏览器中是主要的 JavaScript 标准。</li>
<li>ES6（ECMAScript 2015）： ES6 是 JavaScript 的第六个主要版本，也称为 ECMAScript 2015。它于2015年发布，并引入了许多新的特性和语法改进，如箭头函数、类、模块、解构赋值、let 和 const 变量声明等。ES6使得 JavaScript 更加现代化和强大，并提供了更好的开发工具和技术。尽管它在发布时得到了广泛的支持，但由于浏览器的兼容性问题，需要一些时间才能在所有主要环境中广泛使用。</li>
</ol>
<h4 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h4><p><span> 是一个行内元素（inline element）或内联元素，用于在文本中包裹一部分内容，而不会引入新的块级元素或换行。<span> 通常用于对文本的一部分进行样式设置或添加其他属性，以便在不破坏文本流的情况下对其进行操作。<br><span> 元素本身不会对其包含的文本内容产生任何视觉效果，它主要用于以下情况：</p>
<ol>
<li>样式设置：你可以使用 <span> 元素为文本添加 CSS 样式，例如更改文本的颜色、字体、背景色等。这使得你可以有选择性地为文本的一部分应用样式，而不必更改整个段落或文本块的样式。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;span style=&quot;color: red;&quot;&gt;red text&lt;/span&gt; and this is &lt;span style=&quot;font-weight: bold;&quot;&gt;bold text&lt;/span&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>JavaScript 操作：<span> 通常用于 JavaScript 操作，你可以通过 JavaScript 选择 <span> 元素并修改其内容或属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Click &lt;span id=&quot;mySpan&quot; onclick=&quot;changeText()&quot;&gt;here&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function changeText() &#123;</span><br><span class="line">  var spanElement = document.getElementById(&quot;mySpan&quot;);</span><br><span class="line">  spanElement.innerHTML = &quot;clicked!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="HTML-中-img-标签中的-alt-属性"><a href="#HTML-中-img-标签中的-alt-属性" class="headerlink" title="HTML 中 img 标签中的 alt 属性"></a>HTML 中 img 标签中的 alt 属性</h4><p><code>alt</code> 属性用于提供图片的替代文本(Alternative Text)</p>
<ol>
<li>替代文字：如果图像无法加载或无法显示，浏览器会显示 alt 属性中的文本，以提供对图像内容的文字描述，从而使页面更具可访问性。</li>
<li>辅助工具：屏幕阅读器等辅助技术会读取 alt 文本，以向用户描述图像。因此，良好的 alt 文本可以帮助视觉障碍者理解图像的含义。</li>
<li>优化 SEO：搜索引擎可以使用 alt 文本来理解图像的内容，从而更好地索引和排名网页。</li>
<li>图像加载失败时的占位符。</li>
<li>提示信息：一些浏览器在用户将鼠标悬停在图像上时会显示 alt 文本作为工具提示，以提供附加信息。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;example.jpg&quot; alt=&quot;一只可爱的猫咪&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="axios-和-jQuery"><a href="#axios-和-jQuery" class="headerlink" title="axios 和 jQuery"></a>axios 和 jQuery</h4><p>axios 是一个独立的 JavaScript 库，专注于处理 HTTP 请求。它是一个现代的、基于 Promise 的库，主要用于前端和后端（Node.js）开发，提供了清晰、简单的 API。<br>$.ajax() 是 jQuery 库的一部分，用于处理各种类型的 AJAX 请求。它除了处理 HTTP 请求外，还包括许多其他功能，如 DOM 操作、事件处理、动画等。因此，$.ajax() 只是 jQuery 库的一部分。<br>总结来说就是，axios 是一个相对较小的库，专注于 HTTP 请求。你可以单独引入它，而无需加载整个 jQuery 库。$.ajax() 是 jQuery 的一部分，如果你只需要进行 HTTP 请求，使用 jQuery 会显得冗余，因为它包含了许多其他功能。</p>
<h4 id="VSCode-多光标编辑"><a href="#VSCode-多光标编辑" class="headerlink" title="VSCode 多光标编辑"></a>VSCode 多光标编辑</h4><ol>
<li>按住 <code>alt</code> 点击多个位置(这个方法选择就没有约束)。</li>
<li>按住鼠标滚轮，往下拖动(这个方法只是支持在同一竖线上的多位置编辑)。</li>
</ol>
<h4 id="快速创建-HTML-模板"><a href="#快速创建-HTML-模板" class="headerlink" title="快速创建 HTML 模板"></a>快速创建 HTML 模板</h4><p>创建xxx.html文件，输入: ! + Tab</p>
<h4 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h4><p>在HTML中，实体字符是一种特殊的编码方式，用来表示一些特殊字符或保留字符，以确保它们能够正确地显示在网页上，而不会被解释为HTML标记。以下是一些常见的HTML实体字符</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/%E5%AE%9E%E4%BD%93%E5%AD%97%E7%AC%A6.png" class="">

<h4 id="系统变量和用户变量"><a href="#系统变量和用户变量" class="headerlink" title="系统变量和用户变量"></a>系统变量和用户变量</h4><p>系统变量与用户变量的区别，最重要的即系统变量的优先级高于用户变量。</p>
<h4 id="BeautifulSoup-库"><a href="#BeautifulSoup-库" class="headerlink" title="BeautifulSoup 库"></a>BeautifulSoup 库</h4><p>Beautiful Soup 是一个Python库，用于从HTML或XML文档中提取数据。它是一个强大的解析库，可以帮助你轻松地解析复杂的网页内容，并从中提取所需的信息。<br>它可以帮助我们(在使用Beautiful Soup库时，通常需要指定一个底层的解析器，而 lxml 是一个常用的解析器之一，因为它具有高性能和稳定性。Beautiful Soup本身并没有自带解析器，因此需要依赖第三方解析器来处理HTML或XML文档)：</p>
<ol>
<li>解析 HTML 和 XML。将他们转换为 Python 对象的树状结构。</li>
<li>寻找元素。寻找特定的元素、属性、文本内容，从而提取所需的数据。</li>
<li>修改文档结构。</li>
<li>清除数据。</li>
</ol>
<h4 id="RE-regular-expression-regex"><a href="#RE-regular-expression-regex" class="headerlink" title="RE regular expression regex"></a>RE regular expression regex</h4><p>正则表达式，是用来简介表达一组字符串特征的表达式，最主要的应用在字符串匹配。<br>具体内容见文章 python 爬虫。</p>
<h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>IP地址（Internet Protocol Address，互联网协议地址）是一种用于在计算机网络中唯一标识和定位设备的数字地址。IP地址在互联网通信中起到了非常重要的作用，它允许设备在全球范围内进行通信。<br>一些概念和要点：</p>
<ol>
<li>唯一性：每个设备（如计算机、服务器、路由器）连接到互联网时都被分配一个唯一的IP地址。这确保了在互联网上的每个设备都可以被准确标识和寻址。</li>
<li>IPv4和IPv6：有两个主要的IP地址版本，分别是IPv4（Internet Protocol Version 4）和IPv6（Internet Protocol Version 6）。IPv4地址是32位的，通常以点分十进制表示，如192.168.1.1。IPv6地址是128位的，通常以冒号分隔的十六进制表示，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。由于IPv4地址空间有限，IPv6被引入以满足不断增长的互联网连接需求。</li>
<li>分层和路由：IP地址的设计允许数据在网络中进行分层和路由。它可以告诉路由器和交换机如何将数据包从源设备传送到目标设备，经过多个网络节点。</li>
<li>公共和私有IP地址：IP地址可以是公共的或私有的。公共IP地址用于直接连接到互联网，而私有IP地址用于在私有网络中进行内部通信。私有IP地址通常在家庭网络和企业内部网络中使用，路由器负责将这些地址与公共IP地址进行映射。</li>
<li>动态和静态IP地址：IP地址可以是动态的或静态的。动态IP地址由DHCP（动态主机配置协议）服务器动态分配给设备，而静态IP地址是由网络管理员手动配置的，通常不会更改。</li>
<li>网络服务：IP地址不仅用于标识设备，还用于定位网络服务和资源，如网站、邮件服务器、数据库服务器等。DNS（域名系统）用于将域名映射到IP地址，使人们更容易访问网络资源。</li>
</ol>
<h4 id="Ctrl-R"><a href="#Ctrl-R" class="headerlink" title="Ctrl + R"></a>Ctrl + R</h4><p>在 VSCode 中可以直接搜索文件夹。</p>
<h4 id="抓包-packet-capture"><a href="#抓包-packet-capture" class="headerlink" title="抓包 packet capture"></a>抓包 packet capture</h4><p>「抓包」是将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包经常被用来进行数据截取等。</p>
<h5 id="为什么抓包"><a href="#为什么抓包" class="headerlink" title="为什么抓包"></a>为什么抓包</h5><ol>
<li>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li>
<li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li>
</ol>
<h5 id="常用的抓包工具"><a href="#常用的抓包工具" class="headerlink" title="常用的抓包工具"></a>常用的抓包工具</h5><ol>
<li>httpwatch</li>
<li>fiddler</li>
<li>wireshark</li>
<li>firebug</li>
</ol>
<h4 id="HMAC-SHA256-算法"><a href="#HMAC-SHA256-算法" class="headerlink" title="HMAC-SHA256 算法"></a>HMAC-SHA256 算法</h4><p>HMAC-SHA256（Hash-based Message Authentication Code with SHA-256）是一种基于哈希函数和密钥的消息认证码算法，用于确保消息的完整性和认证消息的发送方。它是SHA-256哈希函数与密钥结合使用</p>
<h4 id="Token-Cookie-和-Session"><a href="#Token-Cookie-和-Session" class="headerlink" title="Token Cookie 和 Session"></a>Token Cookie 和 Session</h4><ol>
<li>Token<br>Token 是一种轻量级的身份验证令牌，通常是一个长字符串，用于识别用户。<br><strong>原理：</strong>当用户登录应用程序时，服务器会颁发一个Token给客户端（通常是JSON Web Token - JWT）。客户端将Token存储在本地（通常是在浏览器的localStorage或sessionStorage中，或在移动应用的存储中）。后面客户端的每个 HTTP 请求都会在 Headers 中附带 Token，服务器<strong>只需要通过特定的密钥和加密算法来验证即可</strong>，不需要再去额外存储用户的 Token 信息。<br><strong>优点：</strong> 无状态(只需要验证，无需存储)、可扩展性强，适用于分布式系统和 API。<br><strong>缺点：</strong> 需要额外的处理来管理 Token 的过期、刷新和安全性。</li>
<li>Cookie<br>Cookie是一小段数据，由服务器发送到用户浏览器，存储在用户本地。它通常包含了一些标识信息和可选的数据。<br><strong>原理：</strong> 服务器在响应HTTP请求时，可以通过Set-Cookie头来设置Cookie。浏览器会将Cookie存储在用户的计算机上，并在后续请求中自动发送给服务器。<br><strong>优点：</strong> 简单、易用，可以持久保存数据，对用户透明。<br><strong>缺点：</strong> 有限的存储容量，每个请求都会带上Cookie，可能会影响性能和安全性（例如，可能受到跨站脚本攻击的影响）。</li>
<li>Session<br>Session是一种服务器端机制，用于跟踪用户在应用程序中的状态和身份。<br><strong>原理：</strong> 服务器在用户登录时创建一个唯一的会话标识，通常是一个Session ID，并将其存储在服务器上。Session ID 可以存储在Cookie中或通过URL重写等方式传递给客户端。<br><strong>优点：</strong> 相对于 Cookie 更加安全，可以存储更多的数据，不受 Cookie 容量限制。<br><strong>缺点：</strong> 占用服务器内存，需要额外的服务器资源，不适于分布式系统。<br>通常，现代Web应用程序使用Token进行身份验证和授权，而Cookie和Session用于保持用户状态和临时数据的存储。</li>
</ol>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>通信协议是计算机和网络设备之间进行数据交换和通信的<strong>规则</strong>和<strong>约定</strong>。它们定义了数据的格式、传输方式、错误检测和纠正机制以及通信参与方之间的行为。</p>
<h5 id="1-OSI-模型"><a href="#1-OSI-模型" class="headerlink" title="1. OSI 模型"></a>1. OSI 模型</h5><p>OSI 模型即 <strong>开放式通信系统互联参考模型</strong>(Open System Interconnection Reference Model)，是国际标准化组织 ISO 提出的一个试图使各种计算机在世界范围内互联为网络的标准框架，简称 OSI</p>
<p>OSI 七层模型<br>OSI 定义了网络互连的七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/OSI%E6%A8%A1%E5%9E%8B.png" class="">
<p>首字母组成 All people seem to need data processing. 所有人似乎都需要数据处理，这句话可以帮助来记忆。</p>
<h5 id="2-TCP-IP-协议族"><a href="#2-TCP-IP-协议族" class="headerlink" title="2. TCP&#x2F;IP 协议族"></a>2. TCP&#x2F;IP 协议族</h5><p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。<br>它是把 OSI 七层模型简化成了五层模型，每一层模型都呼叫它的下一层所提供的网络来完成自己的需求。</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/OSI%E4%B8%8ETCPIP%E5%85%B3%E8%81%94.png" class="">

<h5 id="3-TCP-协议"><a href="#3-TCP-协议" class="headerlink" title="3. TCP 协议"></a>3. TCP 协议</h5><p>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须<strong>先建立</strong> TCP 连接。在传送数据完毕以后，<strong>必须释放</strong>已经建立的 TCP 连接(HTTP 协议通常使用 TCP 作为传输协议，HTTP 是典型的无状态，所以可以用来理解 TCP 协议)。</p>
<p>每一条 TCP 连接只能有两个端点，是点对点的。</p>
<p>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p>
<p>TCP 协议是<strong>面向字节流</strong>的，意味着TCP将数据视为一连串的字节而不是消息或数据块的集合。</p>
<p>产生的影响：</p>
<ol>
<li>无消息边界。<br>在TCP连接中，数据被视为一个连续的字节流，没有明确的消息边界或分隔符。这意味着TCP不会为你自动识别消息的开始或结束。你需要自行定义和实现消息的分割和解析机制。</li>
<li>字节级的精确性<br>TCP保证了数据的字节级精确性，即接收到的数据的每个字节都与发送端相匹配。如果数据在传输过程中损坏或丢失，TCP会负责重传丢失的部分，以确保接收端获得完整且准确的数据。</li>
</ol>
<p>TCP 提供了可靠的、有效的数据传输但是不考虑消息的边界。因此，我们在使用 TCP 协议的时候，应用程序需要负责<strong>定义和实现消息的分割和解析方法</strong>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/64155705">https://zhuanlan.zhihu.com/p/64155705</a> TCP 协议详解</p>
<h5 id="4-HTTP-协议"><a href="#4-HTTP-协议" class="headerlink" title="4. HTTP 协议"></a>4. HTTP 协议</h5><p>HTTP 是 Hyper Text Transfer Protocol(超文本传输协议) 的缩写。HTTP 协议用于 WWW 服务器传输超文本到本地浏览器的传送协议。<br>它不仅可以保证计算机<strong>正确快速地传输</strong>超文本文档，还确定传输文档中哪一部分，以及哪部分内容首先显示(如文本优先于图像)。<br>HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，是一个无状态的协议。</p>
<p><strong>特点：</strong></p>
<ol>
<li>简单快速。客户向服务器请求服务的时候，只需要请求方法和路径。请求方法通常包括 GET、HEAD、POST。</li>
<li>灵活。HTTP 允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。</li>
</ol>
<p><strong>持久连接</strong><br>HTTP 1.1 版本的变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 <code>Connection: keep-alive</code>。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在发送最后一个请求时，发送 <code>Connection: close</code>，明确要求服务器关闭 TCP 连接。</p>
<p><strong>Content-Length</strong> 字段<br>一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪个回应的。这就是 Content-Length 字段的作用，声明本次回应的数据长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Length: 3295</span><br></pre></td></tr></table></figure>
<p>上面代码告诉浏览器，本次回应的长度是3295个字节，后面的字节就属于下一个回应了。</p>
<p>在 1.0 版本中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。<br>使用 Content-Length 的前提是，服务器发送回应前，必须知道回应的数据长度。<strong>对于一些很耗时的动态操作来说，这意味着服务器要完成所有操作以后才可以发送数据</strong>(毕竟是动态的)，显然这样的数据并不是很高。更好的处理方法是，产生一块数据就发送一块，采用「流模式」(stream) 取代「缓存模式」(buffer)。<br>因此，1.1 版本规定可以不使用 Content-Length 字段，而是使用「分块传输编码」(chunked transfer encoding)。只要请求或者回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/http%E5%92%8Ctcp%E5%85%B3%E7%B3%BB.png" class="">

<h5 id="5-FTP-协议"><a href="#5-FTP-协议" class="headerlink" title="5. FTP 协议"></a>5. FTP 协议</h5><p>FTP 协议(File Transfer Protocol)，也是运行在 TCP 上，保证了文件传输的可靠性。与 HTTP 相比，FTP 面向的直接是服务器的文件系统，并且具有维持状态的特点，在文件传输管理上，FTP 更胜一筹。<br><strong>传输流程</strong></p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/FTP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class="">
<p>一共有两个并行的连接，一个是「控制连接」(port: 21)，另一个是「数据连接」(port: 20)。<br>其中，控制连接用于在两个主机之间传输控制信息，如口令、用户标识、存放，获取文件等命令。数据连接用于实际发送一个文件，发送完文件以后数据连接是会关闭的。<br>由于 FTP 使用一个独立的控制连接，所以我们也称 FTP 的控制信息是带外(out-of-band) 传送的。HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行的，所以，HTTP 也可以说是带内 (in-band) 发送控制信息的。<br><strong>传输方式</strong><br>FTP 支持两种方式的传输：文本(ASCII)方式和二进制(Binary)方式。<br>通常文本文件的传输采用 ASCII 方式；而图像、声音文件、加密和压缩文件等非文本文件采用二级制传输方式。<br><strong>传输模式</strong><br>FTP 有两种传输模式–主动(FTP Port)模式和被动(FTP Passive)模式。由于主动模式存在着安全问题，最近几年，大部分的 FTP 客户端开始默认使用被动模式。<br><a href="https://zhuanlan.zhihu.com/p/337513218">https://zhuanlan.zhihu.com/p/337513218</a><br><a href="https://zhuanlan.zhihu.com/p/141472331">https://zhuanlan.zhihu.com/p/141472331</a></p>
<h5 id="6-DNS-协议"><a href="#6-DNS-协议" class="headerlink" title="6. DNS 协议"></a>6. DNS 协议</h5><p>互联网上主机的一种标识方式是使用它的「主机名」(hostname)，如 <code>www.facebook.com</code>、<code>www.google.com</code> 等。但是这是我们人类的记忆方式，路由器不会这么理解，路由器喜欢定长的、有层次结构的 IP 地址。</p>
<blockquote>
<p>主机名 (Hostname) 是计算机或者设备在网络上的名称标识符，用于唯一标识一个特定的计算机或者网络设备。<strong>主机名</strong>通常是人类可读的形式，<strong>但是在网络协议中国会被映射为 IP 地址进行通信</strong>。</p>
</blockquote>
<p>IP 地址由 4 字节组成，并且有着严格的层次结构。例如 <code>121.7.106.83</code> 然而路由器喜欢的是 IP 地址进行解析，我们人类便于记忆的确实网址，此时就用到 DNS 了。<br>DNS 的全称是 <code>Domain Name System</code>，是由一个分层的 DNS 服务器(DNS Server) 实现的分布式数据库；还是一个使得主机能够查询分布式数据库的应用层协议。DNS 服务器通常是运行 <code>Berkeley Internet Name Domain</code> 软件的 Unix 机器。DNS 协议运行在 UDP 之上，使用 53 端口。</p>
<p>DNS 是<strong>一个分布式的系统</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/346236071">https://zhuanlan.zhihu.com/p/346236071</a></p>
<h4 id="h-文件和-hpp-文件区别"><a href="#h-文件和-hpp-文件区别" class="headerlink" title="h 文件和 hpp 文件区别"></a>h 文件和 hpp 文件区别</h4><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/h%E5%92%8Chpp.png" class="">

<h4 id="低耦合-Low-Coupling"><a href="#低耦合-Low-Coupling" class="headerlink" title="低耦合 Low Coupling"></a>低耦合 Low Coupling</h4><p>是在讨论软件工程中的一种设计原则，旨在创建更可维护、可扩展和可重用的代码。低耦合涉及到将代码分解成松散耦合的模块或组件，这些模块之间的依赖性尽量降低。</p>
<h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>在 C++ 中，lambda 表达式的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameters) -&gt; return_type &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class="">

<h4 id="delete-和-delete"><a href="#delete-和-delete" class="headerlink" title="delete 和 delete[]"></a>delete 和 delete[]</h4><p>当你使用 new[] 来分配动态数组时，编译器会记住你分配了多少个元素，因此在释放内存时，你必须使用 delete[] 来确保所有元素都得到释放。如果你使用 delete（而不是 delete[]）来尝试释放动态数组的内存，将导致未定义的行为，可能会导致内存泄漏或程序崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* data_ = new int[size];</span><br><span class="line">delete[] data_;</span><br></pre></td></tr></table></figure>

<h4 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h4><p>静态数组需要在编译的时候知道它的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[size];</span><br></pre></td></tr></table></figure>
<p>也就是说其中的 <code>size</code> 需要是一个常量表达式。如果我们 <code>cin &gt;&gt; size;</code> 后面又 <code>int a[size];</code> 是不行的，因为静态数组要求 <strong>编译的时候大小就确定。</strong></p>
<p>静态数组的内存分配发生在程序的静态存储区域，通常在编译的时候分配，并且在程序结束的时候才会释放，具有全局的声明周期。</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>动态数组的大小在运行的时候确定，通常在堆中分配内存。<code>int* ptr = new int[size];</code>。在最后不使用的时候记得要 <code>delete[] ptr;</code><br>其中 <code>new int[size]</code> 会在堆上分配一段连续的内存，大小为 <code>size * sizeof(int)</code> 个字节，然后返回一个指向这块内存的指针，并将这个指针赋值给 <code>ptr</code></p>
<p>堆上分配的内存不会自动释放，需要程序员负责在确保不需要的时候手动释放，否则可能导致内存泄漏。</p>
<h4 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h4><p>栈内存用于存储局部变量和函数调用信息。每个线程通常都有自己的栈。<br>栈内存的分配和释放是自动的，发生在函数的入栈和出栈过程中。当函数返回时，其局部变量的内存会自动被释放。<br>栈内存的生命周期与函数调用有关，它们在函数调用结束后自动释放。</p>
<h4 id="程序运行时内存区域"><a href="#程序运行时内存区域" class="headerlink" title="程序运行时内存区域"></a>程序运行时内存区域</h4><ol>
<li>栈区 Stack<br>栈区用于存储函数调用的局部变量、函数的参数值以及函数调用的返回地址。<br>栈区是<strong>自动管理</strong>的，函数的局部变量在函数被调用时分配内存，在函数结束时自动释放内存。<br><strong>栈区的大小通常较小</strong>，且生命周期短暂，用于管理函数的执行和调用。</li>
<li>堆区 Heap<br>堆区用于动态分配内存，例如使用 new 和 malloc 来分配内存。<br>堆区的内存分配和释放需要程序员<strong>手动管理</strong>，使用 delete 和 free 来释放内存。<br><strong>堆区的大小通常较大</strong>，用于存储动态分配的数据结构，如动态数组、对象等。</li>
<li>静态存储区域 Static Storage<br>静态存储区域用于<strong>存储全局变量、静态变量和常量</strong>(如静态分配的数组)。<br>这些变量在程序启动时分配内存，在程序结束时释放内存。<br>静态存储区域的变量具有全局可见性，并且在整个程序的生命周期内保持不变。</li>
<li>代码区 Code Segment<br>代码区包含程序的机器码指令，用于执行程序的逻辑。<br>代码区通常是只读的，不允许写入和修改。<br>代码区存储程序的执行指令，每个函数和方法的机器代码以及程序的静态数据。</li>
<li>常量区 Constant Area<br>常量区用于存储常量数据，如字符串文字（string literals）和全局 const 变量。<br>常量区的数据是只读的，不允许修改。</li>
<li>栈帧区 Stack Frame</li>
</ol>
<h4 id="malloc-free-和-new-delete"><a href="#malloc-free-和-new-delete" class="headerlink" title="malloc free 和 new delete"></a>malloc free 和 new delete</h4><p><strong>语言差异</strong>：<br>malloc 和 free 是C语言中的函数，可以在C++中使用，但通常不推荐在C++代码中使用它们，因为C++提供了更强大的内存管理工具。<br>new 和 delete 是C++中的操作符，专门用于创建和销毁对象，并与类的构造函数和析构函数一起工作。</p>
<p><strong>类型安全性：</strong><br>new 和 delete 是类型安全的，它们会为对象的构造和销毁调用适当的构造函数和析构函数。这对于管理类对象非常重要。<br>malloc 和 free 不了解对象的类型，它们只是分配和释放内存块。如果你使用它们来分配和释放类对象，可能会绕过构造函数和析构函数，导致对象的行为不正常。</p>
<p>尽管 malloc 和 free 是C语言中的标准内存分配函数，但在C++中通常更推荐使用 new 和 delete，因为它们提供了更好的类型安全性、异常处理和对象生命周期管理。只有在特殊情况下，如与C库一起使用或需要更底层的内存分配控制时，才使用 malloc 和 free。</p>
<p>其中需要注意，malloc 函数返回的是 <code>void*</code> 类型的指针，也就是并没有规定它的类型，需要我们人为规定。所以我们一般写成这样的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* p = (char*)malloc(100);</span><br></pre></td></tr></table></figure>
<p>其中，100 表示 100 个字节。</p>
<h4 id="C-对象构造"><a href="#C-对象构造" class="headerlink" title="C++ 对象构造"></a>C++ 对象构造</h4><p>有四种方式创建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">MyClass myClass = MyClass();</span><br><span class="line">MyClass* myClass = new MyClass();</span><br><span class="line">MyClass* myClass = new MyClass;</span><br></pre></td></tr></table></figure>
<p>其中，前两种方式是在栈中分配内存，由操作系统进行内存的分配和管理。<br>后两种是在堆中分配内存，由管理者(程序员)进行内存的分配和管理，用完必须 delete，否则会造成内存的泄露。</p>
<h5 id="不使用-new"><a href="#不使用-new" class="headerlink" title="不使用 new"></a>不使用 new</h5><p>对于第一种和第二种，一个隐式调用，一个显式调用。<br><strong>第一种：</strong></p>
<ul>
<li>如果有构造函数，默认使用构造函数来初始化对象。</li>
<li>如果没有默认的构造函数，编译器会报错。</li>
</ul>
<p><strong>第二种：</strong></p>
<ul>
<li>默认使用构造函数</li>
<li>如果没有构造函数，编译器会报错。</li>
<li>与第一种方法不同，这个是先创建一个对象，然后进行对象的复制。</li>
</ul>
<p>虽然上面两种那么说，但是如果我们没有显式定义构造函数，编译器会自动生成一个默认构造函数的。这个默认构造函数会对类中的一些基本数据类型的数据进行初始化，就是随机赋值。</p>
<p>所以，通常情况下，前两种方式相比较，第一种方式直接 <code>MyClass myClass;</code> 是更加直接高效的方法，一般使用这种方式。</p>
<h5 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 new"></a>使用 new</h5><p>在使用 new 创建对象的时候。对于有构造函数的类，不论有没有括号，都用构造函数进行初始化。如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。</p>
<p>对于 new 创建对象，可以作为函数的返回值和参数，因为如果不用new，函数中不能返回该对象的指针，因为函数结束后，该对象的内存就被释放了(函数是栈空间嘛，如果是 new 则在堆空间，由我们人为决定其寿命)。</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/new%E6%9E%84%E9%80%A0.png" class="">
<p>上面是两种new构造的区别，其实不是很大，一般加个括号就好了。</p>
<p>使用 new 创建对象的实际步骤是：</p>
<ol>
<li><p>分配内存：new 会在堆上动态分配足够的内存来存储对象的数据成员，包括对象的成员变量和虚函数表（如果有的话）。</p>
</li>
<li><p>调用构造函数：一旦内存分配完成，C++会调用对象的构造函数来初始化这块内存。构造函数是类的特殊成员函数，用于初始化对象的状态。如果你没有显式定义构造函数，编译器会为你生成一个默认的构造函数来执行默认的初始化操作。</p>
</li>
<li><p>返回指针：new 表达式返回指向分配的内存的指针，该指针指向一个已经构造完成的对象。</p>
</li>
</ol>
<h4 id="CSV-文件-Comma-Separated-Values"><a href="#CSV-文件-Comma-Separated-Values" class="headerlink" title="CSV 文件(Comma-Separated Values)"></a>CSV 文件(Comma-Separated Values)</h4><p>CSV 格式是处理和存储数据的常用格式之一。</p>
<ol>
<li>简单易懂：CSV文件使用纯文本格式，数据之间使用逗号或其他分隔符分隔。</li>
<li>跨平台兼容性：CSV文件是纯文本文件，几乎所有操作系统和应用程序都可以处理它们。</li>
<li>轻量级。</li>
<li>广泛支持：几乎所有类型的编程语言都支持 CSV 格式文件操作。</li>
</ol>
<h4 id="codecs"><a href="#codecs" class="headerlink" title="codecs"></a>codecs</h4><p>“codecs” 是 Python 编程语言中的一个标准库模块，用于处理各种字符编码和解码操作。<br>codecs 的名称来自 <code>code and decode</code>，提供了一种在不同字符码之间进行转换的方式，这在处理文本数据的时候非常有用。<br>下面是一个简单的示例，将 UTF-8 的编码转换为 ASCII 编码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import codecs</span><br><span class="line"></span><br><span class="line"># 要转换的文本</span><br><span class="line">text = &quot;Hello, 你好&quot;</span><br><span class="line"></span><br><span class="line"># 将文本从UTF-8编码转换为ASCII编码</span><br><span class="line">ascii_text = codecs.encode(text, &#x27;ascii&#x27;, &#x27;ignore&#x27;)  # ignore 是一种错误处理，&quot;ignore&quot; 表示在转换时忽略不能被目标字符编码表示的字符。还有 replace 等</span><br><span class="line"></span><br><span class="line"># 输出转换后的文本</span><br><span class="line">print(ascii_text)</span><br></pre></td></tr></table></figure>

<h4 id="Python-列表推导-List-Comprehension"><a href="#Python-列表推导-List-Comprehension" class="headerlink" title="Python 列表推导(List Comprehension)"></a>Python 列表推导(List Comprehension)</h4><p>列表推导是一种简洁的方式来创建新的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[expression for item in iterable if condition]</span><br></pre></td></tr></table></figure>
<p>其中 <code>expression</code> 是生成新列表中元素的表达式，<code>item</code> 是可迭代对象 <code>iterable</code> 中的元素.<br>下面是一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个包含1到10的平方的列表</span><br><span class="line">squares = [x**2 for x in range(1, 11)]</span><br><span class="line"></span><br><span class="line"># 将字符串列表中的所有字符串转换为大写</span><br><span class="line">words = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]</span><br><span class="line">uppercase_words = [word.upper() for word in words]</span><br><span class="line"></span><br><span class="line"># 筛选出一个列表中的偶数元素</span><br><span class="line">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">even_numbers = [x for x in numbers if x % 2 == 0]</span><br></pre></td></tr></table></figure>

<h4 id="Python-赋值"><a href="#Python-赋值" class="headerlink" title="Python 赋值"></a>Python 赋值</h4><p>在 Python 中，赋值分为两种情况：</p>
<ol>
<li>不可变对象(Immutable Objects)<br>包括数字、字符串、元组等不可修改的对象。对不可变对象的赋值是值传递（Pass by Value），意味着在赋值时会创建一个新的对象，并将其值赋给新的变量，而不是将原始对象的引用传递给新的变量。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 5</span><br><span class="line">y = x  # 这是值传递，y 拥有一个新的 5 的副本</span><br></pre></td></tr></table></figure></li>
<li>可变对象(Mutable Objects)<br>包括列表、字典、集合等可以修改的对象。对可变对象的赋值是地址传递（Pass by Reference），意味着在赋值时不会创建新的对象，而是将原始对象的引用传递给新的变量。因此，如果修改一个可变对象，会影响到所有引用它的变量。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1, 2, 3]</span><br><span class="line">list2 = list1  # 这是地址传递，list2 和 list1 引用同一个列表对象</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Python-切片"><a href="#Python-切片" class="headerlink" title="Python 切片"></a>Python 切片</h4><p>切片是 Python 中非常强大的功能，可以用于许多不同的场景。</p>
<ol>
<li>提取子序列<br>可以提取列表、字符串或元组中的特定元素子集。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">subset = my_list[1:4]  # 提取索引1到索引3的元素，得到[2, 3, 4]</span><br></pre></td></tr></table></figure></li>
<li>复制切片<br>我们上面说了，Python 序列是址传递的，所以我们想复制序列的话不可以简单的 <code>list2 = list1</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">original_list = [1, 2, 3, 4, 5]</span><br><span class="line">copy_list = original_list[:]  # 创建一个原始列表的副本，修改 copy_list 不会影响到 original_list</span><br></pre></td></tr></table></figure></li>
<li>步进切片<br>我们可以指定一个步进值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">every_other = my_list[::2]  # 每隔一个元素提取，得到[1, 3, 5]</span><br></pre></td></tr></table></figure></li>
<li>字符串反转 or 序列 反转<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_string = &quot;Hello, World!&quot;</span><br><span class="line">substring = my_string[0:5]  # 提取前五个字符 &quot;Hello&quot;</span><br><span class="line">reversed_string = my_string[::-1]  # 字符串翻转</span><br></pre></td></tr></table></figure></li>
<li>删除元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">del my_list[1:3]  # 删除索引1到索引2的元素，my_list变为[1, 4, 5]</span><br></pre></td></tr></table></figure></li>
<li>替换元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">my_list[1:4] = [10, 20, 30]  # 替换索引1到索引3的元素，my_list变为[1, 10, 20, 30, 5]</span><br></pre></td></tr></table></figure></li>
<li>过滤数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">filtered_list = [x for x in my_list if x % 2 == 0]  # 过滤偶数，得到[2, 4]</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="字符串面值的赋值"><a href="#字符串面值的赋值" class="headerlink" title="字符串面值的赋值"></a>字符串面值的赋值</h4><p>字符串字面值是指在代码中直接以文本形式表示的字符串，通常用双引号括起来的一系列字符。字符串字面值在编程中用于表示固定的文本数据。例如，以下是一些字符串字面值的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello, World!&quot;</span><br><span class="line">&quot;This is a string literal.&quot;</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure>
<p>字符串面值通常是只读的，意味着我们不能对于它们的内容进行修改。</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%A2%E5%80%BC%E7%9A%84%E8%B5%8B%E5%80%BC.png" class="">

<h4 id="关于-char-与-char"><a href="#关于-char-与-char" class="headerlink" title="关于 char[] 与 char*"></a>关于 char[] 与 char*</h4><h5 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h5><ul>
<li>它是一个字符数组，它在栈上分配内存，并且为数组内的每个元素分配空间。</li>
<li>当您使用字符串字面值来初始化字符数组时，编译器会自动为数组分配足够的空间来存储字符串字面值的内容，包括字符串结束符 ‘\0’(与指针直接指向字符串字面值的地址不同，数组是新创建一个空间，然后相当于在新的字符串空间中将字符串字面值给复制过去)。</li>
</ul>
<h5 id="char-1"><a href="#char-1" class="headerlink" title="char*"></a>char*</h5><ul>
<li>char* 是一个字符指针，只是指向一个字符的内存地址。</li>
<li>当我们使用字符串字面值来初始化数组时，实际上是将字符串字面值的地址赋给了指针(但是我们知道，字符串字面值通常只是只读的，所以说我们指针指向了那个地址也是无法修改字符串的值的，因此一般不这么写，编译器也会报警告)。</li>
<li>如果我们想使用 char*</li>
</ul>
<p>并且对于 char* 和 char[]，C&#x2F;C++ 有一种约定成俗的习惯，使用 cout 输出时，会自动识别数组或者指针指向的字符串，并且输出字符串的内容直到遇到空字符 <code>&#39;\0&#39;</code> 停止。</p>
<p>这种行为是通过C&#x2F;C++标准库中的重载运算符和内置函数来实现的，它们会自动迭代字符数组或指针，并输出字符直到遇到空字符。这使得输出字符串变得方便，无需显式循环来逐个字符输出。</p>
<p>同样的，不仅仅是对于 <code>cout</code>，对于 char 的一些函数如 <code>strlen</code>、<code>strcpy</code>，参数为 char* 的时候，同样也是遇到 <code>&#39;\0&#39;</code> 时停止函数操作(一般来说，这些函数是操作 <code>char*</code> 的，我们如果操作 <code>char[]</code> 也是能操作的，因为 <strong>字符数组可以隐式转换为字符指针</strong>)。</p>
<p>如果我们实在想对于 <code>char*</code> 类型赋值，可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* str = new char[20]; // 使用 new 动态分配 20 个字符的内存</span><br><span class="line"></span><br><span class="line">// 将字符串常值赋值给 str</span><br><span class="line">strcpy(str, &quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">// 在不需要时记得释放内存</span><br><span class="line">delete[] str;</span><br></pre></td></tr></table></figure>

<h4 id="常见的-char-函数"><a href="#常见的-char-函数" class="headerlink" title="常见的 char* 函数"></a>常见的 char* 函数</h4><ol>
<li>字符串长度函数<br><code>strlen(const char* str)</code>: 返回字符串的长度，不包括空字符终止符。</li>
<li><code>strcpy(char* dest, const char* src)</code>: 将源字符串复制到目标字符串，包括空字符终止符。需要确保目标字符串有足够的空间来存储源字符串。<br><code>strncpy(char* dest, const char* src, size_t n)</code>: 将源字符串的前 n 个字符复制到目标字符串，可以控制复制的字符数。</li>
<li><code>strcat(char* dest, const char* src)</code>: 将源字符串连接到目标字符串的末尾，需要确保目标字符串有足够的空间来容纳源字符串</li>
<li><code>strcmp(const char* str1, const char* str2)</code>: 比较两个字符串，返回值表示它们的字典顺序关系。<br>请注意，使用这些函数时应格外小心，确保正确处理内存和边界情况，以避免安全漏洞和未定义的行为。</li>
</ol>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/strcpy%E5%92%8Cstrdup.png" class="">
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/strdup%E4%BD%BF%E7%94%A8.png" class="">

<h4 id="endl-与-“-n”"><a href="#endl-与-“-n”" class="headerlink" title="endl 与 “\n”"></a>endl 与 “\n”</h4><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/endl%E4%B8%8En.png" class="">

<h4 id="vector-创建二维数组"><a href="#vector-创建二维数组" class="headerlink" title="vector 创建二维数组"></a>vector 创建二维数组</h4><p>一次性定义：<br>此种方法适用于每一行的列数都相等的二维数组定义(与初始化)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用vector一次性完成二维数组的定义（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br><span class="line"></span><br><span class="line">//以下是拆分理解</span><br><span class="line">//创建一维数组matirx，这个数组里有m个元素，元素是int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m);</span><br><span class="line">//除了定义数组类型及数组大小外，同时给数组中的元素赋值：将元素赋值为大小为n的int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n));</span><br><span class="line">//除了定义数组类型、数组大小、列的大小，同时给数组列中的元素（或者说，数组中的所有元素）赋值为-1。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br></pre></td></tr></table></figure>

<p>插入元素型定义：<br>此种方法适用于每一行的列数都相等或不相等的二维数组的定义（与初始化）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//比较具有普遍性的写法（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;//创建一维数组matirx，这个数组里的元素是int型vector。</span><br><span class="line">int m = 3; //matrix有m行</span><br><span class="line">int n = 10; //matrix有n列</span><br><span class="line">int value = 1; //最终matrix成为二维数组后，其中每个元素的值为1（如果不需要进行初始化，此语句可以省略）</span><br><span class="line">for (int i = 0; i &lt; m; ++ i) &#123;</span><br><span class="line">    vector&lt;int&gt; tmp(n, value); //定义int型一维数组tmp，该数组有n个int型元素，且每个元素的初始值为value</span><br><span class="line">    matrix.push_back(tmp); //将一维数组tmp（小容器）加入matrix（大容器）中，使之成为matrix的元素，令matrix成为二维数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要每一行的列数不同（虽然一般很少这样做），也可以使用下面这种写法进行定义、初始化</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a(10, 1); //单独定义每个小容器的元素个数和元素初始值</span><br><span class="line">vector&lt;int&gt; b(5, 2);</span><br><span class="line">vector&lt;int&gt; c(10, 3);</span><br><span class="line"></span><br><span class="line">matrix.push_back(a); //将每个小容器加入matrix（大容器）中</span><br><span class="line">matrix.push_back(b);</span><br><span class="line">matrix.push_back(c);</span><br></pre></td></tr></table></figure>

<h4 id="assign-函数分配与初始化"><a href="#assign-函数分配与初始化" class="headerlink" title="assign 函数分配与初始化"></a>assign 函数分配与初始化</h4><p>其实也可以使用 vector 的构造函数来初始化。</p>
<p>assign 函数主要用于重新分配 vector 元素并进行初始化。它的用法主要有两种：</p>
<ol>
<li>用迭代器范围进行分配：<br>assign 可以结构两个迭代器参数，从另一个容器或者序列中复制元素到当前 vector 中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">std::vector&lt;int&gt; anotherVec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">vec.assign(anotherVec.begin(), anotherVec.end());</span><br></pre></td></tr></table></figure></li>
<li>用大小和值进行分配：<br>assign 函数也可以接受一个大小参数和一个值参数，用于将 std::vector 的大小更改为指定大小，并用指定的值填充所有新元素。这是一种用于重新分配 std::vector 并<strong>进行初始化的方法</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec(5, 42); // 就是将 vec 的大小设置为 5，每一项设置为 42</span><br><span class="line"></span><br><span class="line">std::vector&lt;vector&lt;int&gt;&gt; v(5, vector&lt;int&gt;(5, 0)); // 创建一个二维数组 v，其中是 5 行 5 列并且每一个元素都是 0</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="遍历-vector-的几种方式"><a href="#遍历-vector-的几种方式" class="headerlink" title="遍历 vector 的几种方式"></a>遍历 vector 的几种方式</h4><p>1. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; v.size(); ++i)</span><br></pre></td></tr></table></figure>
<p>2.<br>使用迭代器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br></pre></td></tr></table></figure>
<p>3.<br>使用 auto 关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line"></span><br><span class="line">for (const auto&amp; element : v)</span><br></pre></td></tr></table></figure>
<p>关于为什么写成 <code>const auto&amp;</code> 可以避免拷贝(加快速度)，保持元素的不可变性。</p>
<h4 id="关于-vector-迭代器"><a href="#关于-vector-迭代器" class="headerlink" title="关于 vector 迭代器"></a>关于 vector 迭代器</h4><p>vector 中迭代器是一个用于访问容器元素的抽象概念。它提供了一种通用的方式来遍历容器中的元素，而不依赖于容器的具体实现细节。<br>在 C++ 中，std::vector 提供了<strong>两种主要类型</strong>的迭代器：</p>
<ol>
<li>begin() 迭代器。这个迭代器指向容器中的第一个元素。</li>
<li>end() 迭代器。这个迭代器指向容器中<strong>最后一个元素的下一个位置</strong>。</li>
</ol>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>主存指的是内存 RAM</p>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><p>SSD 是固态硬盘 (Solid State Drive) 的缩写。与传统的机械硬盘（HDD）不同，SSD不包含可移动的机械部件，而是使用闪存存储技术来存储数据。这使得SSD在许多方面都具有一些显著的优势，包括：</p>
<ol>
<li>更快的速度：SSD比HDD更快，因为它们不需要旋转磁盘和寻道操作来读取数据。这意味着计算机可以更快地启动、加载应用程序和执行文件传输等任务</li>
<li>更低的能耗：由于没有旋转的机械部件，SSD消耗的能量较少，因此在笔记本电脑和移动设备中通常能够延长电池寿命。</li>
<li>更高的可靠性与更轻便<br>但是价格比较高。<br>HDD (Hard Disk Drive) 硬盘驱动器，有时候也成为硬盘或者机械硬盘</li>
</ol>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>BIOS（基本输入&#x2F;输出系统，Basic Input&#x2F;Output System）是计算机系统中的一组固件程序，它们位于计算机的主板上的一个特殊芯片中，通常是闪存芯片。</p>
<ol>
<li>启动自检（POST）：在计算机启动时，BIOS会执行自检程序，检查计算机的硬件组件，如处理器、内存、硬盘、光驱等是否正常工作。如果发现问题，BIOS通常会发出蜂鸣声或显示错误信息，以指示问题的位置。</li>
<li>引导操作系统：一旦自检完成，BIOS会寻找可引导的设备，通常是硬盘驱动器或其他存储设备。它会加载操作系统的引导加载程序（Boot Loader），并将控制权转交给操作系统，使其能够继续启动过程。</li>
<li>设置硬件参数：BIOS还包括一组用户可配置的硬件设置，这些设置通常可通过计算机的BIOS设置界面进行调整。用户可以在BIOS中设置硬盘启动顺序、系统时间、密码保护等选项。</li>
<li>提供基本的输入&#x2F;输出服务：BIOS提供了一些基本的输入&#x2F;输出功能，以便在操作系统加载之前进行一些基本的操作，如键盘输入、显示输出和存储设备的读写。</li>
</ol>
<h4 id="Transistor-Transistor-Logic"><a href="#Transistor-Transistor-Logic" class="headerlink" title="Transistor-Transistor Logic"></a>Transistor-Transistor Logic</h4><p>在集成电路型号中，通常以 74 开头的数字代表它们属于标准的 Transistor-Transistor Logic<br>具体来说，”74” 表示了 TTL 系列中的特定子系列。TTL 门和触发器的型号通常以 “74” 开头，例如，”7400” 代表四输入 NAND 门，”74138” 代表 3-8 译码器&#x2F;多路复用器，等等。</p>
<h4 id="vector-中的-find-函数"><a href="#vector-中的-find-函数" class="headerlink" title="vector 中的 find 函数"></a>vector 中的 find 函数</h4><p><strong>find 函数是在 <code>algorithm</code> 中的，不写的话会报错，血的教训。</strong><br>C++ 标准库中的 <code>std::find()</code> 函数可以用来在容器 (包括 std::vector) 中查找特定值的位置。它的用法如下：</p>
<figure class="highlight plaintext"><figcaption><span><algorithm></span><a href="//">必须包含这个头文件</a></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myVector = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int targetValue = 3;</span><br><span class="line"></span><br><span class="line">// 使用std::find查找特定值</span><br><span class="line">auto it = std::find(myVector.begin(), myVector.end(), targetValue);</span><br><span class="line"></span><br><span class="line">if (it != myVector.end()) &#123;</span><br><span class="line">    // 找到了目标值</span><br><span class="line">    // &#x27;it&#x27; 是一个迭代器，指向找到的元素的位置</span><br><span class="line">    // 在这里，它指向了值为3的元素</span><br><span class="line">    cout &lt;&lt; &quot;找到了目标值: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 没找到目标值</span><br><span class="line">    cout &lt;&lt; &quot;未找到目标值&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::find函数的返回类型是一个迭代器（iterator），它是一个指向容器中找到的元素的位置的指针。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>string 中也是有着迭代器的</p>
<h4 id="电源适配器-power-adapter"><a href="#电源适配器-power-adapter" class="headerlink" title="电源适配器 power adapter"></a>电源适配器 power adapter</h4><p>提到电源适配器可能很多人都不知道这是什么东西，如果说笔记本电脑充电线上那个长方形的配件或者说手机充电器大家倒是常见，是的，那个就是电源适配器，电源适配器（Power adapter）又叫外置电源，是小型便携式电子设备及电子电器的供电电压变换设备，常见于手机、液晶显示器和笔记本电脑等小型电子产品上。<br>它的作用是将家里的220伏高电压转换成这些电子产品能工作的5伏至20伏左右稳定的低电压，使他们能正常工作,一般由外壳、变压器、电感、电容、控制IC、PCB板等元器件组成，它的工作原理由交流输入转换为直流输出</p>
<h4 id="vscode-中-alt-加-上下键"><a href="#vscode-中-alt-加-上下键" class="headerlink" title="vscode 中 alt 加 上下键"></a>vscode 中 alt 加 上下键</h4><p>可以将光标所在的位置的代码行直接进行移动，向上或者向下移动。</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>当一个函数被调用时，通常会创建一个包含该函数的局部变量、参数和执行上下文信息的数据结构，这个数据结构称为栈帧（也称为调用帧或执行帧）。栈帧用于存储函数执行期间的局部状态信息，包括局部变量、函数参数、返回地址等。在函数调用栈中，每个函数调用都对应一个栈帧，它们按照调用的顺序依次排列。</p>
<p>所以我们采取非递归算法，即使是在函数中模拟栈，但是我们并没有过多递归导致产生过多栈帧，所以通常是更加节省空间的。</p>
<h4 id="比较函数规则"><a href="#比较函数规则" class="headerlink" title="比较函数规则"></a>比较函数规则</h4><p>通常情况下，比较函数的返回值为1表示前面的元素大于后面的元素，而返回-1ee或者0表示前面的元素小于或等于后面的元素。这是一种常见的约定，但也可以根据具体需求和实现来定义不同的比较规则。</p>
<h4 id="pair-模板类"><a href="#pair-模板类" class="headerlink" title="pair 模板类"></a>pair 模板类</h4><p>std::pair 是 C++ 标准库提供的一个模板类，用于将两个不同类型的值组合成一个单元。定位于头文件 <code>utility</code> 中。</p>
<p>std::pair 最常见的用法是在函数的返回值中返回多个值，或者在容器中存储多个类型的数据。pair 有两个公共成员 <code>first</code> 和 <code>second</code> </p>
<h4 id="0"><a href="#0" class="headerlink" title="\0"></a>\0</h4><p>在C&#x2F;C++中，\0 通常用作字符串的结束标志，标识字符串的结尾。</p>
<p>当你在一个以\0结尾的字符数组（C-Style字符串）中遇到\0字符时，它表示字符串的结束，告诉程序在这里停止处理字符串。例如：</p>
<h4 id="map-等容器创建"><a href="#map-等容器创建" class="headerlink" title="map 等容器创建"></a>map 等容器创建</h4><p>在C++中，std::map对象的创建方式取决于它是如何声明的。std::map可以在栈上或堆上创建，具体取决于其声明方式。</p>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>将代码写成如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> void insert(const T&amp; value) &#123;</span><br><span class="line">        insertNode(root, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有下面的好处：</p>
<ol>
<li>代码模块化：将插入操作分为两个函数可以使得代码更加模块化，每个函数负责一个明确定义的任务。使得代码更加容易理解和维护。外部调用者著需要调用 insert 函数，而不需要了解内部的递归细节。</li>
<li>可读性：使用 insert 和 insertNode 两个函数可以在外部接口提供更具描述性的函数名，使得代码更加容易理解。</li>
<li>封装内部细节：insertNode 函数是一个内部的实现细节，不需要暴露给用户。这有助于隐藏内部数据结构和实现细节，提高了代码的封装性和安全性。</li>
</ol>
<p>将插入操作拆分为两个函数是一种常见的编程实践，有助于提高代码的清晰度、可维护性和可读性。这种模块化设计方法可以应用于其他类似的操作，使代码更易于管理和扩展。</p>
<h4 id="STL-容器传递用于比较的函数对象类"><a href="#STL-容器传递用于比较的函数对象类" class="headerlink" title="STL 容器传递用于比较的函数对象类"></a>STL 容器传递用于比较的函数对象类</h4><p>在C++的STL容器中（如std::map、std::set等），如果您想要自定义元素的比较行为，您可以传递一个用于比较的函数对象类，而不是传递一个函数对象的实例。这是因为STL容器需要在需要比较元素时创建比较器对象的实例，而不是在容器创建时就传递一个现成的比较结果。</p>
<p>因此，当您向std::map（或其他STL容器）传递一个自定义的比较函数对象时，STL容器会在内部创建该函数对象的实例，以便在需要时进行元素比较。这允许STL容器根据需要多次使用相同的比较器类的不同实例。</p>
<p>所以我们写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">// 自定义的比较函数对象类</span><br><span class="line">struct MyComparator &#123;</span><br><span class="line">    bool operator()(int a, int b) const &#123;</span><br><span class="line">        return a &gt; b; // 比较a是否大于b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 使用自定义比较函数对象创建std::map</span><br><span class="line">    std::map&lt;int, std::string, MyComparator&gt; customMap; // 传递一个结构体，而不是它的实例对象，STL容器会自动创建实例对象来比较</span><br><span class="line"></span><br><span class="line">    // 插入一些元素</span><br><span class="line">    customMap[5] = &quot;Five&quot;;</span><br><span class="line">    customMap[2] = &quot;Two&quot;;</span><br><span class="line">    customMap[8] = &quot;Eight&quot;;</span><br><span class="line"></span><br><span class="line">    // 遍历并打印map的内容</span><br><span class="line">    for (const auto&amp; pair : customMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="struct-和-class"><a href="#struct-和-class" class="headerlink" title="struct 和 class"></a>struct 和 class</h4><p>在C++中，struct和class都是用来定义用户自定义数据类型的关键字，它们之间的主要区别在于默认的访问控制和一些语法细节。下面是它们的主要区别和适用场景：</p>
<ol>
<li>访问控制：</li>
</ol>
<p>struct：struct中的成员默认都是公共的（public），可以被外部代码直接访问。<br>class：class中的成员默认都是私有的（private），需要通过成员函数（方法）来访问。<br>2. 数据封装：</p>
<p>由于class默认成员是私有的，它更适合用于实现数据封装，即将数据隐藏在类的内部，通过公共接口提供访问和修改数据的方法，以维护数据的完整性和安全性。<br>struct通常用于轻量级的数据结构，其成员都是公开的，用于存储一组相关数据，不提供严格的封装。<br>继承：</p>
<ol start="3">
<li><p>struct和class都可以用于实现继承，但默认情况下，class的继承是私有的，而struct的继承是公共的。这意味着从class继承的成员在子类中默认是私有的，而从struct继承的成员在子类中默认是公共的。<br>适用场景：</p>
</li>
<li><p>使用class：当需要实现封装、数据隐藏、访问控制、继承以及更复杂的类层次结构时，通常使用class。<br>使用struct：当只需要一个简单的数据容器，没有需要隐藏的数据，或者需要与C语言交互时，通常使用struct。也可以将struct用于只包含数据而不包含成员函数的情况。<br>无论选择使用struct还是class，都可以在其中定义成员函数（方法）以提供对数据的操作，这取决于您的设计需求和数据封装的程度。在实际应用中，这两个关键字的选择通常是根据项目的需求和编码风格来确定的。</p>
</li>
</ol>
<h4 id="深入理解-C-STL-迭代器"><a href="#深入理解-C-STL-迭代器" class="headerlink" title="深入理解 C++ STL 迭代器"></a>深入理解 C++ STL 迭代器</h4><p>STL（Standard Template Library）中的容器实现迭代器是通过将迭代器作为容器类的内部类来实现的。迭代器是一种用于遍历容器中元素的抽象概念，它提供了访问容器元素的接口，使得可以轻松地遍历容器的内容。</p>
<p>以下是关于STL容器中迭代器的一些一般性原则：</p>
<ol>
<li><p>迭代器是容器的一部分：迭代器通常被定义为容器类的内部类，因此它们可以访问容器内部的数据结构，并提供访问和操作元素的方法。</p>
</li>
<li><p>迭代器的种类：不同类型的STL容器可以提供不同种类的迭代器，例如前向迭代器、双向迭代器和随机访问迭代器。迭代器的种类决定了迭代器的功能和效率，不同的容器支持不同种类的迭代器。</p>
</li>
<li><p>迭代器的操作：迭代器通常支持一组标准操作，如前进、后退、解引用等。这些操作允许您在容器中移动并访问元素。</p>
</li>
<li><p>Begin 和 End：STL容器通常提供 begin() 和 end() 成员函数，分别返回指向容器第一个元素和尾后位置（即不指向任何元素的位置）的迭代器。这些函数用于迭代容器的所有元素。</p>
</li>
<li><p>迭代器的使用：迭代器可以用于遍历容器的元素，从容器的开始（begin()）到结束（end()）。使用迭代器，您可以执行诸如遍历、查找、修改和删除元素等操作。</p>
</li>
<li><p>具体的实现细节和迭代器的性能特征取决于特定的容器类型。例如，std::vector 提供了随机访问迭代器，因此支持快速的随机访问，而 std::list 提供了双向迭代器，因此在列表中的元素上前进和后退较为高效。</p>
</li>
</ol>
<p>总之，STL容器通过定义迭代器来提供对容器元素的访问和遍历，这是STL的一个核心概念，使得STL容器在使用上非常灵活。</p>
<h4 id="红黑树和-AVL-树实现差异"><a href="#红黑树和-AVL-树实现差异" class="headerlink" title="红黑树和 AVL 树实现差异"></a>红黑树和 AVL 树实现差异</h4><ol>
<li>AVL树的插入操作通常使用递归来实现，这是因为AVL树在插入后需要递归地重新平衡，以确保树保持平衡因子的性质。与AVL树不同，红黑树的平衡性质更容易通过迭代修复，因为它只涉及相邻节点之间的颜色变化和旋转操作，而不需要像AVL树那样严格的平衡因子维护。</li>
</ol>
<p>在红黑树中，使用迭代而不是递归的原因之一是它更简单且更高效。另一方面，AVL树的平衡因子维护涉及到更复杂的旋转和递归操作，因此递归更容易理解和实现。</p>
<p>总之，红黑树通常使用迭代插入操作，而AVL树通常使用递归插入操作。不同的数据结构有不同的性质和平衡要求，因此它们的插入和平衡策略也不同。</p>
<h4 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h4><ol>
<li><p>访问权限<br>类（class）的默认访问权限是私有（private）。这意味着类中的成员（数据成员和成员函数）默认情况下只能在类的内部访问，需要使用公有接口才能从外部访问。<br>结构体（struct）的默认访问权限是公共（public）。这意味着结构体中的成员在外部可以直接访问。</p>
</li>
<li><p>继承<br>类可以用于实现类的继承和多态，因为类支持访问控制符（如private、protected、public）来控制基类成员的可见性和访问权限。<br>结构体也可以用于继承，但默认的访问权限是公共，因此它们的成员在子类中具有相同的访问权限。</p>
</li>
<li><p>使用习惯<br>通常情况下，类用于表示具有私有成员和行为的抽象数据类型，用于封装数据和操作。<br>结构体通常用于表示简单的数据结构，其中成员通常是相关的数据字段而不包含复杂的行为。</p>
</li>
</ol>
<h4 id="宏定义-define"><a href="#宏定义-define" class="headerlink" title="宏定义 define"></a>宏定义 define</h4><p>宏定义是在编译前由预处理器处理的，因此它们不会进行类型检查，可能会导致一些潜在的错误。<br>作用：</p>
<ol>
<li>宏替换：预处理器会根据宏定义将源代码中的标识符替换为相应的文本。这允许您创建常量、宏函数以及在代码中的其他地方重复使用文本片段。这提高了代码的可维护性和可读性。</li>
<li>条件编译：通过使用条件指令（如#ifdef、#ifndef、#if、#elif、#else和#endif），您可以根据条件包含或排除代码段。这对于在不同的编译环境或配置下启用或禁用特定功能非常有用，例如调试模式或发布模式下的不同行为。</li>
<li>包含文件：#include指令允许您在源代码中包含其他头文件，以便使用其中定义的函数、变量和类型。这有助于模块化代码并实现代码重用</li>
<li>删除注释：预处理器可以删除注释，这样它们不会包含在编译后的代码中。这有助于减小可执行文件的大小，同时保留了代码的可读性。</li>
<li>定义符号常量：通过#define指令，您可以定义符号常量，以便在代码中使用这些常量而不必硬编码它们的值。这有助于提高代码的可维护性，并减少代码中的魔法数字。</li>
</ol>
<h4 id="数据库语言"><a href="#数据库语言" class="headerlink" title="数据库语言"></a>数据库语言</h4><p>操作数据库经常使用特定的数据库查询语言(Database Query Language)。最常见的数据库查询语言是 SQL(Structured Query Language, 结构化查询语言)。</p>
<p>DBMS(Database manage system) 数据库管理系统</p>
<p>绝大多数数据库软件都支持 SQL 语言，尤其是关系型数据库管理系统(RDBMS)</p>
<p><strong>MySQL 和 SQLite 的关系：</strong><br>MySQL：MySQL是一个强大的关系型数据库管理系统，通常用于大型企业应用程序和高负载的网站。它可以处理大量数据和高并发访问。<br>SQLite：SQLite是一种轻量级的嵌入式数据库，适用于小型到中等规模的应用程序。它通常用于移动应用、桌面应用、嵌入<br>式系统等，不适用于大规模或高并发的场景。</p>
<p>其中，嵌入式指的是 <strong>运行方式和部署方式</strong>。这意味着它的数据库引擎以库（库文件或代码库）的形式直接嵌入到应用程序中，而不是作为一个独立的数据库服务器运行。(还记得如果使用 MySQL 的话，需要在电脑上开启它)</p>
<h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>Redis(Remote Dictionary Server)。Redis 是一种开源的<strong>内存数据库</strong>，可以用作缓存、消息代理、持久化存储以及多种数据结构的高效存储和检索。</p>
<p>内存数据库将数据存储在内存中，可以实现非常快的读取和写入操作。这使得内存数据库在需要快速响应的应用中有非常大的优势，例如实时数据分析、缓存和实时计算。</p>
<h5 id="std-string-npos"><a href="#std-string-npos" class="headerlink" title="std::string::npos"></a>std::string::npos</h5><p>std::string::npos 是C++标准库中的一个特殊常量值，通常用于表示字符串操作的无效或失败状态，特别是在查找子字符串或字符时。</p>
<p>常见的使用方式是在 <code>std::string</code> 的 <code>find</code> 函数中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string text = &quot;Hello, World!&quot;;</span><br><span class="line">    std::size_t found = text.find(&quot;foo&quot;); // 在字符串中查找&quot;foo&quot;</span><br><span class="line">    </span><br><span class="line">    if (found != std::string::npos) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Substring found at position &quot; &lt;&lt; found &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Substring not found.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h4><p><code>size_t</code>  是C&#x2F;C++标准库中定义的一种用于表示对象大小或索引的无符号整数类型。它通常被用于数组索引、容器大小、内存分配、字符串长度以及其他需要表示对象大小的上下文中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    for (size_t i = 0; i &lt; v.size(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Miscellaneous</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉图</title>
    <url>/2023/11/13/%E6%AC%A7%E6%8B%89%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4>]]></content>
  </entry>
  <entry>
    <title>概率论与数理统计关键记录</title>
    <url>/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="第一章-随机事件及其概率"><a href="#第一章-随机事件及其概率" class="headerlink" title="第一章 随机事件及其概率"></a>第一章 随机事件及其概率</h3><p>分球入盒问题：</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://zhuanlan.zhihu.com/p/604142990">https://zhuanlan.zhihu.com/p/604142990</a></li>
</ol>
<h3 id="第二章-随机变量及其分布"><a href="#第二章-随机变量及其分布" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h3><p>Bernoulli 分布：<br>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; p \<br>D(X) &amp;&#x3D; p(1-p)<br>\end{aligned}<br>$$<br>二项分布：<br>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; np \<br>D(X) &amp;&#x3D; np(1 - p)<br>\end{aligned}<br>$$<br>泊松分布：<br>$$<br>\begin{aligned}<br>P(X &#x3D; k) &amp;&#x3D; \dfrac{\lambda^{k}}{k!} e^{-\lambda} \<br>E(X) &amp;&#x3D; \lambda \<br>D(X) &amp;&#x3D; \lambda<br>\end{aligned}<br>$$<br>几何分布：<br>$$<br>\begin{aligned}<br>P(X &#x3D; k) &amp;&#x3D; (1-p)^{k - 1}p \<br>E(X) &amp;&#x3D; \dfrac{1}{p} \<br>D(X) &amp;&#x3D; \dfrac{1 - p}{p^{2}}<br>\end{aligned}<br>$$<br>均匀分布：<br>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \dfrac{a + b}{2} \<br>D(X) &amp;&#x3D; \dfrac{(b - a)^{2}}{12}<br>\end{aligned}<br>$$<br>指数分布：<br>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \dfrac{1}{\lambda} \<br>D(X) &amp;&#x3D; \dfrac{1}{\lambda^{2}}<br>\end{aligned}<br>$$</p>
<blockquote>
<p>注意它和泊松分布数量特征之间的差异</p>
</blockquote>
<p>卡方分布：<br>它的数量特征感觉形式比较复杂，应该不会考。</p>
<p>t 分布：<br>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; 0 \<br>D(X) &amp;&#x3D; \dfrac{n}{n - 2}<br>\end{aligned}<br>$$<br>F 分布：</p>
<p>F 分布也被称为「方差比分布」(Variance Ratio Distribution)</p>
<p>感觉它的数量特征形式也是比较复杂的，但是它的性质好像比较多，应该也不会考。</p>
<p><strong>这一部分的推导可以看之前的期中作业。</strong></p>
<h3 id="第三章-多维随机变量及其分布"><a href="#第三章-多维随机变量及其分布" class="headerlink" title="第三章 多维随机变量及其分布"></a>第三章 多维随机变量及其分布</h3><p>感觉这一部分是需要多做一些题目的。</p>
<h4 id="二维正态分布（多元正态分布）"><a href="#二维正态分布（多元正态分布）" class="headerlink" title="二维正态分布（多元正态分布）"></a>二维正态分布（多元正态分布）</h4><p>关于多元正态分布密度函数公式的推导，我们可以<strong>从特殊情况出发</strong>。先假设 n 个变量是相互独立的，并且每一个都是服从标准正态分布的，那么联合概率密度函数就有：</p>
<p>$$<br>\begin{aligned}<br>p(z_1, z_2, …, z_n) &amp;&#x3D; \prod\limits_{i &#x3D; 1}^{n} \dfrac{1}{\sqrt{2 \pi}} \cdot e^{-\frac{1}{2}\cdot(x_i)^{2}} \<br>&amp;&#x3D; \dfrac{1}{(2\pi)^{\frac{\pi}{2}}} \cdot e^{-\frac{1}{2}\cdot (Z^{T}Z)}<br>\end{aligned}<br>$$</p>
<p>那么在 Z 彼此不是相互独立的情况下，我们该如何求得 Z 的联合密度函数呢？一个想法是我们通过线性变换使得 Z 中的每一个变量都是独立的。</p>
<p>其实，有下面的定理：</p>
<blockquote>
<p>若存在随机向量$\vec{X}\sim\mathcal{N}(\vec{\mu},\Sigma)$,其中$\vec{\mu}\in R^n$ 为均值向量，$\Sigma\in S_{++}^{n\times n}$ 矩阵为$\vec{X}$的协方差矩阵，则存在满秩矩阵$B\in R^{n\times n}$,使得$\vec{Z}&#x3D;B^{-1}(\vec{X}-\vec{\mu})$,而<br> $\vec{z}\sim\mathcal{N}(\vec{0},\mathbf I):.$</p>
</blockquote>
<p>所以经过线性变换可以得到不相关的情况：</p>
<p>$$<br>\begin{aligned}<br>\vec{Z}&amp; &#x3D;B^{-1}(\vec{X}-\vec{\mu}),\vec{Z}\sim\mathcal{N}(\vec{0},I)  \<br>p(z_{1},\cdots,z_{n})&amp; &#x3D;\frac{1}{(2\pi)^{\frac{n}{2}}}\cdot e^{-\frac{1}{2}\cdot(Z^{\top}Z)}  \<br>p(z_{1}(x_{1},\cdots,x_{n}),\cdots)&amp; &#x3D;\frac{1}{(2\pi)^{\frac{n}{2}}}\cdot e^{-\frac{1}{2}\cdot[(B^{-1}(\vec{X}-\vec{\mu}))^{\top}(B^{-1}(\vec{X}-\vec{\mu}))]}  \<br>&amp;&#x3D;\frac{1}{(2\pi)^{\frac{n}{2}}}\cdot e^{-\frac{1}{2}\cdot[(\vec{X}-\vec{\mu})^\top(BB^\top)^{-1}(\vec{X}-\vec{\mu})]}<br>\end{aligned}<br>$$</p>
<p>此时有：</p>
<p>$$<br>\begin{aligned}<br>\text{1}&amp; &#x3D;\int_{-\infty}^{+\infty}\cdots\int_{-\infty}^{+\infty}p(z_{1}(x_{1},\cdots,x_{n}),\cdots)dz_{1}\cdots dz_{n}  \<br>&amp;&#x3D;\int_{-\infty}^{+\infty}\cdots\int_{-\infty}^{+\infty}\frac{1}{(2\pi)^{\frac{n}{2}}}\cdot e^{-\frac{1}{2}\cdot[(\vec{X}-\vec{\mu})^\top(BB^\top)^{-\lambda}(\vec{X}-\vec{\mu})]}dz_{1}\cdot\cdots dz_{n}<br>\end{aligned}<br>$$</p>
<p>注意，其中有一个 Jaccobi 行列式。</p>
<p>$$<br>J(\vec{Z}\to\vec{X})&#x3D;\left|B^{-1}\right|&#x3D;|B|^{-1}&#x3D;|B|^{-\frac{1}{2}}\cdot\left|B^\top\right|^{-\frac{1}{2}}&#x3D;\left|BB^\top\right|^{-\frac{1}{2}}<br>$$</p>
<p>所以，进一步可以得到：</p>
<p>$$<br>1&#x3D;\int_{-\infty}^{+\infty}\cdots\int_{-\infty}^{+\infty}\frac{1}{(2\pi)^{\frac{n}{2}}|BB^\top|^{\frac{1}{2}}}\cdot e^{-\frac{1}{2}\cdot[(\vec{X}-\vec{\mu})^\top(BB^\top)^{-1}(\vec{X}-\vec{\mu})]}dx_1\cdots dx_n<br>$$</p>
<p>这样，我们就得到了最终的联合密度函数：</p>
<p>$$<br>p(x_1,\cdots,x_n)&#x3D;\frac{1}{(2\pi)^{\frac{n}{2}}|BB^\top|^{\frac{1}{2}}}\cdot e^{-\frac{1}{2}\cdot[(\vec{X}-\vec{\mu})^\top(BB^\top)^{-1}(\vec{X}-\vec{\mu})]}<br>$$</p>
<h4 id="边缘分布"><a href="#边缘分布" class="headerlink" title="边缘分布"></a>边缘分布</h4><p>设二位随机变量 $(X, Y)$ 的分布函数为 $F(x, y)$，分别记关于 X 和 Y 的边缘分布函数为 $F_X(x)$ 和 $F_Y(y)$，有<br>$$<br>F_X(x) &#x3D; P(X \leq x) &#x3D; P(X \leq x, Y &lt; +\infty)&#x3D; F(x, +\infty)<br>$$</p>
<p>二维正态分布的两个边缘分布都是一维正态分布，并且不依赖于参数 $\rho$</p>
<p>n 维正态分布的 k 维边缘分布也是正态分布，但是边缘分布都是正态分布的随机变量，联合分布不一定是二维正态分布。</p>
<h4 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h4><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203121601168.png" class="" title="image-20231203121601168">

<blockquote>
<p>又遇到了关于连续型概率密度函数取一块很小的区间的应用。在推导顺序统计量的密度函数的时候也用到过。</p>
</blockquote>
<p>所以对应的密度函数有<br>$$<br>f_{Y|X} &#x3D; \dfrac{f(x, y)}{f_X(x)}<br>$$</p>
<h4 id="随机变量的独立性"><a href="#随机变量的独立性" class="headerlink" title="随机变量的独立性"></a>随机变量的独立性</h4><p>首先我们是用分布函数引入的独立性 $F(x, y) &#x3D; F_X(x) \times F_Y(y)$</p>
<p>为连续型随机变量的时候等价于：$f(x, y) &#x3D; f_X(x) \cdot f_Y(y)$</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231223094518219.png" class="" title="image-20231223094518219">

<h4 id="二维随机变量的分布"><a href="#二维随机变量的分布" class="headerlink" title="二维随机变量的分布"></a>二维随机变量的分布</h4><h5 id="Z-X-Y"><a href="#Z-X-Y" class="headerlink" title="Z &#x3D; X + Y"></a>Z &#x3D; X + Y</h5><p>$$<br>f(z) &amp;&#x3D; \int_{-\infty}^{+\infty}f(x, z - x) \mathrm{d}x \<br>&amp;&#x3D; \int_{-\infty}^{+\infty} f(z - y, y) \mathrm{d}y<br>$$</p>
<p>当 X 和 Y 相互独立的时候，我们才可以把密度函数写为 <strong>卷积的形式</strong></p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203123454579.png" class="" title="image-20231203123454579">

<h5 id="Z-XY"><a href="#Z-XY" class="headerlink" title="Z &#x3D; XY"></a>Z &#x3D; XY</h5><p>$$<br>f(z) &#x3D; \int_{-\infty}^{+\infty} \dfrac{1}{|x|}f(x, \dfrac{z}{x})\mathrm{d}x<br>$$</p>
<h5 id="Z-dfrac-X-Y"><a href="#Z-dfrac-X-Y" class="headerlink" title="Z &#x3D; $\dfrac{X}{Y}$"></a>Z &#x3D; $\dfrac{X}{Y}$</h5><p>$$<br>f(z) &#x3D; \int_{-\infty}^{+\infty} |y| f(yz, y) \mathrm{d}y<br>$$</p>
<h5 id="M-max-X-Y-N-min-X-Y"><a href="#M-max-X-Y-N-min-X-Y" class="headerlink" title="M &#x3D; $\max{X, Y}, N &#x3D; \min{X,Y}$"></a>M &#x3D; $\max{X, Y}, N &#x3D; \min{X,Y}$</h5><p>$$<br>\begin{aligned}<br>F_{\max}(z) &amp;&#x3D; F_{X_1}(z)\cdot F_{X_2}(z)…F_{X_n}(z) \<br>F_{\min}(z) &amp;&#x3D; 1 - [1 - F_{X_1}(z)][1 - F_{X_2}(z)]…[1 - F_{X_n}(z)]<br>\end{aligned}<br>$$</p>
<h4 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h4><p>1. </p>
<h3 id="第四章-随机变量的数字特征与极限定理"><a href="#第四章-随机变量的数字特征与极限定理" class="headerlink" title="第四章 随机变量的数字特征与极限定理"></a>第四章 随机变量的数字特征与极限定理</h3><h4 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h4><p>离散型：如果级数 $\sum\limits_{k &#x3D; 1}^{+\infty} x_kp_k$ <strong>绝对收敛</strong>，则称级数 $\sum\limits_{k &#x3D; 1}^{+\infty} x_kp_k$ 的和为离散型随机变量的数学期望。</p>
<p>连续型：积分 $\int_{-\infty}^{+\infty}f(x)\mathrm{d}x$ 绝对收敛，就称积分值为 X 的数学期望。</p>
<blockquote>
<p>注意：期望的定义是绝对收敛。<br>因为如果某一个级数只是条件收敛，那么它的绝对值并不收敛，则将这一个级数的各项次序改排以后，可以使得他不收敛或者收敛但是和等于事先任意给定的值。这就意味期望的大小与是否存在与 X 所取值的顺序有关。但是 E(X) 作为描述 X 的某种特性的数值，有客观意义，不应该取值随着次序变化，所以在定义 E(X) 的时候，我们要求它绝对收敛。</p>
</blockquote>
<p>注意：柯西分布的数学期望不存在</p>
<p>离散型期望不存在的例子？？？</p>
<p>如果 $X,Y$ 独立，则 $E(XY) &#x3D; E(X)E(Y)$（直接使用定义证明就行）但是反过来，若 $E(XY) &#x3D; E(X)E(Y)$，X Y 不一定独立，如 $X \sim N(0, 1), Y &#x3D; X^{2}$</p>
<h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p> 若$c\neq EX$,则 $DX&lt;E(X-c)^2$</p>
<p>$E(X - c)^{2}$ 变为 $(E(X) - c)^{2} + D(X)$</p>
<h4 id="柯西施瓦兹不等式"><a href="#柯西施瓦兹不等式" class="headerlink" title="柯西施瓦兹不等式"></a>柯西施瓦兹不等式</h4><h4 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h4><p>可以证明，若 $ac &gt; 0$，则 $\rho_{aX + b,cY + d} &#x3D; \rho_{XY}$</p>
<p>若 $ac &lt; 0$，则 $\rho_{aX + b,cY + d} &#x3D; -\rho_{XY}$</p>
<p>对于二元正态分布，X 与 Y 不相关 等价于 X 与 Y 独立</p>
<h4 id="协方差与协方差矩阵"><a href="#协方差与协方差矩阵" class="headerlink" title="协方差与协方差矩阵"></a>协方差与协方差矩阵</h4><p>对于随机变量 X 和 Y 的协方差，定义为：</p>
<p>$$<br>\begin{aligned}<br>   \sigma(x,y)&#x3D;E[(x-E(x))(y-E(y))]<br>\end{aligned}<br>$$</p>
<p>对于<strong>二维数据</strong>，我们可以得到四个值构成的协方差矩阵：</p>
<p>$$<br>\begin{aligned}<br>   \Sigma&#x3D;\begin{bmatrix}\sigma(x,x)&amp;\sigma(x,y)\\sigma(y,x)&amp;\sigma(y,y)\end{bmatrix}<br>\end{aligned}<br>$$</p>
<p>如果上面的 X 和 Y 是 <strong>n 维的数据</strong>，$\left.\mathbf{X}:&#x3D;\left[\begin{array}{c}x_1\x_2\\vdots\x_m\end{array}\right.\right]\mathbf{Y}:&#x3D;\left[\begin{array}{c}y_1\y_2\\vdots\y_n\end{array}\right]$</p>
<p>这样，对于 $m \times n$ 个 $a_{ij}$ 组成的矩阵 $\mathbf{A} &#x3D; [a_{ij}]<em>{m \times n}$，定义：$\operatorname{E}[\mathbf{A}]:&#x3D;\left[\operatorname{E}(a</em>{ij})\right]_{m\times n}$，也就是说：</p>
<p>$$<br>\begin{aligned}<br>   \mathrm{E}[\mathbf{A}]:&#x3D;\begin{bmatrix}\mathrm{E}(a_{11})&amp;\mathrm{E}(a_{12})&amp;\cdots&amp;\mathrm{E}(a_{1n})\\mathrm{E}(a_{21})&amp;\mathrm{E}(a_{22})&amp;\cdots&amp;\mathrm{E}(a_{2n})\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\mathrm{E}(a_{m1})&amp;\mathrm{E}(a_{m2})&amp;\cdots&amp;\mathrm{E}(a_{mn})\end{bmatrix}<br>\end{aligned}<br>$$</p>
<p>那么我们又可以把定义写为：</p>
<p>$$<br>\begin{aligned}<br>   \mathbf{cov}(X,Y)&#x3D;\mathbf{E}\left[\left(\mathbf{X}-\mathbf{E}[\mathbf{X}]\right)\left(\mathbf{Y}-\mathbf{E}[\mathbf{Y}]\right)^\mathrm{T}\right]<br>\end{aligned}<br>$$</p>
<h5 id="对于维度的理解"><a href="#对于维度的理解" class="headerlink" title="对于维度的理解"></a>对于维度的理解</h5><p>可以是 n 个不同对象，也可以是一个对象的 n 个不同角度。</p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>$\mathbf{\Sigma}&#x3D;\mathbf{cov}(X,X)$ 有以下的性质：</p>
<ol>
<li><p>$\mathbf{\Sigma}&#x3D;\mathrm{E}(\mathbf{X}\mathbf{X}^T)-\mathrm{E}(\mathbf{X})[\mathrm{E}(\mathbf{X})]^T$</p>
</li>
<li><p>$\mathbf{\Sigma}$ 是半正定的和对称的矩阵<br>关于半正定的证明:<br>$$<br>\begin{aligned}<br>   \mathbf{\Sigma}&#x3D;\mathrm{E}(\mathbf{X}\mathbf{X}^T)-\mathrm{E}(\mathbf{X})[\mathrm{E}(\mathbf{Y})]^T<br>\end{aligned}<br>$$</p>
</li>
</ol>
<h4 id="SVD-奇异值分解"><a href="#SVD-奇异值分解" class="headerlink" title="SVD(奇异值分解)"></a>SVD(奇异值分解)</h4><p>奇异值分解(SVD, Singular Value Decomposition)</p>
<h4 id="PCA-主成分分析"><a href="#PCA-主成分分析" class="headerlink" title="PCA(主成分分析)"></a>PCA(主成分分析)</h4><h4 id="示性函数"><a href="#示性函数" class="headerlink" title="示性函数"></a>示性函数</h4><p>对于随机时间 A，引入<strong>示性函数</strong> $I_A$，$I_A &#x3D; \begin{aligned}\begin{cases}1, A 发生 \ 0,A不发生\end{cases}\end{aligned}$。</p>
<p>这个函数很特殊，它的数学期望就是事件 A 发生的概率。</p>
<h4 id="马尔可夫不等式"><a href="#马尔可夫不等式" class="headerlink" title="马尔可夫不等式"></a>马尔可夫不等式</h4><p>对于随机变量 X 和定值 a，随机事件 $x \geq a$，画出示性函数 $I_A$，如图：</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202173730081.png" class="" title="image-20231202173730081">

<p>容易发现：$I_{X \geq a} \leq \dfrac{x}{a}$。对于这个式子取数学期望，可以得到：$\mathbb E I_{X \geq a} &#x3D; P(X \geq a) \leq \dfrac{\mathbb E X}{a}$</p>
<h4 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h4><p>考虑随机事件 $A &#x3D; {|x - \mu| \geq a}$，其示性函数如图：</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202175026393.png" class="" title="image-20231202175026393">

<p>所以 $I_{|X - \mu|\geq a} \leq \dfrac{(x - \mu)^{2}}{a^{2}}$，取数学期望可以得到：$\mathbb E I_{|X -\mu| \geq a} &#x3D; P(|X - \mu| \geq a) \leq \dfrac{ D X}{a^{2}}$</p>
<p>这个就是<strong>切比雪夫不等式</strong></p>
<p>课本上给出的证明是根据积分来证明的。<br>$$<br>\begin{aligned}<br>P(|X - \mu| \leq a) &amp;&#x3D; \int_{a - \mu}^{a + \mu} f(x) \mathrm{d}x \<br>&amp;\leq \dfrac{1}{a^{2}} \int_{a - \mu}^{a + \mu} (x - \mu)^{2}f(x) \mathrm{d}x \<br>&amp;\leq \dfrac{1}{a^{2}} \int_{-\infty}^{+\infty} (x - \mu)^{2}f(x) \mathrm{d}x \<br>&amp;\leq \dfrac{D X}{a^{2}}<br>\end{aligned}<br>$$</p>
<blockquote>
<p>注意到方差的定义的式子。</p>
</blockquote>
<h4 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h4><p>大数定律简单来说，就是随机事件发生的频率会向某一个常数值收敛，该常数值为该事件发生的概率。</p>
<p>大数定律告诉我们：<strong>可以近似使用频率代替概率，能用样本均值近似代替总体均值</strong></p>
<table>
<thead>
<tr>
<th>大数定律</th>
<th>要求</th>
<th>证明</th>
</tr>
</thead>
<tbody><tr>
<td>辛钦大数定律（弱大数定律）</td>
<td>独立同分布的变量，对于方差不做要求</td>
<td>用到了特征函数</td>
</tr>
<tr>
<td>切比雪夫大数定律</td>
<td>独立的随机变量，期望存在，方差存在公共上界</td>
<td>切比雪夫不等式</td>
</tr>
<tr>
<td>伯努利大数定律</td>
<td>n 重伯努利试验</td>
<td>辛钦的特殊情况</td>
</tr>
</tbody></table>
<p>相比于辛钦大数定律，切比雪夫大数定律未要求同分布，所以更具一般性。</p>
<h4 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h4><p>对于它的证明，用到了特征函数。</p>
<p>条件：<strong>独立同分布</strong> <em>、</em>不一定就是正态分布**</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202183810838.png" class="" title="image-20231202183810838">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202183820451.png" class="" title="image-20231202183820451">

<h4 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://zhuanlan.zhihu.com/p/259280292">https://zhuanlan.zhihu.com/p/259280292</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/491155921">https://zhuanlan.zhihu.com/p/491155921</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29846048">https://zhuanlan.zhihu.com/p/29846048</a> 奇异值分解</li>
</ol>
<h3 id="第五章-数理统计的基本知识"><a href="#第五章-数理统计的基本知识" class="headerlink" title="第五章 数理统计的基本知识"></a>第五章 数理统计的基本知识</h3><h4 id="统计量与三大分布"><a href="#统计量与三大分布" class="headerlink" title="统计量与三大分布"></a>统计量与三大分布</h4><p>样本来源于总体，含有总体的信息。为了对于总体进行推断，需要对于样本的 n 个观测值进行加工处理，把样本含有的<strong>信息集中起来</strong>。具体地说，就是对于不同的问题构造样本不同的函数，再利用这些函数对总体进行推断。<strong>这类函数就是统计量</strong>。</p>
<h5 id="常用统计量"><a href="#常用统计量" class="headerlink" title="常用统计量"></a>常用统计量</h5><ol>
<li>样本均值</li>
<li>样本方差</li>
<li>样本标准差</li>
<li>样本 k 阶原点矩</li>
<li>样本 k 阶中心矩</li>
<li><strong>顺序统计量</strong></li>
</ol>
<p>此外，如果是二维的，则常用：</p>
<ol>
<li>样本协方差</li>
<li>样本相关系数</li>
</ol>
<h5 id="三大分布"><a href="#三大分布" class="headerlink" title="三大分布"></a>三大分布</h5><h6 id="mathcal-X-2-分布"><a href="#mathcal-X-2-分布" class="headerlink" title="$\mathcal{X}^{2}$ 分布"></a>$\mathcal{X}^{2}$ 分布</h6><p>设随机变量 $X_1, X_2, …, X_n$ 相互独立，并且 $X_i \sim N(0, 1)$，那么 $\mathcal{X}^{2} &#x3D; X_1^{2} + X_2^{2} + … + X_n^{2}$ 服从自由度为 n 的 $\mathcal{X}^{2}$ 分布。</p>
<ul>
<li>可加性</li>
<li>一种 pdf 的证明方式是使用 n-1 此坐标变换，见参考 2</li>
<li>当自由度 $n \to +\infty$ 的时候，卡方分布趋近于正态分布，自由度偏小的时候，呈现偏态，自由度比较大的时候，呈现正态</li>
<li>$EX &#x3D; n, DX &#x3D; 2n$</li>
<li>卡方分布的极限分布是正态分布<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222221439014.png" class="" title="image-20231222221439014">
所以，n 很大的时候，有 $\chi^{2}(n)$ 近似为 $N(n, 2n)$</li>
</ul>
<h6 id="t-分布（学生分布）"><a href="#t-分布（学生分布）" class="headerlink" title="t 分布（学生分布）"></a>t 分布（学生分布）</h6><p>设随机变量 X 和 Y 相互独立，并且 $X \sim N(0, 1), Y \sim \mathcal{X}^{2}(n)$，那么称随机变量 $t &#x3D; \dfrac{X}{\sqrt{Y &#x2F; n}}$ 为服从自由度为 n 的 t 分布。</p>
<ul>
<li>$EX &#x3D; 0, DX &#x3D; \dfrac{n}{n - 2}$</li>
<li>是一个偶函数</li>
<li>自由度趋近于无穷的时候，趋近于一个正态分布，并且一般 n &gt; 30，就认为是标准正态分布、</li>
<li>pdf 的推导参见参考 4</li>
<li>t 分布的极限分布是 标准正态分布</li>
</ul>
<h6 id="F-分布"><a href="#F-分布" class="headerlink" title="F 分布"></a>F 分布</h6><p>设随机变量 X 和 Y <strong>相互独立</strong>，并且 $X \sim \mathcal{X}^{2}(m), Y \sim \mathcal{X}^{2}(n)$，则称随机变量 $Z&#x3D; \dfrac{X &#x2F; m}{Y &#x2F; n}$ 服从自由度为 $(m,n)$ 的 F 分布，其中，m、n 分别称为第一二自由度。</p>
<ul>
<li><p>若 $X \sim F(m, n)$，那么 $\dfrac{1}{X} \sim F(n, m)$</p>
</li>
<li><p>若 $X \sim t(n)$，则 $X^{2} \sim F(1, n)$，也就是 t 分布的平方是 F 分布</p>
</li>
<li><p>${F_\alpha(m,n)&#x3D;\frac1{F_{1-\alpha}(n,m)}}$</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222224328724.png" class="" title="image-20231222224328724"></li>
</ul>
<h4 id="正态分布的抽样分布"><a href="#正态分布的抽样分布" class="headerlink" title="正态分布的抽样分布"></a>正态分布的抽样分布</h4><h5 id="一组样本"><a href="#一组样本" class="headerlink" title="一组样本"></a>一组样本</h5><p><strong>注意：</strong>下面讨论的是在<strong>正态分布</strong>的主体之下，上一部分是比较普遍的情况！！！</p>
<p>总体分布已知的时候，统计量的分布可以通过随机变量函数的分布求得，但是在实际的生活之中，往往计算很复杂，但是在正态总体的条件之下，一些常用的统计量有着比较简单的结果，下面给出正态分布中的统计量的分布。</p>
<ol>
<li>$U &#x3D; \dfrac{\overline{X} - \mu}{\sigma &#x2F; \sqrt{n}} \sim N(0, 1)$</li>
<li>$\dfrac{(n - 1)S^{2}}{\sigma^{2}} \sim \mathcal{X}^{2}(n - 1)$</li>
<li>$\overline{X}$ 和 $S^{2}$ 相互独立</li>
<li>$\dfrac{\overline{X} - \mu}{S &#x2F; \sqrt{n}} \sim t(n - 1)$</li>
</ol>
<p>其实，感觉 1 和 4 还是很对应的，因为 4 是样本方差，少一个自由度，所以不是正态分布，而是接近于正态分布的 t 分布。</p>
<p>对于式子 2 的证明，还是比较复杂的，暂时还没看，等复习一下线性代数之后再看吧。</p>
<p>第三个式子的证明可以从第二个的过程中延申</p>
<p>第四个式子由第三个的结果得来，看看课本可以</p>
<p>所以这几个式子的关系层层递进，关系还是很密切的。</p>
<h5 id="两组样本"><a href="#两组样本" class="headerlink" title="两组样本"></a>两组样本</h5><p>上面是一组样本的情况，下面看一下两组样本。</p>
<ol>
<li>$\dfrac{S_X^{2} &#x2F; \sigma_1^{2}}{S_Y^{2} &#x2F; \sigma_2^{2}} \sim F(m - 1, n - 1)$</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202220155672.png" class="" title="image-20231202220155672"></li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202220209898.png" class="" title="image-20231202220209898"></li>
</ol>
<p>证明还是看课本吧，感觉很大段。</p>
<h4 id="顺序统计量的分布"><a href="#顺序统计量的分布" class="headerlink" title="顺序统计量的分布"></a>顺序统计量的分布</h4><p>设 $(X_1, X_2, …, X_n)$ 是从总体 X 中抽取的一个样本，$(x_1, x_2, …, x_n)$ 是它的一个观测值，那么按照从小到大的顺序重新排列，得到的 $(x_{(1)},x_{(2)}, …, x_{(n)})$ 就是<strong>顺序统计量</strong>。</p>
<p>一般他们不是相互独立的。</p>
<h4 id="单个顺序统计量-x-k-的分布"><a href="#单个顺序统计量-x-k-的分布" class="headerlink" title="单个顺序统计量 $x_{(k)}$ 的分布"></a>单个顺序统计量 $x_{(k)}$ 的分布</h4><p>第 $k$ 个顺序统计量 $X_{(k)}$ 的分布函数为<br>$$<br>\begin{aligned}<br>F_{X_{(k)}} &amp;&#x3D; \dfrac{n!}{(k - 1)!(n - k)!} \int_0^{F(x)} t^{k - 1}(1- t)^{n - k} \mathrm{d}t \<br>&amp;&#x3D; \sum\limits_{i &#x3D; k}^{n} \begin{pmatrix}n \k\end{pmatrix} F^{k}(x)(1 - F(x))^{n - k}<br>\end{aligned}<br>$$<br>这是两种常见的书写形式，但是至于下面的式子如何推导得到上面的式子，也不是很清楚，不过好像可以求导证明他俩的相等。</p>
<p>如果是求密度函数的话，可以对于上面的两个式子求导。</p>
<p>其中，对于密度函数的推导还可以是：</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202191108492.png" class="" title="image-20231202191108492">

<p>这是一种思路，其中这种极限的思想还是比较常见的。</p>
<h4 id="任意两个次序统计量的联合pdf"><a href="#任意两个次序统计量的联合pdf" class="headerlink" title="任意两个次序统计量的联合pdf"></a>任意两个次序统计量的联合pdf</h4><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202191624139.png" class="" title="image-20231202191624139">

<h4 id="顺序统计量的期望"><a href="#顺序统计量的期望" class="headerlink" title="顺序统计量的期望"></a>顺序统计量的期望</h4><p>均匀分布随机变量的每一个顺序统计量的期望如何求？ - Maggie的回答 - 知乎<br><a href="https://www.zhihu.com/question/426131981/answer/1909047998">https://www.zhihu.com/question/426131981/answer/1909047998</a></p>
<h4 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://zhuanlan.zhihu.com/p/595063134">https://zhuanlan.zhihu.com/p/595063134</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/476377429">https://zhuanlan.zhihu.com/p/476377429</a> 卡方分布密度函数的推导</li>
<li><a href="https://zhuanlan.zhihu.com/p/488540788">https://zhuanlan.zhihu.com/p/488540788</a> 卡方分布密度函数的推导</li>
<li><a href="https://zhuanlan.zhihu.com/p/453323000">https://zhuanlan.zhihu.com/p/453323000</a> t 分布密度函数的推导</li>
<li><a href="https://zhuanlan.zhihu.com/p/453635917">https://zhuanlan.zhihu.com/p/453635917</a> F 分布密度函数的推导</li>
<li><a href="https://www.zhihu.com/question/426131981/answer/1909047998">https://www.zhihu.com/question/426131981/answer/1909047998</a> 顺序统计量的期望求解</li>
</ol>
<h3 id="第六章-参数估计和假设检验"><a href="#第六章-参数估计和假设检验" class="headerlink" title="第六章 参数估计和假设检验"></a>第六章 参数估计和假设检验</h3><p>数理统计的根本任务是<strong>样本的推断总体</strong>。很多时候，我们对于参数并不清楚，只有参数确定以后，我们才可以有一个总体的认识。<strong>参数估计就是一种由样本推断总体参数的方法</strong>。</p>
<p>参数估计<strong>有两种形式</strong>，点估计和区间估计。</p>
<h4 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h4><h5 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h5><p>矩估计就是根据分布的 K 阶矩的式子和样本计算得到的 K 阶矩对应相等，然后解方程组。</p>
<p>矩估计的 $\widehat\mu &#x3D; \overline{X}, \widehat\sigma^{2} &#x3D; \dfrac{n - 1}{n}S^{2}$</p>
<p>是一种古老的方式，但是有两个不足：</p>
<ol>
<li>所要求的总体阶矩可能不存在</li>
<li>解方程组可能很困难</li>
</ol>
<p>而且当总体的分布类型已知的时候，矩估计并没有充分利用分布提供的信息</p>
<h5 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h5><p>关键两步，写出 L 的式子，然后求解极值。</p>
<p>写出似然函数，写出似然方程，求解似然方程。</p>
<h5 id="估计量的优劣评价标准"><a href="#估计量的优劣评价标准" class="headerlink" title="估计量的优劣评价标准"></a>估计量的优劣评价标准</h5><p>MSE Mean Squared Error 均方误差来衡量，指的是估计值个真实值之间的差异。												</p>
<p>$$<br>\begin{aligned}<br>MSE(\widehat \theta) &amp;&#x3D; E(\widehat\theta - \theta)^{2} &#x3D; E[(\widehat\theta - E(\theta)) + (E(\theta) - \theta)]^{2} \<br>&amp;&#x3D; E[\widehat\theta - E(\widehat\theta)]^{2} + [E(\widehat\theta) - \theta]^{2} \<br>&amp;&#x3D; D(\widehat\theta)  + [E(\widehat\theta) - \theta]^{2}<br>\end{aligned}<br>$$</p>
<p>然后让 $E(\widehat\theta)$ 与 $\theta$ 尽可能接近。</p>
<p>所以我们使用估计量的期望来衡量估计量和实际量的差异程度大小。</p>
<ul>
<li>X 的一阶矩和二阶矩存在，记 $E(X) &#x3D; \mu, D(X) &#x3D; \sigma^{2}$，则样本均值 $\overline{X}$ 是 $\mu$ 的无偏估计，$S_{n}^{2}$ 是 $\sigma^{2}$ 的渐进无偏估计，样本方差 $S^{2}$ 是 $\sigma^{2}$ 的无偏估计。</li>
</ul>
<ol>
<li>无偏性</li>
<li>有效性</li>
<li>相合性</li>
</ol>
<p>因为矩估计是无偏的，所以说它的线性组合也是无偏的。</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222201942757.png" class="" title="image-20231222201942757">

<h4 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h4><p>点估计可以给出 $\theta$ 的一个估计的数值，但是只是一个近似值。而且误差是多少我们也不知道，但是人们真实情况下还是比较关注误差的，为此，引入了满足误差范围内的估计区间，<strong>区间估计</strong>。</p>
<p><strong>区间估计的步骤：</strong></p>
<ol>
<li>寻找一个与待估计参数 $\theta$ 有关的统计量 T</li>
<li>找出 T 和 $\theta$ 之间的函数 $H(T, \theta)$，要求 H 分布已知并且与 $\theta$ 无关，其中 $H(T, \theta)$ 称为枢轴变量</li>
<li>寻找适当的常数 c 和 d，使得 $P(c \leq H(T, \theta)\leq d) &#x3D; 1 - \alpha$</li>
<li>求解得到区间</li>
</ol>
<p><strong>一个区间估计的表格吧</strong></p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231202234157042.png" class="" title="image-20231202234157042">

<h4 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h4><p>前面提到的参数估计是给出未知参数的一个合适的估计值，但是生活中还有另一类问题，一种统计推断的问题。</p>
<p>包括 <strong>参数检验和非参数检验</strong></p>
<p><strong>假设检验的步骤：</strong></p>
<ol>
<li>建立假设<br>原假设 $H_0$<br>备择假设 $H_1$<br>检验的目的就是在两个之间选择一个</li>
<li>选取检验的统计量，并且在 $H_0$ 成立的条件下确定该统计量的分布</li>
<li>选取检验的显著水平 $\alpha$ 与临界值</li>
<li>做出判断<br>计算统计量的观测值，和临界做比较。</li>
</ol>
<h5 id="原假设与备择假设的选取原则"><a href="#原假设与备择假设的选取原则" class="headerlink" title="原假设与备择假设的选取原则"></a>原假设与备择假设的选取原则</h5><p>通常，原假设不能轻易被否定。按照下面的原则：</p>
<ol>
<li>研究者要证明的为 $H_1$</li>
<li>研究者要反对的为 $H_0$</li>
<li>现状作为原假设的 $H_0$</li>
<li>把不能轻易被否定的作为 $H_0$</li>
</ol>
<h5 id="双侧检验与单侧检验"><a href="#双侧检验与单侧检验" class="headerlink" title="双侧检验与单侧检验"></a>双侧检验与单侧检验</h5><p>如果 $H_1$ 的区域在 $H_0$ 区域的左侧，叫做 <strong>左侧检验</strong>，如果位于右侧叫做 <strong>右侧检验</strong></p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203001506424.png" class="" title="image-20231203001506424">

<blockquote>
<p>注意：其中 <strong>当 U 的值偏大的时候，对于原假设 $H_0$ 不利，所以拒绝域是大于一个数的集合。</strong></p>
</blockquote>
<h5 id="假设检验的两类错误"><a href="#假设检验的两类错误" class="headerlink" title="假设检验的两类错误"></a>假设检验的两类错误</h5><p><strong>弃真</strong> 和 <strong>存伪</strong> 两类错误。<br>弃真：$H_0$ 为真，但是落入了拒绝域</p>
<p>存伪：$H_1$ 为真，但是落入了非拒绝域</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203001945711.png" class="" title="image-20231203001945711">

<h4 id="正态总体参数的假设检验"><a href="#正态总体参数的假设检验" class="headerlink" title="正态总体参数的假设检验"></a>正态总体参数的假设检验</h4><p>还是特殊的，我们考虑正态分布的假设检验</p>
<p>包括一元的和二元的。就是利用前面提到的一元和二元的各自的三个分布的式子。</p>
<h4 id="分布拟合检验-Goodness-of-Fit-Test-补充"><a href="#分布拟合检验-Goodness-of-Fit-Test-补充" class="headerlink" title="分布拟合检验(Goodness of Fit Test, 补充)"></a>分布拟合检验(Goodness of Fit Test, 补充)</h4><p>判断总体是否为某种分布(如正态分布)的检验问题，通常称为 <strong>分布的拟合优度检验</strong>，简称为 <strong>分布拟合检验</strong>。</p>
<h5 id="为什么是卡方分布"><a href="#为什么是卡方分布" class="headerlink" title="为什么是卡方分布"></a>为什么是卡方分布</h5><p>可以看参考 2 和 3。但是感觉证明过程还是超出课程很多的，了解一下就可以了。</p>
<h5 id="离散型拟合优度检验"><a href="#离散型拟合优度检验" class="headerlink" title="离散型拟合优度检验"></a>离散型拟合优度检验</h5><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203115256149.png" class="" title="image-20231203115256149">

<p><strong>关于为何是使用卡方分布的推导</strong> 见 参考 2</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203115723170.png" class="" title="image-20231203115723170">

<h5 id="连续型拟合优度检验"><a href="#连续型拟合优度检验" class="headerlink" title="连续型拟合优度检验"></a>连续型拟合优度检验</h5><p>可以将 X 的取值范围分割为若干个区间，并且在每一个区间上面计算出相应的理论概率 $p_i$，通过这样处理，将问题转化为离散型问题。</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231203120555768.png" class="" title="image-20231203120555768">

<h5 id="列联表的独立性检验"><a href="#列联表的独立性检验" class="headerlink" title="列联表的独立性检验"></a>列联表的独立性检验</h5><p>列联表分析的基本问题是：<strong>考察各属性之间有无关联，即判别两属性是否独立。</strong></p>
<h4 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="https://zhuanlan.zhihu.com/p/602423325">https://zhuanlan.zhihu.com/p/602423325</a> 认识估计准则</li>
<li><a href="https://zhuanlan.zhihu.com/p/567894150">https://zhuanlan.zhihu.com/p/567894150</a> 分布拟合检验使用卡方分布的推导</li>
<li><a href="https://zhuanlan.zhihu.com/p/198864907">https://zhuanlan.zhihu.com/p/198864907</a> 对于拟合优度检验使用卡方分布的另一个理解</li>
</ol>
<h3 id="第七章-一元线性回归分析和方差分析"><a href="#第七章-一元线性回归分析和方差分析" class="headerlink" title="第七章 一元线性回归分析和方差分析"></a>第七章 一元线性回归分析和方差分析</h3><h4 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h4><p>回归分析主要是处理变量之间的关系。变量之间的关系主要有两类：</p>
<ol>
<li><p>确定性关系（函数关系）y &#x3D; f(x)</p>
</li>
<li><p>统计相关关系<br>变量的相关关系不能用函数关系来表示，但是 <strong>在平均意义下</strong> 有一定的定量关系式。</p>
</li>
</ol>
<h5 id="一元线性回归模型"><a href="#一元线性回归模型" class="headerlink" title="一元线性回归模型"></a>一元线性回归模型</h5><h6 id="对于一元线性回归模型的一些理解"><a href="#对于一元线性回归模型的一些理解" class="headerlink" title="对于一元线性回归模型的一些理解"></a>对于一元线性回归模型的一些理解</h6><ol>
<li>每一个 $y_i$ 都是一个变量</li>
<li>x 的取值是固定的，当作常数</li>
<li>我们估计出来的 $\beta_1$ 和 $\beta_0$ 都是关于当前得到的 n 个数据点的，其中 x 是被当作常数，y 被当作随机变量处理</li>
</ol>
<h6 id="正规方程组"><a href="#正规方程组" class="headerlink" title="正规方程组"></a>正规方程组</h6><p>一般采用最小二乘方法估计模型中的参数 $\beta_0、\beta_1$，令：<br>$$<br>Q(\beta_0,\beta_1) &#x3D; \sum\limits_{i&#x3D;  1}^{n}(y_i - \beta_0 - \beta_1 x_i)^{2}<br>$$<br>则有：<br>$$<br>\begin{cases}\frac{\partial Q}{\partial\hat{\beta}<em>0}&#x3D;-2\sum</em>{i&#x3D;1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)&#x3D;0\\left{\frac{\partial Q}{\partial\hat{\beta}<em>1}&#x3D;-2\sum</em>{i&#x3D;1}^n(y_i-\hat{\beta}_0-\hat{\beta}_1x_i)x_i\right.&#x3D;0&amp;\end{cases}<br>$$<br>其中，这个方程组被称为「正规方程组」</p>
<p>整理得到：<br>$$<br>\begin{aligned}<br>&amp;l_{xy}&#x3D; \sum_{i&#x3D;1}^n(x_i-\overline{x})(y_i-\overline{y})&#x3D;\sum_{i&#x3D;1}^nx_iy_i-n\overline{x}\overline{y}  \<br>&amp;l_{xx}&#x3D; \sum_{i&#x3D;1}^n(x_i-\overline{x})^2&#x3D;\sum_{i&#x3D;1}^nx_i^2-n\overline{x}^2  \<br>&amp;\boldsymbol{l}<em>{yy}&#x3D; \sum</em>{i&#x3D;1}^n(y_i-\overline{y})^2&#x3D;\sum_{i&#x3D;1}^ny_i^2-n\overline{y}^2<br>\end{aligned}<br>$$<br>所以，求解正规方程组得到：<br>$$<br>\begin{cases}\boldsymbol{\hat{\beta}}<em>1&#x3D;\boldsymbol{l}</em>{xy}&#x2F;\boldsymbol{l}_{xx}\\boldsymbol{\hat{\beta}}_0&#x3D;\overline{\boldsymbol{y}}-\boldsymbol{\hat{\beta}}_1\overline{\boldsymbol{x}}\end{cases}<br>$$</p>
<h6 id="常用性质"><a href="#常用性质" class="headerlink" title="常用性质"></a>常用性质</h6><p>感觉还是很重要的</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231212160820339.png" class="" title="image-20231212160820339">

<p>证明见课件。</p>
<p><strong>注意，最后一个式子是我们后面求解 $y_0$ 置信区间的基础</strong></p>
<p>其中，一个改写还是比较常用的：<br>$$<br>\hat{\beta}<em>1&#x3D;\sum\frac{x_i-\overline{x}}{l</em>{.xx}}y_i,\quad\hat{\beta}<em>0&#x3D;\sum\left[\frac1n-\frac{(x_i-\overline{x})\overline{x}}{l</em>{.xx}}\right]y_i<br>$$</p>
<h6 id="显著性检验"><a href="#显著性检验" class="headerlink" title="显著性检验"></a>显著性检验</h6><p>如果 $\beta_1$ 不等于 0，那么当 x 变化的时候，$E(y)$ 随 x 的变化作线性变化，此时得到的回归方程就有意义，称回归方程是 <strong>显著的</strong>。</p>
<p>综上，对于回归方程是否有意义作判断就是进行如下的显著性检验：<br>$$<br>H_0:\beta_1{&#x3D;}0\Leftrightarrow H_1:\beta_1\neq0<br>$$<br><strong>此时，拒绝表示回归方程是显著的。</strong></p>
<p>运用方差分析的思想，研究各 $y_i$ 不同的原因，也就是此时，我们把 x 看作了方差分析中的 <strong>控制的变量</strong>，然后 n 个不同的 x 表示 x 的 n 个 <strong>程度</strong>（其实就是一个因素方面的 n 个不同的取值）。</p>
<p>数据总的波动大小使用总偏差平方和表示：<br>$$<br>S_T &#x3D; \sum\limits_{i &#x3D; 1}^{n}(y_i - \overline{y})^{2} &#x3D; l_{yy}<br>$$<br>引起各 $y_i$ 不同的因素主要有两个方面：其一是 $H_0$ 可能不真，<strong>我们使用波动回归平方和表示</strong> $S_R&#x3D; \sum\limits_{i &#x3D; 1}^{n} (\hat{y_i} - \overline{y})^{2}$，另一个是随机因素，<strong>我们使用残差平方和表示</strong> $S_e &#x3D; \sum\limits_{i &#x3D; 1}^{n} (y_i - \hat{y_i})^{2}$</p>
<p>可以得到，$S_T &#x3D; S_R + S_e$</p>
<p><strong>下面是对于 SR 和 SE 的性质，还是看课件吧。</strong></p>
<p><strong>然后是应用。</strong></p>
<p>对于 $E(y_0)$ 和 $y_0$ 的置信区间估计，其中 $y_0$ 并不是我们初始数据中的 n 个点对应的 x，而是我们使用我们构建的模型来预测的数值。</p>
<h5 id="多元线性回归模型（补充）"><a href="#多元线性回归模型（补充）" class="headerlink" title="多元线性回归模型（补充）"></a>多元线性回归模型（补充）</h5><p>现实世界中一个因变量往往受到多个因素的影响，也就是存在多个自变量。</p>
<p>还是看课件吧。感觉东西好多…</p>
<h4 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h4><p>在科学实验和生产实践中，我们经常要考虑<strong>不同的实验条件是否对实验结果有显著的影响</strong>。</p>
<p>在<strong>可控因素</strong>之中，有些因素对于生产和实验的影响比较大，有一些比较小。我们<strong>希望找出影响显著的那些因素</strong>，以便找到最优的生产或者实验条件。</p>
<p>所以，我们<strong>采用方差分析的方法来推断某一个因素是否具有显著影响</strong>。</p>
<p>之所以是叫做「方差分析」，是因为我们是在 <strong>方差恒定的假设下</strong> 进行的假设检验。</p>
<p>检验具有相同方差的多个正态总体的均值是否相同的一种方法。</p>
<p>感觉顺着课本的思路看就很好。</p>
<h5 id="单因素方差分析"><a href="#单因素方差分析" class="headerlink" title="单因素方差分析"></a>单因素方差分析</h5><p>$$<br>\begin{aligned}<br>E\left(\dfrac{S_e}{n - r}\right) &amp;&#x3D; \sigma^{2} \<br>E\left(\dfrac{S_A}{r - 1}\right) &amp;&#x3D; \sigma^{2} + \dfrac{1}{r - 1}\sum\limits_{i &#x3D; 1}^{r} n_i \alpha_{i}^{2}<br>\end{aligned}<br>$$</p>
<p>所以，当 $H_0$ 成立的时候，$S_e &#x2F; (n - r)$ 和 $S_A &#x2F; (r - 1)$ 都是 $\sigma^{2}$ 的无偏估计，从而 $\dfrac{S_A &#x2F; (r - 1)}{S_e &#x2F; (n - r)}$ 应该接近 1。不成立的时候，应该比值比 1 明显的偏大。</p>
<p>$$<br>\begin{aligned}<br>F &#x3D; \dfrac{S_A &#x2F; (r - 1)}{S_e &#x2F; (n - r)} \sim F(r - 1, n - r)<br>\end{aligned}<br>$$</p>
<h5 id="双因素方差分析-补充"><a href="#双因素方差分析-补充" class="headerlink" title="双因素方差分析(补充)"></a>双因素方差分析(补充)</h5><p>分为有相互作用的双因素方差分析和无相互交互作用的方差分析。</p>
<h4 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h4><h3 id="题目记录"><a href="#题目记录" class="headerlink" title="题目记录"></a>题目记录</h3><p>记录一些吉米多维奇或者课后习题中遇到的典型题目。</p>
<h4 id="第一章-随机事件及其概率-1"><a href="#第一章-随机事件及其概率-1" class="headerlink" title="第一章 随机事件及其概率"></a>第一章 随机事件及其概率</h4><h5 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h5><p>A + B 表示 <strong>事件 A 和事件 B 中至少有一个发生</strong>，所以 $P(A+B) &#x3D; P(A\cup B) &#x3D; P(A) + P(B) - P(AB)$，当 $A$ 和 $B$ 互斥的时候，就有 $P(A + B) &#x3D; P(A) + P(B)$</p>
<p>A - B 表示 <strong>事件 A 发生但是事件 B 不发生</strong>，所以 $P(A - B) &#x3D; P(A) - P(AB) &#x3D; P(A \overline{B})$，当 $B \subset A$ 的时候，有 $P(A - B) &#x3D; P(A) - P(B)$</p>
<p>所以，如果是单纯对于事件的计算，则有 $A + B &#x3D; A\cup B, A - B &#x3D; A \cap \overline{B} &#x3D; A\overline{B}$</p>
<p>一定要 <strong>注意事件之间的加减和概率运算之间的转换。</strong></p>
<ol>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214141445850.png" class="" title="image-20231214141445850">
</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214141628536.png" class="" title="image-20231214141628536">
<p>感觉这个题目使用古典概型还是很好想的。<br>一定要有 <strong>古典概型使用事件个数计算的思想。</strong></p>
</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214142439833.png" class="" title="image-20231214142439833">
</li>
<li><p>运用摩根律可以得到：<br>$$<br>P(\overline{A}\overline{B}\overline{C})&#x3D;1-P(A\cup B\cup C)<br>$$<br>其实也可以直观理解。</p>
</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214152012990.png" class="" title="image-20231214152012990">
<p>注意<strong>对于状态的建模</strong>，要大胆去设事件。</p>
</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214152128190.png" class="" title="image-20231214152128190">
<p>最后转换为求事件的并，可以使用容器原理计算。</p>
</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231214152237454.png" class="" title="image-20231214152237454"></li>
</ol>
<h4 id="第二章-随机变量及其分布-1"><a href="#第二章-随机变量及其分布-1" class="headerlink" title="第二章 随机变量及其分布"></a>第二章 随机变量及其分布</h4><p>对于离散随机变量分布，如果已知 X 的分布函数 $F(x)$，则 X 的分布律为：<br>$$<br>P(X &#x3D; x_k) &#x3D; F(x_k) - F(x_k - 0)<br>$$<br><strong>注意这个定义形式。</strong></p>
<p><strong>泊松定理：</strong><br>在独立试验中，以$p_n$ 代表事件$A$在试验中出现的概率，它与试验总数$n$ 有关，如果$np_n\to\lambda$,则当$n\to\infty$时，有：</p>
<p>$$<br>b\left(k;n,p\right)\rightarrow\frac{\lambda^{k}}{k!}e^{-\lambda}<br>$$<br>泊松定理表示二项分布可以近似为泊松分布，同时，如果样本容量很大，远大于我们选取的目标的个数，那么超几何分布也可以近似为二项分布。</p>
<p>同时，正态分布又可以作为二项分布和泊松分布的近似。</p>
<h4 id="第三章-多维随机变量及其分布-1"><a href="#第三章-多维随机变量及其分布-1" class="headerlink" title="第三章 多维随机变量及其分布"></a>第三章 多维随机变量及其分布</h4><p>这一部分还是多看看题目吧，一定要注意<strong>取值范围</strong>的问题。</p>
<ol>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217214750041.png" class="" title="image-20231217214750041"></li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217215516951.png" class="" title="image-20231217215516951">
注意第二种方式是有绝对值的。</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217215634641.png" class="" title="image-20231217215634641">
注意二项分布取得最大概率时的情况，是有公式的。</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217220152512.png" class="" title="image-20231217220152512">
感觉上可能算一个比较经典的结论？</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217222404158.png" class="" title="image-20231217222404158">
注意 $P(X_1X_2 &#x3D; 0) &#x3D; 1$ 同时也表示 $P(X_1X_2 \neq 0) &#x3D; 0$</li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217224744627.png" class="" title="image-20231217224744627"></li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217224815559.png" class="" title="image-20231217224815559">
注意，求解未知量的时候，不仅仅只有概率总和为 1 这一个等式可以利用，还有别的等式。</li>
</ol>
<h4 id="第四章-随机变量的数字特征"><a href="#第四章-随机变量的数字特征" class="headerlink" title="第四章 随机变量的数字特征"></a>第四章 随机变量的数字特征</h4><p>一定要注意，期望的定义是级数或者积分<strong>绝对收敛</strong>的时候才存在。</p>
<p>如果 X 和 Y 相互独立，那么 $E(XY) &#x3D; E(X) \cdot E(Y)$</p>
<p>$[E(XY)]^{2} \leq E(X^{2}) \cdot E(Y^2)$</p>
<ol>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217225313015.png" class="" title="image-20231217225313015"></li>
<li><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231217225331315.png" class="" title="image-20231217225331315"></li>
<li></li>
</ol>
<h4 id="第五章-大数定律与中心极限定理"><a href="#第五章-大数定律与中心极限定理" class="headerlink" title="第五章 大数定律与中心极限定理"></a>第五章 大数定律与中心极限定理</h4><p>注意大数定律是带有绝对值的，但是中心极限定理没有绝对值。</p>
<h4 id="第六章-数理统计基本概念"><a href="#第六章-数理统计基本概念" class="headerlink" title="第六章 数理统计基本概念"></a>第六章 数理统计基本概念</h4><p>注意 $\chi^{2}$ 分布、t 分布、F 分布各自的定义和图像。</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231220220652680.png" class="" title="image-20231220220652680">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231220220701615.png" class="" title="image-20231220220701615">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231220220710119.png" class="" title="image-20231220220710119">

<h4 id="第七章-参数估计"><a href="#第七章-参数估计" class="headerlink" title="第七章 参数估计"></a>第七章 参数估计</h4><p><strong>估计量的相合性（一致性）问题</strong>：</p>
<p>这种问题一般有两种方法</p>
<ol>
<li><p>利用定义证明，往往需要结合大数定律</p>
<p>设 $\hat{\theta}$ 为未知参数 $\theta$ 的估计量，若对任意给定的 $\varepsilon&gt;0$ , 都有</p>
<p>$$<br>\lim_{n\to\infty}P{\mid\hat{\theta}-\theta|&lt;\varepsilon}&#x3D;1:<br>$$</p>
<p>即 $\hat{\theta}$ 依概率收敛于参数 $\theta$ , 则 $\hat{\theta}$ 称为 $\theta$ 的一致估计或相合估计</p>
</li>
<li><p>利用定理证明，结论如下：<br>设 $\hat{\theta}<em>n$ 是 $\theta$ 的一个估计量，若：<br>$$<br>\lim</em>{n\to\infty}E(\stackrel{\wedge}{\theta}<em>n)&#x3D;\theta,\quad\lim</em>{n\to\infty}D(\stackrel{\wedge}{\theta}_n)&#x3D;0<br>$$<br>则 $\hat{\theta}_n$ 是 $\theta$ 的相合估计。<br>关于此定理的证明：</p>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222210558571.png" class="" title="image-20231222210558571">
<p>相合性是对估计量的一个基本要求，不具备相合性的估计量是不予考虑的。</p>
</li>
<li></li>
</ol>
<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222211440745.png" class="" title="image-20231222211440745">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222211454169.png" class="" title="image-20231222211454169">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231222211506697.png" class="" title="image-20231222211506697">



<p>4. </p>
<h4 id="第八章-假设检验"><a href="#第八章-假设检验" class="headerlink" title="第八章 假设检验"></a>第八章 假设检验</h4><img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231221224838696.png" class="" title="image-20231221224838696">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231221230138831.png" class="" title="image-20231221230138831">

<img src="/2023/12/02/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231221230144922.png" class="" title="image-20231221230144922">
]]></content>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>登录实现</title>
    <url>/2023/09/07/%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>一个讲解 <a href="https://www.jianshu.com/p/53e687c198b5">https://www.jianshu.com/p/53e687c198b5</a></p>
]]></content>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记3</title>
    <url>/2024/02/11/%E6%9D%82%E8%AE%B03/</url>
    <content><![CDATA[<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>操作系统提供了一个抽象的接口，使得应用程序可以通过标准的系统调用来请求操作系统代表其与硬件进行交互。</p>
<h4 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h4><p>GPIO（General Purpose Input&#x2F;Output）在计算机领域，特别是嵌入式系统和单板计算机（比如树莓派）中，GPIO指的是一组可以通过编程控制的引脚，用于与外部电路进行通信。这些引脚可以配置为输入或输出，并且可以通过编程来读取或写入数字信号。在树莓派等单板计算机中，GPIO通常用于连接和控制各种外部设备，如传感器、LED灯、电机等。GPIO的灵活性和可编程性使其成为嵌入式系统中常见的重要功能之一。</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p>一个命令行解释器，相当于是包在内核外面的一个外壳，是底层操作系统核心和外部应用的一个接口，可以进行一些翻译和解释。</p>
<h4 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h4><p>less 命令用于查看文本文件的内容，类似于更老的命令行工具 more，但是提供了更多的功能和选项。</p>
<p>使用 less 命令可以逐页或者按需浏览文本文件，支持向前和向后翻页，搜索文本内容，跳转到指定行等操作。在终端下查看</p>
<h4 id="env-命令"><a href="#env-命令" class="headerlink" title="env 命令"></a>env 命令</h4><p>使用 env 命令可以列出当前 Shell 进程的环境变量。</p>
<h4 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h4><p>静态语言是一种编程的范畴，与动态语言相对应。静态语言中，变量的类型在编译时期就已经确定，并且一旦确定，类型通常不可以发生改变。常见的静态语言有 C++、C、Java、C#、GO 等。静态语言相比动态的可以提供更多的错误检查和优化，但是有时候也需要更多的时间和精力。</p>
<p>常见的动态语言有：Python、JavaScript、Ruby、PHP、R</p>
<h4 id="AIGC"><a href="#AIGC" class="headerlink" title="AIGC"></a>AIGC</h4><p>AIGC 是 AI generated content 的缩写，比如说 AI 生成的文本、代码、图片、音频和视频。国外更火的一个词是 Generative AI（生成式 AI），生成式 AI 生成的内容就是 AIGC。但是 AIGC 这个词在国内比生成式 AI 更加流行，所以很多时候 AIGC 也被指做生成式 AI。</p>
<h4 id="strip-函数"><a href="#strip-函数" class="headerlink" title="strip 函数"></a>strip 函数</h4><p>strip() 函数是 python 字符串对象的方法之一，用于去除字符串开头和结尾的空白字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text = &quot;    hello world    &quot;</span><br><span class="line">stripped_text = text.strip()</span><br><span class="line">print(stripped_text) # 输出 &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外，strip 函数还可以去除多种其余字符，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text = &quot;,,.! hello world!.,,&quot;</span><br><span class="line">stripped_text = text.strip(&quot;,.!&quot;)</span><br><span class="line">print(stripped_text)</span><br></pre></td></tr></table></figure>

<h4 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h4><p>Numpy(Numerical Python) 是 Python 中用于科学计算的核心库之一。提供了高性能的多维数组对象。</p>
<p>Pandas 是建立在 NumPy 上的数据分析工具，提供了数据清洗、准备、分析等任务更简单的数据结构和函数。Pandas 中最重要的两个数据结构就是 Series 和 DataFrame。底层是 ndarray</p>
<p>NumPy 中的 array 和 Pandas 中的 Series 都表示的是列向量。</p>
<h4 id="MinGW"><a href="#MinGW" class="headerlink" title="MinGW"></a>MinGW</h4><p>MinGW 的全称是 Minimalist GNU for Windows，它的目标是提供一个轻量级的开发环境，使得开发者能够在Windows上编写和编译C和C++代码，同时尽量减少对于外部依赖的需求。</p>
<p>MinGW 是一个在Windows平台上开发C和C++程序的工具集合，它提供了一组GNU工具，包括编译器、链接器和其他必要的工具，使得开发者可以在Windows上使用类Unix环境下的工具进行编程。</p>
<h4 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h4><p>PyTorch 其中的 Py 表示的是 Python；Torch 最初指的是 Torch 库，是一个用 Lua 编写的科学计算框架和机器学习库，后来发展为一个 Python 的机器学习库。它提供了建立和训练神经网络的工具以及处理自动微分等任务的工具。</p>
<h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>广播机制是 NumPy 中的一个重要特性。允许在不同形状的数组之间进行算数运算时自动进行适当的形状变换。</p>
<p>下面分别是两种常见的广播示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">array1 = np.array([[1, 2, 3],</span><br><span class="line">                    [4, 5, 6]])</span><br><span class="line"></span><br><span class="line">array2 = np.array([[10],</span><br><span class="line">                    [20]])</span><br><span class="line"></span><br><span class="line">array3 = np.array([10, 20, 30])</span><br><span class="line"></span><br><span class="line">result1 = array1 + array2</span><br><span class="line"></span><br><span class="line">result2 = array1 + array3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h4><p>GDB(GNU Debugger) 是一个开源调试器，用于调试 C、C++ 等编程语言写的程序。有许多功能，包括：</p>
<ol>
<li>设置断点</li>
<li>单步执行</li>
<li>查看变量</li>
<li>堆栈跟踪</li>
<li>内存检查</li>
<li>多线程调试</li>
</ol>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode 将所有的语言都统一到一套编码中，这样就不会出现乱码问题了。现代操作系统和大多数编程语言都直接支持 unicode</p>
<p>Unicode 是字符集，定义了字符与代码点之间关系。而 UTF-8 是 Unicode 的一种具体实现形式，一种具体编码方案。</p>
<h4 id="open-方法"><a href="#open-方法" class="headerlink" title="open 方法"></a>open 方法</h4><p>python 中的 open 方法默认的是使用 gbk 编码方式，所以如果我们想输入中文的相关内容，应修改参数 <code>encoding=&#39;UTF-8&#39;</code></p>
<h4 id="POST-和-GET-方法"><a href="#POST-和-GET-方法" class="headerlink" title="POST 和 GET 方法"></a>POST 和 GET 方法</h4><p>GET 方法中参数是以字符串的形式附加在 URL 后面的，对于长度有限制，适用于传递少量数据</p>
<p>POST 方法中的参数包含在消息体中，不会显示在 URL 中，因此相对安全，适合传递大量数据或者敏感数据。参数长度理论上没有限制</p>
<h4 id="Python-中的-urllib-request-和-requests"><a href="#Python-中的-urllib-request-和-requests" class="headerlink" title="Python 中的 urllib.request 和 requests"></a>Python 中的 urllib.request 和 requests</h4><p>urllib.request 和 requests 两个库都是用于发起 HTTP 请求的库。但是它们呢有一些区别：</p>
<ol>
<li>简洁性和易用性。<br> requests 库通常被认为更加简洁易用，它提供了更友好的 API。虽然 urllib.request 库也可以完成同样的任务，但是通常需要更多的代码来实现，因此相对而言更加复杂</li>
<li>功能性。<br> requests 库在设计上更加面向现代 Web 开发，提供了更多便利的功能<br> urllib.request 库则更加接近 Python 标准库，提供了基本的 HTTP 请求功能，但是一些高级功能上不如 requests 库强大。</li>
<li>依赖性。<br> urllib.request 是标准库的一部分，不需要额外安装<br> requests 则需要额外安装</li>
</ol>
<h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>python 中不可以使用关键字来命名文件名，比如说一些库的名字或者其中的方法名就不可以用来当作文件名。</p>
<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><p>如果我们直接输出 HTTP 传输的内容，最开始的字母是 b，表示这个数据是二进制的形式。</p>
<h4 id="Unicode-和-UTF-8"><a href="#Unicode-和-UTF-8" class="headerlink" title="Unicode 和 UTF-8"></a>Unicode 和 UTF-8</h4><p>Unicode 是一种字符集，它为世界上几乎所有的字符分配了唯一的数字代码，包括字母、数字、标点符号和各种符号。</p>
<p>而 UTF-8 是一种针对 Unicode 字符集的可变长度字符编码的方案。之所以它被广泛使用，是因为它对于 ASCII 字符是向后兼容的（即 ASCII 字符的编码和 UTF-8 编码是相同的）</p>
<p>所以，总结来看，他们之间的关系就是，Unicode 定义了字符集，为每一个字符分配了唯一的码点，UTF-8 是 Unicode 的一种实现方式。</p>
<h4 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h4><p>由于整个Python语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写Python解释器来执行Python代码（当然难度很大）。事实上，确实存在多种Python解释器。</p>
<h5 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h5><p>我们从 Python 官方网站下载并安装的 Python3.x 后，就是获得了一个官方版本的解释器：CPython，这个解释器是使用 C 语言开发的。当我们在命令行下运行 python 就是启动 CPython 解释器。</p>
<p>CPython 是使用最广的 Python 解释器。</p>
<h5 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h5><p>IPython 是基于 CPython 之上的一个交互式解释器，也就是说 IPython 在交互上有所增强，但是执行代码的功能与 CPython 是一样的。</p>
<h5 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h5><p>它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译（注意不是解释），所以可以显著提高Python代码的执行速度。但是和 CPython 有一些区别，所以结果可能不同，所以需要注意。</p>
<h5 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h5><p>Jython是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。</p>
<h4 id="Python-发行版"><a href="#Python-发行版" class="headerlink" title="Python 发行版"></a>Python 发行版</h4><p>Python 发行版是建立在 Python 解释器之上的软件包集合，它们包含了 Python 解释器、标准库以及其他工具和库。</p>
<p>Python 发行版可以定制为满足需求的软件包集合，比如用于科学计算和数据分析、Web 开发等。比如说，Anaconda 是一个 Python 的发行版，它包含了许多常用的科学计算和数据分析库，如 NumPy、Scipy、Pandas 等。Anaconda 还提供了一个名为 conda 的包管理器，用于管理 Python 包和环境。</p>
<p>对于不同的发行版，往往带有不同版本的 Python 解释器。</p>
<h4 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h4><p>jQuery 是 JavaScript 世界中一个使用最广泛的库，它简化了编程中许多常见的任务，特别是涉及 DOM 操作和事件处理的任务。下面是它的一些特点：</p>
<ol>
<li><p>简化 DOM 操作：jQuery 提供了简洁而强大的 API，使得选择 DOM 元素、修改 DOM 属性和内容、处理样式等操作变得非常简单和直观。</p>
</li>
<li><p>事件处理：jQuery 提供了方便的事件处理方法，可以轻松地添加、移除和触发事件，如点击事件、鼠标事件、键盘事件等。</p>
</li>
<li><p>AJAX 请求：jQuery 提供了简化的 AJAX 方法，使得在 JavaScript 中进行异步请求变得更加简单，可以轻松地与服务器进行数据交换。</p>
</li>
<li><p>动画效果：jQuery 提供了丰富的动画效果和方法，可以实现淡入淡出、滑动、展开收起等动画效果，使得网页的交互性更加丰富。</p>
</li>
<li><p>跨浏览器兼容性：jQuery 封装了许多常见的跨浏览器兼容性问题，使得你可以在各种不同的浏览器中编写一致的 JavaScript 代码，而无需担心兼容性问题。</p>
</li>
<li><p>插件生态系统：jQuery 拥有一个庞大的插件生态系统，其中包含了许多由社区开发的插件和扩展，可以扩展 jQuery 的功能，满足各种不同的需求。</p>
</li>
</ol>
<h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><p> AJAX（Asynchronous JavaScript and XML）是一种用于在不重新加载整个网页的情况下，通过 JavaScript 向服务器发送请求并获取数据的技术。使用 AJAX，你可以异步地向服务器请求数据，然后在网页上动态地更新内容，而无需刷新整个页面。</p>
<p>关于 JavaScript 的 HTTP 请求的一个发展历史：</p>
<ol>
<li>初期阶段：使用原生的 JavaScript 进行 AJAX 请求。<br> 在早期的 Web 开发中，开发人员通常会使用原生的 JavaScript 以及 XMLHttpRequest 对象来实现 AJAX 请求。这种方式需要编写相对繁琐的代码来处理不同浏览器的兼容性等问题，使得开发和维护变得较为复杂。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;https://api.example.com/data&#x27;, true);</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">        if (xhr.status === 200) &#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.error(&#x27;Error:&#x27;, xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></li>
<li>jQuery 出现<br> jQuery 简化了 JavaScript 在网页上的操作，包括（ajax 的请求操作，注意，jQuery 不仅仅简化了 ajax，还提供了很多关于 DOM 的接口，是一个更大的概念），例如 $.ajax <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url: &#x27;https://api.example.com/data&#x27;,</span><br><span class="line">method: &#x27;GET&#x27;,</span><br><span class="line">success: function(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;,</span><br><span class="line">error: function(xhr, status, error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, status, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>Axios 出现<br> Axios 是基于 Promise 的现代 JavaScriptHTTP 客户端，相比于 jQuery，它更加简洁、灵活。逐渐取代了 jQuery 在处理 AJAX 请求方面的地位。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.get(&#x27;https://api.example.com/data&#x27;)</span><br><span class="line">.then(function(response) &#123;</span><br><span class="line">    console.log(response.data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(error) &#123;</span><br><span class="line">    console.error(&#x27;Error:&#x27;, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>尽管 jQuery 在过去在处理 AJAX 请求方面扮演了重要角色，但随着技术的发展和新的库的出现，如今 Axios 已经成为了更受欢迎的选择，而 jQuery 则逐渐减弱了在处理 AJAX 请求方面的重要性。</p>
<h4 id="jQuery-返回"><a href="#jQuery-返回" class="headerlink" title="jQuery 返回"></a>jQuery 返回</h4><p>注意，jQuery 在查找 DOM 元素的时候，返回的是一个数组</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>浏览器的同源策略（Same-Origin policy）是一种安全机制，用于限制一个源（origin）的文档或脚本如何能够与另一个源的资源进行交互。在 Web 安全方面，同源策略起到了重要的作用，可以帮助防止恶意网站并保护用户的隐私信息。</p>
<p>同源策略规定了以下内容被视为同源：</p>
<ol>
<li>协议（protocol）。两个 URL 的协议必须相同，比如 http 和 https 就是不同源的</li>
<li>域名（Domain）。</li>
<li>端口号（Port）。如果 URL 中没有指定 URL，则默认为 80（HTTP）和 443（HTTPS）</li>
</ol>
<p>同源策略的存在可以防止恶意网站利用脚本收集用户的敏感信息，比如从其他网站加载并解析用户的 cookie。但同时也会带来一些限制，比如在跨域请求数据时需要使用 CORS（Cross-Origin Resource Sharing）等机制来进行权限控制。</p>
<h4 id="JavaScript-中的-setTimeout-函数"><a href="#JavaScript-中的-setTimeout-函数" class="headerlink" title="JavaScript 中的 setTimeout() 函数"></a>JavaScript 中的 setTimeout() 函数</h4><p>当调用 setTimeout 函数设置延迟的时候，JavaScript 引擎会在延迟时间到达后将指定的代码添加到事件队列中，在延迟的这段时间内，JavaScript 引擎会继续执行后续的代码，不会阻塞或者等待定时器完成任务。</p>
<p>可以使用下面的代码测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function time() &#123;</span><br><span class="line">    let cur_time = new Date()</span><br><span class="line">    console.log(&#x27;call back &#x27; + cur_time.toLocaleTimeString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(time, 2000)</span><br><span class="line"></span><br><span class="line">let cur = new Date()</span><br><span class="line"></span><br><span class="line">console.log(&#x27;main &#x27; + cur.toLocaleTimeString())</span><br></pre></td></tr></table></figure>

<h4 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h4><p>脚本语言的代码通常是文本形式，并由解释器逐行解释执行。与传统的编译型语言相比，脚本语言不需要事先将代码编译成可执行的机器码或者字节码，而是在运行的时候直接由解释器解释和执行。</p>
<p>脚本语言通常具有动态类型的特性。允许变量在运行时根据需要改变类型。并且脚本语言通常具有高级特性，如垃圾回收、自动内存管理，使得开发者更专注于解决问题，而不需要关注底层的细节。</p>
<h4 id="JS-引擎-解释器"><a href="#JS-引擎-解释器" class="headerlink" title="JS 引擎&#x2F;解释器"></a>JS 引擎&#x2F;解释器</h4><p>JS 引擎就是指的是 JS 解释器。</p>
<p>可以了解一下 JS 引擎的发展历史。V8 引擎是 Google 公司开发的高性能 JavaScript 引擎，用于 Google Chrome 浏览器。</p>
<p>后来，Nodejs 基于 V8 引擎构建的 JavaScript 运行时的环境（不仅仅提供了 JS 的解释器，还提供了一些 JS 的库），用于在服务器端运行 JavaScript 代码。除了 Nodejs 自带的一些模块，Nodejs 社区也提供了大量的第三方包。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node 交互式命令窗口，在写代码的过程中，把部分代码粘贴到命令行去验证。</p>
<h4 id="node-模块"><a href="#node-模块" class="headerlink" title="node 模块"></a>node 模块</h4><p>在 Node 环境中，一个 js 代码就是一个模块。把很多代码分为一个一个的模块，这大大提高了代码的可维护性，其次，编写代码不必从零开始，我们可以重复引用代码。还可以避免函数名和变量名的冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub = (a, b) =&gt; &#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var PI = 3.1415</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    add, sub, PI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是我们的 hello.js，当我们想调用这一个模块的时候，就可以在文件中书写 <code>const hello = require(hello)</code> 或者 <code>var hello = require(hello)</code>，可以直接使用 hello.add 来调用函数了。</p>
<h5 id="内置的基本模块"><a href="#内置的基本模块" class="headerlink" title="内置的基本模块"></a>内置的基本模块</h5><p>具体信息可以看廖雪峰的 blog</p>
<ol>
<li>fs 模块<br> node.js 内置的 fs 模块就是文件系统模块，负责文件的读写，同时提供了同步和异步的方法。</li>
<li>stream 模块<br> 是一个 nodejs 提供的仅在服务端可用的模块，目的是支持流这种数据结构</li>
<li>http 模块<br> Node.js开发的目的就是为了用JavaScript编写Web服务器程序。因为 JS 已经统治了浏览器端的脚本。</li>
<li>URL 模块<br> URL 模块可以把一个字符串解析为一个 URL 对象</li>
</ol>
<h4 id="JS-匿名函数"><a href="#JS-匿名函数" class="headerlink" title="JS 匿名函数"></a>JS 匿名函数</h4><p>两种书写方式，一种是使用 ES6（ECMAScript 2015）中引入的一种新的函数声明方式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myfunction = function() &#123;</span><br><span class="line">    console.log(&quot;xxxx&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myfunction = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;xxxx&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数有下面的特点：</p>
<ol>
<li>简洁性。箭头函数代码更加简洁，可以省略 function 关键字和大括号（如果是一行代码就行）</li>
<li>绑定 this，箭头函数的 this 在定义时确定，并且整个函数周期不变，不会重新绑定</li>
</ol>
<h4 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h4>]]></content>
  </entry>
  <entry>
    <title>概率论中各种分布</title>
    <url>/2023/10/24/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p>当时用 Latex 写的，直接粘贴过来的，排版太乱了，有时间再修吧。</p>
<h3 id="离散分布"><a href="#离散分布" class="headerlink" title="离散分布"></a>离散分布</h3><h4 id="Bernoulli-分布-Bernoulli-Distribution"><a href="#Bernoulli-分布-Bernoulli-Distribution" class="headerlink" title="Bernoulli 分布(Bernoulli Distribution)"></a>Bernoulli 分布(Bernoulli Distribution)</h4><h5 id="符号：-X-sim-B-1-p"><a href="#符号：-X-sim-B-1-p" class="headerlink" title="符号：$X \sim B(1, p)$"></a>符号：$X \sim B(1, p)$</h5><h5 id="概率：-P-X-k-p-k-1-p-1-k"><a href="#概率：-P-X-k-p-k-1-p-1-k" class="headerlink" title="概率：$P(X &#x3D; k) &#x3D; p^{k}(1-p)^{1-k}$"></a>概率：$P(X &#x3D; k) &#x3D; p^{k}(1-p)^{1-k}$</h5><h5 id="期望：-E-X-0-times-1-p-1-times-p-p"><a href="#期望：-E-X-0-times-1-p-1-times-p-p" class="headerlink" title="期望：$E(X) &#x3D; 0\times (1-p) + 1 \times p &#x3D; p$"></a>期望：$E(X) &#x3D; 0\times (1-p) + 1 \times p &#x3D; p$</h5><h5 id="方差：-D-X-E-X-2-E-X-2-p-p-2-p-1-p"><a href="#方差：-D-X-E-X-2-E-X-2-p-p-2-p-1-p" class="headerlink" title="方差：$D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; p - p^2 &#x3D; p(1-p)$"></a>方差：$D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; p - p^2 &#x3D; p(1-p)$</h5><h5 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h5><h5 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h5><h4 id="二项分布-Binomial-Distribution"><a href="#二项分布-Binomial-Distribution" class="headerlink" title="二项分布(Binomial Distribution)"></a>二项分布(Binomial Distribution)</h4><h5 id="符号：-X-sim-B-n-p"><a href="#符号：-X-sim-B-n-p" class="headerlink" title="符号：$X\sim B(n, p)$"></a>符号：$X\sim B(n, p)$</h5><h5 id="概率："><a href="#概率：" class="headerlink" title="概率："></a>概率：</h5><p>$$<br>\begin{aligned}<br>P(X &#x3D; k) &#x3D; \begin{pmatrix}<br>n \<br>k<br>\end{pmatrix} (1-p)^{n - k}p^k<br>\end{aligned}<br>$$</p>
<h5 id="期望："><a href="#期望：" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X)&#x3D; \sum\limits_{k &#x3D; 0}^{n}kp(X &#x3D; k) &#x3D;\sum\limits_{k &#x3D; 0}^{n} k\begin{pmatrix}<br>n \<br>k<br>\end{pmatrix} (1-p)^{n - k}p^k \<br>&#x3D; \sum\limits_{k &#x3D; 1}^{n}\begin{pmatrix} n - 1\ m - 1\end{pmatrix}p^{k}(1-p)^{n - k} \quad \quad \quad \<br>&#x3D; \sum\limits_{k &#x3D; 0}^{n - 1}np\begin{pmatrix}n - 1 \ k \end{pmatrix} p^{k}(1-p)^{n - 1 - k} \quad \<br>&#x3D; np\times (p + (1 - p))^{n - 1} \quad \quad \quad \quad \quad  \<br>&#x3D; np \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad<br>\end{aligned}<br>$$</p>
<h5 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D;E(X(X-1)+X) - E(X)^{2} \<br>&#x3D;E(X(X-1)) + E(X) - E(X)^{2} \quad \quad \quad \quad  \</p>
<p>E(X(X-1)) &#x3D; \sum\limits_{k &#x3D; 0}^{n}k(k - 1)\begin{pmatrix} n \ k\end{pmatrix} p^{k}(1-p)^{n - k} \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad  \ &#x3D; n(n - 1)\sum\limits_{k &#x3D; 2}^{n} \begin{pmatrix} n - 2\ k - 2\end{pmatrix} p^{k}(1 - p)^{n - l} \quad \quad \<br>&#x3D; n(n - 1)\sum\limits_{k &#x3D; 0}^{n - 2}\begin{pmatrix} n - 2 \ k \end{pmatrix} p^{k + 2}(1-p)^{n - 2 - k} \<br>&#x3D; n(n - 1) p^{2} (1 + (1 - p))^{n - 2} \ \ \ \  \quad \quad \quad \quad  \<br>&#x3D; n(n - 1)p^{2} \quad \quad \quad \quad \quad \quad \quad \quad \quad \ \ \ \quad \quad \</p>
<p>D(X) &#x3D; n(n -1)p^{2} + np - n^{2}p^{2}  &#x3D; np(1-p) \quad \quad \quad<br>\end{aligned}<br>$$</p>
<h5 id="性质：-1"><a href="#性质：-1" class="headerlink" title="性质："></a>性质：</h5><h5 id="应用：-1"><a href="#应用：-1" class="headerlink" title="应用："></a>应用：</h5><ol>
<li>一段时间内物理实验仪器捕获的粒子数目。</li>
<li>一段时间内计算机病毒的入侵数。</li>
<li>一本书中的错字数。</li>
</ol>
<h4 id="多项分布-Multinomial-Distribution"><a href="#多项分布-Multinomial-Distribution" class="headerlink" title="多项分布(Multinomial Distribution)"></a>多项分布(Multinomial Distribution)</h4><p>多项分布(Multinomial Distribution)，它是二项分布的推广。二项分布的试验结果只有两个(成功和失败)，而多项分布的试验结果则多于两个。</p>
<h5 id="联合概率函数："><a href="#联合概率函数：" class="headerlink" title="联合概率函数："></a>联合概率函数：</h5><p>$$<br>\begin{aligned}<br>P(X_1 &#x3D; x_1, X_2 &#x3D; x_2, …, X_k &#x3D; x_k) &#x3D; \dfrac{n!}{x_1!x_2!…x_k!} p_1^{x_1}p_2^{x_2}…p_{k}^{x_k}<br>\end{aligned}<br>$$</p>
<p>多项分布对于每一个结果都有均值和方差，分别为：</p>
<h5 id="期望：-1"><a href="#期望：-1" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X_i) &#x3D; np_i<br>\end{aligned}<br>$$</p>
<h5 id="方差：-1"><a href="#方差：-1" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X_i) &#x3D; np_i(1-p_i)<br>$$</p>
<h4 id="泊松分布-Possion-Distribution"><a href="#泊松分布-Possion-Distribution" class="headerlink" title="泊松分布(Possion Distribution)"></a>泊松分布(Possion Distribution)</h4><h5 id="符号：-X-sim-P-lambda"><a href="#符号：-X-sim-P-lambda" class="headerlink" title="符号：$X\sim P(\lambda)$"></a>符号：$X\sim P(\lambda)$</h5><h5 id="概率：-P-X-x-dfrac-e-lambda-lambda-x-x"><a href="#概率：-P-X-x-dfrac-e-lambda-lambda-x-x" class="headerlink" title="概率：$P(X &#x3D; x) &#x3D; \dfrac{e^{-\lambda}\lambda^{x} }{x!}$"></a>概率：$P(X &#x3D; x) &#x3D; \dfrac{e^{-\lambda}\lambda^{x} }{x!}$</h5><p>证明：<br>由 $\lambda$ 的定义，单位时间内随机事件发生 $\lambda$ 次，并且每一次事件发生都是独立的，和时间没有关系的。</p>
<p>所以如果我们将单位单位时间划分为 n 份，当 n 趋近于正无穷的时候，我们可以认为每一段时间内事件发生的次数是均匀的。所以每一段时间事件发生的概率都是 $\dfrac{\lambda}{n}$ </p>
<p>$$<br>\begin{aligned}<br>P(X &#x3D; x) &#x3D; \lim\limits_{n \to +\infty}\begin{pmatrix} n \ x\end{pmatrix} (\dfrac{\lambda}{n})^{x}(1 - \dfrac{\lambda}{n})^{n - x} &#x3D; \dfrac{\lambda^{k}}{k!}e^{-\lambda}<br>\end{aligned}<br>$$</p>
<h5 id="期望：-2"><a href="#期望：-2" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \sum\limits_{k&#x3D;0}^{+\infty} k \dfrac{\lambda^{k}}{k!}e^{-\lambda} \<br>&amp;&#x3D; \lambda e^{-\lambda} \sum\limits_{k &#x3D; 1}^{+\infty} \dfrac{\lambda^{k - 1}}{(k - 1)!} \<br>&amp;&#x3D; \lambda e^{-\lambda} e^{\lambda} \<br>&amp;&#x3D; \lambda<br>\end{aligned}<br>$$</p>
<h5 id="方差：-2"><a href="#方差：-2" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>E(X^{2}) &#x3D; E(X(X - 1) + X) &#x3D; E(X(X-1)) + E(X) \<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>E(X(X - 1)) &amp;&#x3D; \sum\limits_{k &#x3D; 1}^{+\infty} k(k - 1) \dfrac{\lambda^{k}}{k!}e^{-\lambda} \<br>&amp;&#x3D;\sum\limits_{k &#x3D; 2}^{+\infty}\dfrac{\lambda^{k}}{(k - 2)!}e^{-\lambda} \<br>&amp;&#x3D; \lambda^{2}e^{-\lambda}\sum\limits_{k &#x3D; 0}^{+\infty}\dfrac{\lambda^{k}}{k!}\<br>&amp;&#x3D; \lambda^{2}<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>D(X) &amp;&#x3D; E(X^{2}) - E(X)^{2} \<br>&amp;&#x3D; E(X(X - 1)) + E(X) - E(X)^{2} \<br>&amp;&#x3D; \lambda^{2} + \lambda - \lambda^{2}\<br>&amp;&#x3D; \lambda<br>\end{aligned}<br>$$</p>
<h5 id="性质：-2"><a href="#性质：-2" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>伯努利分布是二项分布的特殊情况，当 n &#x3D; 1 的时候，二项分布变为伯努利分布。泊松分布可以被看作是二项分布的极端情况，在试验次数非常多或者成功概率非常小的情况下，可以近似为泊松分布。指数分布也可以由泊松分布推导而来。</li>
<li>泊松分布中 $\lambda$ 表示单位时间内随机事件的平均发生次数。在一个特定时间内，某一个事件都会在任意时刻发生(前提是，每次发生都是独立的，并且跟事件没有关系)。</li>
</ol>
<h5 id="应用：-2"><a href="#应用：-2" class="headerlink" title="应用："></a>应用：</h5><p>泊松分布是用来描述在给定时间段内随机事件发生次数的分布。例如一天之间收到的电子邮件数量。</p>
<h4 id="几何分布-Geometric-Distribution"><a href="#几何分布-Geometric-Distribution" class="headerlink" title="几何分布(Geometric Distribution)"></a>几何分布(Geometric Distribution)</h4><h5 id="符号：-X-sim-G-p"><a href="#符号：-X-sim-G-p" class="headerlink" title="符号：$X\sim G(p)$"></a>符号：$X\sim G(p)$</h5><h5 id="概率：-P-X-k-1-p-k-1-p"><a href="#概率：-P-X-k-1-p-k-1-p" class="headerlink" title="概率：$P(X &#x3D; k) &#x3D; (1-p)^{k - 1}p$"></a>概率：$P(X &#x3D; k) &#x3D; (1-p)^{k - 1}p$</h5><h5 id="期望：-3"><a href="#期望：-3" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \sum\limits_{k &#x3D; 1}^{+\infty} k \cdot (1-p)^{k - 1}p \<br>&amp;&#x3D;p \sum\limits_{k &#x3D; 1}^{+\infty} \left( \int k \cdot (1-p)^{k - 1}\right)’ \<br>&amp;&#x3D; p \left(-\sum\limits_{k &#x3D; 1}^{+\infty}(1-p)^{k} \right)’ \<br>&amp;&#x3D; p \cdot \dfrac{1}{p^{2}} \<br>&amp;&#x3D; \dfrac{1}{p}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-3"><a href="#方差：-3" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &amp;&#x3D; E(X^{2}) - E(X)^{2} \<br>&amp;&#x3D; \sum\limits_{k &#x3D; 1}^{+\infty} k^{2}(1 - p)^{k - 1}p - \dfrac{1}{p^{2}} \<br>&amp;&#x3D; p \left[\sum\limits_{k &#x3D; 1}^{+\infty}(k+ 1)kq^{k - 1} - \sum\limits_{k &#x3D; 1}^{+\infty} kq^{k - 1} \right] - \dfrac{1}{p^{2}} \<br>&amp;&#x3D; \dfrac{1 - p}{p^{2}}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-3"><a href="#性质：-3" class="headerlink" title="性质："></a>性质：</h5><h4 id="超几何分布-Hypergeometric-Distribution"><a href="#超几何分布-Hypergeometric-Distribution" class="headerlink" title="超几何分布(Hypergeometric Distribution)"></a>超几何分布(Hypergeometric Distribution)</h4><h5 id="符号："><a href="#符号：" class="headerlink" title="符号："></a>符号：</h5><h5 id="概率：-P-X-k-frac-begin-pmatrix-M-k-end-pmatrix-begin-pmatrix-N-M-n-k-end-pmatrix-begin-pmatrix-N-M-end-pmatrix-k-leq-min-n-M-k-1"><a href="#概率：-P-X-k-frac-begin-pmatrix-M-k-end-pmatrix-begin-pmatrix-N-M-n-k-end-pmatrix-begin-pmatrix-N-M-end-pmatrix-k-leq-min-n-M-k-1" class="headerlink" title="概率：$P(X &#x3D; k) &#x3D; \frac{\begin{pmatrix} M \ k\end{pmatrix} \begin{pmatrix} N - M \ n - k\end{pmatrix} }{\begin{pmatrix} N \ M\end{pmatrix} }, k \leq \min(n, M) &#x3D; k_1$"></a>概率：$P(X &#x3D; k) &#x3D; \frac{\begin{pmatrix} M \ k\end{pmatrix} \begin{pmatrix} N - M \ n - k\end{pmatrix} }{\begin{pmatrix} N \ M\end{pmatrix} }, k \leq \min(n, M) &#x3D; k_1$</h5><h5 id="期望：-4"><a href="#期望：-4" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \sum\limits_{k &#x3D; 1}^{k_1} k \cdot \frac{\begin{pmatrix} M \ k\end{pmatrix} \begin{pmatrix} N - M \ n - k\end{pmatrix}}{\begin{pmatrix} N \ M\end{pmatrix}} \<br>&amp;&#x3D; \sum\limits_{k &#x3D; 1}^{k_1} \begin{pmatrix} N - M \ n - k\end{pmatrix}\times \frac{\frac{M(M - 1)!}{(k - 1)!(M - k)!}}{\frac{N(N - 1)!}{n(n - 1)!(N-n)!}} \<br>&amp;&#x3D; \dfrac{nM}{N}\sum\limits_{k &#x3D; 1}^{k_1} \frac{\begin{pmatrix} M - 1 \ k - 1\end{pmatrix}\begin{pmatrix}N - M \ n - k \end{pmatrix} }{\begin{pmatrix} N - 1\ n - 1\end{pmatrix}}\<br>&amp;&#x3D; \dfrac{nM}{N} \frac{\sum\limits_{k &#x3D; 1}^{k_1} \begin{pmatrix} M - 1 \ k - 1\end{pmatrix}\begin{pmatrix}N - 1 - (M - 1) \ n - 1 - (k - 1) \end{pmatrix}}{\begin{pmatrix} N - 1 \ n - 1\end{pmatrix}} \<br>&amp;&#x3D; \dfrac{nM}{N}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-4"><a href="#方差：-4" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>E(X^{2})&#x3D; E(X(X - 1) + X) &#x3D; E(X(X - 1)) + E(X)<br>$$</p>
<p>$$<br>\begin{aligned}<br>E(X(X - 1))) &amp;&#x3D; \sum\limits_{k &#x3D; 0}^{k_1} k(k - 1) \frac{\begin{pmatrix}M \k \end{pmatrix} \begin{pmatrix} N - M \ n - k\end{pmatrix}}{\begin{pmatrix} N \ n\end{pmatrix}} \<br>&amp;&#x3D; \frac{nM(n - 1)(M - 1)}{N(N - 1)} \sum\limits_{k &#x3D; 2}^{k_1} \frac{\begin{pmatrix} M - 2 \ k - 2\end{pmatrix} \begin{pmatrix} N - M \ n - k\end{pmatrix}}{\begin{pmatrix} N - 2 \ n - 2\end{pmatrix}} \<br>&amp;&#x3D; \frac{nM(n - 1)(M - 1)}{N(N - 1)}<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>D(X) &#x3D; E(X(X - 1))) + E(X) - E(X)^{2}  &#x3D; \frac{nM(N - M)(N - n)}{N^{2}(N - 1)}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-4"><a href="#性质：-4" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>当总物品个数远远大于选的个数，或者总物品个数区域无穷大的时候，超几何分布可以近似为二项分布。</li>
<li></li>
</ol>
<h5 id="应用：-3"><a href="#应用：-3" class="headerlink" title="应用："></a>应用：</h5><h4 id="负二项分布-帕斯卡分布-Negative-Binomial-Distribution-Pascal-Distribution"><a href="#负二项分布-帕斯卡分布-Negative-Binomial-Distribution-Pascal-Distribution" class="headerlink" title="负二项分布(帕斯卡分布, Negative Binomial Distribution, Pascal Distribution)"></a>负二项分布(帕斯卡分布, Negative Binomial Distribution, Pascal Distribution)</h4><h5 id="符号：-X-sim-text-Pascal-n-p"><a href="#符号：-X-sim-text-Pascal-n-p" class="headerlink" title="符号：$X \sim \text{Pascal}(n, p)$"></a>符号：$X \sim \text{Pascal}(n, p)$</h5><h5 id="概率：-P-X-x-begin-pmatrix-x-1-r-1-end-pmatrix-p-r-1-p-x-r"><a href="#概率：-P-X-x-begin-pmatrix-x-1-r-1-end-pmatrix-p-r-1-p-x-r" class="headerlink" title="概率：$P(X &#x3D; x) &#x3D; \begin{pmatrix} x - 1\ \ r - 1\end{pmatrix}p^{r}(1  -p)^{x - r}$"></a>概率：$P(X &#x3D; x) &#x3D; \begin{pmatrix} x - 1\ \ r - 1\end{pmatrix}p^{r}(1  -p)^{x - r}$</h5><p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024232853695.png" alt="image-20231024232853695"></p>
<h5 id="期望：-5"><a href="#期望：-5" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \sum\limits_{x &#x3D; r}^{+\infty} x f(x) \<br>&amp;&#x3D; \sum\limits_{x &#x3D; r}^{+\infty} x\begin{pmatrix} x - 1 \ r - 1\end{pmatrix} p^{r}(1 - p)^{x - r} \<br>&amp;&#x3D; \frac{r}{p} \sum\limits_{x &#x3D; r}^{+\infty} \begin{pmatrix}x  \ r \end{pmatrix} p^{r + 1} (1 - p)^{x  - r} \<br>&amp;&#x3D; \frac{rp}{1 - p}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-5"><a href="#方差：-5" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>E(X^{2}) &amp;&#x3D; \sum\limits_{x &#x3D; r}^{+\infty} x^{2}f(x) \<br>&amp;&#x3D; \sum\limits_{x &#x3D; r}^{+\infty} x^{2} \begin{pmatrix}x - 1 \ r-  1 \end{pmatrix}p^{r}(1 - p)^{x - r} \<br>&amp;&#x3D; \frac{r}{p} \sum\limits_{x &#x3D; r}^{+\infty} x\begin{pmatrix} x \ r\end{pmatrix}p^{r + 1} (1 - p)^{x- r} \<br>&amp;&#x3D; \frac{r}{p} \left[\sum\limits_{x &#x3D; r}^{+\infty}(x + 1)\begin{pmatrix} x  \ r\end{pmatrix} p^{r+ 1}(1 - p)^{x - r} - \sum\limits_{x &#x3D; r}^{+\infty}\begin{pmatrix} x \ r\end{pmatrix} p^{r+ 1}(1 - p)^{x - r}\right] \<br>&amp;&#x3D; \frac{r}{p}(\frac{r + 1}{p} - 1) \<br>&amp;&#x3D; \frac{r(r - p + 1)}{p^{2}}<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; \frac{r(1 - p)}{p^{2}}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-5"><a href="#性质：-5" class="headerlink" title="性质："></a>性质：</h5><p>Binomial 分布和 Negative Binomial 分布都是多次重复的 Bernoulli 实验。</p>
<p>Binomial关注的是，重复Bernoulli实验成功概率为p，条件为总共实验N次，随机变量为N次实验中成功实验次数k（k∈Z,k∈[0,N]），该随机变量[概率分布为Binomial分布。</p>
<p>Negative Binomial关注的是，重复Bernoulli实验成功概率为p，条件为累计出现r次失败，随机变量为成功实验次数k（k∈Z,k∈[0,+∞)），该随机变量的概率分布为Negative Binomial分布。</p>
<p>Binomial和Negative Binomial分布的随机变量都是成功实验次数，条件不同。从定义上来看，”负“可以理解为站在失败次数的角度看成功。</p>
<h5 id="应用：-4"><a href="#应用：-4" class="headerlink" title="应用："></a>应用：</h5><h4 id="伽马-泊松分布-Gamma-Poisson-Distribution"><a href="#伽马-泊松分布-Gamma-Poisson-Distribution" class="headerlink" title="伽马-泊松分布(Gamma-Poisson Distribution)"></a>伽马-泊松分布(Gamma-Poisson Distribution)</h4><h5 id="符号：-X-sim-text-gamma-Poisson-alpha-beta"><a href="#符号：-X-sim-text-gamma-Poisson-alpha-beta" class="headerlink" title="符号：$X \sim \text{gamma-Poisson}(\alpha, \beta)$"></a>符号：$X \sim \text{gamma-Poisson}(\alpha, \beta)$</h5><h5 id="概率密度函数："><a href="#概率密度函数：" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>\begin{aligned}<br>f(x) &#x3D; \dfrac{\Gamma(x + \beta) \alpha^{x}}{\Gamma(\beta)(1+\alpha)^{\beta + x}x!}<br>\end{aligned}<br>$$</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024233912306.png" alt="image-20231024233912306"></p>
<h5 id="期望：-6"><a href="#期望：-6" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \alpha\beta<br>$$</p>
<h5 id="方差：-6"><a href="#方差：-6" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &#x3D; \alpha \beta + \alpha^{2}\beta<br>\end{aligned}<br>$$</p>
<h5 id="性质：-6"><a href="#性质：-6" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>做变换：$\alpha &#x3D; (1 - p) &#x2F; p, \beta &#x3D; n$，就得到 Pascal 分布</li>
</ol>
<h4 id="Zeta-分布-Zeta-Distribution"><a href="#Zeta-分布-Zeta-Distribution" class="headerlink" title="Zeta 分布(Zeta Distribution)"></a>Zeta 分布(Zeta Distribution)</h4><h5 id="符号：-X-sim-text-Zeta-alpha"><a href="#符号：-X-sim-text-Zeta-alpha" class="headerlink" title="符号：$X \sim \text{Zeta}(\alpha)$"></a>符号：$X \sim \text{Zeta}(\alpha)$</h5><h5 id="概率函数："><a href="#概率函数：" class="headerlink" title="概率函数："></a>概率函数：</h5><p>$$<br>\begin{aligned}<br>f(x) &#x3D; \dfrac{1}{x^{\alpha}\sum\limits_{i &#x3D; 1}^{+\infty}(1&#x2F;i)^{\alpha}} \quad x &#x3D; 1, 2, 3, …<br>\end{aligned}<br>$$</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026215915467.png" alt="image-20231026215915467"></p>
<h5 id="累计分布函数"><a href="#累计分布函数" class="headerlink" title="累计分布函数"></a>累计分布函数</h5><p>$$<br>\begin{aligned}<br>F(x) &#x3D; P(X \leq x) &#x3D; \dfrac{\sum\limits_{i &#x3D; 1}^{x} (1&#x2F;i)^{\alpha}}{\zeta(\alpha)} \quad x &#x3D; 1, 2, …<br>\end{aligned}<br>$$</p>
<h5 id="期望：-7"><a href="#期望：-7" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &#x3D; \dfrac{\zeta(\alpha - 1)}{\zeta(\alpha)}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-7"><a href="#方差：-7" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &#x3D; \dfrac{\zeta(\alpha)\zeta(\alpha - 2) - \zeta(\alpha - 1)^{2}}{\zeta(\alpha)^{2}}<br>\end{aligned}<br>$$</p>
<h4 id="Zipf-分布-齐夫定律"><a href="#Zipf-分布-齐夫定律" class="headerlink" title="Zipf 分布(齐夫定律)"></a>Zipf 分布(齐夫定律)</h4><h5 id="符号：-X-sim-text-Zipf-alpha-n"><a href="#符号：-X-sim-text-Zipf-alpha-n" class="headerlink" title="符号：$X \sim \text{Zipf}(\alpha, n)$"></a>符号：$X \sim \text{Zipf}(\alpha, n)$</h5><h5 id="概率函数：-1"><a href="#概率函数：-1" class="headerlink" title="概率函数："></a>概率函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{1}{x^{\alpha}\sum\limits_{i &#x3D; 1}^{n}(1 &#x2F; i)^{\alpha}} \quad  x &#x3D; 1, 2, 3, …, n<br>$$</p>
<p>下面是 $\alpha &#x3D; 1, n &#x3D; 10$</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026224615881.png" alt="image-20231026224615881"></p>
<p>我们记 $H_{n, \alpha} &#x3D; \sum\limits_{i &#x3D; 1}^{n} \left(\dfrac{1}{i}\right)^{\alpha}$</p>
<h5 id="期望：-8"><a href="#期望：-8" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \dfrac{H_{n, \alpha - 1}}{H_{n, \alpha}}<br>$$</p>
<h5 id="方差：-8"><a href="#方差：-8" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{H_{n, \alpha - 2}H_{n, \alpha} - H_{n, \alpha}^{2}}{H_{n, \alpha}^{2}}<br>$$</p>
<h5 id="齐夫定律："><a href="#齐夫定律：" class="headerlink" title="齐夫定律："></a>齐夫定律：</h5><p>在自然语言的语料库里，一个单词出现的率与它在频<br>率表里的排名成反比。所以，频率最高的单词出现的频率大约是出现频率第二位的单词的2<br>倍，而出现频率第二位的单词侧是出现频率第四位的单词的2倍。这个定律被作为任何与幂<br>定律概率分布有关的事物的参考。</p>
<h5 id="应用-or-遵循该定律的现象："><a href="#应用-or-遵循该定律的现象：" class="headerlink" title="应用 or 遵循该定律的现象："></a>应用 or 遵循该定律的现象：</h5><ol>
<li>英文单词或中文汉字的出现频率：不仅适用于语料全体，也适用于单独的一篇文章</li>
<li>网页访问频率</li>
<li>城镇人口与城镇等级的关系</li>
<li>收入前3%的人的收入</li>
<li>地震震级</li>
<li>固体破碎时的碎片大小</li>
</ol>
<h3 id="连续分布"><a href="#连续分布" class="headerlink" title="连续分布"></a>连续分布</h3><h4 id="均匀分布-Uniform-Distribution"><a href="#均匀分布-Uniform-Distribution" class="headerlink" title="均匀分布(Uniform Distribution)"></a>均匀分布(Uniform Distribution)</h4><h5 id="符号：-X-sim-U-a-b"><a href="#符号：-X-sim-U-a-b" class="headerlink" title="符号：$X \sim U(a, b)$"></a>符号：$X \sim U(a, b)$</h5><h5 id="概率密度函数：-1"><a href="#概率密度函数：-1" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases} \dfrac{1}{b - a} , a &lt; x &lt; b \<br>0\end{cases}<br>$$</p>
<h5 id="分布函数："><a href="#分布函数：" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; \begin{cases}<br>\frac{x - a}{b - a}, &amp;a &lt; x &lt; b \<br>0,&amp;x &lt; a \<br>1,&amp;x &gt; b<br>\end{cases}<br>$$</p>
<h5 id="期望：-9"><a href="#期望：-9" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_{-\infty}^{+\infty} x \cdot f(x) \mathrm{d}x \<br>&amp;&#x3D; \int_{a}^{b} \dfrac{x}{b - a} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{a + b}{2}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-9"><a href="#方差：-9" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>E(X^{2}) &amp;&#x3D; \int_{a}^{b} \dfrac{x^{2}}{b - a} \mathrm{d}x\<br>&amp;&#x3D; \dfrac{a^{2}+ab + b^{2}}{3}<br>$$</p>
<p>$$<br>\begin{aligned}<br>D(X) &amp;&#x3D; E(X^{2}) - E(X)^{2} \<br>&amp;&#x3D; \dfrac{a^{2}+ab + b^{2}}{3} - \left( \dfrac{a+b}{2}\right)^{2} \<br>&amp;&#x3D; \dfrac{(b - a)^{2}}{12}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-7"><a href="#性质：-7" class="headerlink" title="性质："></a>性质：</h5><h5 id="应用：-5"><a href="#应用：-5" class="headerlink" title="应用："></a>应用：</h5><h4 id="指数分布-Exponential-Distribution"><a href="#指数分布-Exponential-Distribution" class="headerlink" title="指数分布(Exponential Distribution)"></a>指数分布(Exponential Distribution)</h4><p>指数分布一个很重要的特征就是无记忆性 $P(x &gt; s | x &gt; t) &#x3D; P(x &gt; s - t), s &gt; t$ 。如果我们使用 x 表示等待的时间。那么这个式子的含义就是 <strong>未来我还需要等到多少时间和我已经等待了多长时间没有关系</strong>。</p>
<p>无记忆性的离散版本是 <strong>几何分布。</strong></p>
<h5 id="符号：-X-sim-E-lambda"><a href="#符号：-X-sim-E-lambda" class="headerlink" title="符号：$X\sim E(\lambda)$"></a>符号：$X\sim E(\lambda)$</h5><h5 id="概率密度函数：-2"><a href="#概率密度函数：-2" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases}<br>\lambda e^{-\lambda x}, &amp;x &gt; 0 \<br>\<br>0, &amp;x \leq 0<br>\end{cases}<br>$$</p>
<p>推导：</p>
<p>我们根据实际情况来考虑，如果一个产品的使用寿命是 T，分布函数是 $F(t)$，那么寿命大于 t 的概率为 $S(t) &#x3D; 1- F(t)$</p>
<p>如果一个产品已经使用 t 时间，那么在 $(t, t + \Delta t)$ 这一段时间内，死亡的「风险」为:<br>$$<br>\lambda(t) &#x3D; \lim\limits_{\Delta t \to 0} \dfrac{P(t \leq T \leq t + \Delta t)}{\mathrm{d}t \cdot S(t)} &#x3D; \dfrac{f(t)}{S(t)} &#x3D; -\dfrac{S’(t)}{S(t)} &#x3D; -\dfrac{\mathrm{d}}{\mathrm{d}t}\ln(S(t))<br>$$</p>
<blockquote>
<p>解释：因为我们首先需要活到这个时间，然后在这个时间段死亡，所以有 $S(t) \cdot \lambda(t) &#x3D; p(T &#x3D; t)$</p>
</blockquote>
<p>我们称这个 $\lambda(t)$ 为风险函数（到这里还没有涉及到无记忆性，这个 $\lambda(t)$ 是一个普遍的风险函数）</p>
<p>如果我们要满足无记忆性，就要有 $\lambda(t) &#x3D; \text{Const}$（也就是我们在每一个时间下「死亡」的概率都是等大的）</p>
<p>或者我们由「无记忆性」的直接式子推导：$P(T &gt; s | T &gt; t) &#x3D; P(T &gt; s - t) \Rightarrow P(t \leq T \leq t + \Delta t) &#x3D; P(T &lt; \mathrm{d}t) \cdot S(t)$ 也是得到 $\lambda(t) &#x3D; \text{Const}$ </p>
<p>所以有<br>$$<br>-\dfrac{\mathrm{d}}{\mathrm{d}t}\ln(S(t)) &#x3D; \text{Const}<br>$$<br>解得 $F(t) &#x3D; 1 - e^{-\text{Const} \cdot t}$</p>
<p>其中，$\text{Const}$ 表示每一个时间点死亡的风险大小，也就是每一个时间点死亡的概率大小。</p>
<h5 id="分布函数：-1"><a href="#分布函数：-1" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; \begin{cases}<br>1 - e^{-\lambda x}, &amp;x &gt; 0 \<br>0, &amp;x \leq 0<br>\end{cases}<br>$$</p>
<h5 id="期望：-10"><a href="#期望：-10" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_{-\infty}^{+\infty} x \cdot f(x) \mathrm{d}x \<br>&amp;&#x3D; \int_0^{+\infty} x \cdot \lambda e^{-\lambda x} \mathrm{d}x \<br>&amp;&#x3D; x(-e^{-\lambda x})|<em>{0}^{+\infty} - \int</em>{0}^{+\infty} -e^{-\lambda x} \mathrm{d}x \<br>&amp;&#x3D; \frac{1}{\lambda}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-10"><a href="#方差：-10" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>E(X^{2}) &amp;&#x3D; \int_0^{+\infty} x^{2} \cdot \lambda e^{-\lambda x} \mathrm{d}x \<br>&amp;&#x3D; \int_0^{+\infty} x^{2} \mathrm{d}(-e^{-\lambda x}) \<br>&amp;&#x3D; x^{2}(-e^{-\lambda x})|_{0}^{+\infty} + 2\int_0^{+\infty}xe^{-\lambda x} \mathrm{d}x \<br>&amp;&#x3D; \frac{2}{\lambda^{2}}<br>\end{aligned}<br>$$</p>
<p>$$<br>D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; \frac{1}{\lambda^{2}}<br>$$</p>
<h5 id="性质：-8"><a href="#性质：-8" class="headerlink" title="性质："></a>性质：</h5><p>指数分布通常用来建模持续时间，只不过指数分布能够建模的持续时间具有比较特殊的性质，也就是所谓的“无记忆性”</p>
<p>无记忆性：<br>$$</p>
<p>$$</p>
<h5 id="应用：-6"><a href="#应用：-6" class="headerlink" title="应用："></a>应用：</h5><ol>
<li><p>泊松分布、指数分布、二项分布、伯努利分布之间的关系：</p>
<p>当 n 趋近于无穷大时，二项分布可以近似为泊松分布；当 $\lambda$ 趋近于无穷大<br>时，泊松分布可以近似为正态分布；而指数分布则是泊松分布在连续时间上的推广，因此也与泊松<br>分布有一定的联系。但是，这些分布之间的应用场景和特点是不同的，需要根据实际问题选择合适<br>的分布模型。</p>
</li>
<li></li>
</ol>
<h4 id="正态分布-高斯分布-Normal-Distribution"><a href="#正态分布-高斯分布-Normal-Distribution" class="headerlink" title="正态分布(高斯分布, Normal Distribution)"></a>正态分布(高斯分布, Normal Distribution)</h4><h5 id="符号：-X-sim-N-mu-sigma-2"><a href="#符号：-X-sim-N-mu-sigma-2" class="headerlink" title="符号：$X\sim N(\mu, \sigma^{2})$"></a>符号：$X\sim N(\mu, \sigma^{2})$</h5><h5 id="概率密度函数：-3"><a href="#概率密度函数：-3" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{1}{\sqrt{2\pi} \sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}}(\mu \in R, \sigma &gt; 0)<br>$$</p>
<h5 id="分布函数：-2"><a href="#分布函数：-2" class="headerlink" title="分布函数："></a>分布函数：</h5><h5 id="期望：-11"><a href="#期望：-11" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_{-\infty}^{+\infty} x \cdot \frac{1}{\sqrt{2 \pi} \sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \<br>&amp;&#x3D;\int_{-\infty}^{+\infty}(x - \mu + \mu) \cdot \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x - \mu)^{2}}{2\sigma^{2}}} \mathrm{d}(x - \mu)\<br>&amp;&#x3D; \int_{-\infty}^{+\infty} \frac{t}{\sqrt{2\pi}\sigma}e^{-\frac{t^{2}}{2\sigma^{2}}} \mathrm{d}t + \mu \int_{-\infty}^{+\infty}\frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x - \mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \<br>&amp;&#x3D; 0 + \mu \<br>&amp;&#x3D; \mu<br>\end{aligned}<br>$$</p>
<h5 id="方差：-11"><a href="#方差：-11" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &amp;&#x3D; \int_{-\infty}^{+\infty} x^{2} \cdot \frac{1}{\sqrt{2 \pi} \sigma}e^{-\frac{-(x-\mu)^{2}}{2\sigma^{2}}} \mathrm{d}x \<br>&amp;&#x3D; \int_{-\infty}^{+\infty}(x - \mu)^{2} f(x) \mathrm{d}x + 2\mu \int_{-\infty}^{+\infty}x \cdot f(x) \mathrm{d}x - \mu^{2} \int_{-\infty}^{+\infty} f(x)\mathrm{d}x \<br>&amp;&#x3D; \frac{1}{\sqrt{2\pi} \sigma}\int_{0}^{+\infty} \sqrt{t}e^{\frac{t}{2\sigma^{2}}} \mathrm{d}t + 2\mu^{2} - \mu^{2}\<br>&amp;&#x3D; \sigma^{2}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-9"><a href="#性质：-9" class="headerlink" title="性质："></a>性质：</h5><p>标准正态分布：</p>
<h5 id="应用：-7"><a href="#应用：-7" class="headerlink" title="应用："></a>应用：</h5><h4 id="多元高斯分布-Multivariate-Gaussian-Distribution"><a href="#多元高斯分布-Multivariate-Gaussian-Distribution" class="headerlink" title="多元高斯分布(Multivariate Gaussian Distribution)"></a>多元高斯分布(Multivariate Gaussian Distribution)</h4><h5 id="概率密度函数：-4"><a href="#概率密度函数：-4" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><h5 id="应用：多元高斯分布的性质和应用在统计学、机器学习、信号处理和贝叶斯推断等领域中都非常重要。"><a href="#应用：多元高斯分布的性质和应用在统计学、机器学习、信号处理和贝叶斯推断等领域中都非常重要。" class="headerlink" title="应用：多元高斯分布的性质和应用在统计学、机器学习、信号处理和贝叶斯推断等领域中都非常重要。"></a>应用：多元高斯分布的性质和应用在统计学、机器学习、信号处理和贝叶斯推断等领域中都非常重要。</h5><h4 id="混合高斯分布-Mixture-of-Gaussian-Distributions"><a href="#混合高斯分布-Mixture-of-Gaussian-Distributions" class="headerlink" title="混合高斯分布(Mixture of Gaussian Distributions)"></a>混合高斯分布(Mixture of Gaussian Distributions)</h4><h5 id="应用：-8"><a href="#应用：-8" class="headerlink" title="应用："></a>应用：</h5><p>混合高斯模型在许多领域中有广泛的应用，如模式识别、聚类分析、异常检测和图像分割。它允许建模复杂的数据分布，其中数据点可以由多个不同的分布生成，而不仅仅是单一的高斯分布。这使得混合高斯模型成为数据建模和分析中的强大工具。</p>
<h4 id="对数正态分布-Log-Normal-Distribution"><a href="#对数正态分布-Log-Normal-Distribution" class="headerlink" title="对数正态分布(Log-Normal Distribution)"></a>对数正态分布(Log-Normal Distribution)</h4><h4 id="伽马分布-Gamma-Distribution"><a href="#伽马分布-Gamma-Distribution" class="headerlink" title="伽马分布(Gamma Distribution)"></a>伽马分布(Gamma Distribution)</h4><h5 id="符号：-X-sim-Ga-alpha-lambda"><a href="#符号：-X-sim-Ga-alpha-lambda" class="headerlink" title="符号：$X \sim Ga(\alpha, \lambda)$"></a>符号：$X \sim Ga(\alpha, \lambda)$</h5><h5 id="概率密度函数：-5"><a href="#概率密度函数：-5" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases}<br>\dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} x^{\alpha - 1}e^{-\lambda x}, &amp;x \geq 0\<br>0 &amp; x &lt; 0<br>\end{cases}<br>$$</p>
<h5 id="期望：-12"><a href="#期望：-12" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \dfrac{\lambda^{\alpha}}{\Gamma(\alpha)}\int_{0}^{+\infty} x^{\alpha} e^{-\lambda x} \mathrm{d}x \ &amp;&#x3D; \dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} \int_{0}^{+\infty} \dfrac{t^{\alpha}}{\lambda ^{\alpha + 1}}e^{-t} \mathrm{d}t \<br>&amp;&#x3D; \dfrac{\Gamma(\alpha  +1)}{\Gamma(\alpha) \cdot \lambda} \<br>&amp;&#x3D; \frac{\alpha}{\lambda}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-12"><a href="#方差：-12" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>E(X^{2}) &amp;&#x3D; \int_{0}^{+\infty} x^{2} \cdot \dfrac{\lambda^{\alpha}}{\Gamma(\alpha)} x^{\alpha - 1}e^{-\lambda x} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{1}{\lambda^{2}\Gamma(\alpha)} \int_0^{+\infty} t^{\alpha+1}e^{-t}\mathrm{d}t \<br>&amp;&#x3D; \dfrac{\alpha(\alpha + 1)}{\lambda^{2}}<br>\end{aligned}<br>$$</p>
<p>$$<br>D(X) &#x3D; E(X^{2}) - E(X)^{2}  &#x3D; \dfrac{\alpha}{\lambda^{2}}<br>$$</p>
<h5 id="性质：-10"><a href="#性质：-10" class="headerlink" title="性质："></a>性质：</h5><ol>
<li><p>$\alpha  &#x3D; 1$ 的时候，伽马分布与指数分布之间的关系就建立起来了，有 $Ga(1, \lambda ) &#x3D; E(\lambda)$</p>
</li>
<li><p>当 $\alpha &#x3D; \dfrac{n}{2}, \lambda &#x3D; \dfrac{1}{2}$ 的时候，伽马分布和卡方分布之间的关系就建立起来了，有 $Ga(\dfrac{n}{2}, \dfrac{1}{2}) &#x3D; \mathcal{X}^{2}(n)$</p>
</li>
<li><p>伽马分布的可加性。<img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20231024194312138.png" alt="image-20231024194312138"></p>
</li>
<li></li>
</ol>
<h5 id="应用：-9"><a href="#应用：-9" class="headerlink" title="应用："></a>应用：</h5><h4 id="对数伽马分布-Log-Gamma-Distribution"><a href="#对数伽马分布-Log-Gamma-Distribution" class="headerlink" title="对数伽马分布(Log-Gamma Distribution)"></a>对数伽马分布(Log-Gamma Distribution)</h4><h5 id="符号：-X-sim-text-log-gamma-alpha-beta"><a href="#符号：-X-sim-text-log-gamma-alpha-beta" class="headerlink" title="符号：$X \sim \text{log-gamma}(\alpha, \beta)$"></a>符号：$X \sim \text{log-gamma}(\alpha, \beta)$</h5><h5 id="概率密度函数：-6"><a href="#概率密度函数：-6" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{e^{\beta x}e^{-e^{x} &#x2F; a}}{\alpha^{\beta}\Gamma(\beta)} -\infty &lt; x &lt; +\infty<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024233520269.png" alt="image-20231024233520269"></p>
<h4 id="贝塔分布-Beta-Distribution"><a href="#贝塔分布-Beta-Distribution" class="headerlink" title="贝塔分布(Beta Distribution)"></a>贝塔分布(Beta Distribution)</h4><h5 id="符号：-X-sim-Beta-alpha-beta"><a href="#符号：-X-sim-Beta-alpha-beta" class="headerlink" title="符号：$X \sim \Beta(\alpha, \beta)$"></a>符号：$X \sim \Beta(\alpha, \beta)$</h5><h5 id="概率密度函数：-7"><a href="#概率密度函数：-7" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases}<br>\dfrac{1}{\Beta(\alpha, \beta)} x^{\alpha - 1}(1-x)^{\beta - 1}, 0 &lt; x &lt; 1 \<br>0<br>\end{cases}<br>$$</p>
<h5 id="分布函数：-3"><a href="#分布函数：-3" class="headerlink" title="分布函数："></a>分布函数：</h5><h5 id="期望：-13"><a href="#期望：-13" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_0^{1}x \cdot \dfrac{1}{\Beta(\alpha, \beta)} x^{\alpha - 1}(1-x)^{\beta - 1} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{\Beta(\alpha + 1, \beta)}{\Beta(\alpha, \beta)} \int_0^{1}\dfrac{1}{\Beta(\alpha + 1, \beta)} x^{(\alpha + 1) - 1}(1-x)^{\beta - 1} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{\Gamma(\alpha + 1)\Gamma(\beta)}{\Gamma(\alpha + \beta + 1)} \cdot \dfrac{\Gamma(\alpha + \beta)}{\Gamma(\alpha)\Gamma(\beta)} \<br>&amp;&#x3D; \dfrac{\alpha}{\alpha + \beta}<br>\end{aligned}<br>$$</p>
<h5 id="方差：-13"><a href="#方差：-13" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>E(X^{2}) &amp;&#x3D; \int_0^{1} \dfrac{1}{\Beta(\alpha, \beta)}x^{(\alpha + 2) - 1}(1 - x)^{\beta - 1} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{\Beta(\alpha + 2, \beta)}{\Beta(\alpha, \beta)} \<br>&amp;&#x3D; \dfrac{\alpha(\alpha + 1)}{(\alpha + \beta)(\alpha + \beta + 1)}<br>\end{aligned}<br>$$</p>
<p>$$<br>D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; \dfrac{\alpha \beta}{(\alpha + \beta)^{2}(\alpha + \beta + 1)}<br>$$</p>
<h5 id="性质：-11"><a href="#性质：-11" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>$Beta(1, 1) &#x3D; U(0, 1)$</li>
</ol>
<h5 id="应用：-10"><a href="#应用：-10" class="headerlink" title="应用："></a>应用：</h5><h4 id="威布尔分布-韦伯分布，Weibull-Distribution"><a href="#威布尔分布-韦伯分布，Weibull-Distribution" class="headerlink" title="威布尔分布(韦伯分布，Weibull Distribution)"></a>威布尔分布(韦伯分布，Weibull Distribution)</h4><p>概率密度函数：<br>$$<br>f(x;\lambda, k) &#x3D; \begin{cases}<br>\dfrac{k}{\lambda}(\dfrac{x}{\lambda})^{k - 1}e^{-(\dfrac{x}{\lambda})^k}, &amp;x \geq 0 \<br>0, &amp;x &lt; 0<br>\end{cases}<br>$$<br>其中，x 是随机变量，$\lambda &gt; 0$ 是比例系数(scale parameter)，$k &gt; 0$ 是形状参数(shape parameter)。显然，它的累计分布函数是扩展的指数分布函数。 </p>
<h5 id="期望：-14"><a href="#期望：-14" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \lambda \Gamma(1 + \dfrac{1}{k})<br>$$</p>
<h5 id="方差：-14"><a href="#方差：-14" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \lambda^{2}\left[\Gamma(1 + \dfrac{2}{k}) - \Gamma^{2}(1 + \dfrac{1}{k})\right]<br>$$</p>
<h5 id="应用：-11"><a href="#应用：-11" class="headerlink" title="应用："></a>应用：</h5><p>威布尔分布在<a href="https://baike.baidu.com/item/%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%B7%A5%E7%A8%8B/3129248?fromModule=lemma_inlink">可靠性工程</a>中被广泛应用。</p>
<ol>
<li>研究生产过程和运输时间关系</li>
<li>预测天气</li>
<li>可靠性和失效分析</li>
<li>雷达系统</li>
<li>对接受的杂波信号依分布建模</li>
<li>量化寿险模型的重复索赔</li>
<li>描述风速分布</li>
</ol>
<h4 id="瑞利分布-Rayleigh-Distribution"><a href="#瑞利分布-Rayleigh-Distribution" class="headerlink" title="瑞利分布(Rayleigh Distribution)"></a>瑞利分布(Rayleigh Distribution)</h4><p>瑞利分布就是两个垂直分量服从独立且均值为0,标准差相同的高斯分布叠加之后的模。<br>换句话说，复高斯分布的模服从瑞利分布。</p>
<p><a href="https://zhuanlan.zhihu.com/p/573644622">瑞利分布的推导过程 - 知乎 (zhihu.com)</a> 瑞利分布</p>
<h4 id="柯西分布-柯西-洛伦兹分布，Cauchy-Distribution"><a href="#柯西分布-柯西-洛伦兹分布，Cauchy-Distribution" class="headerlink" title="柯西分布(柯西-洛伦兹分布，Cauchy Distribution)"></a>柯西分布(柯西-洛伦兹分布，Cauchy Distribution)</h4><h5 id="符号：-X-sim-text-Cauthy-a-alpha"><a href="#符号：-X-sim-text-Cauthy-a-alpha" class="headerlink" title="符号：$X \sim \text{Cauthy}(a, \alpha)$"></a>符号：$X \sim \text{Cauthy}(a, \alpha)$</h5><h5 id="概率密度函数：-8"><a href="#概率密度函数：-8" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{1}{\alpha\pi[1 + ((x - a) &#x2F; \alpha)^{2}]} \quad \quad -\infty &lt; x &lt; +\infty<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025112236557.png" alt="image-20231025112236557"></p>
<h5 id="由来推导："><a href="#由来推导：" class="headerlink" title="由来推导："></a>由来推导：</h5><p>柯西分布描述了以随机角度倾斜的线段切割 x 轴的水平距离分布。</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025113546164.png" alt="image-20231025113546164"><br>$$<br>\tan(\theta) &#x3D; \dfrac{x}{b} \<br>\theta &#x3D; \arctan{\dfrac{x}{b}} \<br>\mathrm{d}\theta &#x3D; \dfrac{1}{1 + \frac{x^{2}}{b^{2}}} \dfrac{\mathrm{d}x}{b}<br>$$<br>所以可以使用 $\dfrac{\mathrm{d}\theta}{\pi} &#x3D; \dfrac{1}{\pi} \dfrac{b\mathrm{d}x}{b^2 + x ^{2}}$ 来计算关于 x 的分布。<br>$$<br>\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}} \dfrac{\theta}{\pi} &#x3D; 1 \Rightarrow \int_{-\infty}^{+\infty} \dfrac{1}{\pi} \dfrac{b \mathrm{d}x}{b^2 + x^{2}} &#x3D; 1<br>$$<br>所以，$P(X &#x3D; x) &#x3D; \dfrac{1}{\pi} \dfrac{b}{(x - m)^{2} + b^2}$</p>
<h5 id="分布函数：-4"><a href="#分布函数：-4" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; P(X \leq x) &#x3D; \dfrac{1}{2\pi}\left(\pi - 2\arctan(\dfrac{a - x}{\alpha})\right) \quad -\infty &lt; x &lt; +\infty<br>$$</p>
<h5 id="期望：-15"><a href="#期望：-15" class="headerlink" title="期望："></a>期望：</h5><p>不存在</p>
<h5 id="方差：-15"><a href="#方差：-15" class="headerlink" title="方差："></a>方差：</h5><p>不存在</p>
<h5 id="应用：-12"><a href="#应用：-12" class="headerlink" title="应用："></a>应用：</h5><ol>
<li>柯西分布，也称为柯西-洛伦兹分布或洛伦兹分布，是描述共振行为的连续分布。它还描述了以随机角度倾斜的线段切割 x 轴的水平距离分布。</li>
<li>在量子世界，粒子和粒子距离很远，比如，电子到原子核的距离，就好比一个汽车到三千公里外的一个城市距离，因此，要显著描述电子的位置分布，只能是柯西-洛伦兹分布，不能用高斯分布刻画，因为高斯分布尺度不够，信号太弱，噪声将把电子的电磁能量淹没，模型无效。</li>
</ol>
<h5 id="性质：-12"><a href="#性质：-12" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>柯西分布的取值范围非常广，很大的值也有一定概率取到，因而柯西分布也称为heavy-tail distribution。并且相比于gaussian，概率密度的最大取值只有0.1，就是x&#x3D;0的那个地方。</li>
</ol>
<h4 id="拉普拉斯分布-双指数分布，Laplace-Distribution"><a href="#拉普拉斯分布-双指数分布，Laplace-Distribution" class="headerlink" title="拉普拉斯分布(双指数分布，Laplace Distribution)"></a>拉普拉斯分布(双指数分布，Laplace Distribution)</h4><h5 id="符号：-X-sim-text-Laplace-alpha-1-alpha-2"><a href="#符号：-X-sim-text-Laplace-alpha-1-alpha-2" class="headerlink" title="符号：$X \sim \text{Laplace}(\alpha_1, \alpha_2)$"></a>符号：$X \sim \text{Laplace}(\alpha_1, \alpha_2)$</h5><h5 id="概率密度函数：-9"><a href="#概率密度函数：-9" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases}<br>\dfrac{1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_1}}, &amp;x &lt; 0 \<br>\dfrac{1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_2}}, &amp; x \geq 0<br>\end{cases}<br>$$</p>
<blockquote>
<p>The Laplace distribution is an alternative to the normal distribution with heavier tails. The probability density function for three different parameters settings is illustrated below.</p>
</blockquote>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024230803046.png" alt="image-20231024230803046"></p>
<h5 id="分布函数：-5"><a href="#分布函数：-5" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; P(X \leq x) &#x3D; \begin{cases}<br>\dfrac{\alpha_1}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_1}} &amp;x &lt; 0 \<br>1 - \dfrac{\alpha_2}{\alpha_1 + \alpha_2}e^{-\frac{x}{\alpha_2}}&amp;x \geq 0<br>\end{cases}<br>$$</p>
<h5 id="期望：-16"><a href="#期望：-16" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_{-\infty}^{0} x \cdot f(x)\mathrm{d}x + \int_0^{+\infty} x \cdot f(x) \mathrm{d}x\<br>&amp;&#x3D; \alpha_2 - \alpha_1<br>\end{aligned}<br>$$</p>
<h5 id="方差：-16"><a href="#方差：-16" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>\begin{aligned}<br>D(X) &amp;&#x3D; \int_{-\infty}^{0} x^2 \cdot f(x)\mathrm{d}x + \int_0^{+\infty} x^2 \cdot f(x) \mathrm{d}x\<br>&amp;&#x3D; \alpha_1^{2} + \alpha_2^{2}<br>\end{aligned}<br>$$</p>
<h5 id="性质：-13"><a href="#性质：-13" class="headerlink" title="性质："></a>性质：</h5><ol>
<li>可看作两平移指数分布背靠背拼接在一起，因此又称双指数分布 (Double exponential distribution)</li>
</ol>
<h5 id="应用：-13"><a href="#应用：-13" class="headerlink" title="应用："></a>应用：</h5><h4 id="玻尔兹曼分布-Boltzmann-Distribution"><a href="#玻尔兹曼分布-Boltzmann-Distribution" class="headerlink" title="玻尔兹曼分布(Boltzmann Distribution)"></a>玻尔兹曼分布(Boltzmann Distribution)</h4><h4 id="幂律分布-Power-Distribution"><a href="#幂律分布-Power-Distribution" class="headerlink" title="幂律分布(Power Distribution)"></a>幂律分布(Power Distribution)</h4><h5 id="符号：-X-sim-text-Power-1-beta"><a href="#符号：-X-sim-text-Power-1-beta" class="headerlink" title="符号：$X\sim \text{Power}(1, \beta)$"></a>符号：$X\sim \text{Power}(1, \beta)$</h5><h5 id="概率密度函数：-10"><a href="#概率密度函数：-10" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \beta x^{\beta - 1} \quad \quad 0 &lt; x &lt; 1<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231024235040777.png" alt="image-20231024235040777"></p>
<h5 id="分布函数：-6"><a href="#分布函数：-6" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; P(X \leq x) &#x3D; x^{\beta}<br>$$</p>
<h5 id="期望：-17"><a href="#期望：-17" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D;<br>$$</p>
<h5 id="方差：-17"><a href="#方差：-17" class="headerlink" title="方差："></a>方差：</h5><h4 id="三角分布-Standard-Triangular-Distribution"><a href="#三角分布-Standard-Triangular-Distribution" class="headerlink" title="三角分布(Standard Triangular Distribution)"></a>三角分布(Standard Triangular Distribution)</h4><h5 id="符号：-X-sim-text-Triangular-1-1-1"><a href="#符号：-X-sim-text-Triangular-1-1-1" class="headerlink" title="符号：$X \sim \text{Triangular}(-1, 1, 1)$"></a>符号：$X \sim \text{Triangular}(-1, 1, 1)$</h5><h5 id="概率密度函数：-11"><a href="#概率密度函数：-11" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \begin{cases}<br>x + 1, &amp;-1 &lt; x &lt; 0 \<br>1 - x, &amp; 0 \leq x &lt; 1<br>\end{cases}<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025114540132.png" alt="image-20231025114540132"></p>
<h5 id="分布函数：-7"><a href="#分布函数：-7" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; \begin{cases}<br>\frac{1}{2}x^{2} + x + \frac{1}{2}, &amp;-1 &lt; x &lt; 0 \<br>-\frac{1}{2}x^{2} + x + \frac{1}{2}, &amp;0 \leq x &lt; 1<br>\end{cases}<br>$$</p>
<h5 id="期望：-18"><a href="#期望：-18" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; 0<br>$$</p>
<h5 id="方差：-18"><a href="#方差：-18" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{1}{6}<br>$$<br>更一般的，三角形分布是底限为 a，众数为 c，上限为 b 的连续概率分布。<br>$$<br>f(x|a, b, c) &#x3D; \begin{cases}<br>\dfrac{2(x - a)}{(b - a)(c - a)} \quad a \leq x \leq c \<br>\<br>\dfrac{2(b - x)}{(b - a)(b - c)} \quad c \leq x \leq b<br>\end{cases}<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025124956772.png" alt="image-20231025124956772"></p>
<h4 id="逻辑斯谛分布-增长分布-Log-Logistic-Distribution"><a href="#逻辑斯谛分布-增长分布-Log-Logistic-Distribution" class="headerlink" title="逻辑斯谛分布(增长分布, Log-Logistic Distribution)"></a>逻辑斯谛分布(增长分布, Log-Logistic Distribution)</h4><h5 id="符号：-X-sim-text-loglogistic-lambda-kappa"><a href="#符号：-X-sim-text-loglogistic-lambda-kappa" class="headerlink" title="符号：$X \sim \text{loglogistic}(\lambda, \kappa)$"></a>符号：$X \sim \text{loglogistic}(\lambda, \kappa)$</h5><h5 id="概率密度函数：-12"><a href="#概率密度函数：-12" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{\lambda\kappa(\lambda\kappa)^{\kappa - 1}}{(1 + (\lambda x)^{\kappa})^{2}} \quad x &gt; 0<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025130217056.png" alt="image-20231025130217056"></p>
<h5 id="分布函数：-8"><a href="#分布函数：-8" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; P(X &lt;&#x3D; x) &#x3D; \dfrac{(\lambda x)^{\kappa}}{1 + (\lambda x)^{\kappa}}  \quad x &gt; 0<br>$$</p>
<h5 id="期望：-19"><a href="#期望：-19" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>\begin{aligned}<br>E(X) &amp;&#x3D; \int_0^{+\infty} x \cdot f(x) \mathrm{d}x \<br>&amp;&#x3D; \dfrac{1}{\lambda} \int_0^{+\infty}\dfrac{m^{\frac{1}{k}}}{(1+m)^{2}} \mathrm{d}m \<br>&amp;&#x3D; \dfrac{1}{\kappa \lambda} \cdot \dfrac{\pi}{\sin (\frac{\pi}{\kappa})} \<br>&amp;&#x3D; \dfrac{\pi}{\kappa \lambda(\sin (\frac{\pi}{\kappa})}<br>\end{aligned}<br>$$<br>其中，计算的时候可以使用留数定理。</p>
<h5 id="方差：-19"><a href="#方差：-19" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{\pi \left(2\kappa(1 - \cos (\frac{\pi}{\kappa})^{2}) + \pi\sin(\frac{\pi(\kappa + 2)}{\kappa}) \right)}{\left(\sin (\frac{\pi(\kappa + 2)}{\kappa}) \right)\left( \cos(\frac{\pi}{\kappa})^{2} - 1\right)(\lambda \kappa)^{2}}<br>$$</p>
<h4 id="逻辑分布-Logistic-Distribution"><a href="#逻辑分布-Logistic-Distribution" class="headerlink" title="逻辑分布(Logistic Distribution)"></a>逻辑分布(Logistic Distribution)</h4><h5 id="符号：-X-sim-text-logistic-lambda-kappa"><a href="#符号：-X-sim-text-logistic-lambda-kappa" class="headerlink" title="符号：$X \sim \text{logistic}(\lambda, \kappa)$"></a>符号：$X \sim \text{logistic}(\lambda, \kappa)$</h5><h5 id="概率密度函数：-13"><a href="#概率密度函数：-13" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{\lambda^{\kappa}\kappa e^{\kappa x}}{(1 + (\lambda e^{x})^{\kappa})^{2}} \quad -\infty &lt; x &lt; +\infty<br>$$<br><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231025134453817.png" alt="image-20231025134453817"></p>
<h5 id="分布函数：-9"><a href="#分布函数：-9" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>F(x) &#x3D; P(X \leq x) &#x3D; \dfrac{\lambda^{\kappa}e^{\kappa x}}{1 + \lambda^{\kappa}e^{x}} \quad -\infty &lt; x &lt; +\infty<br>$$</p>
<h5 id="期望：-20"><a href="#期望：-20" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; -\ln \lambda<br>$$</p>
<h5 id="方差：-20"><a href="#方差：-20" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{\pi ^{2}}{3\kappa^{2}}<br>$$</p>
<h4 id="t-分布-T-Distribution"><a href="#t-分布-T-Distribution" class="headerlink" title="t 分布(T Distribution)"></a>t 分布(T Distribution)</h4><p>如果 $X\sim N(0, 1), Y \sim \chi^{2}(n)$，则有 $Z &#x3D; \dfrac{X}{\sqrt{\frac{Y}{n}}} \sim t(n)$</p>
<h5 id="概率密度函数：-14"><a href="#概率密度函数：-14" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>\begin{aligned}<br>f(z) &#x3D;\dfrac{\Gamma(\frac{n + 1}{2})}{\sqrt{n\pi}\Gamma(\frac{n}{2})}\left(\dfrac{z^{2}}{n} + 1\right)^{-\frac{n + 1}{2}}<br>\end{aligned}<br>$$</p>
<h5 id="推导："><a href="#推导：" class="headerlink" title="推导："></a>推导：</h5><p>做变换：<br>$$<br>\begin{aligned}<br>\begin{cases}<br>u &#x3D; \dfrac{X}{\sqrt{\frac{Y}{n}}} \<br>\<br>v &#x3D; Y<br>\end{cases}<br>\end{aligned}<br>$$<br>所以有反函数：<br>$$<br>\begin{cases}<br>X &#x3D; u\sqrt{\dfrac{v}{n}} \<br>\<br>Y &#x3D; v<br>\end{cases}<br>$$<br>雅可比行列式是：<br>$$<br>|J| &#x3D;<br>$$<br>所以原问题的分布函数变为：<br>$$<br>\begin{aligned}<br>\iint\limits_{A}f(x,y)\mathrm{d}x\mathrm{d}y &amp;&#x3D; \iint\limits_{B}f(x(u, v),y(u, v)) |J| \mathrm{d}u \mathrm{d}v \<br>&amp;&#x3D; \int_{-\infty}^{z}\int_{0}^{+\infty}f_X(u\sqrt{\dfrac{v}{u}})f_Y(v) (\dfrac{v}{n})^{-\frac{1}{2}} \mathrm{d}u \mathrm{d}v \</p>
<p>\end{aligned}<br>$$<br>有<br>$$<br>\begin{aligned}<br>f_X(x) &#x3D; \dfrac{1}{\sqrt{2\pi}}e^{-\frac{x^{2}}{2}} \<br>f_Y(y) &#x3D; \dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}y^{\frac{n}{2}- 1}e^{-\frac{y}{2}}<br>\end{aligned}<br>$$<br>所以：<br>$$<br>\begin{aligned}<br>F(Z) &amp;&#x3D; \int_{-\infty}^{z}\int_0^{+\infty} \dfrac{1}{\sqrt{2\pi}}e^{-\frac{1}{2}u^{2}\frac{v}{n}} \dfrac{1}{2^{\frac{n}{2}}\Gamma(\frac{n}{2})}v^{\frac{n}{2} - 1} e^{-\frac{v}{2}}(\dfrac{v}{n})^{-\frac{1}{2}} \mathrm{d}v\mathrm{d}u \<br>&amp;&#x3D; \int_{-\infty}^{z}\dfrac{1}{\sqrt{n\pi}\sqrt{2}}\dfrac{1}{2^{\frac{n}{2}} \Gamma(\frac{n}{2})} \int_0^{+\infty}e^{-\frac{1}{2}u^{2}\frac{v}{n} - \frac{v}{2}}v^{\frac{n - 1}{2}} \mathrm{d}u \mathrm{d}v<br>\end{aligned}<br>$$</p>
<h5 id="期望：-21"><a href="#期望：-21" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; 0<br>$$</p>
<h5 id="方差：-21"><a href="#方差：-21" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>V(X) &#x3D; \dfrac{n}{n - 2}<br>$$</p>
<h5 id="性质：-14"><a href="#性质：-14" class="headerlink" title="性质："></a>性质：</h5><h5 id="应用：-14"><a href="#应用：-14" class="headerlink" title="应用："></a>应用：</h5><h4 id="F-分布-F-Distribution"><a href="#F-分布-F-Distribution" class="headerlink" title="F 分布(F Distribution)"></a>F 分布(F Distribution)</h4><p>F 分布也被称为「方差比分布(Variance Ratio Distribution)」和「Fisher-Snedecor Distribution」。</p>
<p>设 $U \sim \chi^{2}(n_1), V \sim \chi^{2}(n_2)$，并且 U 和 V 相互独立，则称随机变量 $F &#x3D; \dfrac{U &#x2F; n_1}{V &#x2F; n_2}$ 服从自由度为 $(n_1, n_2)$ 的 F 分布</p>
<h5 id="概率密度函数：-15"><a href="#概率密度函数：-15" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(z) &#x3D; \dfrac{\Gamma(\frac{n_1 + n_2}{2})(\frac{n_1}{n_2})^{\frac{n_1}{2}}z^{\frac{n_1}{2} - 1}}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})\left[1 + \frac{n_1}{n_2}z\right]^{\frac{n_1 + n_2}{2}}}<br>$$</p>
<h5 id="推导：-1"><a href="#推导：-1" class="headerlink" title="推导："></a>推导：</h5><p>$\text{lemma1}:$<br>$$<br>f_{\frac{Y}{X}}(z) &#x3D; \int_{-\infty}^{+\infty}|x|f(x, xz)\mathrm{d}x<br>$$<br>$\text{lemma2}:$<br>$$<br>f_{aX + b} &#x3D; \dfrac{1}{|a|}f_X(\dfrac{y - b}{a}) \quad a \neq 0<br>$$<br>所以我们可以得到 $Y &#x3D; \dfrac{U}{n_1}, X &#x3D; \dfrac{V}{n_2}$ 的概率密度函数为：<br>$$<br>f_Y(y) &#x3D; \dfrac{(\frac{n_1}{2})^{\frac{n_1}{2}}}{\Gamma(\frac{n_1}{2})}y^{\frac{n_1}{2} - 1}e^{-\frac{n_1y}{2}} \quad y &gt; 0<br>$$</p>
<p>$$<br>f_X(x) &#x3D; \dfrac{(\frac{n_2}{2})^{\frac{n_2}{2}}}{\Gamma(\frac{n_2}{2})}y^{\frac{n_2}{2} - 1}e^{-\frac{n_2y}{2}} \quad x &gt; 0<br>$$</p>
<p>$$<br>\begin{aligned}<br>f_F(z) &amp;&#x3D; f_{\frac{Y}{X}}(z) \<br>&amp;&#x3D; \int_0^{+\infty} xf(x, xz) \mathrm{d}x \<br>&amp;&#x3D; \int_0^{+\infty} xf_Y(xz)f_X(x) \mathrm{d}x \<br>&amp;&#x3D; \int_0^{+\infty} x \dfrac{(\frac{n_1}{2})^{\frac{n_1}{2}}}{\Gamma(\frac{n_1}{2})}(xz)^{\frac{n_1}{2} - 1}e^{-\frac{n_1y}{2}} \cdot  \dfrac{(\frac{n_2}{2})^{\frac{n_2}{2}}}{\Gamma(\frac{n_2}{2})}y^{\frac{n_2}{2} - 1}e^{-\frac{n_2y}{2}} \mathrm{d}x \<br>&amp;&#x3D; \dfrac{(n_1 &#x2F; 2)^{n_1 &#x2F; 2}(n_2 &#x2F; 2)^{n_2 &#x2F; 2}}{\Gamma(\frac{n_1}{2}) \Gamma(\frac{n_2}{2})}z^{\frac{n_1}{n_2} - 1}\int_0^{+\infty}x^{\frac{n_1 + n_2}{2} - 1}e^{\frac{-x}{2}(n_1z + n_2)} \mathrm{d}x \<br>\end{aligned}<br>$$</p>
<p>设 $u &#x3D; \dfrac{x}{2}(n_1z + n_2)$</p>
<p>最后得到：<br>$$<br>f(z) &#x3D; \dfrac{\Gamma(\frac{n_1 + n_2}{2})(\frac{n_1}{n_2})^{\frac{n_1}{2}}z^{\frac{n_1}{2} - 1}}{\Gamma(\frac{n_1}{2})\Gamma(\frac{n_2}{2})\left[1 + \frac{n_1}{n_2}z\right]^{\frac{n_1 + n_2}{2}}}<br>$$</p>
<h5 id="期望：-22"><a href="#期望：-22" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \dfrac{n_2}{n_2 - 2}<br>$$</p>
<h5 id="方差：-22"><a href="#方差：-22" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>V(X) &#x3D; \dfrac{2n_2^{2}(n_1+ n_2 - 2)}{n_1}<br>$$</p>
<h5 id="性质：-15"><a href="#性质：-15" class="headerlink" title="性质："></a>性质：</h5><ol>
<li><p>$F_{1 - \alpha}(n_1, n_2) &#x3D; \dfrac{1}{F_{\alpha}(n_2, n_1)}$<br>证明：<br>$$<br>\begin{aligned}<br>1 - \alpha &amp;&#x3D; P{F &gt; F_{1 - \alpha}(n_1, n_2)} \<br>&amp;&#x3D; P{\dfrac{1}{F} &lt; \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}} \<br>&amp;&#x3D; 1 - P{\dfrac{1}{F} \geq \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}} \<br>&amp;&#x3D; 1 - P{\dfrac{1}{F} &gt; \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}} \<br>\end{aligned}<br>$$<br>所以 $P{\dfrac{1}{F} &gt; \dfrac{1}{F_{1 - \alpha}(n_1, n_2)}} &#x3D; \alpha$ 并且 $\dfrac{1}{F} \sim F(n_2, n_1)$，所以 $F_{1 - \alpha}(n_1, n_2) &#x3D; \dfrac{1}{F_{\alpha}(n_2, n_1)}$</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/453635917">F分布概率密度公式推导 - 知乎 (zhihu.com)</a></p>
</li>
</ol>
<h5 id="应用：-15"><a href="#应用：-15" class="headerlink" title="应用："></a>应用：</h5><h4 id="chi-分布-卡方分布-chi-Distribution"><a href="#chi-分布-卡方分布-chi-Distribution" class="headerlink" title="$\chi 分布$(卡方分布, $\chi$ Distribution)"></a>$\chi 分布$(卡方分布, $\chi$ Distribution)</h4><p>$Z_1, Z_2, …, Z_k$ 是独立、标准正态分布的随机变量，把他们的平方和记为 Q，则有 $Q &#x3D; \sum\limits_{i &#x3D; 1}^{k} Z_i^{2}$</p>
<p>这个 Q 是服从自由度为 K 的卡方分布的。通常会被记为 $Q \sim \chi^{2}(k)$</p>
<h5 id="符号：-Q-sim-chi-2-k"><a href="#符号：-Q-sim-chi-2-k" class="headerlink" title="符号：$Q \sim \chi^{2}(k)$"></a>符号：$Q \sim \chi^{2}(k)$</h5><h5 id="概率密度函数：-16"><a href="#概率密度函数：-16" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{1}{2^{\frac{n}{2}}\Gamma(\dfrac{n}{2})}x^{^{\frac{n}{2}} - 1}e^{-\frac{x^{2}}{2}} \quad z &gt; 0<br>$$</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026212407458.png" alt="image-20231026212407458"></p>
<h5 id="K-阶矩"><a href="#K-阶矩" class="headerlink" title="K 阶矩"></a>K 阶矩</h5><p>$$<br>\begin{aligned}<br>E(X^{k}) &amp;&#x3D; \int_0^{+\infty} x^{k} \cdot \dfrac{1}{2^{\frac{n}{2}}\Gamma(\dfrac{n}{2})}x^{^{\frac{n}{2}} - 1}e^{-\frac{x^{2}}{2}} \mathrm{d}x \<br>\end{aligned}<br>$$</p>
<p>设 $\dfrac{x^{2}}{2}&#x3D; t$，式子变为：<br>$$<br>\begin{aligned}<br>E(X^{k}) &amp;&#x3D; \dfrac{2^{\frac{k}{2}}}{\Gamma(\frac{n}{2})}\int_0^{+\infty} t^{\frac{n + k}{2} - 1}e^{-t}\mathrm{d}t \<br>&amp;&#x3D; \dfrac{2^{k &#x2F; 2}\Gamma(\frac{n + k}{2})}{\Gamma(n &#x2F; 2)}<br>\end{aligned}<br>$$</p>
<h5 id="期望：-23"><a href="#期望：-23" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \dfrac{\sqrt{2}\Gamma(\frac{n + 1}{2})}{\Gamma(n &#x2F; 2)}<br>$$</p>
<h5 id="方差：-23"><a href="#方差：-23" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>E(X^{2}) &#x3D; \dfrac{2\Gamma(n &#x2F; 2 + 1)}{\Gamma(n &#x2F; 2)} &#x3D; n<br>$$</p>
<p>所以<br>$$<br>D(X) &#x3D; E(X^{2}) - E(X)^{2} &#x3D; n^{2} - E(X)^{2}<br>$$</p>
<h5 id="性质：-16"><a href="#性质：-16" class="headerlink" title="性质："></a>性质：</h5><h5 id="应用：-16"><a href="#应用：-16" class="headerlink" title="应用："></a>应用：</h5><h4 id="狄拉克分布"><a href="#狄拉克分布" class="headerlink" title="狄拉克分布"></a>狄拉克分布</h4><h4 id="多项式分布和迪利克雷分布"><a href="#多项式分布和迪利克雷分布" class="headerlink" title="多项式分布和迪利克雷分布"></a>多项式分布和迪利克雷分布</h4><h4 id="帕累托分布-布拉德福分布-Pareto-Distribution"><a href="#帕累托分布-布拉德福分布-Pareto-Distribution" class="headerlink" title="帕累托分布(布拉德福分布, Pareto Distribution)"></a>帕累托分布(布拉德福分布, Pareto Distribution)</h4><p>这个分布是是从大量真实世界的现象中发现的<a href="https://zh.wikipedia.org/wiki/%E5%86%AA%E5%AE%9A%E5%BE%8B">幂定律</a>分布。这个分布在经济学以外，也被称为<strong>布拉德福分布</strong>。</p>
<h5 id="分布函数：-10"><a href="#分布函数：-10" class="headerlink" title="分布函数："></a>分布函数：</h5><p>$$<br>P(X &gt; x) &#x3D; \left(\dfrac{x}{x_{\min}} \right)^{-k}<br>$$</p>
<p>其中，x 是任何一个大于 $x_{\min}$ 的数，$x_{\min}$ 是 X 最小的可能值(正数)。</p>
<h5 id="概率密度："><a href="#概率密度：" class="headerlink" title="概率密度："></a>概率密度：</h5><p>$$<br>\begin{aligned}<br>p(x) &#x3D; \begin{cases}<br>0 \quad x &lt; x_{\min} \<br>\<br>\<br>\dfrac{kx_{\min}^{k}}{x^{k + 1}} \quad x &gt; x_{\min}</p>
<p>\end{cases}<br>\end{aligned}<br>$$</p>
<p>帕累托分布属于连续概率分布。「齐夫定律」也被称为「Zeta 分布」，也可以被认为是在离散概率分布中的帕累托分布。</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026223709526.png" alt="image-20231026223709526"></p>
<h5 id="期望：-24"><a href="#期望：-24" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \int_0^{+\infty} x\cdot f(x) \mathrm{d}x &#x3D; \dfrac{x_\min k}{k - 1}<br>$$</p>
<h5 id="方差：-24"><a href="#方差：-24" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{x_\min}{k - 1}\sqrt{\dfrac{k}{k - 2}}<br>$$</p>
<h5 id="应用：-17"><a href="#应用：-17" class="headerlink" title="应用："></a>应用：</h5><ol>
<li>财富在个人之间的分布</li>
<li>人类居住区的大小</li>
<li>对维基百科条目的访问</li>
<li>接近绝对零度时，玻色一爱因斯坦疑聚的团簇</li>
<li>在互联网流量中文件尺寸的分布</li>
<li>油田的石油储备数量</li>
<li>龙卷风带来的灾难的数量</li>
</ol>
<h5 id="引申："><a href="#引申：" class="headerlink" title="引申："></a>引申：</h5><p>帕累托法则(Pareto Principle)，或者叫做「二八定律」，「关键少数法则」，「巴莱多定律」。这个定律指出，约仅有 20% 的因素影响了 80% 的结果。也就是说，所有变因中，最重要的仅有 20%，虽然剩余的 80% 占了大多数。</p>
<h4 id="反正弦分布-Arcsin-Distribution"><a href="#反正弦分布-Arcsin-Distribution" class="headerlink" title="反正弦分布(Arcsin Distribution)"></a>反正弦分布(Arcsin Distribution)</h4><h5 id="符号：-X-sim-text-arcsin-x"><a href="#符号：-X-sim-text-arcsin-x" class="headerlink" title="符号：$X \sim \text{arcsin}(x)$"></a>符号：$X \sim \text{arcsin}(x)$</h5><h5 id="概率密度函数：-17"><a href="#概率密度函数：-17" class="headerlink" title="概率密度函数："></a>概率密度函数：</h5><p>$$<br>f(x) &#x3D; \dfrac{1}{\pi \sqrt{x(1 - x)}} \quad 0 &lt; x &lt; 1<br>$$</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026220704838.png" alt="image-20231026220704838"></p>
<h5 id="累计分布函数："><a href="#累计分布函数：" class="headerlink" title="累计分布函数："></a>累计分布函数：</h5><p>$$<br>F(x) &#x3D; P(X \leq x) &#x3D; \dfrac{\pi + 2\arcsin(2x - 1)}{2\pi}<br>$$</p>
<h5 id="期望：-25"><a href="#期望：-25" class="headerlink" title="期望："></a>期望：</h5><p>$$<br>E(X) &#x3D; \dfrac{1}{2}<br>$$</p>
<h5 id="方差：-25"><a href="#方差：-25" class="headerlink" title="方差："></a>方差：</h5><p>$$<br>D(X) &#x3D; \dfrac{1}{8}<br>$$</p>
<h5 id="性质：-17"><a href="#性质：-17" class="headerlink" title="性质："></a>性质：</h5><p>对于积分 $\int_{a}^{b}\dfrac{\mathrm{d}x}{\sqrt{(x - a)(b - x)}}$ 它的结果是$\pi$</p>
<p>对于这样类型的积分，我们一般是通过换元进行计算 $x  &#x3D;a\cos^{2}\theta + b\sin^{2}\theta$，那么原来的积分可以变为一个简单的积分：<br>$$<br>\int_a^{b}\dfrac{\mathrm{d}x}{\sqrt{(x - a)(b - x)}} &#x3D; 2\int_0^{\frac{\pi}{2}} \mathrm{d}\theta &#x3D; \pi<br>$$<br>对于这个式子的含义继续深究</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026221614582.png" alt="image-20231026221614582"></p>
<p>所以原来的定积分就正好代表了上半圆的弧长，也就是整个圆的半周长。</p>
<p><img src="C:\Users\24964\AppData\Roaming\Typora\typora-user-images\image-20231026221707845.png" alt="image-20231026221707845"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/517424307">https://zhuanlan.zhihu.com/p/517424307</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/164883777">https://zhuanlan.zhihu.com/p/164883777</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/449733211">常见分布的数学期望和方差及相关证明 - 知乎 (zhihu.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/578567547">https://zhuanlan.zhihu.com/p/578567547</a> 特征函数推导</p>
<p><a href="https://zhuanlan.zhihu.com/p/353187472">https://zhuanlan.zhihu.com/p/353187472</a> <a href="https://www.zhihu.com/question/354825596/answer/893242882">https://www.zhihu.com/question/354825596/answer/893242882</a> 指数分布</p>
<p><a href="https://zhuanlan.zhihu.com/p/503557666">https://zhuanlan.zhihu.com/p/503557666</a> 正态分布</p>
<p>怎么来理解伽玛（gamma）分布？ - 知之的回答 - 知乎 <a href="https://www.zhihu.com/question/34866983/answer/60191363">https://www.zhihu.com/question/34866983/answer/60191363</a> 伽马分布和其他分布之间的关系</p>
<p>伽马分布，指数分布，卡方分布之间的关系及期望，方差 - 拾柒的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/379131967">https://zhuanlan.zhihu.com/p/379131967</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/303359921">深入理解高斯分布 - 知乎 (zhihu.com)</a> 多元高斯分布</p>
<p><a href="https://zhuanlan.zhihu.com/p/596023351">混合高斯分布与其参数估计 - 知乎 (zhihu.com)</a> 混合高斯分布</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出 PyTorch</title>
    <url>/2024/02/19/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-PyTorch/</url>
    <content><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>Jupyter notebook&#x2F;Lab 简述</p>
<p>在数据科学、机器学习和深度学习中，我们希望即使进行图像的可视化和函数的计算，基于这种需求，人们开发出来了基于网页的用于交互计算的应用程序 Jupyter Notebook。在 Jupyter Notebook 中编写的文档保存为 <code>.ipynb</code> 格式文件，文档可以导出为 HTML、Latex、markdown、pdf 等格式。</p>
<p>除此之外，Jupyter Notebook 还有一个双胞胎–Jupyter Lab。可以当作是一个进化版的 Jupyter Notebook。</p>
<h4 id="PyTorch-简介"><a href="#PyTorch-简介" class="headerlink" title="PyTorch 简介"></a>PyTorch 简介</h4><p>PyTorch 是由 Facebook 开发的一个深度学习工具或者说框架，具有简单、高效和扩展性好的特点。TensorFlow 早年比较流行，但是后来逐渐被 PyTorch 占有更多的份额</p>
<h4 id="PyTorch-基础知识"><a href="#PyTorch-基础知识" class="headerlink" title="PyTorch 基础知识"></a>PyTorch 基础知识</h4><p>scalar 一个标量；vector 向量；Matrix 矩阵；Tensor 张量（维度是不限的）</p>
<p>张量并非是 PyTorch 才有的概念，数学中它有明确的定义，但是它是 PyTorch 中运算的基本单元。</p>
]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>现代优化算法</title>
    <url>/2023/08/25/%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>20 世纪 70 年代初期，随着计算复杂性的理论逐步形成，科学工作者发现并证明了大量来源于实际生活中的组合最优化问题是非常难解的，即所谓的 NP 完全问题和 NP 难问题。<br>80 年代一些现代化优化算法，如遗传算法、模拟退火算法、人工神经网络算法等。这些算法可以比较容易的解决一些复杂的、常规算法很难解决的问题。</p>
<h4 id="遗传算法-Genetic-Algorithm-GA"><a href="#遗传算法-Genetic-Algorithm-GA" class="headerlink" title="遗传算法(Genetic Algorithm, GA)"></a>遗传算法(Genetic Algorithm, GA)</h4>]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树永久化标记</title>
    <url>/2023/11/27/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%B0%B8%E4%B9%85%E5%8C%96%E6%A0%87%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="一些优势"><a href="#一些优势" class="headerlink" title="一些优势"></a>一些优势</h4><ol>
<li><p>时间效率。使用永久化标记无需再去 <code>push_down</code> 和 <code>push_up</code>，所以常数可能会小一点。</p>
</li>
<li><p>空间效率。标记永久化可以降低区间修改的时间复杂度。</p>
</li>
<li><p>支持撤销操作。可以使得我们方便地对于之前的操作进行撤销，因为我们并没有在最基础的数据上进行修改(比较 <code>push_down</code> 和 <code>push_up</code> 操作的话，都是在原来的数据上操作，不可撤销)</p>
</li>
<li><p>方便版本管理，我们可以很方便地回溯到某一个版本。</p>
</li>
</ol>
<p>可以参考例题：<a href="https://acm.hdu.edu.cn/showproblem.php?pid=4348">https://acm.hdu.edu.cn/showproblem.php?pid=4348</a> 来理解这个可持久化的时候我们需要使用永久化标记。</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>网管会</title>
    <url>/2023/10/28/%E7%BD%91%E7%AE%A1%E4%BC%9A/</url>
    <content><![CDATA[<p>ipconfig&#x2F;all 命令可以看一下网络的配置</p>
<p>一般来说 ip 地址都是一个设备一个，但是可以有多张网卡，多个设备？</p>
<p>路由器一个地址？手机和路由器地址之间的关系？</p>
<p>2011 年 IPV4 已经使用完了，我们开始使用 IPV6</p>
<h4 id="逐渐推广的-IPV6"><a href="#逐渐推广的-IPV6" class="headerlink" title="逐渐推广的 IPV6"></a>逐渐推广的 IPV6</h4><p>每组中的前导 0 都可以省略，连续两个或者多个均为 0，使用 :: 代替，但是只能使用一个</p>
<h4 id="IPV4-和-IPV6-如何过渡？"><a href="#IPV4-和-IPV6-如何过渡？" class="headerlink" title="IPV4 和 IPV6 如何过渡？"></a>IPV4 和 IPV6 如何过渡？</h4><h4 id="子网掩码-子网划分-前缀长度"><a href="#子网掩码-子网划分-前缀长度" class="headerlink" title="子网掩码 &#x2F; 子网划分 &#x2F; 前缀长度"></a>子网掩码 &#x2F; 子网划分 &#x2F; 前缀长度</h4><h4 id="DOH-DOT"><a href="#DOH-DOT" class="headerlink" title="DOH DOT"></a>DOH DOT</h4><p>外网、内网？</p>
<h4 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h4><p>网络是分层的？</p>
<p>QQ 上的去，但是网页上不去</p>
<p>校园网登录地址？</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>交换机 AC + AP</p>
<p>如果统一反应网络问题，可能是总层楼的交换机坏掉了。</p>
<h4 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h4><p>V4 下载 60 上传 100<br>V6 都是千兆的</p>
<p>Steam 下载很快，但是下载别的东西很慢，内网？？</p>
<h4 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h4><p>中国流量商用的很贵，很多都想来换取流量？京东云？</p>
<h4 id="路由追踪"><a href="#路由追踪" class="headerlink" title="路由追踪"></a>路由追踪</h4><h4 id="网线-双绞线"><a href="#网线-双绞线" class="headerlink" title="网线(双绞线)"></a>网线(双绞线)</h4><p>网线的连接标准有两种，T568A 和 T568B</p>
<p>双绞线的好处？</p>
<p>PoE 网线连接的时候同时有一个供电？一般是 48V。标准 PoE 和非标准 PoE</p>
<p>多 AP 方案无线漫游协议</p>
<p>无线加密：wpa2、AES 加密算法</p>
<h4 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h4><p>如果 IPV4 地址是以 169.254 开头说明没有获取到 ip 地址。因为这是 windows 通过 DHCP 自动生成的地址。</p>
<h4 id="OSI-七层网络模型"><a href="#OSI-七层网络模型" class="headerlink" title="OSI 七层网络模型"></a>OSI 七层网络模型</h4><h4 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h4><ol>
<li>下周六前提交</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>组合优化与随机性模型</title>
    <url>/2023/08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在有限个可行解集合中找出最优解，这类问题称为组合优化问题。如最短路径问题、最小连接问题、分配问题、运输问题、服务点设置问题、中国邮递员问题、背包问题、装箱问题等等。</p>
<p>贪心法和分支定界法是组合优化问题中常见的两种有效的方法。</p>
<h4 id="随机性模型"><a href="#随机性模型" class="headerlink" title="随机性模型"></a>随机性模型</h4><ol>
<li>报童问题<br> 一个分区间讨论收益的问题（可以抽象为类似的生产或者进货然后销售求最大收益的问题），下面的问题建模对于未出售完的报纸进行退回（可以抽象为低价处理）。<br> 设没份报纸的进价为 b，零售价为 a，退回价格为 c，报童应该如何购进报纸数量以获得最高的收入？ <img src="/2023/08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%8A%A5%E7%AB%A5%E9%97%AE%E9%A2%98.png" class="" title="收入和 n 的函数关系">
 假设需求量 r 的分布为 $P{r &#x3D; k} &#x3D; f(k), k &#x3D; 0, 1, 2, …$<br> 但是注意到 G 是一个<strong>随机目标函数</strong>，求其最大值没有什么意义，我们转为求解其最大期望。<br> $\overline{G}(n) &#x3D; \sum\limits_{r &#x3D; 0}^{n}[(a - b)r - (b - c)(n - r)]f(r) + \sum\limits_{r &#x3D; n + 1}^{+\infty} (a-b)nf(r)$，<strong>该问题很难求解，可以将上述函数进行连续化</strong>（数列求和和积分之间的转化使问题求解简单），可以得到 $\overline{G}(n) &#x3D; \int_0^{n}[(a - b)r - (b - c)(n - r)]f(r)\mathrm{d}r + \int_{n + 1}^{+\infty} (a - b)nf(r)\mathrm{d}r$，所求问题变为 $\max \overline{G}(n)$，求导，导数为 0，得到 $\int_0^{n} f(r)\mathrm{d}r &#x3D; \frac{a- b}{a - c}$ 的时候，期望收益最大。</li>
<li>轧钢中的浪费问题<br> 由于收到环境技术的影响，得到的钢材的长度是随机的，其数值上大体呈正态分布，均值可以通过调整轧机设定，而均方误差是由设备的精度决定的，不能随意改变。如果粗轧后的钢材长度大于规定长度，精轧时要把多余的部分切除，造成浪费；而如果粗轧后的钢材长度小于规定长度，则造成整根浪费。（一般我们不会利用多余的切除部分再次制作成钢材，因为实际生产中钢材长度 $l &gt;&gt; \sigma$）<br> 这样我们有模型总的平均浪费长度：<br> $W &#x3D; \int_{l}^{+\infty} (x - l)f(x)\mathrm{d}x + \int_{-\infty}^{l} xf(x) \mathrm{d}x &#x3D; \int_{-\infty}^{+\infty}xf(x)\mathrm{d}x - l\int_{-\infty}^{+\infty} f(x)\mathrm{d}x $<br> $ &#x3D; E(X) - lP{X &gt; l} &#x3D; m - lp$<br> 其中，$p &#x3D; P{X &gt; l} &#x3D; 1 - \Phi(\frac{l - m}{\sigma})$<br> 但是上式中，W 的含义是没轧一根钢材平均浪费的长度，这是从<strong>最终的产量分析浪费量</strong>；但是从实际中一个工厂的发展来看，工厂追求的是效益，可以由生产一根成品钢材浪费的平均长度来衡量，所以目标函数修改为：<br> $J &#x3D; \frac{W}{P{X &gt; l}} &#x3D; \frac{m - lp}{p}&#x3D; \dfrac{m}{1 - \Phi(\frac{l - m}{\sigma}) - l}$，决策目标为 $\min J(m)$</li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>自用博客维护规范</title>
    <url>/2023/11/18/%E8%87%AA%E7%94%A8%E5%8D%9A%E5%AE%A2%E7%BB%B4%E6%8A%A4%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h4 id="markdown-书写规范"><a href="#markdown-书写规范" class="headerlink" title="markdown 书写规范"></a>markdown 书写规范</h4><h4 id="数学公式书写规范"><a href="#数学公式书写规范" class="headerlink" title="数学公式书写规范"></a>数学公式书写规范</h4><h4 id="tag-标签规范"><a href="#tag-标签规范" class="headerlink" title="tag 标签规范"></a>tag 标签规范</h4><ol>
<li><p>首字母大写（非特殊情况下）。</p>
</li>
<li><p>如果有多个标签，每行一个，多行分开，并且每一行以 <code>-</code> 开头。</p>
</li>
</ol>
<h4 id="列举"><a href="#列举" class="headerlink" title="列举"></a>列举</h4><p>尤其是列举内容较多时，要保证格式</p>
<h4 id="文章名字"><a href="#文章名字" class="headerlink" title="文章名字"></a>文章名字</h4><ol>
<li><p>英文字母开头，首字母大写（非特殊情况下）</p>
</li>
<li><p>英文单词和汉字之间空格</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Standard</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队算法</title>
    <url>/2023/08/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>莫队</strong>，是莫涛发明的一种解决区间查询等问题的 <strong>离线算法</strong>，基于 <strong>分块</strong> 思想，复杂度为 $O(n\sqrt{n})$</p>
<p>一般来说，如果可以在 $O(1)$ 内从 $[l, r]$ 的答案转移到 $[l - 1, r]、[l + 1, r]、[l, r - 1]、[l, r + 1]$ 这四个与之紧邻的区间的答案，则可以考虑使用莫队。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/SP3267">DQUERY - D-query - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>HH 的项链弱化版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, vis[M], bel[N], a[N], st[N], ed[N], cnt[M], ans[N];</span><br><span class="line"><span class="type">int</span> l, r, cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; q[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        st[i] = n / len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[len] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? bel[x.r] &lt; bel[y.r] : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --cnt[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>();</span><br><span class="line">        q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].num = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) </span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) </span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        ans[q[i].num] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="莫队算法的扩展-——-带修莫队"><a href="#莫队算法的扩展-——-带修莫队" class="headerlink" title="莫队算法的扩展 —— 带修莫队"></a>莫队算法的扩展 —— 带修莫队</h3><p>前面说过，莫队算法是离线算法，不支持修改，强制在线需要另寻他法。但是对于某些允许离线的带修改区间查询来说，莫队还是能大展拳脚的。做法就是把莫队直接加上一维，变为带修莫队。</p>
<p>我们的做法是把修改操作编号，称为「时间戳」。</p>
<p>跑主算法时定义当前时间戳为 t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</p>
<p><strong>跑主算法时定义当前时间戳为 t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</strong></p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>[P1903 <a href="https://www.luogu.com.cn/problem/P1903">国家集训队] 数颜色 &#x2F; 维护队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">133335</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, bel[N], st[N], ed[N], a[N], len;</span><br><span class="line"><span class="type">int</span> cnt_1, cnt_2, vis[M], ans[N], cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_1</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q1[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">&#125; q2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    len = sqrt(n);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i) &#123;</span></span><br><span class="line"><span class="comment">        st[i] = n / len * (i - 1) + 1;</span></span><br><span class="line"><span class="comment">        ed[i] = n / len * i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ed[len] = n;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i)</span></span><br><span class="line"><span class="comment">        for (int j = st[i]; j &lt;= ed[i]; ++j)</span></span><br><span class="line"><span class="comment">            bel[j] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">ceil</span>((<span class="type">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        st[i] = len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question_1 x, Question_1 y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? (bel[x.r] == bel[y.r] ? x.time &lt; y.time : bel[x.r] &lt; bel[y.r]) : bel[x.l] &lt; bel[y.l]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++vis[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --vis[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q1[++cnt_1].l = x;</span><br><span class="line">            q1[cnt_1].r = y;</span><br><span class="line">            q1[cnt_1].time = cnt_2;</span><br><span class="line">            q1[cnt_1].id = cnt_1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q2[++cnt_2].col = y;</span><br><span class="line">            q2[cnt_2].pos = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;no error&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q1 + <span class="number">1</span>, q1 + <span class="number">1</span> + cnt_1, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q1[i].l)</span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q1[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q1[i].l)</span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q1[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q1[i].time) &#123;</span><br><span class="line">            ++t;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q1[i].time) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">            --t;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q1[i].id] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一道题目块的大小取得 $n^{\frac{2}{3}} $ 时时间复杂度最小。如果还是 $\sqrt{n}$ 的话，会超时。</p>
<h3 id="莫队算法的扩展-——-树上莫队"><a href="#莫队算法的扩展-——-树上莫队" class="headerlink" title="莫队算法的扩展 —— 树上莫队"></a>莫队算法的扩展 —— 树上莫队</h3><p>前面我们所使用的莫队都是在一维的序列上进行，即使加了一维的时间轴，但是主题还是一维序列。那么树上统计问题能否用莫队来处理呢？答案是肯定的。</p>
<p>但是普通的 dfs 序没有办法确定一个对应区间</p>
<p>使用 <strong>欧拉序</strong>，可以解决许多普通 dfs 序无法解决的问题（就比如树上莫队）。</p>
<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230723182411099.png" alt="image-20230723182411099"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, cur, cnt, tot, date[N], a[N], dep[N], top[N], fa[N], bel[N &lt;&lt; <span class="number">1</span>], siz[N], son[N], head[N], st[N &lt;&lt; <span class="number">1</span>], ed[N &lt;&lt; <span class="number">1</span>], id[N], fir[N], las[N], use[N &lt;&lt; <span class="number">1</span>], ans[M], cot[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> lca;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">&#125; q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++cnt].nxt = head[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    fir[x] = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to, x);</span><br><span class="line">        siz[x] += siz[to];</span><br><span class="line">        <span class="keyword">if</span> (siz[to] &gt; Max) &#123;</span><br><span class="line">            Max = siz[to];</span><br><span class="line">            son[x] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    las[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[x] = tp;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == fa[x] || to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (++cot[pos] == 1) cur++;</span></span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cot[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (--cot[pos] == 0) cur--;</span></span><br><span class="line">    --cot[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;this is a test&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//use[pos] ? del(a[pos]) : add(a[pos]);</span></span><br><span class="line">    <span class="comment">//use[pos] ^= 1;</span></span><br><span class="line">    use[pos] ? <span class="built_in">del</span>(pos) : <span class="built_in">add</span>(pos);</span><br><span class="line">    use[pos] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = date[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> num = std::<span class="built_in">unique</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n) - date - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n, a[i]) - date;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i)</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int x, y;</span></span><br><span class="line">    <span class="type">int</span> ancestor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (fir[x] &gt; fir[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        ancestor = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        <span class="keyword">if</span> (ancestor == x) &#123;</span><br><span class="line">            q[i].l = fir[x]; <span class="comment">// 欧拉序中的位置</span></span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = las[x];</span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">            q[i].lca = ancestor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp2);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">        q[i].ans = cur;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;htih&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans[q[i].id] = q[i].ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="莫队算法的扩展——回滚莫队"><a href="#莫队算法的扩展——回滚莫队" class="headerlink" title="莫队算法的扩展——回滚莫队"></a>莫队算法的扩展——回滚莫队</h3><p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230724130521246.png" alt="image-20230724130521246"></p>
<p>感觉细节有一些多，比较麻烦的</p>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/AT_joisc2014_c">AT_joisc2014_c 歴史の研究</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll n, m, Max, tot, a[N], b[N], st[N], ed[N], bel[N], ans[N], cnt[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">    Max = std::<span class="built_in">max</span>(Max, cnt[a[pos]] * b[a[pos]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// split block </span></span><br><span class="line">    ll block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        st[i] = n / block * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / block * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[block] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort question </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(), q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mo</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> l;</span><br><span class="line">        <span class="type">int</span> r = ed[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span> (cnt));</span><br><span class="line">        Max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (bel[q[p].l] == i) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;sdasda&quot;;</span></span><br><span class="line">            <span class="comment">//Max = -1;</span></span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            l = ed[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bel[q[p].l] == bel[q[p].r]) &#123;</span><br><span class="line">                ll cur = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = q[p].l; j &lt;= q[p].r; ++j) &#123;</span><br><span class="line">                    ++cnt[a[j]];</span><br><span class="line">                    c[++tot] = a[j];</span><br><span class="line">                    Max = std::<span class="built_in">max</span>(Max, cnt[a[j]] * b[a[j]]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[q[p].id] = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">                    --cnt[c[j]];</span><br><span class="line">                ++p;</span><br><span class="line">                Max = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[p].r)</span><br><span class="line">                <span class="built_in">add</span>(++r);</span><br><span class="line">            ll cur = Max;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;cur: &quot; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[p].l)</span><br><span class="line">                <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[p].id] = Max;</span><br><span class="line">            Max = cur;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= ed[i]) </span><br><span class="line">                --cnt[a[l++]];</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230725000620621.png" alt="image-20230725000620621"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/WAMonster/p/10118934.html">莫队算法——从入门到黑题 - WAMonster - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/115243708">算法学习笔记(24): 莫队 - 知乎 (zhihu.com)</a></p>
<p>OIwiki</p>
]]></content>
  </entry>
  <entry>
    <title>随机数</title>
    <url>/2023/10/07/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h5 id="线性同余法"><a href="#线性同余法" class="headerlink" title="线性同余法"></a>线性同余法</h5><p>线性同余法是目前应用广泛的<strong>伪随机数生成算法</strong>。基本思想是对于一个数进行线性运算并取模从而得到下一个数，递归公式为：$x_{n+1}&#x3D;(ax_n+c) \pmod{m}, y_{n + 1} &#x3D; x_{n+1}&#x2F;m$</p>
<p>线性同余法的最大周期是 m，但是一般情况下会小于 m，如果要使得周期达到最大，应该满足：</p>
<ol>
<li>c 和 m 互质</li>
<li>m 所有质因子的积能整除 a-1</li>
<li>a c 初值都比 m 小</li>
<li>a c 是正整数</li>
</ol>
<h5 id="梅森旋转法"><a href="#梅森旋转法" class="headerlink" title="梅森旋转法"></a>梅森旋转法</h5><p>梅森旋转法也是一种伪随机数产生算法。</p>
<h5 id="密码学安全随机数生成器"><a href="#密码学安全随机数生成器" class="headerlink" title="密码学安全随机数生成器"></a>密码学安全随机数生成器</h5><h5 id="硬件随机数生成器"><a href="#硬件随机数生成器" class="headerlink" title="硬件随机数生成器"></a>硬件随机数生成器</h5>]]></content>
  </entry>
  <entry>
    <title>矩阵求导</title>
    <url>/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h4 id="向量变元的实值函数"><a href="#向量变元的实值函数" class="headerlink" title="向量变元的实值函数"></a>向量变元的实值函数</h4><p>单纯的对于<strong>向量</strong>求导和实数的求导大同小异，也是常数为 0，乘法有链式法则，除法的形式也是一样的。<br>其中有行向量形式和列向量形式（也叫做<strong>梯度向量形式</strong>，记作 $\nabla _{x}f(\boldsymbol{x})$）<br>然后就是几个比较重要的常见公式</p>
<h4 id="几个重要的向量变元求导公式"><a href="#几个重要的向量变元求导公式" class="headerlink" title="几个重要的向量变元求导公式"></a>几个重要的向量变元求导公式</h4><p>符合分子布局或者分母布局的形式(谁是列向量就是什么布局)</p>
<img src="/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC.png" class="" title="矩阵求导公式">

<h4 id="矩阵变元的实值函数"><a href="#矩阵变元的实值函数" class="headerlink" title="矩阵变元的实值函数"></a>矩阵变元的实值函数</h4><p>实值函数的求导其实还是比较容易理解的。对于矩阵变元无非是对于矩阵中每一个元素求导。<br>和对于向量变元的实值函数求导差不多，也是有着四个求导法则，分别对应常数、线性相加、乘法和商。</p>
<h4 id="几个重要的矩阵变元的求导公式"><a href="#几个重要的矩阵变元的求导公式" class="headerlink" title="几个重要的矩阵变元的求导公式"></a>几个重要的矩阵变元的求导公式</h4><img src="/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E5%8F%98%E5%85%83%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F.png" class="" title="矩阵变元常用求导公式">

<h4 id="更详细证明了解链接"><a href="#更详细证明了解链接" class="headerlink" title="更详细证明了解链接"></a>更详细证明了解链接</h4><p>比较懒，贴几个链接，更深的内容可以看 <strong>矩阵分析</strong> 相关的书籍。<br><a href="https://www.zhihu.com/question/352174717/answer/1436808747">https://www.zhihu.com/question/352174717/answer/1436808747</a><br><a href="https://zhuanlan.zhihu.com/p/263777564">https://zhuanlan.zhihu.com/p/263777564</a><br><a href="https://zhuanlan.zhihu.com/p/273729929">https://zhuanlan.zhihu.com/p/273729929</a><br>讲解最小二乘法的高维形式 <a href="https://zhuanlan.zhihu.com/p/38128785">https://zhuanlan.zhihu.com/p/38128785</a></p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>跳表(skiplist)</title>
    <url>/2023/10/30/%E8%B7%B3%E8%A1%A8-skiplist/</url>
    <content><![CDATA[<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipListNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        std::vector&lt;SkipListNode*&gt; nxt;</span><br><span class="line">        <span class="built_in">SkipListNode</span>(<span class="type">int</span> val, <span class="type">int</span> level)</span><br><span class="line">            : <span class="built_in">value</span>(val)</span><br><span class="line">            , <span class="built_in">nxt</span>(level, <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Skiplist</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxLevel = <span class="number">32</span>;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    SkipListNode* head;</span><br><span class="line">    <span class="built_in">Skiplist</span>() &#123;</span><br><span class="line">        level = <span class="number">1</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">SkipListNode</span>(<span class="number">0</span>, maxLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (level &lt; maxLevel &amp;&amp; (<span class="built_in">rand</span>() % <span class="number">2</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; target) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &amp;&amp; current-&gt;nxt[<span class="number">0</span>] &amp;&amp; current-&gt;nxt[<span class="number">0</span>]-&gt;value == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;SkipListNode*&gt; <span class="title">update</span><span class="params">(maxLevel, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; num) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> newLevel = <span class="built_in">randomLevel</span>();</span><br><span class="line">        <span class="keyword">if</span> (newLevel &gt; level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = level; i &lt; newLevel; ++i) &#123;</span><br><span class="line">                update[i] = head;</span><br><span class="line">            &#125;</span><br><span class="line">            level = newLevel;</span><br><span class="line">        &#125;</span><br><span class="line">        SkipListNode* newNode = <span class="keyword">new</span> <span class="built_in">SkipListNode</span>(num, newLevel);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; newLevel; ++i) &#123;</span><br><span class="line">            newNode-&gt;nxt[i] = update[i]-&gt;nxt[i];</span><br><span class="line">            update[i]-&gt;nxt[i] = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        SkipListNode* current = head;</span><br><span class="line">        <span class="function">std::vector&lt;SkipListNode*&gt; <span class="title">update</span><span class="params">(maxLevel, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current-&gt;nxt[i] &amp;&amp; current-&gt;nxt[i]-&gt;value &lt; num) &#123;</span><br><span class="line">                current = current-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            update[i] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!current || !current-&gt;nxt[<span class="number">0</span>] || current-&gt;nxt[<span class="number">0</span>]-&gt;value != num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;nxt[<span class="number">0</span>] &amp;&amp; current-&gt;nxt[<span class="number">0</span>]-&gt;value == num) &#123;</span><br><span class="line">            SkipListNode* toRemove = current-&gt;nxt[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (update[i]-&gt;nxt[i] != toRemove) &#123; <span class="comment">// 不能直接判断 value 因为可能出现多个相同数值的情况</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                update[i]-&gt;nxt[i] = toRemove-&gt;nxt[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> toRemove;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 更新 level</span></span><br><span class="line">        <span class="keyword">while</span> (level &gt; <span class="number">1</span> &amp;&amp; head-&gt;nxt[level - <span class="number">1</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">            level--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://github.com/youngyangyang04/Skiplist-CPP/blob/master/skiplist.h">https://github.com/youngyangyang04/Skiplist-CPP/blob/master/skiplist.h</a><br><a href="https://www.luogu.com.cn/problem/solution/P3369?page=2">https://www.luogu.com.cn/problem/solution/P3369?page=2</a><br>leetcode 跳表题解<br><a href="https://yuerblog.cc/2019/02/13/skiplist-rank/">https://yuerblog.cc/2019/02/13/skiplist-rank/</a> 实现 rank</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>规划论模型</title>
    <url>/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>规划论模型也成为运筹与优化模型，在实际问题的建模中应用最为广泛，涉及面较广。</p>
<h4 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h4><p>通常对于只有两个决策变量的情形，可以使用图解法加以求解。而对于大于两个决策变量的情形，需要借助单纯形方法加以求解。单纯形方法的基本思想是迭代思想的一种体现。首先找到初始可行解，并通过迭代逐步从可行域的一个顶点走向另一个顶点，最终走到最优解。</p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/linprog.png" class="">
<p>下面的例题：</p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/problem1.jpg" class="">
<p>其中，求 max，所以我们把 z 的系数取反。第二个不等式是大于等于，我们也同样取反。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-1; -2; 3];</span><br><span class="line">A = [3 2 1; -4 -7 6];</span><br><span class="line">b = [6; -8];</span><br><span class="line">Aeq = [2 1 5];</span><br><span class="line">beq = [4];</span><br><span class="line">vlb = [0; 0; 0];</span><br><span class="line">vub= [];</span><br><span class="line">[x, fval] = linprog(f, A, b, Aeq, beq, vlb, vub)</span><br></pre></td></tr></table></figure>
<h5 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h5><p>较为常见的运输模型叙述如下：</p>
<blockquote>
<p>某物资有 m 个原产地 $A_i$，产量为 $a_i$；有 n 个销地 $B_j$，销量关系为 $b_j$，从 $A_i$ 到 $B_j$ 之间的单位物资运价为 $d_{ij}$，则产销平衡时有 $\sum\limits_{i &#x3D; 1}^{m}a_i &#x3D; \sum\limits_{j &#x3D; 1}^{n} b_j$</p>
</blockquote>
<h5 id="多目标规划问题"><a href="#多目标规划问题" class="headerlink" title="多目标规划问题"></a>多目标规划问题</h5><p>在建立优化模型时有时追求的目标可能是多个，无论忽略其中的哪个因素可能都会降低优化结果的可信度。对于这类问题通常有下面的三种处理方式：</p>
<ol>
<li>为每个目标设置重要性权重。<br> 当存在 n 个目标时，首先对目标函数进行归一化处理（就是消除量纲的影响，进行标准统一）后分别设置自己的权重，假设第 i 个目标的权重为 $\alpha_i$，目标取值为 $M_i$，则可以建立下面的优化模型：$\max \alpha_1M_1 + \alpha_2M_2 + … + \alpha_nM_n$</li>
<li>为各种目标设定优先权，并将模型转化为多个优化模型。</li>
<li>分别求得个目标的最优值后，将主要目标设定为目标函数，而将次要目标适当调整后修改为约束条件。</li>
</ol>
<h4 id="适度指标的线性处理"><a href="#适度指标的线性处理" class="headerlink" title="适度指标的线性处理"></a>适度指标的线性处理</h4><p>适度指标是指该指标的他正是数据大了或者小了均不好，要充分地接近于某一事先给定的标准指标，比如水的 PH 值。<br>求 $\min |x - D|$，D 为数据指标的理想取值。<br>例题：<br>一个富豪准备拿 10 万元买股票。经过他的筛选，有三种候选投资股票。这三种股票的价格、收益率以及风险系数如表所示：</p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E8%82%A1%E7%A5%A8.png" class="">
<p>这是一个多规划问题，我们如果直接列两个不等式的话，可能存在无解的情况。所以我们可以采取上面所说的方法2，建立如下的两个不等式条件：</p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E7%AD%89%E5%BC%8F.png" class="">
<p>如果我们优先考虑投资的风险，就可以建立下面的线性规划模型：</p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">Aeq = [1 3 5 1 -1 0 0; 2 5 8 0 0 1 -1; 10 20 30 0 0 0 0];</span><br><span class="line">beq = [15000; 25000; 100000];</span><br><span class="line">f = zeros(7, 1);</span><br><span class="line">f(5) = 1;</span><br><span class="line">vlb = zeros(7, 1);</span><br><span class="line">vub = [];</span><br><span class="line">a = [];</span><br><span class="line">b = [];</span><br><span class="line">[x, y] = linprog(f, a, b, Aeq, beq, vlb, vub);</span><br><span class="line">fx = x(1) + 3 * x(2) + 5 * x(3)</span><br><span class="line">lr = 2 * x(1) + 5 * x(2) + 8 * x(3)</span><br></pre></td></tr></table></figure>

<h4 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h4><p>在线性规划模型中，如果各个决策变量的取值均为整数，则称此类模型为整数规划模型。<br>整数规划的解法主要有穷举法(变量维数较高时不可行)、舍入凑整法、分支定界法(比较可行)、割平面法(比较可行)等。</p>
<ol>
<li>舍入凑整法<br> 感觉很是玄学，就是假装没有整数约束，求解出最优解后每个变量往下或者上取整比较一下。</li>
<li>分支界定法<br> 如果不满足整数条件，任选一个不满足整数条件的变量来构造新的约束，在原可行域中剔除部分非整数解。然后，再在缩小的可行域中求解新构造的线性规划的最优解（好抽象）。<br> 步骤：<ol>
<li>解没有整数约束的问题。</li>
<li>定界</li>
<li>分支</li>
<li>修改上下界</li>
<li>比较与剪枝</li>
</ol>
</li>
</ol>
<h5 id="0-1-型整数规划"><a href="#0-1-型整数规划" class="headerlink" title="0-1 型整数规划"></a>0-1 型整数规划</h5><p>约束条件为 $0 \leq x_i \leq 1,x_i$ 为整数。这样就和一般的整数规划问题统一了。 </p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92.png" class="" title="整数规划求解函数">
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-3; 2; -5];</span><br><span class="line">intcon = [1, 2, 3]; % 表示哪几个变量为整数</span><br><span class="line">A = [1 2 -1; 1 4 1; 1 1 0; 4 0 1];</span><br><span class="line">b = [2; 4; 3; 6];</span><br><span class="line">Aeq = [];</span><br><span class="line">beq = [];</span><br><span class="line">lb = [0; 0; 0]; % 如果下界为 0 上界为 1，其实就是 0-1 整数规划了。</span><br><span class="line">rb = [1; 1; 1];</span><br><span class="line">[x, val] = intlinprog(f, intcon, A, b, Aeq, beq, lb, rb)</span><br></pre></td></tr></table></figure>

<h5 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h5><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98.png" class="" title="指派问题">
<p>当人数和任务的个数不同的时候，会出现某些人没有任务可做或者某些任务无人完成的情况。出现这两种情况的时候只需将约束条件中的某一个等于 1 的约束条件修改为小于等于 1 即可。有时也可以一对多（一个人多任务，一个任务多个人）。<br>2013 年碎纸片拼接复原问题 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cell&#123;1,1&#125;=imread(&#x27;000.bmp&#x27;);</span><br><span class="line">cell&#123;1,2&#125;=imread(&#x27;001.bmp&#x27;);</span><br><span class="line">cell&#123;1,3&#125;=imread(&#x27;002.bmp&#x27;);</span><br><span class="line">cell&#123;1,4&#125;=imread(&#x27;003.bmp&#x27;);</span><br><span class="line">cell&#123;1,5&#125;=imread(&#x27;004.bmp&#x27;);</span><br><span class="line">cell&#123;1,6&#125;=imread(&#x27;005.bmp&#x27;);</span><br><span class="line">cell&#123;1,7&#125;=imread(&#x27;006.bmp&#x27;);</span><br><span class="line">cell&#123;1,8&#125;=imread(&#x27;007.bmp&#x27;);</span><br><span class="line">cell&#123;1,9&#125;=imread(&#x27;008.bmp&#x27;);</span><br><span class="line">cell&#123;1,10&#125;=imread(&#x27;009.bmp&#x27;);</span><br><span class="line">cell&#123;1,11&#125;=imread(&#x27;010.bmp&#x27;);</span><br><span class="line">cell&#123;1,12&#125;=imread(&#x27;011.bmp&#x27;);</span><br><span class="line">cell&#123;1,13&#125;=imread(&#x27;012.bmp&#x27;);</span><br><span class="line">cell&#123;1,14&#125;=imread(&#x27;013.bmp&#x27;);</span><br><span class="line">cell&#123;1,15&#125;=imread(&#x27;014.bmp&#x27;);</span><br><span class="line">cell&#123;1,16&#125;=imread(&#x27;015.bmp&#x27;);</span><br><span class="line">cell&#123;1,17&#125;=imread(&#x27;016.bmp&#x27;);</span><br><span class="line">cell&#123;1,18&#125;=imread(&#x27;017.bmp&#x27;);</span><br><span class="line">cell&#123;1,19&#125;=imread(&#x27;018.bmp&#x27;);</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">level=graythresh(cell&#123;1,i&#125;);%选择灰度阈值</span><br><span class="line">cell1&#123;1,i&#125;=im2bw(cell&#123;1,i&#125;,level); %将图像二值化</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19                %循环19个图像</span><br><span class="line">    for k=1:19</span><br><span class="line">        xs(i,k)=0;</span><br><span class="line">        for j=1:1980</span><br><span class="line">            if (cell1&#123;1,i&#125;(j,72)==cell1&#123;1,k&#125;(j,1))%判断图像的边缘信息特征，求相似度矩阵</span><br><span class="line">                xs(i,k)=1+xs(i,k);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">    xs(i,i)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19 </span><br><span class="line">da(i)=max(xs(i,:));</span><br><span class="line">end</span><br><span class="line">wei=find(da==max(da));for i=1:19</span><br><span class="line">    k=find(xs(i,[1:19])==da(i));  %求两两相邻的矩阵</span><br><span class="line">    lian(i,1)=i;                  %前面一个</span><br><span class="line">    lian(i,2)=k;                  %后面一个</span><br><span class="line">end</span><br><span class="line">lian(wei,1)=0;</span><br><span class="line">tou=lian(wei,2);</span><br><span class="line">xu(1)=tou;</span><br><span class="line">for i=1:18</span><br><span class="line">    xu(i+1)=lian(xu(i),2);        %正确的排列顺序</span><br><span class="line">end</span><br><span class="line">%根据排出来顺序xu画图</span><br><span class="line">for i=1:19</span><br><span class="line">I(:,[72*(i-1)+1:72*i])=cell&#123;1,xu(i)&#125;;   %图像的整合</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">imwrite(I,&#x27;hanzi.jpg&#x27;,&#x27;quality&#x27;,100);</span><br><span class="line">imshow(&#x27;hanzi.jpg&#x27;)          %输出图像</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="选址问题"><a href="#选址问题" class="headerlink" title="选址问题"></a>选址问题</h5><p>集合覆盖选址模型和最大覆盖选址模型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>马克思主义基本原理关键记录</title>
    <url>/2023/12/20/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="导论章-马克思主义概述"><a href="#导论章-马克思主义概述" class="headerlink" title="导论章 马克思主义概述"></a>导论章 马克思主义概述</h3><ul>
<li><p>马克思主义的<strong>三个组成</strong>部分或者说马克思主义的主要内容：</p>
<ol>
<li>马克思主义哲学（理论的基础）</li>
<li>马克思主义政治经济学（理论的论证）</li>
<li>科学社会主义（理论的归宿）</li>
</ol>
</li>
<li><p>无产阶级在反抗资产阶级斗争中从<strong>自发走向自觉</strong>，作为独立的<strong>政治力量登</strong>上历史舞台，由此称为马克思主义的<strong>阶级基础</strong>。</p>
</li>
<li><p>19 世纪欧洲三大工人运动：</p>
<ol>
<li>法国里昂工人起义</li>
<li>英国宪章运动</li>
<li>德国西里西亚纺织工人起义</li>
</ol>
</li>
<li><p>马克思主义的<strong>基本原理</strong>体现了马克思主义的根本性质和整体特征，体现了马克思主义的科学性和革命性的统一。</p>
</li>
<li><p>马克思主义的创立背景：</p>
<ol>
<li>社会两极分化，工人极端困苦</li>
<li>周期性经济危机频繁爆发</li>
<li>无产阶级作为独立的政治力量登上历史舞台</li>
</ol>
</li>
<li><p>马克思主义的<strong>直接理论来源</strong>：</p>
<ol>
<li>德国古典哲学</li>
<li>英国古典政治经济学</li>
<li>英法空想社会主义</li>
</ol>
</li>
<li><p>马克思主义的<strong>自然科学前提</strong>：</p>
<ol>
<li>细胞学说</li>
<li>能量守恒与转化定律</li>
<li>生物进化论</li>
</ol>
</li>
<li><p>1848 年 2 月，《共产党宣言》发表，标志着<strong>马克思主义的公开问世</strong>。</p>
</li>
<li><p>马克思主义的<strong>基本特征</strong>：</p>
<ol>
<li>科学性</li>
<li>人民性</li>
<li>实践性</li>
<li>发展性</li>
</ol>
<p>后三者，又可以统称为 <strong>革命性</strong>。所以马克思主义将 <strong>科学性和革命性相结合。</strong></p>
<p>这些特征<strong>体现了马克思主义的本质和使命</strong>，也展现出马克思主义的理论形象。</p>
<p>用一句话概括马克思主义的基本特征，就是 <strong>科学性和革命性的统一</strong>。</p>
</li>
</ul>
<h3 id="第一章-辩证唯物主义世界观"><a href="#第一章-辩证唯物主义世界观" class="headerlink" title="第一章 辩证唯物主义世界观"></a>第一章 辩证唯物主义世界观</h3><ul>
<li><p>哲学的<strong>基本问题</strong>：</p>
<ol>
<li>存在和思维何者为第一性的问题</li>
<li>存在和思维有无同一性的问题</li>
</ol>
<p>对第一个问题的回答，形成了<strong>唯物主义和唯心主义</strong>对立的哲学派系，对第二个问题的回答，产生了可知论和不可知论的理论分野。</p>
<p>对哲学基本问题的回答是解决其他一切哲学问题的<strong>前提和基础</strong>。</p>
</li>
<li><p>唯物主义：</p>
<ol>
<li>古代朴素唯物主义（世界本原或本质是一种或几种具体的物质形态）</li>
<li>近代形而上学唯物主义（把哲学的物质概念和自然科学物质概念混为一谈，把物质等同于原子）</li>
<li>辩证唯物主义（抽象出哲学的物质概念）</li>
</ol>
<p>辩证唯物主义和旧唯物主义虽然都坚持反映论，认为认识是主体对客体的反映，但是两者之间又有着本质上的区别。旧唯物主义（即形而上学唯物主义）的认识论，把人的认识看成消极地、被动地反映外界对象</p>
</li>
<li><p>唯心主义：</p>
<ol>
<li>主观唯心主义<br>人的主观精神作为认识世界的出发点，认为物质世界是人的主观意识的体现或产物。<br>笛卡尔「我思故我在」、贝克莱「存在就是被感知，物是感觉的集合」</li>
<li>客观唯心主义<br>把世界的本原归结为某种独立存在的、客观的精神。<br>朱熹「理在事先」、黑格尔「绝对理念」</li>
</ol>
</li>
<li><p>辩证唯物主义物质意义 or 马克思主义的物质范畴具有深刻的意义：</p>
<ol>
<li>坚持了唯物主义一元论</li>
<li>坚持了能动的反映论和可知论</li>
<li>体现了唯物论和辩证法的统一</li>
<li>物质的<strong>根本属性</strong>是运动</li>
</ol>
<p>运动是物质的<strong>根本属性</strong>和<strong>存在方式</strong>。<br>客观实在性是物质的唯一特性</p>
</li>
<li><p>物质世界的运动是绝对的，运动是绝对的，静止是相对的。静止是事物运动的一种特殊状态。</p>
</li>
</ul>
<h4 id="物质和意识的辩证关系"><a href="#物质和意识的辩证关系" class="headerlink" title="物质和意识的辩证关系"></a>物质和意识的辩证关系</h4><ul>
<li>意识是人脑的机能和属性，是客观世界的主观映像。</li>
<li>物质对于意识的决定作用表现在意识的起源和本质上：<ol>
<li>意识是自然界长期发展的产物</li>
<li>意识也是社会历史发展的产物</li>
</ol>
</li>
<li>物质决定意识，意识对物质有反作用，这种反作用就是<strong>意识的能动作用</strong>。<br>意识的能动作用体现：（最核心的就是理解能动这一个词语）<ol>
<li>意识具有目的性和计划性</li>
<li>意识具有创造性</li>
<li>意识具有指导实践改造客观世界的作用（意识具有变革世界的作用）</li>
<li>意识具有调控人的行为和生理活动的作用</li>
</ol>
</li>
<li>意识是物质世界长期发展的产物，是人脑的机能和属性，是物质世界的主观映像。（三句话中，第三句话是最标准的解释）<br>意识的三个发展阶段：<ol>
<li>一切物质具有的反应特性到低等生物的刺激感应性（对应应激性？）</li>
<li>再到高等动物的感觉和心理（还没有到人，并且此时还不能叫做意识）</li>
<li>最终发展为人类的意识（<strong>所以，我们可以认为意识是人独有的</strong>）</li>
</ol>
</li>
<li>社会实践特别是劳动在意识的产生和发展中起着<strong>决定性作用</strong>，语言又促进了意识的发展，语言是意识的物质外壳（劳动和语言都是意识发展的因素，其余还有很多因素）</li>
</ul>
<h4 id="世界的物质统一性"><a href="#世界的物质统一性" class="headerlink" title="世界的物质统一性"></a>世界的物质统一性</h4><ul>
<li><p>马克思认为，<strong>世界的统一性在于它的物质性：</strong></p>
<ol>
<li>世界统一于物质：<ol>
<li>自然界是物质的，具有客观实在性</li>
<li>人类社会是物质的，具有客观实在性</li>
<li>意识是物质的产物和机能，从属于物质</li>
</ol>
</li>
<li>世界的物质统一性是多样性的统一</li>
<li>世界的物质统一性是在运动、变化、发展中的统一</li>
</ol>
</li>
<li><p>世界的<strong>物质统一性原理</strong>是辩证唯物主义 <strong>最基本、最核心</strong> 的观点，是马克思主义的基石。</p>
</li>
<li><p>唯物辩证法：用联系的、发展的、全面的观点去观察事物、认识事物和处理问题<br>形而上学：用孤立的、片面的、静止的观点去观察、认识事物和处理问题</p>
</li>
</ul>
<h4 id="事物的普遍联系和变化发展"><a href="#事物的普遍联系和变化发展" class="headerlink" title="事物的普遍联系和变化发展"></a>事物的普遍联系和变化发展</h4><ul>
<li><p><strong>联系和发展</strong>的观点是唯物辩证法的总观点。</p>
</li>
<li><p>发展的实质：新事物的产生和旧事物的灭亡</p>
</li>
<li><p>发展的原因：</p>
<ol>
<li>对立面的统一和斗争</li>
<li>新事物继承了旧事物合理的因素，并且添加了新的内容</li>
<li>新事物符合人民群众的根本利益</li>
</ol>
</li>
<li><p>发展的形式：</p>
<ol>
<li>形式上表现为事物在时间上的持续性、空间上的广延性的交替</li>
<li>内容上表现为事物在运动形式、状态、功能和关系上的更新</li>
</ol>
</li>
<li><p>联系的特点：</p>
<ol>
<li>客观性</li>
<li>普遍性</li>
<li>多样性</li>
<li>条件性</li>
</ol>
</li>
</ul>
<h4 id="矛盾的同一性和斗争性及其在事物发展中的作用"><a href="#矛盾的同一性和斗争性及其在事物发展中的作用" class="headerlink" title="矛盾的同一性和斗争性及其在事物发展中的作用"></a>矛盾的同一性和斗争性及其在事物发展中的作用</h4><ul>
<li><p>矛盾的基本属性：</p>
<ol>
<li>对立属性-斗争性</li>
<li>统一属性-同一性</li>
</ol>
</li>
<li><p>同一性体现：</p>
<ol>
<li>矛盾着的对立面相互依存、互为存在的前提（有无相生，难易相成）（静态的）</li>
<li>对立面相互贯通，在一定条件下可以相互转化（祸兮福所依，福兮祸所倚）（动态的）</li>
</ol>
<p>斗争性体现：矛盾着的对立面相互排斥、相互分离的趋势</p>
</li>
</ul>
<h4 id="矛盾的普遍性和特殊性及其在事物发展中的作用"><a href="#矛盾的普遍性和特殊性及其在事物发展中的作用" class="headerlink" title="矛盾的普遍性和特殊性及其在事物发展中的作用"></a>矛盾的普遍性和特殊性及其在事物发展中的作用</h4><ul>
<li><p>矛盾的普遍性和特殊性：<br>普遍性：</p>
<ul>
<li>矛盾存在于一切事物中，事事有矛盾</li>
<li>矛盾存在于一切事物的发展过程的始终，时时有矛盾</li>
</ul>
<p>特殊性：</p>
<ul>
<li>各个事物的具体矛盾、每一个矛盾的各个方面在发展的不同阶段上各有特点</li>
</ul>
</li>
<li><p>矛盾的地位和作用的不平衡原理为我们提供了「两点论」和「重点论」相结合的方法。</p>
<ul>
<li>两点论：<br>在研究复杂事物的发展过程中，既要看到主要矛盾，也要看到次要矛盾；在研究某一矛盾时，既要看到矛盾的主要方面，也要看到矛盾的次要方面</li>
<li>重点论：<br>在分析复杂事务的发展过程时，要着重把握它的主要矛盾；在分析某一矛盾时，要着重把握矛盾的主要方面。</li>
</ul>
</li>
</ul>
<h4 id="量变质变规律"><a href="#量变质变规律" class="headerlink" title="量变质变规律"></a>量变质变规律</h4><ul>
<li>量变：事物<strong>数量的增减</strong>和<strong>组成要素排列次序</strong>的变动，是保持事物的质地相对稳定的不显著变化<br>质变：事物<strong>性质的根本变化</strong>，是事物从一种质态向另一种质态的飞跃</li>
<li>量变和质变的辩证关系：<ol>
<li>量变是质变的必要准备</li>
<li>质变是量变的必然结果</li>
<li>量变和质变是相互渗透的</li>
</ol>
</li>
<li>量变和质变规律的<strong>方法论</strong>意义：<ol>
<li>当事物的发展处于量变阶段的时候，要踏踏实实做好日常工作，为未来的重大变化做准备</li>
<li>当质变来临的时候，要果断地、不失时机地抓住机遇、促成质变，使工作迈上新台阶</li>
</ol>
</li>
</ul>
<h4 id="否定之否定规律"><a href="#否定之否定规律" class="headerlink" title="否定之否定规律"></a>否定之否定规律</h4><ul>
<li><p>事物内部都存在否定因素和肯定因素<br>其中，肯定因素是<strong>维持现存事物存在的因素</strong>，否定因素是<strong>促成现存事物灭亡的因素</strong>。</p>
</li>
<li><p>否定之否定规律揭示了事物发展的<strong>前进性和曲折性</strong>的统一。<br>前进性：</p>
<ul>
<li>前进性体现在<strong>每一次否定都是质变</strong>，都把事物推进到新的阶段上；每一个周期都是开放的，前一个周期的终点时下一个周期的起点</li>
</ul>
<p>曲折性：</p>
<ul>
<li>曲折性体现在回复性上，其中有暂时的停顿甚至倒退。这表明，事物的发展不是直线式前进，而是螺旋式上升的。</li>
</ul>
</li>
</ul>
<h3 id="第二章-辩证唯物主义认识论"><a href="#第二章-辩证唯物主义认识论" class="headerlink" title="第二章 辩证唯物主义认识论"></a>第二章 辩证唯物主义认识论</h3><h4 id="科学实践观"><a href="#科学实践观" class="headerlink" title="科学实践观"></a>科学实践观</h4><ul>
<li><strong>实践性</strong>是马克思主义的区别于其他理论的<strong>根本特征</strong>（前面提到了马克思主义的四个基本特征），是马克思主义<strong>首要的和基本的</strong>观点。<br>（物质和意识如何沟通呢？就是实践。是物质和意识沟通的一个桥梁。）</li>
<li>人与世界的关系主要包括两个方面：<ol>
<li>认识世界</li>
<li>改造世界</li>
</ol>
</li>
<li>实践的本质：实践是<strong>人类</strong>能动改造世界的<strong>社会性的物质活动</strong>（实践的主体只能是人类。实践是物质的）</li>
<li>实践的三个<strong>基本特征</strong>：<ol>
<li>客观实在性（能够引起客观世界的某些物质改变，可以把人们脑中的观念变为现实的存在，给人们提供现实的成果）</li>
<li>自觉能动性</li>
<li>社会历史性</li>
</ol>
</li>
<li>实践的基本形式：<ol>
<li>物质生产实践</li>
<li>社会政治实践</li>
<li>科学文化实践</li>
</ol>
</li>
</ul>
<h4 id="实践对认识的决定作用"><a href="#实践对认识的决定作用" class="headerlink" title="实践对认识的决定作用"></a>实践对认识的决定作用</h4><ul>
<li><p>实践对认识的决定作用（体现在四个方面）：</p>
<ol>
<li>认识的基础（认识的来源）</li>
<li>认识发展的动力</li>
<li>认识的目的</li>
<li>实践是检验真理的唯一标准</li>
</ol>
<p>辩证唯物主义认为，实践是认识的基础，实践在认识活动中起着决定性的作用。</p>
</li>
</ul>
<h4 id="认识的过程"><a href="#认识的过程" class="headerlink" title="认识的过程"></a>认识的过程</h4><ul>
<li>感性认识<br>是指人们<strong>在实践的基础上</strong>，由<strong>感觉器官</strong>直接感受到的关于事物的现象、事物的<strong>外部</strong>联系、事物的各个方面的认识（对象是 事物的外部形体）<br>形式：感性认识包括 <strong>感觉、知觉、表象</strong> 三种形式<br>特点：直接性和具体性</li>
<li>理性认识（是认识的高级阶段）<br>对事物的全体、本质、<strong>内部联系</strong>和事物自身规律性的认识（对象是内部联系）<br>形式：理性认识包括 <strong>概念、判断、推理</strong> 三种形式<br>性质：间接性和抽象性</li>
<li>我们对于任何事物的认识一定都是既有感性认识于与理性认识</li>
<li>如果我们过于夸大感性认识而忽略了理性认识，就会出现经验主义错误；如果只要理性认识而忽略感性认识，就会导致教条主义错误</li>
<li>理性认识和感性认识的<strong>辩证关系</strong>：（感觉很类似于质变和量变之间的关系，或者像这种二元的关系，基本都是两个一对一，然后他们相互之间的关系）<ol>
<li>理性认识依赖于感性认识</li>
<li>感性认识有待于发展和深化理性认识</li>
<li>感性认识和理性认识相互渗透，相互包含</li>
</ol>
</li>
<li>从认识到实践的<strong>必要性和重要性</strong>：（第二次能动飞跃）<ol>
<li>认识世界的目的是改造世界（认识的目的是实践）</li>
<li>认识的真理只有在实践中才能得到检验和发展</li>
</ol>
</li>
</ul>
<h4 id="真理"><a href="#真理" class="headerlink" title="真理"></a>真理</h4><ul>
<li><p>真理的客观性：<br>指真理的内容是对<strong>客观事物</strong>及其规律的正确反应，真理中不包含依赖于人和人的意识的客观内容，<strong>客观性是真理的本质属性</strong></p>
</li>
<li><p>真理的客观性决定了真理的<strong>一元性</strong>。真理是内容上的一元性与形式上的多样性的统一</p>
</li>
<li><p>真理有绝对性和相对性（不好命材料题）</p>
</li>
<li><p>马克思主义是绝对性和相对性的统一：<br>马克思主义<strong>正确反映了人类社会发展规律，因而具有绝对性</strong>；马克思主义经典作家并没有穷尽真理，而是不断为寻求真理和发展真理开辟道路，<strong>马克思主义并没有对一切事物及其规律的认识，而是随着社会实践的发展而发展，因而又具有相对性</strong></p>
</li>
<li><p>实践是检验真理的唯一标准：<br>实践是检验真理的<strong>唯一标准</strong>，但实践对真理的检验不可能一次完成，实践检验真理是一个永无止境的发展过程</p>
</li>
</ul>
<h4 id="价值论"><a href="#价值论" class="headerlink" title="价值论"></a>价值论</h4><ul>
<li>价值的基本特征：<ol>
<li>主体性</li>
<li>客观性</li>
<li>多维性</li>
<li>社会历史性</li>
</ol>
</li>
</ul>
<h3 id="第三章-唯物史观（历史唯物主义原理）"><a href="#第三章-唯物史观（历史唯物主义原理）" class="headerlink" title="第三章 唯物史观（历史唯物主义原理）"></a>第三章 唯物史观（历史唯物主义原理）</h3><p>在马克思主义产生之前，唯心史观一直占据统治地位，它的主要缺陷是：</p>
<ol>
<li>至多考察人们活动的<strong>思想动机</strong>，而没有进一步追究思想动机背后的物质动因</li>
<li>只看到<strong>个人在历史上的作用</strong>，而忽视人民群众创造历史的决定作用</li>
</ol>
<h4 id="社会存在与社会意识及其辩证关系"><a href="#社会存在与社会意识及其辩证关系" class="headerlink" title="社会存在与社会意识及其辩证关系"></a>社会存在与社会意识及其辩证关系</h4><ul>
<li>存在和意识只是我们学过的两个老概念变了个名字，对应着物质和意识（在唯物史观中）</li>
</ul>
<p>唯物史观是唯物辩证法在对历史和社会发展进行分析时的具体应用。它强调通过对社会历史的唯物主义和辩证法的研究，深刻理解社会发展的客观规律。？？？？</p>
<ul>
<li>马克思科学地解决了社会存在与社会意识的关系问题，创立了唯物史观</li>
<li>社会存在：是指社会<strong>物质生活条件</strong>，是社会生活的物质方面<br>社会意识：是社会存在的反映，是<strong>社会生活的精神方面</strong>，既包括社会意识的各种形式，又包括社会心理与自发形成的风俗、习惯</li>
<li>社会存在包括：<ol>
<li><strong>物质生活资料</strong>的生产以及生产方式（生产方式包括生产关系和生产力，社会存在构成中的决定性因素）</li>
<li>地理环境</li>
<li>人口因素</li>
</ol>
</li>
<li>社会意识的<strong>相对独立性</strong>：（相对 相对 相对 相对独立性！虽然社会意识是被社会存在决定的）<ol>
<li>社会意识与社会存在的发展具有<strong>不完全同步性和不平衡性</strong></li>
<li>社会意识内部各种形式之间相互影响且各自具有历史继承性</li>
<li>社会意识对社会存在具有能动的反作用（类比意识对于存在有着反作用）</li>
</ol>
</li>
<li>社会存在决定社会意识：<ol>
<li>社会存在是社会意识内容的客观来源</li>
<li>社会意识是人们进行社会物质交往的产物</li>
<li>社会意识是具体的、历史的</li>
</ol>
</li>
<li>社会的基本矛盾：<ol>
<li>生产力和生产关系的矛盾（生产关系一定要适合生产力状况的规律）</li>
<li>经济基础和上层建筑之间的矛盾（上层建筑一定要适合经济基础状况的规律）</li>
</ol>
</li>
</ul>
<h4 id="生产力与生产关系的矛盾运动及其规律"><a href="#生产力与生产关系的矛盾运动及其规律" class="headerlink" title="生产力与生产关系的矛盾运动及其规律"></a>生产力与生产关系的矛盾运动及其规律</h4><ul>
<li>生产力的要素：（三个）<ol>
<li>劳动资料（是进行生产过程中被劳动者利用、改造的物质和工具）</li>
<li>劳动对象（是劳动者通过劳动所直接改造和加工的物质）</li>
<li>劳动者</li>
</ol>
</li>
<li>生产关系<br>生产关系是指：人们在<strong>物质生产过程中</strong>形成的不以人的意志为转移的<strong>经济关系</strong><br>生产关系的构成：（<strong>其实就是人和生产力的三个要素之间关系</strong>）<ol>
<li>生产资料所有制关系</li>
<li>生产中人与人的关系</li>
<li>产品分配关系</li>
</ol>
</li>
<li>生产力决定生产关系：<ol>
<li>生产力<strong>状况</strong>决定生产关系的<strong>性质</strong></li>
<li>生产力的<strong>发展</strong>决定生产关系的<strong>变化</strong></li>
</ol>
</li>
<li>生产关系对生产力具有能动的反作用：<ol>
<li>当生产关系适合生产力发展的客观要求时，对生产力发展起推动作用</li>
<li>当生产关系不再适合生产力发展的客观要求时，就会阻碍生产力的发展</li>
</ol>
</li>
</ul>
<h4 id="经济基础与上层建筑的矛盾运动及其规律"><a href="#经济基础与上层建筑的矛盾运动及其规律" class="headerlink" title="经济基础与上层建筑的矛盾运动及其规律"></a>经济基础与上层建筑的矛盾运动及其规律</h4><ul>
<li>经济基础：<br>由社会一切发展阶段上的生产力所决定的生产关系的总和</li>
<li>上层建筑：<ul>
<li>观念上层建筑：又叫「意识形态」，包括政治法律思想、道德、艺术、宗教哲学等思想观念</li>
<li>政治上层建筑：国家政治制度、国家政权机构、政党、军队、监狱、法庭等政治组织形态和设施</li>
</ul>
</li>
<li>经济基础决定上层建筑，上层建筑一定要适合经济基础状况</li>
</ul>
<h4 id="普遍交往与世界历史"><a href="#普遍交往与世界历史" class="headerlink" title="普遍交往与世界历史"></a>普遍交往与世界历史</h4><ul>
<li>普遍交往是世界历史的基本特征<br><strong>生产方式的变革</strong>是世界历史形成和发展的基础</li>
</ul>
<h4 id="社会形态更替与人的自主选择"><a href="#社会形态更替与人的自主选择" class="headerlink" title="社会形态更替与人的自主选择"></a>社会形态更替与人的自主选择</h4><ul>
<li><p>社会的根本性变革和进步就是通过<strong>社会形态</strong>的更替实现的。<br>依据经济基础<strong>特别是生产关系</strong>的不同性质，社会历史可以划分为五种社会形态：</p>
<ol>
<li>原始社会</li>
<li>奴隶社会</li>
<li>封建社会</li>
<li>资本主义社会</li>
<li>共产主义社会</li>
</ol>
</li>
<li><p>社会主义社会是共产主义的第一阶段，又称共产主义社会的初级阶段</p>
</li>
<li><p>社会形态更替的必然性：</p>
</li>
</ul>
<h3 id="第四章-自由资本主义"><a href="#第四章-自由资本主义" class="headerlink" title="第四章 自由资本主义"></a>第四章 自由资本主义</h3><h4 id="商品二因素和劳动二重性"><a href="#商品二因素和劳动二重性" class="headerlink" title="商品二因素和劳动二重性"></a>商品二因素和劳动二重性</h4><ul>
<li><p>商品的二因素：</p>
<ul>
<li><p>使用价值：使用价值是指商品能够满足人的某种需要的<strong>有用性</strong><br>使用价值反应人与自然之间的物质关系，是商品的<strong>自然属性</strong>，是一切劳动产品所共有的属性，使用价值构成财富的物质内容</p>
</li>
<li><p>价值：价值是<strong>凝聚</strong>在商品中的无差别的<strong>一般人类劳动</strong>，即人的脑力和体力的<strong>耗费</strong>。<br>价值是商品所特有的<strong>社会属性</strong></p>
</li>
</ul>
</li>
<li><p>商品的使用价值和价值是一种对立统一的关系<br>对立性：商品的使用价值和价值是互相排斥的，二者不可兼得<br>统一性：作为商品，使用价值和价值二者缺一不可</p>
</li>
<li><p>价值如何衡量（时间衡量）：<br>决定价值量的，不是生产商品的个别劳动时间，而是必要劳动时间。</p>
</li>
<li><p>劳动二重性：<br>劳动二重性是指生产商品的劳动<strong>既是具体劳动过程</strong>，<strong>又凝结抽象劳动</strong></p>
<ul>
<li>具体劳动<br>生产一定使用价值的具体形式的劳动。具体劳动形成商品的使用价值，<strong>是劳动的自然属性</strong></li>
<li>抽象劳动<br>撇开一切具体形式的无差别的一般人类劳动，即人的体力和脑力的耗费。这种无差别的人类劳动，在商品经济条件下创造出商品的价值实体，<strong>是劳动的社会属性</strong></li>
</ul>
</li>
</ul>
<h4 id="价值规律"><a href="#价值规律" class="headerlink" title="价值规律"></a>价值规律</h4><ul>
<li>价值规律是商品生产和商品交换的<strong>基本规律</strong><ul>
<li>商品的价值由生产商品的社会<strong>必要劳动时间</strong>决定</li>
<li>商品交换以价值量为基础，按照等价交换的原则进行</li>
</ul>
</li>
<li>价值律的表现形式：<br>价值规律的表现形式是，商品的价格围绕商品的价值自发波动</li>
<li>价值规律在市场配置资源过程中的作用：<ul>
<li>积极作用<ol>
<li>自发地调节生产资料和劳动力在社会各生产部门之间的分配比例</li>
<li>自发地刺激社会生产力的发展</li>
<li>自发地调节社会收入的分配</li>
</ol>
</li>
<li>消极作用：<ol>
<li>导致社会资源浪费</li>
<li>阻碍社会进步</li>
<li>导致收入两级分化</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="剩余价值生产"><a href="#剩余价值生产" class="headerlink" title="剩余价值生产"></a>剩余价值生产</h4><ul>
<li>剩余价值的两种生产方法：<ol>
<li>绝对剩余价值的生产<br>通过延长工作日从而延长剩余劳动时间生产剩余价值的方法，就是<strong>绝对剩余价值的生产</strong></li>
<li>相对剩余价值的生产<br>在工作日不变的前提下，通过缩短必要劳动时间从而相对延长剩余劳动时间生产剩余价值的方法，就是<strong>相对剩余价值的生产</strong></li>
</ol>
</li>
</ul>
<h4 id="资本循环和资本周转"><a href="#资本循环和资本周转" class="headerlink" title="资本循环和资本周转"></a>资本循环和资本周转</h4><h4 id="资本主义基本矛盾与经济危机"><a href="#资本主义基本矛盾与经济危机" class="headerlink" title="资本主义基本矛盾与经济危机"></a>资本主义基本矛盾与经济危机</h4><ul>
<li>生产社会化和生产资料私人占有之间的矛盾，是资本主义的基本矛盾<br>资本主义的基本矛盾表现为 <strong>生产无限扩大的趋势和劳动人民有支付能力的需求相对缩小的矛盾</strong>，这种矛盾导致生产数量超过需求能力。</li>
<li>经济危机的实质是 <strong>生产相对过剩的危机</strong>，是生产相对于有支付能力的需求过剩的危机<br>资本主义的基本矛盾的尖锐导致大量商品转化不了货币，导致经济危机的爆发</li>
</ul>
<h3 id="第五章-垄断资本主义"><a href="#第五章-垄断资本主义" class="headerlink" title="第五章 垄断资本主义"></a>第五章 垄断资本主义</h3><h4 id="形成垄断的历史必然性"><a href="#形成垄断的历史必然性" class="headerlink" title="形成垄断的历史必然性"></a>形成垄断的历史必然性</h4><ul>
<li>垄断：是指少数资本主义为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制，是通过一定的垄断组织实现的。</li>
<li>垄断没有消除竞争<br>垄断是作为竞争的对立面诞生的，垄断形成后，反而使竞争变得更加复杂和激烈。</li>
<li>金融资本：<br>由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本</li>
<li>垄断利润</li>
</ul>
<h4 id="国家垄断资本主义"><a href="#国家垄断资本主义" class="headerlink" title="国家垄断资本主义"></a>国家垄断资本主义</h4><h3 id="第六章-社会主义理论"><a href="#第六章-社会主义理论" class="headerlink" title="第六章 社会主义理论"></a>第六章 社会主义理论</h3><h4 id="空想社会主义"><a href="#空想社会主义" class="headerlink" title="空想社会主义"></a>空想社会主义</h4><ul>
<li>空想社会主义反映的是早期无产者对资本主义的控诉以及对未来美好社会的向往</li>
<li>核心观点和著作：</li>
</ul>
<h4 id="科学社会主义"><a href="#科学社会主义" class="headerlink" title="科学社会主义"></a>科学社会主义</h4><ul>
<li>唯物史观<ul>
<li>揭示了历史发展的一般规律</li>
<li>揭示了<strong>人民群众的历史主体作用</strong></li>
<li>揭示了阶级斗争在阶级社会发展中的巨大作用</li>
</ul>
</li>
<li>剩余价值学说<ul>
<li>揭示了资本家剥削工人的秘密</li>
<li>揭示了无产阶级与资产阶级利益的根本对立</li>
</ul>
</li>
<li><ol>
<li>资本主义必然灭亡，社会主义必然胜利<br>「两个必然」是科学社会主义的核心命题，在科学社会主义理论与实践中具有首要和基础的地位，是共产主义理想信念的核心要义</li>
<li>无产阶级是最先进最革命的阶级，肩负着推翻资本主义旧世界、建立社会主义和共产主义新世界的历史使命</li>
<li>无产阶级革命是无产阶级进行斗争的最高形式，以建立无产阶级专政的国家为目的</li>
<li>社会主义社会要在生产资料公有制基础上组织生产，以满足全体社会成员的需要为生产的根本目的</li>
<li>社会主义社会要对社会生产进行有计划的指导和调节，实行按劳分配原则</li>
<li>社会主义要合乎自然规律改造和利用自然，努力实现人与自然的和谐共生</li>
<li>社会主义必须坚持科学的理论指导，大力发展社会主义先进文化</li>
<li>无产阶级政党是无产阶级的先锋队，社会主义事业必须始终坚持无产阶级政党领导</li>
<li>社会主义社会要大力解放和发展生产力，逐步消灭剥削和消除两级分化，实现共同富裕和社会全面进步，并最终向共产主义社会过渡</li>
<li>共产主义是人类最美好的社会，实现共产主义是共产党人最高理想</li>
</ol>
</li>
</ul>
<h3 id="第七章-共产主义理论"><a href="#第七章-共产主义理论" class="headerlink" title="第七章 共产主义理论"></a>第七章 共产主义理论</h3><h4 id="共产主义的内涵"><a href="#共产主义的内涵" class="headerlink" title="共产主义的内涵"></a>共产主义的内涵</h4><ul>
<li>共产主义的内涵：<ol>
<li>作为思想体系的共产主义，是一个学说，具有科学性和阶级性</li>
<li>作为社会运动的共产主义，共产主义是一种现实的运动，是由无产阶级领导的、以推翻资产阶级和剥削压阶级压迫、为实现共产主义而进行的社会变革运动</li>
<li>作为社会制度的共产主义，共产主义制度是共产主义运动的必然结果和最终归宿</li>
</ol>
</li>
</ul>
<h4 id="马克思主义预见未来理想社会的方法论原则"><a href="#马克思主义预见未来理想社会的方法论原则" class="headerlink" title="马克思主义预见未来理想社会的方法论原则"></a>马克思主义预见未来理想社会的方法论原则</h4><ul>
<li>马克思主义预见未来理想社会的方法论原则，四个立足于：<ol>
<li>立足于人类社会的一般发展规律，指明社会发展的方向</li>
<li>立足于通过剖析旧世界来阐发新世界的特点</li>
<li>立足于揭示未来社会一般特征而非细节描述</li>
<li>立足于社会主义发展的历史经验深化对共产主义的认识</li>
</ol>
</li>
</ul>
<h4 id="共产主义社会的基本特征"><a href="#共产主义社会的基本特征" class="headerlink" title="共产主义社会的基本特征"></a>共产主义社会的基本特征</h4><ul>
<li>共产主义社会基本特征：<ol>
<li>物质财富极大丰富，消费资料按需分配</li>
<li>社会关系高度和谐，人们精神境界极大提高<br>阶级消亡，国家消亡、「三大差别」消失、社会与自然达成和谐</li>
<li>每个人得到自由而全面的发展，人类实现从必然王国向自由王国的飞跃（也是根本特征）</li>
</ol>
</li>
</ul>
<h3 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a>整体理解</h3><ul>
<li>辩证唯物主义世界观和辩证唯物主义认识论<ul>
<li>辩证唯物主义世界观是<strong>对整个宇宙和自然界的</strong>一种根本的、系统的看法，强调一切事物都是相互联系的、相互作用、相互转化的</li>
<li>辩证唯物主义认识论是<strong>对人类思维和认识活动的原理</strong>的一种认识，强调思维的辩证性、历史性、社会性</li>
</ul>
</li>
<li>唯物史观<br>唯物史观是在辩证唯物主义的基础上，通过对<strong>社会历史的唯物主义分析</strong>，探讨<strong>人类社会发展规律</strong>的理论。它强调生产力和生产关系之间的矛盾与斗争是社会历史发展的基本动力。</li>
<li>自由资本主义和垄断资本主义<ul>
<li>自由资主义是对资本主义制度的早期阶段的描述，强调市场经济、私有制、自由竞争等特征。</li>
<li>垄断资本主义则是对资本主义发展的较晚阶段的分析，突出了垄断、集中经济权力、金融资本等在资本主义体系中的重要作用。</li>
</ul>
</li>
<li>社会主义理论和共产主义理论<ul>
<li>社会主义理论是对资本主义制度的批判和超越，主张通过无产阶级革命建立社会主义制度，实现生产资料公有制。</li>
<li>共产主义理论则是对社会主义制度向更高阶段的过渡的设想，强调在共产主义社会中，阶级差别将消失，实现了人类共同拥有和共同管理社会财富。</li>
</ul>
</li>
</ul>
<p>这些理论体现了从哲学、认识论到社会历史发展的逻辑层次。</p>
<p><strong>辩证唯物主义提供了整体的哲学基础，唯物史观通过对社会历史的唯物主义分析揭示了社会发展的规律，而自由资本主义、垄断资本主义、社会主义理论和共产主义理论则是在这个基础上对不同社会形态和制度的分析和建构。</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li>马克思主义诞生于 <strong>十九世纪四十年代</strong></li>
<li>狭义的马克思主义：马克思恩格斯创立的基本理论、基本观点和学说的体系<br>广义的马克思主义：<strong>不仅</strong>指马克思恩格斯创建的基本理论、基本观点和学说的体系，<strong>也包括继承者</strong>对它的发展</li>
<li>马克思主义最重要的理论品质：<strong>与时俱进</strong></li>
<li>德国古典哲学最有代表性的人物：黑格尔、费尔巴哈</li>
<li>作为马克思主义产生基础的 19 世纪三大工人运动：<ol>
<li>法国里昂工人起义</li>
<li>英国宪章运动</li>
<li>德国西里西亚纺织工人起义</li>
</ol>
</li>
<li>马克思和恩格斯最重要的理论创新 &#x2F; 最重要的贡献是：唯物史观、剩余价值学说</li>
<li>马克思主义公开问世的标志性著作：《共产党宣言》</li>
<li>马克思主义是关于无产阶级和人类解放的科学</li>
<li>马克思主义科学性与革命性统一的基础是<strong>实践性</strong></li>
<li>马克思主义的<strong>生命力根源</strong>在于：以实践性为基础的科学性与革命性的统一</li>
<li>马克思主义区别于其他旧哲学的最主要最显著特征：实践性</li>
<li>马克思主义产生的经济根源是：<strong>资本主义社会生产力和生产关系的矛盾运动</strong></li>
<li>区分辩证法和形而上学的标准：世界是怎样的？如果认为世界是运动的、变化的，就是辩证法，如果认为是孤立的、静止的，就是形而上学的。</li>
<li>区分唯物史观和唯心史观的标准：社会存在和社会意识和为第一性的问题</li>
<li>判断一个东西是不是物质我们需要判断是不是依赖于人类的感知存在的<br>例如：<br>下面属于物质范畴的是：ABCD<br>A. 钢铁<br>B. 人类历史<br>C. 生产力<br>D. 生产关系</li>
<li></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>计算机组成原理关键记录</title>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="第一章-计算机系统概念"><a href="#第一章-计算机系统概念" class="headerlink" title="第一章 计算机系统概念"></a>第一章 计算机系统概念</h3><p>将高级语言程序翻译为机器语言程序的软件   称为翻译软件，有两种，一种是「编译程序」，一种是「解释程序」。</p>
<p>冯诺依曼计算机的特点：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209144026178.png" class="" title="image-20231209144026178">

<p>现代的计算机已经转变为「以<strong>存储器</strong>为中心」。</p>
<p>CPU 和主存储器合起来，又可以称为「主机」。</p>
<p>主存储器简称主存或者内存，包括存储体 M、各种逻辑部件和控制电路。<strong>存储体由许多存储单元组成，每一个存储单元又有若干个存储元件</strong>（或者称为存储元、存储基元），每个存储元件都能寄存一位二进制代码。可见，<strong>一个存储单元可以存储一串二进制代码</strong>，称这串二进制代码为一个<strong>存储字</strong>，这串二进制代码的位数为<strong>存储字长</strong>。</p>
<p>主存工   作的时候是按照<strong>存储单元</strong>的地址号来存取</p>
<p><strong>MAR：</strong> memory address register</p>
<p><strong>MDR：</strong> memory data register</p>
<p>现在，MDR 和 MAR 通常集成在 CPU 芯片内。</p>
<p>一般情况下，所有的硬件组件（CPU、GPU、外设等）都无法直接访问外存，而是通过内存进行交互。当计算机启动时，操作系统会将需要的程序和数据从外存加载到内存中，然后 CPU 可以直接访问内存中的数据来执行任务。</p>
<p><strong>PC</strong>，Program Counter 程序计数器，与 MAR 之间有通路连接。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231224200952029.png" class="" title="image-20231224200952029">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226110547094.png" class="" title="image-20231226110547094">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231226110746804.png" class="" title="image-20231226110746804">

<p>还有主频、吞吐量、响应时间</p>
<p><strong>指令和数据都存储在存储器中，如何区分它们？</strong></p>
<p>通过不同的时间段来区分指令和数据，即在取指令阶段(或取指微程序)取出的为指令，在执行指令阶段(或相应微程序)取出的即为数据。<br>通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。</p>
<h3 id="第二章-计算机的发展及应用"><a href="#第二章-计算机的发展及应用" class="headerlink" title="第二章 计算机的发展及应用"></a>第二章 计算机的发展及应用</h3><p><strong>计算机的产生和发展</strong>：</p>
<ol>
<li>第一代电子管计算机，1943 二战时期</li>
<li>第二代晶体管计算机，1947</li>
<li>第三代集成电路计算机</li>
</ol>
<p>总线 bus</p>
<p>总线按照不同的角度，有很多种分类方式，按连接部件的不同，有三种：</p>
<ol>
<li>片内总线，指的是芯片内部的总线，如 CPU 芯片的内部、寄存器与寄存器之间。</li>
<li>系统总线，指的是 CPU、主存、IO 设备各大部件之间的信息传输线<br>按照传输信息的不同，又可以分为三类：数据总线、地址总线、控制总线</li>
<li>通信总线，这类总线用于计算机系统之间或者计算机系统与其他系统之间的通信。</li>
</ol>
<h3 id="第四章-存储器"><a href="#第四章-存储器" class="headerlink" title="第四章 存储器"></a>第四章 存储器</h3><p>按照在系统中的作用分类，可以分为主存储器、辅助存储器、缓冲存储器</p>
<p>主存储器：可以和 CPU 直接交换信息</p>
<p>辅助存储器：不能和 CPU 直接交换信息</p>
<p>主存的结构：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209163806854.png" class="" title="image-20231209163806854">

<p>现代的计算机主存都是由半导体集成电路构成，图中的驱动器、译码器和读写电路均制作在存储芯片之中，而 MAR 和 MDR 制作在 CPU 芯片之中。存储芯片和 CPU 芯片可以通过总线连接。</p>
<p><strong>存储速度</strong>是由<strong>存储时间</strong>和<strong>存储周期</strong>来表示的。</p>
<p>存储时间：存储器的访问时间，指启动一次存储器操作（读或者写）到完成该操作的时间</p>
<p>存储周期：存储器进行连续两次独立的存储器操作所需的最小间隔时间，<strong>通常存储周期大于存储时间</strong>。总线传输周期是包含在存储周期内部的。</p>
<p>存储带宽：表示单位时间内存储器的存取信息量。（与存储周期紧密相连的指标）</p>
<p><strong>一个关于存储时间和存储周期的解释：</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231224202940456.png" class="" title="image-20231224202940456">

<p><strong>半导体存储器</strong>是由<strong>许多个</strong>半导体存储芯片构成的，所以需要进行片选，决定哪一个存储芯片工作。</p>
<p>下面是一个存储芯片的构成结构</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209164855648.png" class="" title="image-20231209164855648">

<p><strong>地址线和数据线的位数共同反应</strong>存储芯片的容量。</p>
<h5 id="随机存储器"><a href="#随机存储器" class="headerlink" title="随机存储器"></a>随机存储器</h5><p>随机存取存储器按照存储信息的原理不同，可以分为动态 RAM 和静态 RAM 两大类。</p>
<p>存储器中用于存储 0 和 1 的代码电路称为存储器的「基本单元电路」，也就是存储基元，一个<strong>存储单元</strong>包括多个存储基元。</p>
<p><strong>静态 RAM：</strong>静态 RAM 是使用触发器原理存储信息的，因此读出信息以后，仍然保持原状，不需要再生，但是掉电时，原来的信息丢失。</p>
<p><strong>动态 RAM：</strong>动态 RAM 基本单元电路中有三管式和单管式两种，并且共同特点是都是靠 <strong>电容存储电荷</strong> 的原理来寄存信息。</p>
<p>电容上的电荷一般只能维持 1 到 2ms，所以即使电源不断电，信息也会自动消失。所以必须在 2ms 内 刷新一次。</p>
<p>由于动态 RAM 相比静态 RAM 集成度更高、功耗更低，所以目前被各类计算机广泛使用。</p>
<p><strong>刷新：</strong><br>采用定时刷新的方式，规定一段时间，必须对于所有的基本单元电路都刷新一次。这个时间叫做「再生周期」或者「刷新周期」。</p>
<p>刷新是一行一行进行的，通常有三种方式刷新：集中刷新、分散刷新和异步刷新。</p>
<ol>
<li>对全部的存储单元集中一段时间逐行进行刷新。此刻必须停止读&#x2F;写操作。<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209173508149.png" class="" title="image-20231209173508149">
关于时间死区的计算</li>
<li>分散刷新是指每行存储单元的刷新<strong>分散到每一个存取周期内完成</strong><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209174055131.png" class="" title="image-20231209174055131"></li>
<li>异步刷新。将前两种方式结合，可以缩短死时间，也可以充分利用刷新周期 2ms。</li>
</ol>
<p><strong>存储器容量的扩展：</strong></p>
<ol>
<li>位扩展<br>增加<strong>存储字长</strong>。</li>
<li>字扩展<br>字扩展指的是<strong>增加存储字的数量。</strong></li>
</ol>
<p><strong>存储器和 CPU 的连接：</strong></p>
<ol>
<li>CPU 的地址线通常比存储芯片的地址线数多。通常是将 CPU 地址线的低位与存储芯片的地址线相连，CPU 的地址线的高位或在存储芯片扩充时使用，或者用做其他用途。</li>
<li>CPU 的数据线和存储芯片的数据线数可能也不同，<strong>此时必须对于存储芯片进行位扩展</strong>。</li>
</ol>
<p><strong>存储器的校验：</strong></p>
<p><strong>提高访存速度的措施：</strong></p>
<p>除了寻找高速元件和采用层次结构以外，调整主存的结构也可以提高访存速度。</p>
<ol>
<li><p>单体多字系统<br>采用前提是：指令和数据在主存中是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，效果不明显。</p>
</li>
<li><p>多体并行系统</p>
<p>高位地址交叉编址 和 低位地址交叉编址</p>
</li>
</ol>
<p>关于这两种的时间计算问题</p>
<p><strong>存控：</strong></p>
<p>多体模块存储器不仅要与 CPU 交换信息，还要与辅存、IO 设备、乃至IO处理机交换信息。因此，某一时刻，应该决定主存究竟和哪一个部件交换信息。<strong>这就是由存储器控制部件（简称存控）来承担。</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209181755310.png" class="" title="image-20231209181755310">



<p><strong>Cache 主存地址映射</strong> </p>
<p>Cache 与主存之间的数据交换是以块为单位的，CPU 与 Cache 之间的数据交换是以字为单位的。</p>
<p>由主存地址映射到 Cache 地址叫做地址映射。</p>
<p>在这里我们是按照 <strong>字块</strong> 为单位进行映射的，其中 <strong>字块</strong> 的大小不一定，根据题目的定义来。<strong>字块</strong> 包括了若干个 <strong>字</strong>，一个 <strong>字</strong> 是若干位，这些都是题目定义。</p>
<p>我们把主存和 Cache 分成了若干块，进行映射。</p>
<p>有直接相连映射、全相联映射和组相连映射。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209203305851.png" class="" title="image-20231209203305851">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209203320092.png" class="" title="image-20231209203320092">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209203332745.png" class="" title="image-20231209203332745">

<p>这里的题目还是比较重要的。<br><strong>课本 P120</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209203951268.png" class="" title="image-20231209203951268">

<p>还有若干例题。。。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </p>
<h3 id="第五章-输入输出系统"><a href="#第五章-输入输出系统" class="headerlink" title="第五章 输入输出系统"></a>第五章 输入输出系统</h3><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209210730500.png" class="" title="image-20231209210730500">

<p>IO 设备与主机交换信息时的控制方式：</p>
<ol>
<li>程序查询方式</li>
<li>程序中断方式</li>
<li>DMA（直接存储器存取方式）</li>
</ol>
<p><strong>设置 IO 接口的理由：</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209214224933.png" class="" title="image-20231209214224933">

<p><strong>这三种方式的接口电路设计：</strong></p>
<p>程序查询方式：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209215450386.png" class="" title="image-20231209215450386">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209215605843.png" class="" title="image-20231209215605843">

<p>IO 设备直接和主存交互的时候是 DMA 方式，但是这里是程序查询方式，所以我们就是必须经过中间的 CPU，然后再将数据存入主存。</p>
<p>程序中断方式：<br>CPU <strong>启动设备以后</strong>往往需要等待一段时间才能实现主机与 IO 设备之间的信息交换。如果在设备准备的同时，CPU 不做无谓的等待，而是继续执行程序，只有 IO 设备准备就绪的时候才向 CPU 提出请求，暂时中断 CPU 现行程序进入 IO 服务程序，这就是 IO 中断。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209220904784.png" class="" title="image-20231209220904784">

<p>CPU 总是在统一的时间，比如每条指令执行阶段的最后阶段，查询所有的设备是否有中断请求。</p>
<p>中断向量地址形成部件的输入是来自排队器的输出，它的输出是中断向量。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209222325961.png" class="" title="image-20231209222325961">

<p><strong>中断请求、中断判优、中断响应、中断服务、中断返回</strong>五个阶段。</p>
<p>对于其中的<strong>中断服务阶段</strong>，一般来说可以分为：保护现场、中断服务、恢复现场、中断返回</p>
<p>保护现场：两个含义。一个是保存程序的断点，一个是保存通用寄存器和状态寄存器的内容。</p>
<p>恢复现场：在中断服务程序的结尾部分，在退出程序之前，将原程序中断时的现场恢复到原来的寄存器之中。</p>
<p>中断返回：返回原程序的断电之处</p>
<p>DMA 方式：</p>
<p>DMA 接口又叫做 DMA 控制器，数据的传输过程完全由 DMA 接口电路控制。</p>
<p>主存和 DMA 接口之间有一个数据通路。此时主存和设备交换信息的时候，不需要经过 CPU，也不需要 CPU 暂停现行程序去为设备服务。适合 <strong>高速 IO 或者辅存与主存之间的信息交换</strong>。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209224832903.png" class="" title="image-20231209224832903">

<p>课本 P204</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209231605543.png" class="" title="image-20231209231605543">

<p><strong>了解 DMA 方式的工作过程。</strong></p>
<h5 id="DMA-小结："><a href="#DMA-小结：" class="headerlink" title="DMA 小结："></a>DMA 小结：</h5><ol>
<li>从数据传送来看，程序<strong>中断方式靠程序传送</strong>，DMA 方式靠硬件传送。</li>
<li>从 CPU 响应时间来看，程序中断方式是在一条指令执行结束的时候响应，而 DMA 方式可以在指令周期内任意存取周期结束时响应。</li>
<li>程序中断方式有着处理异常的能力，而 DMA 方式没有这种能力，主要用于大批数据的传送。</li>
<li>DMA 不中断现行程序，所以不需要保护。</li>
<li>DMA 的优先级比程序中断的优先级高。</li>
</ol>
<h5 id="DMA-接口的类型"><a href="#DMA-接口的类型" class="headerlink" title="DMA 接口的类型"></a>DMA 接口的类型</h5><p>现代的集成电路技术已经将 DMA 接口制造成芯片，通常有选择型和多路型两类。</p>
<h5 id="三种方式的-CPU-工作效率比较"><a href="#三种方式的-CPU-工作效率比较" class="headerlink" title="三种方式的 CPU 工作效率比较"></a>三种方式的 CPU 工作效率比较</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231225120237653.png" class="" title="image-20231225120237653">

<h3 id="第六章-计算机的运算方法"><a href="#第六章-计算机的运算方法" class="headerlink" title="第六章 计算机的运算方法"></a>第六章 计算机的运算方法</h3><p>计算机中的数均放在寄存器中，<strong>通常称寄存器的位数为机器字长</strong></p>
<p>把符号数字化的数称为机器数，把带有「+」或者「-」符号的数字称为真值。</p>
<h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>原码是机器数中最简单的一种表示形式。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210092251645.png" class="" title="image-20231210092251645">

<p>对于小数原码的定义：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210092420098.png" class="" title="image-20231210092420098">



<p>此时，对于 0 的原码：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210092501731.png" class="" title="image-20231210092501731">

<p>可见 +0 和 -0 的原码表示不一样，<strong>所以原码中，零 有两种表达形式。</strong></p>
<h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>其实就是<strong>模意义下的</strong>一种编码方式。</p>
<p>对于整数的补码编码：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210092651747.png" class="" title="image-20231210092651747">

<p>小数的补码定义：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210092744349.png" class="" title="image-20231210092744349">

<p>其实和原码相比，就是前面的数 2 的幂次加了 1，但是由 -x 统一变为了 +x</p>
<p>此时的 0，只有一种编码形式。所以它可以比原码能多表示一个数字，如果是小数，可以多表示一个 -1。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210102402739.png" class="" title="image-20231210102402739">

<h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>反码通常用作原码求补码或者补码求原码的<strong>中间过渡</strong>。</p>
<p>整数反码的定义如下：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210093343619.png" class="" title="image-20231210093343619">

<p>小数的反码定义如下：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210093737400.png" class="" title="image-20231210093737400">

<h4 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h4><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210101826008.png" class="" title="image-20231210101826008">

<p>当浮点数的阶码用移码表示的时候，我们可以很方便地判断阶码的大小。、</p>
<p>同一个真值的补码和移码仅仅差一个符号位，所以移码就是对于原码，连带符号位取反加一。</p>
<h4 id="浮点数和定点数"><a href="#浮点数和定点数" class="headerlink" title="浮点数和定点数"></a>浮点数和定点数</h4><p>在计算机中，小数点不用专门的器件表示，而是按照约定的方式标出。</p>
<p>定点数与浮点数的比较：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231224123722644.png" class="" title="image-20231224123722644">

<h4 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h4><h5 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231224130156929.png" class="" title="image-20231224130156929">

<h5 id="加法与减法"><a href="#加法与减法" class="headerlink" title="加法与减法"></a>加法与减法</h5><p>对于补码意义下的加法与减法，其实就是模意义下的运算。</p>
<h6 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h6><p>补码定点加减运算判断溢出有两种方式。</p>
<ol>
<li><p>一位符号位判断溢出</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210104008118.png" class="" title="image-20231210104008118">
</li>
<li><p>两位符号位判断</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210104136558.png" class="" title="image-20231210104136558">
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210104411999.png" class="" title="image-20231210104411999"></li>
</ol>
<h5 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h5><p>分为原码乘法和补码乘法</p>
<h6 id="原码乘法"><a href="#原码乘法" class="headerlink" title="原码乘法"></a>原码乘法</h6><p>其中对于原码乘法，符号位需要单独判断。然后让绝对值相乘。</p>
<h6 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h6><p>对于补码乘法，分两种情况：</p>
<ol>
<li>被乘数 x 符号任意，乘数 y 符号为正。<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210105259734.png" class="" title="image-20231210105259734"></li>
<li>被乘数 x 符号任意，乘数 y 为负。</li>
</ol>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210105317158.png" class="" title="image-20231210105317158">

<p>乘积的符号在过程中自然形成，这是补码乘法和原码乘法的重要区别。</p>
<h6 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h6><p>比较法是 Booth 夫妇首先提出来的，又叫做 Booth 算法。</p>
<h5 id="乘法运算-1"><a href="#乘法运算-1" class="headerlink" title="乘法运算"></a>乘法运算</h5><h6 id="原码除法"><a href="#原码除法" class="headerlink" title="原码除法"></a>原码除法</h6><p>符号位是单独处理的。</p>
<p>原码除法中，对于余数的不同处理，又可以分为恢复余数法和不恢复余数法（加减交替法）两种。</p>
<h6 id="补码除法"><a href="#补码除法" class="headerlink" title="补码除法"></a>补码除法</h6><h4 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h4><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210113358606.png" class="" title="image-20231210113358606">

<p>对阶的时候是小阶向大阶看齐，阶小的尾数向右移位，次数为阶差。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210113638785.png" class="" title="image-20231210113638785">

<p>步骤：</p>
<ol>
<li>对阶</li>
<li>求和（尾数）</li>
<li>规格化</li>
<li>舍入处理</li>
<li>溢出判断</li>
</ol>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231224172227948.png" class="" title="image-20231224172227948">

<h3 id="第七章-指令系统"><a href="#第七章-指令系统" class="headerlink" title="第七章 指令系统"></a>第七章 指令系统</h3><h4 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h4><p>指令是由操作码和地址码组成的。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210122712315.png" class="" title="image-20231210122712315">

<p>操作码：用来反应该指令要完成的操作。</p>
<p>地址码：用来指出该指令的源操作数的地址（一个或者两个）、结果的地址以及下一条指令的地址。这里的「地址」可以是主存的地址，也可以是寄存器的地址，甚至可以是 IO 设备的地址。</p>
<h5 id="扩展操作码"><a href="#扩展操作码" class="headerlink" title="扩展操作码"></a>扩展操作码</h5><p>操作码的长度可以是固定的，也可以是变化的。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210123749614.png" class="" title="image-20231210123749614">

<p>注意最后一句话，点明了 <strong>扩展操作码</strong> 的应用场景。</p>
<p>一种设计方法举例：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210124222991.png" class="" title="image-20231210124222991">

<p>设计扩展操作码时需要注意：</p>
<ol>
<li>不允许短码是长码的前缀</li>
<li>各个指令的操作码一定不能重复</li>
</ol>
<p>参考：<a href="https://blog.51cto.com/yang/2892195">https://blog.51cto.com/yang/2892195</a></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210125621267.png" class="" title="image-20231210125621267">

<p>这个例题还是很有代表性的</p>
<h5 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h5><p>指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数。</p>
<h5 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h5><p>操作数地址就是指令中的地址码字段。</p>
<p>常见的操作数类型有：地址、数字、字符、逻辑数</p>
<h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><p>寻址方式分为<strong>指令寻址和数据寻址</strong>两大类</p>
<h5 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h5><p>指令寻址较为简单，分为 <strong>顺序寻址和跳跃寻址</strong> 两种。</p>
<p>顺序寻址就是 PC 自动 +1<br>跳跃寻址则是通过转移类指令实现</p>
<h5 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h5><p>数据寻址的种类比较多，必须设置一字段来表明属于哪一种寻址方式。</p>
<p>指令的 <strong>地址码</strong> 字段通常不代表操作数的真实地址，故把他称为 <strong>形式地址</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210131113003.png" class="" title="image-20231210131113003">

<h6 id="1-立即寻址"><a href="#1-立即寻址" class="headerlink" title="1. 立即寻址"></a>1. 立即寻址</h6><p>形式地址 A 表示的不是地址，而是就是 <strong>操作数本身</strong>，采用补码的形式存放</p>
<p>一般 <code>#</code> 表示立即数寻址的特征</p>
<p><strong>但是此时 A 的位数限制了所能表述的立即数的范围</strong></p>
<h6 id="2-直接寻址"><a href="#2-直接寻址" class="headerlink" title="2. 直接寻址"></a>2. 直接寻址</h6><p>形式地址 A 就是操作数的真实地址 EA(Effective Address)，即 EA &#x3D; A</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210132039459.png" class="" title="image-20231210132039459">

<p>特点：</p>
<ol>
<li>寻找操作数比较简单，执行的时候只是对于主存访问一次</li>
<li><strong>但是 A 的位数限制了操作数的寻址范围</strong></li>
</ol>
<h6 id="3-隐含寻址"><a href="#3-隐含寻址" class="headerlink" title="3. 隐含寻址"></a>3. 隐含寻址</h6><h6 id="4-间接寻址"><a href="#4-间接寻址" class="headerlink" title="4. 间接寻址"></a>4. 间接寻址</h6><p>形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址（感觉很像指针）。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210164425122.png" class="" title="image-20231210164425122">

<p>这种方式与直接寻址相比，扩大了操作数的寻址范围。同时，易于编制程序，例如，利用间接寻址可以很方便地完成子程序返回。</p>
<p>间接寻址的缺点在于指令的执行阶段需要 <strong>访存两次或者多次</strong>，致使指令 <strong>执行时间</strong> 延长。</p>
<h6 id="5-寄存器寻址"><a href="#5-寄存器寻址" class="headerlink" title="5. 寄存器寻址"></a>5. 寄存器寻址</h6><p>地址码字段直接给出了寄存器的编号。由于操作数不在主存之中，所以寄存器寻址在执行阶段无需访存，减少了执行时间。</p>
<p>又由于地址字段只需指明寄存器编号，所以指令字较短，因此寄存器寻址在计算机中应用广泛。</p>
<h6 id="6-寄存器间接寻址"><a href="#6-寄存器间接寻址" class="headerlink" title="6. 寄存器间接寻址"></a>6. 寄存器间接寻址</h6><p>寄存器 $R_i$ 中的内容不是操作数，<strong>而是操作数所在的主存单元地址号</strong>。所以仍需访问主存，但是比间接寻址少访问一次主存。</p>
<h6 id="7-基址寻址"><a href="#7-基址寻址" class="headerlink" title="7. 基址寻址"></a>7. 基址寻址</h6><p>基址寻址需设有基址寄存器 BR，<strong>操作数的有效地址 EA 等于指令字中的形式地址与基址寄存器中的内容相加</strong>，也就是 EA &#x3D; A + (BR)</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210165321513.png" class="" title="image-20231210165321513">

<p>基址寻址<strong>可以扩大操作数的寻址范围</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210165520480.png" class="" title="image-20231210165520480">

<h6 id="8-变址寻址"><a href="#8-变址寻址" class="headerlink" title="8. 变址寻址"></a>8. 变址寻址</h6><p>变址寻址和基址寻址极为相似。有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，EA &#x3D; A + (IX)</p>
<h6 id="9-相对寻址"><a href="#9-相对寻址" class="headerlink" title="9. 相对寻址"></a>9. 相对寻址</h6><p>相对寻址的有效地址是将程序计数器 PC 的内容（即当前指令的地址）与指令字中的形式地址 A 相加，即 EA &#x3D; (PC) + A</p>
<p>相对寻址常用于转移类指令，其中<strong>位移量 A 可正可负</strong>，采用补码表示。</p>
<h6 id="10-堆栈寻址"><a href="#10-堆栈寻址" class="headerlink" title="10. 堆栈寻址"></a>10. 堆栈寻址</h6><p>要求计算机中设有堆栈，既可以使用寄存器组来实现，也可以利用主存的一部分空间作为堆栈。</p>
<p>其中，SP (Stack Point) 始终指向栈顶地址。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210183444176.png" class="" title="image-20231210183444176">

<h5 id="指令格式举例"><a href="#指令格式举例" class="headerlink" title="指令格式举例"></a>指令格式举例</h5><h5 id="指令设计举例"><a href="#指令设计举例" class="headerlink" title="指令设计举例"></a>指令设计举例</h5><h4 id="RSIC-技术"><a href="#RSIC-技术" class="headerlink" title="RSIC 技术"></a>RSIC 技术</h4><p>RSIC(Reduced Instruction Set Computer)</p>
<p>CISC(Complex Instruction Set Computer)</p>
<p><strong>RSIC 的主要特征：</strong></p>
<ol>
<li>选用使用频度较高的一些 <strong>简单指令</strong>，复杂指令的功能使用简单指令来组合</li>
<li>指令长度固定、指令格式种类少、寻址方式少</li>
<li>访存指令只有 LOAD 和 STORE</li>
<li>CPU 中有多个通用寄存器</li>
<li>采用流水技术 一个时钟周期内完成一条指令</li>
<li>采用组合逻辑实现控制器</li>
<li>采用优化的编译程序</li>
</ol>
<h3 id="第八章-CPU-结构和功能"><a href="#第八章-CPU-结构和功能" class="headerlink" title="第八章 CPU 结构和功能"></a>第八章 CPU 结构和功能</h3><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>CPU 每<strong>取出并且执行一条指令的时间叫做指令周期</strong>，也即 CPU 完成一条指令的时间。</p>
<p>指令周期的组成如下（一般来说）：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210193320109.png" class="" title="image-20231210193320109">

<p>但是如果是间址寻址，还需访存一次主存，取出操作数，所以指令周期就是：</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210193519753.png" class="" title="image-20231210193519753">

<p>此外，如果在每条指令结束前，发送中断查询，如果进入中断相应阶段，则又包括中断周期。<strong>这样就包括 取值、间址、执行、中断 四个部分。</strong></p>
<p>上面四个部分都有访存操作，但是目的不同。取指是为了取出指令，间址是为了取出有效地址，执行是为了取出操作数，中断时为了保存程序断点。这四个周期又可以称为 CPU 的<strong>工作周期</strong>。</p>
<h4 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h4><h5 id="取值周期的数据流"><a href="#取值周期的数据流" class="headerlink" title="取值周期的数据流"></a>取值周期的数据流</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210194510392.png" class="" title="image-20231210194510392">

<h5 id="间址周期的数据流"><a href="#间址周期的数据流" class="headerlink" title="间址周期的数据流"></a>间址周期的数据流</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210194628952.png" class="" title="image-20231210194628952">

<h5 id="执行周期的数据流"><a href="#执行周期的数据流" class="headerlink" title="执行周期的数据流"></a>执行周期的数据流</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210194806418.png" class="" title="image-20231210194806418">

<h5 id="中断周期的数据流"><a href="#中断周期的数据流" class="headerlink" title="中断周期的数据流"></a>中断周期的数据流</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210194822716.png" class="" title="image-20231210194822716">

<p><strong>注意：</strong>有保存断点操作并且有中断服务程序的入口送入 PC 的操作。</p>
<h4 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h4><p>指令流水大概是类似于一种并行吧。</p>
<h5 id="流水线性能"><a href="#流水线性能" class="headerlink" title="流水线性能"></a>流水线性能</h5><p>感觉光看看这里的题目就足够了。</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><h5 id="中断服务程序入口地址的寻找"><a href="#中断服务程序入口地址的寻找" class="headerlink" title="中断服务程序入口地址的寻找"></a>中断服务程序入口地址的寻找</h5><p>通常有两种方法寻找入口地址：<strong>硬件向量法和软件查询法</strong>。</p>
<h6 id="硬件向量法"><a href="#硬件向量法" class="headerlink" title="硬件向量法"></a>硬件向量法</h6><p>硬件向量法寻找入口地址速度快，在现代计算机中被普遍采用。</p>
<h6 id="软件查询法"><a href="#软件查询法" class="headerlink" title="软件查询法"></a>软件查询法</h6><h5 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h5><p>与响应 IO 中断一样，CPU 总是在指令执行周期结束后，响应任何中断源的请求。</p>
<p>之所以 CPU 在指令的执行后期进入中断周期，是因为 CPU 在执行周期的结束时刻统一向所有的中断源发送中断查询信号，只有此时，CPU 才可以知道哪一个中断源有请求。</p>
<p>但是计算机中某一些指令的执行时间都很长，如果查询信号还是统一安排在执行周期的结束时刻，则有可能因为 CPU 发现中断请求过迟而发生差错。所以，我们可以在指令执行过程中设置若干查询断点。</p>
<p>保护现场、寻找入口地址、关中断这些操作都是在中断周期内由一条中断隐指令完成的。所谓中断隐指令，即在机器指令系统中没有的指令，是 CPU 在中断周期内由硬件自动完成的一条指令。</p>
<h5 id="保护现场和恢复现场"><a href="#保护现场和恢复现场" class="headerlink" title="保护现场和恢复现场"></a>保护现场和恢复现场</h5><p>保护程序断点和保护 CPU 内部的寄存器两个方面。</p>
<p>其中，保护程序断点由中断隐指令完成，各个寄存器内的现场可以在中断服务程序中由用户（或者系统）由机器指令编程实现。</p>
<h5 id="中断隐指令"><a href="#中断隐指令" class="headerlink" title="中断隐指令"></a>中断隐指令</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231225190340372.png" class="" title="image-20231225190340372">

<h5 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h5><p>主要用于多重中断。</p>
<p><strong>屏蔽触发器与屏蔽字</strong></p>
<p>屏蔽技术可以改变优先等级</p>
<p>每一个中断请求触发器就有一个屏蔽触发器，将所有的屏蔽触发器组合在一起，便构成了一个屏蔽寄存器，屏蔽寄存器中的内容就是<strong>屏蔽字</strong>。</p>
<h3 id="第九章-控制单元的功能"><a href="#第九章-控制单元的功能" class="headerlink" title="第九章 控制单元的功能"></a>第九章 控制单元的功能</h3><p>将结合指令周期的<strong>四个阶段</strong>，着重分析控制单元为了完成不同指令所发出的各种操作命令（又称控制信号）。</p>
<h4 id="微操作命令的分析"><a href="#微操作命令的分析" class="headerlink" title="微操作命令的分析"></a>微操作命令的分析</h4><p>控制单元具有发出各种<strong>微操作命令</strong>（<strong>即控制信号</strong>）序列的功能。</p>
<p>下面按照指令周期的四个阶段进一步分析其对应的微操作命令。</p>
<h5 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210204743514.png" class="" title="image-20231210204743514">

<h5 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210204754320.png" class="" title="image-20231210204754320">

<h5 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h5><p>不同指令的执行周期的微操作是不同的，下面分别讨论<strong>非访存指令、访存指令和转移类指令</strong>的微操作。</p>
<h6 id="非访存指令"><a href="#非访存指令" class="headerlink" title="非访存指令"></a>非访存指令</h6><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210204858927.png" class="" title="image-20231210204858927">

<h6 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h6><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210205036659.png" class="" title="image-20231210205036659">

<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210205132900.png" class="" title="image-20231210205132900">

<h6 id="转移类指令"><a href="#转移类指令" class="headerlink" title="转移类指令"></a>转移类指令</h6><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210205232859.png" class="" title="image-20231210205232859">

<h5 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h5><p>在中断周期中，中断隐指令自动完成保护断点、寻找中断服务程序入口地址以及硬件关中断的操作。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210205423361.png" class="" title="image-20231210205423361">

<h4 id="控制单元的功能"><a href="#控制单元的功能" class="headerlink" title="控制单元的功能"></a>控制单元的功能</h4><h5 id="控制单元的外特性"><a href="#控制单元的外特性" class="headerlink" title="控制单元的外特性"></a>控制单元的外特性</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210213457033.png" class="" title="image-20231210213457033">

<h6 id="输入信号"><a href="#输入信号" class="headerlink" title="输入信号"></a>输入信号</h6><ol>
<li>时钟<br>为了使控制单元按照一定的先后顺序、一定的节奏发出各个控制信号，控制单元必须受时钟控制。<strong>即每一个时钟脉冲使控制单元发出一个操作命令或者发出一组需要同时执行的命令。</strong></li>
<li>指令寄存器<br>现行指令的操作码决定了不同指令在执行周期所需完成的不同操作，所以<strong>指令的操作码字段</strong>是控制单元的输入信号，它与时钟配合可以产生不同的控制信号。</li>
<li>标志<br>控制单元<strong>有时候依赖于 CPU 的状态</strong>（如 ALU 操作的结果）产生控制信号（如 BAN 指令，控制信号要根据上一条指令的结果是否为负产生不同的控制信号）</li>
<li>来自系统总线（控制总线）的控制信号<br>例如，中断请求，DMA 请求</li>
</ol>
<h6 id="输出信号"><a href="#输出信号" class="headerlink" title="输出信号"></a>输出信号</h6><ol>
<li>CPU 内的控制信号</li>
<li>送至系统总线的控制信号</li>
</ol>
<h5 id="控制信号举例"><a href="#控制信号举例" class="headerlink" title="控制信号举例"></a>控制信号举例</h5><p>控制单元就是发出各种不同的控制信号，下面以间接寻址的加法指令 <code>Add @ X</code> 为例，进一步理解控制信号在完成一条指令过程中所起到的作用。</p>
<ol>
<li>不采用 CPU 内部总线方式（就是 CPU 中的各个相关部件都是相连的）<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210215852624.png" class="" title="image-20231210215852624">
 <img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210215924367.png" class="" title="image-20231210215924367">
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210215944658.png" class="" title="image-20231210215944658"></li>
<li>采用 CPU 内部总线的方式<br>。。。。课本 P 382</li>
</ol>
<h5 id="多级时序系统"><a href="#多级时序系统" class="headerlink" title="多级时序系统"></a>多级时序系统</h5><h6 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h6><p><strong>机器周期可以看作是所有指令执行的一个基准时间。</strong></p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210220809562.png" class="" title="image-20231210220809562">

<h6 id="时钟周期（节拍、状态）"><a href="#时钟周期（节拍、状态）" class="headerlink" title="时钟周期（节拍、状态）"></a>时钟周期（节拍、状态）</h6><p>一个机器周期里面可以完成若干个微操作，每一个微操作都需要一定的时间，可以使用 <strong>时钟信号</strong> 来控制产生每一个微操作命令。</p>
<p><strong>时钟信号的频率就是 CPU 的主频</strong>。</p>
<p><strong>用时钟信号控制节拍发生器，就可以产生节拍。每一个节拍的宽度正好对应一个时钟周期。</strong></p>
<p><strong>在每一个节拍周期里面机器可以完成一个或者几个需要同时执行的操作，是控制计算机执行的最小单位。</strong></p>
<p><strong>也就是 机器周期包含若干个时钟周期（节拍周期）。</strong>机器周期又是所有指令执行的一个基准时间。</p>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210221728323.png" class="" title="image-20231210221728323">

<h6 id="多级时序系统-1"><a href="#多级时序系统-1" class="headerlink" title="多级时序系统"></a>多级时序系统</h6><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210221934965.png" class="" title="image-20231210221934965">

<h5 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h5><p>通常将如何形成控制不同微操作序列所采用的<strong>时序控制方式</strong>称为 CU 控制方式。</p>
<p>常见的控制方式有：同步控制、异步控制、联合控制和人工控制。</p>
<p>。。。</p>
<h5 id="多级时序系统实例分析"><a href="#多级时序系统实例分析" class="headerlink" title="多级时序系统实例分析"></a>多级时序系统实例分析</h5><p>。。。</p>
<h3 id="第十章-控制单元的设计"><a href="#第十章-控制单元的设计" class="headerlink" title="第十章 控制单元的设计"></a>第十章 控制单元的设计</h3><p>本章将<strong>介绍控制单元的两种设计方法</strong>。</p>
<h4 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h4><h5 id="组合逻辑控制框图"><a href="#组合逻辑控制框图" class="headerlink" title="组合逻辑控制框图"></a>组合逻辑控制框图</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210224337586.png" class="" title="image-20231210224337586">

<h5 id="微操作的节拍安排"><a href="#微操作的节拍安排" class="headerlink" title="微操作的节拍安排"></a>微操作的节拍安排</h5><p>参见课本 P396</p>
<p>感觉还是很重点的这一块</p>
<h5 id="组合逻辑设计步骤"><a href="#组合逻辑设计步骤" class="headerlink" title="组合逻辑设计步骤"></a>组合逻辑设计步骤</h5><ol>
<li>列出微操作命令的操作时间表</li>
<li>写出微操作命令的最简逻辑表达式</li>
<li>画出微操作命令的逻辑图</li>
</ol>
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231211153050821.png" class="" title="image-20231211153050821">

<p>如图，由各个微操作命令和逻辑运算组成的微操作设计电路图。</p>
<p>这样设计思路清晰，但是设计完毕以后就会发现控制单元的线路十分复杂，并且不规范。所以<strong>为了克服这些缺点，我们可以采用微程序设计方案</strong>。</p>
<p>但是，随着 RSIC 的出现，组合逻辑设计仍然是设计计算机的一种重要方法。</p>
<h4 id="微程序设计"><a href="#微程序设计" class="headerlink" title="微程序设计"></a>微程序设计</h4><h5 id="微程序设计思想的产生"><a href="#微程序设计思想的产生" class="headerlink" title="微程序设计思想的产生"></a>微程序设计思想的产生</h5><p>为了克服组合逻辑控制单元线路庞杂的缺点，他大胆设想采用与存储程序相类似的方法，来解决微操作命令序列的形成。</p>
<p>微程序控制单元的核心部件是一个控制存储器。由于执行一条机器指令必须多次访问存储器，以取出多条微指令来控制执行各个操作，因此需要控制存储器的速度较高。</p>
<h5 id="微程序控制单元框图及工作原理"><a href="#微程序控制单元框图及工作原理" class="headerlink" title="微程序控制单元框图及工作原理"></a>微程序控制单元框图及工作原理</h5><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231211160557847.png" class="" title="image-20231211160557847">

<p>控制单元的内部结构。</p>
<p>其中，控制存储器（简称存控）是微程序控制单元的核心部件，用来存放全部微程序。</p>
<p>CMAR 是控存地址寄存器，用来存放欲读出的微指令地址</p>
<p>CMDR 是控存数据寄存器，用来存放从存控读出的微指令</p>
<p>顺序逻辑是用来控制微指令序列的，具体就是控制形成下一条微指令（即后续微指令）的地址</p>
<h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><h5 id="微指令序列地址的形成"><a href="#微指令序列地址的形成" class="headerlink" title="微指令序列地址的形成"></a>微指令序列地址的形成</h5><h5 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h5><h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><ol>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207153912299.png" class="" title="image-20231207153912299">
</li>
<li><p>周期窃取又叫做周期挪用，是指利用 CPU 不访问存储器的那些周期来实现 DMA 操作。</p>
</li>
<li><p>I&#x2F;O设备要求DMA传送会遇到三种情况，一种是此时CPU不需访问主存(如CPU正在执行乘法指令，由于乘法指令执行时间较长，此时CPU不需访问主存)，故I&#x2F;O设备访存与CPU不发生冲突。第二种情况是I&#x2F;O设备要求DMA传送时，CPU正在访存，此时必须待 存取周期结束时刻，CPU才能将总线占有权让出。第三种情况是I&#x2F;O设备要求访存时，CPU也要求访存，这就出现了访存冲突。此刻，I&#x2F;O访存优先于CPU访存，因为I&#x2F;O不立即访存就可能丢失数据，这时I&#x2F;O要窃取一二个存取周期，意味着CPU在执行访存指令过程中插入了DMA请求，并挪用了一二个存取周期，使CPU延缓了一二个存取周期再访存。</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207162859023.png" class="" title="image-20231207162859023">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207163257678.png" class="" title="image-20231207163257678">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207163551737.png" class="" title="image-20231207163551737">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207165814006.png" class="" title="image-20231207165814006">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231207170831367.png" class="" title="image-20231207170831367">
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/633191759">https://zhuanlan.zhihu.com/p/633191759</a></p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209150515503.png" class="" title="image-20231209150515503">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231209151825169.png" class="" title="image-20231209151825169">
</li>
<li><p>指令字长、存储字长、机器字长</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210131953000.png" class="" title="image-20231210131953000">
</li>
<li><p>32位的计算机中：32位(bit)&#x3D;4字节(byte)&#x3D;1字(word)</p>
<p>64位的计算机中：64位(bit)&#x3D;8字节(byte)&#x3D;1字(word)</p>
<p>由此可见，<strong>在不同位数的计算机中，一个字的大小也是不同的，所以一个字等于多少字节，是多少位，与计算机的系统硬件有关,不可以错误的对一个字是几字节下固定的判断</strong>。</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210190332080.png" class="" title="image-20231210190332080">
<p>存储字？</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231210191311320.png" class="" title="image-20231210191311320">
<p>对于扩展码的实际应用</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219220620549.png" class="" title="image-20231219220620549">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219221118811.png" class="" title="image-20231219221118811">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219222624866.png" class="" title="image-20231219222624866">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219230323825.png" class="" title="image-20231219230323825">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219230847814.png" class="" title="image-20231219230847814">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219232243387.png" class="" title="image-20231219232243387">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219232703307.png" class="" title="image-20231219232703307">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219232740920.png" class="" title="image-20231219232740920">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219233045969.png" class="" title="image-20231219233045969">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219233240243.png" class="" title="image-20231219233240243">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219233333311.png" class="" title="image-20231219233333311">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219233516247.png" class="" title="image-20231219233516247">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231219233536291.png" class="" title="image-20231219233536291">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231225115337794.png" class="" title="image-20231225115337794">
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231225145004473.png" class="" title="image-20231225145004473">
</li>
<li><p>边界对齐</p>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20231225161305743.png" class="" title="image-20231225161305743">
<p>P328 题目</p>
</li>
<li><p>P331 例题7.7</p>
</li>
<li><p>指令和数据都存储在存储器中，计算机如何区分它们？</p>
<ol>
<li>通过不同的时间段来区分指令和数据，即在取指令阶段(或取指微程序)取出的为指令，在执行指令阶段(或相应微程序)取出的即为数据。</li>
<li>通过地址来源区分，由PC提供存储单元地址的取出的是指令，由指令地址码部分提供存储单元地址的取出的是操作数。</li>
</ol>
</li>
</ol>
<h4 id="考试"><a href="#考试" class="headerlink" title="考试"></a>考试</h4><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/667609db17d80704fe232e8ef19f826c.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/cccef010812373902fde3be31e189adc.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/7710574e7af5829abbc252d691bb0080.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/b465c7d6061ae5d82834cabbd72dff06.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/bc3728b92a12a15b74ea5a14b48472b3.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/7187d9bd9aa1a0e0811f4005ec5bec91.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/6c9f70143858cb4e068830def67d501e.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/49a8bf2117a7aabdfea9d261780a5ecf.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/96316c64856c85cf3804e6768a8de882.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/967e29c0f18fad417cc936d3992e0b61.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/b141b7bc5df573bdbda7e787e81e2aca.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/fc54f0bf384954397959709c0fbabf86.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/07fd9368093a312caef6c3cd9bcd28c2.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/3c17a277fc4eda6dcd91e079a96a4bf5.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/7384cc2ff89b011332e0469c15602da5.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/f16bd578014a5d651c4e3950b639ee69.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/eb41d77d372dec03bccc87188917b54d.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/8bef6054fe23d8b6d8b94926e2cc712b.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/dc9e47f79f59ba830e9014643d7b56bc.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/1b9d52ad9a61a0a0e216f3d0de4679f8.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/a8fc17935532fbec8bf36ebbe7548ee8.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/39278e7fbc20b1c91ce303b67281f0f3.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/9840b944602de7aac2d855fc6d79e0bd.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/05fd0d0e38d667b6d212b81c01f30d4b.png" class="" title="img"><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/98964ab63df1512f262c081b9245f7ca.png" class="" title="img">提高带宽，减小存储体？ <img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/32521ce1ee826878033acd08a026e4b3.png" class="" title="img">通道方式没学？<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/494ab01e2a6c2503821e78e323ec02b9.png" class="" title="img">

<ul>
<li>决定计算机计算精度的主要指标是计算机的字长。</li>
<li>边界对齐方式虽然会浪费一些空间，但是可以提高取指令和取数的速度。</li>
<li>多少位的机器，这里的多少位一般指的是「机器字长」</li>
<li>每一个 Cache 块都要有一个标记项，来指明是哪一块的副本，所以在计算 Cache 容量的时候，需要同时分析标记项和 Cache 数据块的位数</li>
<li>Cache 的标记项，包括有效位、脏位、替换控制位、标记位<br>有效位是指 一个块是否在 Cache 中<br>修改位（脏位）是指 这个块是否被处理及修改（采用写回法的时候）</li>
<li>注意区分 Cache 地址和 Cache 行内的内容<br>Cache 行内，前部分是标记，后面是数据，标记并不参与编址，后面的内容参与编址。地址就是 Cache 行数 + 块内地址</li>
<li>注意 CPU 中，运算器和控制器的寄存器区分。<br>运算器有 ACC、PSW、MQ（乘商寄存器）、X（操作数寄存器）、变址寄存器（IX）、基址寄存器（BR）<br>控制器有 PC、IR、MAR、MDR（关于指令的一些寄存器都在控制器中）</li>
<li>计算机软件按照功能分类，可以分为系统软件和应用软件<br><strong>系统软件</strong>主要有（基本上最后都是 xxx 系统）：OS（操作系统）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序<br>应用软件主要有：科学计算类程序、网络软件程序</li>
<li>汇编程序：将汇编语言程序翻译为机器语言程序<br>解释程序：将原程序中的语句按执行顺序<strong>逐条翻译</strong>为机器指令并立即执行（直接到机器语言）<br>编译程序：将高级语言翻译为<strong>汇编语言</strong>或者<strong>机器语言</strong>程序（都可以）</li>
<li>冯诺依曼机最根本的特征是采用「存储程序」原理，基本工作方式是<strong>控制流驱动方式</strong>。</li>
<li><strong>机器字长</strong>（字长）是指计算机<strong>一次整数运算</strong>（即定点整数运算）所能处理的二进制数据的位数。</li>
<li>在计算机中，CPI 和时钟频率无关，只是频率更快一些的话，可以加快运行速度。</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240103163951506.png" class="" title="image-20240103163951506">
选 B</li>
<li>机器语言和汇编语言与机器指令对应，而高级语言不与机器指令对应，所以有更好的 <strong>可移植性</strong>。</li>
<li>指令字长和存储字长都必须是字节的整数倍，所以如果我们计算 <strong>位数</strong>，最后的结果应该变为 8 的倍数</li>
<li>移码用来表示浮点数的阶码，只可以用来表示整数</li>
<li>一个真值的移码和补码仅差一个符号位</li>
<li>补码判断大小：对于正数，很容易判断；对于负数，<strong>数值部分越大</strong>，绝对值越小，<strong>真值越大</strong></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240103172730016.png" class="" title="image-20240103172730016">
注意整数、小数十进制和二进制之间的转换</li>
<li>[-x]补 是 [x]补 含符号位在内，全部取反，末位加一</li>
<li>n 位二进制最大表示 $2^{n} - 1$</li>
<li>补码的情况下，左移高位丢 0 结果出错，右移低位丢 1 影响精度</li>
<li>逻辑移位的时候，高位直接移丢，低位补 0</li>
<li>溢出判断有三种方式：一位符号位、二位符号位、一位加上最高位进位</li>
<li>浮点数运算中，数据一旦产生了上溢，计算机必须中断运算操作，进行溢出处理。当数据下溢的时候，因为绝对值过小，激素那几仅当成机器零来处理。<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104103339056.png" class="" title="image-20240104103339056"></li>
<li>基数不同，浮点数的规格化形式也不同，当基数为 4 的时候，原码规格化形式的尾数的最高两位<strong>不全为 0</strong><br>（规格化这里要注意，是对于原码规格化还是说对于补码规格化）</li>
<li>浮点数的基数越大，表示的范围越大，但是精度越低。同时，因为对阶或者尾数溢出需右移以及规格化需左移的次数显著变少，因此运算速度可能提高。</li>
<li>舍入是浮点数的概念，定点数中没有舍入的概念</li>
<li>RAM 和 ROM 的存取方式都是随机存取，ROM 可以和 RAM 共同作为主存的一部分，统一构成主存的地址域</li>
<li>主存和 Cache 之间的数据调动是由硬件自动完成的，对所有的程序员都是透明的；<br>主存和辅存之间的数据调动则是由硬件和操作系统共同完成的，对应用程序员是透明的（如果使用汇编语言，就不是透明的）</li>
<li>Cache 的效率：Cache 访问的时间 &#x2F; 平均访问的时间</li>
<li>DRAM 的刷新是透明的，刷新不依赖于外部的访问</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104110952404.png" class="" title="image-20240104110952404">
10+8+2+1（最后的是两个读写控制信号线和一个片选线)，所以是 A</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104111408195.png" class="" title="image-20240104111408195">
5+8+2+2<br>片选线是两个，因为采用了地址复用技术，所以分为行通选信号和列通选信号</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104112417927.png" class="" title="image-20240104112417927">
选 C，这一个题目还是比较有意思的</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104114044137.png" class="" title="image-20240104114044137">
<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104114105035.png" class="" title="image-20240104114105035"></li>
<li>高位交叉存储不符合程序运行的局部性原理</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104115436049.png" class="" title="image-20240104115436049"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104142057903.png" class="" title="image-20240104142057903">
仔细计算一下会发现，其实只有位扩展，所以选 A</li>
<li>算数移位的时候，只有低位的符号位参与移动</li>
<li>IO 设备统一编址的时候不需要单独设置指令，访存指令就可以，而单独编址的时候需要设定单独的访存指令。</li>
<li>SRAM 不是破坏性读出，而 DRAM 是破坏性读出</li>
<li>由于程序的转移的概率不是很低，数据分布的离散性较大，所以单纯依靠并行系统提高主存系统的频宽是有限的，这就必须从<strong>系统结构</strong>上进行改进，所以提出了 Cache-主存 和 主存-辅存 层次。</li>
<li>当 CPU 发出读请求时，若访存地址在 Cache 中命中，就将此地址转换成 Cache 地址，直接对于 Cache 进行读操作。</li>
<li>CPU 与 Cache 或者主存之间交互的单位是「字」，而 Cache 与主存之间的信息交互单位是「字块」</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104161019509.png" class="" title="image-20240104161019509">
根据直相联映射，直接选取地址的后 14 位（因为 Cache 的容量为 16KB)，所以选 C</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104200609153.png" class="" title="image-20240104200609153"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104204219414.png" class="" title="image-20240104204219414"></li>
<li>单重中断和多重中断之间的区别：<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104211142752.png" class="" title="image-20240104211142752"></li>
<li>中断处理的全过程：<ol>
<li>关中断</li>
<li>保护断点</li>
<li>中断服务程序寻址</li>
<li>保护现场和屏蔽字</li>
<li>开中断</li>
<li>执行中断服务程序</li>
<li>关中断</li>
<li>恢复现场和屏蔽字</li>
<li>开中断、中断返回，<strong>中断服务程序的最后一条指令通常是中断返回指令</strong><br>（整个进入）</li>
</ol>
</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104214823019.png" class="" title="image-20240104214823019"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104215604992.png" class="" title="image-20240104215604992"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240104220215439.png" class="" title="image-20240104220215439"></li>
<li>调用子程序的指令和转移指令的区别：<ol>
<li>执行调用指令时必须保存下一条指令的地址，当子程序结束的时候，根据返回地址回到主程序继续执行</li>
<li>转移指令不返回执行</li>
</ol>
</li>
<li>程序控制类指令的功能是改变程序执行的顺序</li>
<li>在指令格式中，采用扩展码设计方案的目的是：保持指令字长度不变而增加指令的数量</li>
<li>立即数寻址的地址字段就是操作数本身，而不是地址，<strong>采用补码的形式</strong></li>
<li>直接寻址的寻址方式，优点是简单，在执行阶段仅仅需要访存一次，但是<strong>操作数的地址不易修改</strong>（因为我们一般不能改变指令的格式）</li>
<li>相对寻址广泛用于转移指令，<strong>便于实现多道程序</strong></li>
<li>基址寻址中，基址寄存器的内容不变，形式地址可变，有利于多道程序设计，并且可以用于编制浮动程序，但是偏移量 A 比较短</li>
<li>变址寻址中，形式地址 A 不变，所以利于编制循环程序（对于数组的应用）</li>
<li>寄存器寻址，寄存器中的数字就是我们要取的操作数；寄存器间接寻址，寄存器中是我们要取的操作数的地址</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240105171237087.png" class="" title="image-20240105171237087">
为 B，操作数地址</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240105175751192.png" class="" title="image-20240105175751192">
A<br>对于 D，控制信号指的是 CU 根据操作码发出的信号，所以对于单周期的处理器来说，一个时钟周期内指令不会变化，所以控制信号就不会发生变化</li>
<li>控制存储器（CM, 存储微程序的）在 CPU 内部，使用 ROM 实现，是微程序控制器的核心组成部分</li>
<li>微指令编码中，<strong>直接编码方式</strong>简单、直观，执行速度快，操作并行性好；但是指令字长过长，造成存储器容量极大<br><strong>字段直接编码方式中</strong>，分为若干块，比直接编码方式慢</li>
<li>因为指令无法直接读取 PC 和 PSW 等，所以在关中断以后，先保护断点在栈或者特定的寄存器中；而对于现场信息，指令可以直接访问，所以通常在中断服务程序中通过指令把它们保存在栈中。</li>
<li>DMA 控制器（又叫做 DMA 接口），功能是接受外设发出的 <strong>DMA 请求</strong>，并且向 CPU 发出<strong>总线请求</strong>。（注意区分两个请求和两个对象）</li>
<li>DMA 在数据传送的过程中，完全由硬件实现（预处理、数据传送、后处理三个过程）</li>
<li>DMA 不中断现行程序，不需要保护现场，除了预处理和后处理，不占用任何 CPU 资源</li>
<li>中断向量是硬件方法</li>
<li><strong>中断向量就是</strong>中断服务程序的入口</li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240106003453047.png" class="" title="image-20240106003453047"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240106003504275.png" class="" title="image-20240106003504275"></li>
<li><img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240106003716629.png" class="" title="image-20240106003716629"></li>
<li>在 DMA 方式下，主存和 IO 设备之间有一条物理通路相连吗？<img src="/2023/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/image-20240106003900192.png" class="" title="image-20240106003900192"></li>
<li></li>
</ul>
<h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ol>
<li>主存储器 MM(Main Memory) 又叫做内存</li>
<li>辅存 又叫做 外存</li>
<li>指令集结构 ISA</li>
<li>CPI Cycle Per Instruction</li>
<li>MIPS Million Instructions Per Second</li>
<li>MREQ 访存控制信号 Memory Request</li>
<li></li>
</ol>
<h3 id="复习课"><a href="#复习课" class="headerlink" title="复习课"></a>复习课</h3><h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>如何区分指令和数据？</p>
<p>计算机硬件的主要指标（三个）：计算速度（CPI（不同情况下不同概念）、百万指令条数）、机器字长、？？</p>
<p>关于计算时间的作业题，这里的计算大概是重点</p>
<p>还有一个层次结构，理解了就行</p>
<h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><p>两级存储体系：缓存（纯硬件实现，为了解决速度问题，自己设计一个 Cache，设计一个流水的访存指令？）主存-为了提高访问主存速度，主存辅存-为了解决容量问题</p>
<p>存储单元的属性（每一个都有自己的地址和内容），字节编址？字编址？大端小端？、命名字的地址（不管大端小端都是低地址）？</p>
<p>C 语言变量在内存中分配字节数</p>
<p>不管读写主存，CPU 都是送出地址，然后一个读写命令</p>
<p><strong>重点：</strong> 存储体有一个 <strong>地址锁存器</strong>，地址译码器，还有存储体，读写逻辑，读出来的信息放在数据缓冲器寄存器里面，然后送给数据总线</p>
<p>动态存储的刷新（使用电容存储电荷来存储信息，不然会掉电丢失）三种刷新方式必须掌握（最好的刷新方式？）</p>
<p><strong>重点难点：</strong>存储器设计、译码器、容量计算、每一个选中的芯片都有片内地址（无法参与外部的译码电路）、片外地址、小容量的芯片一定需要二次译码、二次译码差几倍就是几根地址线？选的不同芯片不要差别太大，不然电路设计麻烦</p>
<p>汉明码（奇偶校验，看题干）</p>
<p><strong>重点</strong> 低位和高位交叉编址的带宽计算，与由多少存储体组成有关</p>
<p><strong>重点</strong> Cache 命中率、效率、访问时间计算</p>
<p><strong>重点</strong> Cache 主存地址映射，会出  大题</p>
<p>几个片选信号写几个范围</p>
<p>汉明码先纠错，再取有效信息</p>
<p>低位存取周期？？？？</p>
<h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><p>总线没讲，因为太老了，但是智慧树的习题上面有几道例题，讲的数据总线。</p>
<p>涉及到的题目大部分是数据总线上的数据传输率的题目</p>
]]></content>
      <tags>
        <tag>computer</tag>
      </tags>
  </entry>
</search>
