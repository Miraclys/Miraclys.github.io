<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito:300,300italic,400,400italic,700,700italic%7Cfira+code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The key record of data structure.">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构关键记录">
<meta property="og:url" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Miraclys">
<meta property="og:description" content="The key record of data structure.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E6%8E%92%E5%BA%8F%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%88%86%E6%B2%BB%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png">
<meta property="og:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="article:published_time" content="2023-09-06T06:06:06.000Z">
<<<<<<< HEAD
<meta property="article:modified_time" content="2023-11-18T08:30:13.329Z">
=======
<meta property="article:modified_time" content="2023-11-20T11:32:23.015Z">
>>>>>>> 1e50b1f9bc507effde69552824d90fe0193643ca
<meta property="article:author" content="Miraclys">
<meta property="article:tag" content="Data Structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png">


<link rel="canonical" href="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/","path":"2023/09/06/数据结构关键记录/","title":"数据结构关键记录"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构关键记录 | Miraclys</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Miraclys</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">课堂笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">找出有环链表的入环点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E5%92%8C-Brent-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">Floyd 判圈算法和 Brent 判圈算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">1.1.3.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B-divide-and-conquer"><span class="nav-number">1.2.</span> <span class="nav-text">分而治之 divide-and-conquer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.2.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-D-maxima-finding-problem"><span class="nav-number">1.2.3.</span> <span class="nav-text">2-D maxima finding problem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-closest-pair-problem"><span class="nav-number">1.2.4.</span> <span class="nav-text">the closest pair problem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#the-convex-hull-problem"><span class="nav-number">1.2.5.</span> <span class="nav-text">the convex hull problem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#matrix-multiplication"><span class="nav-number">1.2.6.</span> <span class="nav-text">matrix multiplication</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FFT"><span class="nav-number">1.2.7.</span> <span class="nav-text">FFT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Medians-and-Order-Statistics"><span class="nav-number">1.2.8.</span> <span class="nav-text">Medians and Order Statistics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-1"><span class="nav-number">1.2.9.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Abstract-Data-Type-ADT"><span class="nav-number">1.2.10.</span> <span class="nav-text">Abstract Data Type(ADT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-2"><span class="nav-number">1.2.11.</span> <span class="nav-text">扩展</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%B6%88%E9%99%A4"><span class="nav-number">1.3.</span> <span class="nav-text">递归消除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%80%A7%E6%B6%88%E9%99%A4%E5%8A%9E%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">一般性消除办法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.2.</span> <span class="nav-text">倒水问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B1%82%E8%A7%A3%E7%BB%84%E5%90%88%E6%95%B0"><span class="nav-number">1.3.3.</span> <span class="nav-text">求解组合数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-3"><span class="nav-number">1.3.4.</span> <span class="nav-text">扩展</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lowbit"><span class="nav-number">1.3.5.</span> <span class="nav-text">lowbit</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.</span> <span class="nav-text">树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.4.1.</span> <span class="nav-text">树的表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="nav-number">1.4.2.</span> <span class="nav-text">非递归遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.3.</span> <span class="nav-text">中序遍历的线索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.4.</span> <span class="nav-text">前序遍历的线索二叉树</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">1.4.5.</span> <span class="nav-text">后序遍历的线索二叉树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.5.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="nav-number">1.5.1.</span> <span class="nav-text">二叉堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E9%A1%B9%E5%A0%86"><span class="nav-number">1.5.2.</span> <span class="nav-text">二项堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Fibonacci-%E5%A0%86"><span class="nav-number">1.5.3.</span> <span class="nav-text">Fibonacci 堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lazy-%E6%9C%BA%E5%88%B6"><span class="nav-number">1.5.4.</span> <span class="nav-text">lazy 机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.6.</span> <span class="nav-text">编码问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">1.7.</span> <span class="nav-text">霍夫曼树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%80%BE%E5%A0%86-%E5%B7%A6%E5%80%BE%E6%A0%91-%E5%B7%A6%E5%81%8F%E5%A0%86-%E5%B7%A6%E5%81%8F%E6%A0%91"><span class="nav-number">1.8.</span> <span class="nav-text">左倾堆 &#x2F; 左倾树 &#x2F; 左偏堆 &#x2F; 左偏树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="nav-number">1.9.</span> <span class="nav-text">二叉平衡树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#the-mathematics-of-rubik%E2%80%99s-cube"><span class="nav-number">1.10.</span> <span class="nav-text">the mathematics of rubik’s cube</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95"><span class="nav-number">1.11.</span> <span class="nav-text">Dijkstra 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9C%A8%E5%8C%BA%E9%97%B4%E4%B8%8A%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">二叉树在区间上？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%AE%B5%E7%9B%B8%E4%BA%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.13.</span> <span class="nav-text">线段相交的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kd-%E6%A0%91"><span class="nav-number">1.14.</span> <span class="nav-text">kd 树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8-Skip-List"><span class="nav-number">1.15.</span> <span class="nav-text">跳表 Skip List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP"><span class="nav-number">1.16.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-find"><span class="nav-number">1.17.</span> <span class="nav-text">并查集(Union-find)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">1.18.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-number">1.18.1.</span> <span class="nav-text">欧拉回路问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="nav-number">1.19.</span> <span class="nav-text">最短路</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dijkstra-%E7%AE%97%E6%B3%95%E9%81%87%E5%88%B0%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="nav-number">1.19.1.</span> <span class="nav-text">Dijkstra 算法遇到负权边</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bellman-Ford-%E7%AE%97%E6%B3%95"><span class="nav-number">1.19.2.</span> <span class="nav-text">Bellman-Ford 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd-Warshall-%E7%AE%97%E6%B3%95"><span class="nav-number">1.19.3.</span> <span class="nav-text">Floyd-Warshall 算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%9F%E7%8E%AF%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">1.19.4.</span> <span class="nav-text">负环的检测</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.20.</span> <span class="nav-text">图的闭包问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A"><span class="nav-number">2.</span> <span class="nav-text">作业</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Miraclys"
      src="/../images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Miraclys</p>
  <div class="site-description" itemprop="description">Live a life you will remember.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Miraclys" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Miraclys" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:miraclysyunsenl@gmail.com" title="E-Mail → mailto:miraclysyunsenl@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../images/avatar.jpg">
      <meta itemprop="name" content="Miraclys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miraclys">
      <meta itemprop="description" content="Live a life you will remember.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构关键记录 | Miraclys">
      <meta itemprop="description" content="The key record of data structure.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构关键记录
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-06 14:06:06" itemprop="dateCreated datePublished" datetime="2023-09-06T14:06:06+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
<<<<<<< HEAD
      <time title="Modified: 2023-11-18 16:30:13" itemprop="dateModified" datetime="2023-11-18T16:30:13+08:00">2023-11-18</time>
=======
      <time title="Modified: 2023-11-20 19:32:23" itemprop="dateModified" datetime="2023-11-20T19:32:23+08:00">2023-11-20</time>
>>>>>>> 1e50b1f9bc507effde69552824d90fe0193643ca
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/09/06/数据结构关键记录/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

            <div class="post-description">The key record of data structure.</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>TO DO</p>
<p>定义一个模板类 ? </p>
<p>如何判断链表是否有环？</p>
<ol>
<li><p>使用 map 对于地址打上标记，如果同一个地址被访问了两次就是有环的。</p>
</li>
<li><p>快慢指针(Floyd’s Cycle Detection Algorithm)，使用同余方程得到 $a + kp$ 和 $b + kq \pmod{n}$，其中 a b 分别是两个指针进入环的初始步长，k 是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 $b - a \equiv k(p - q)$ 它们的步长差值为 1 的时候可以始终保证同余。</p>
<p> 对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为 1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。<br> 下面是一段 Python 程序演示：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<h5 id="找出有环链表的入环点"><a href="#找出有环链表的入环点" class="headerlink" title="找出有环链表的入环点"></a>找出有环链表的入环点</h5><p>可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S 点，入环点是 T 点，绿色的部分是慢指针所走过的路程。</p>
<p>对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S 点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。</p>
<p>可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以 ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class="" title="入环点">

<h5 id="Floyd-判圈算法和-Brent-判圈算法"><a href="#Floyd-判圈算法和-Brent-判圈算法" class="headerlink" title="Floyd 判圈算法和 Brent 判圈算法"></a>Floyd 判圈算法和 Brent 判圈算法</h5><p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。</p>
<p>其实上面的快慢指针方法就是 Floyd 判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。<br>还有一种判圈的算法，比它更快，就是 <strong>Brent</strong> 判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第 n 轮，乌龟跳到兔子的位置，兔子走$2^{n-1}$步。</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>在申明类中的成员函数后面加上 <code>const</code> 函数就成了只读函数，如 <code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字”static”的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
</blockquote>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure>

<p>函数指针的应用：</p>
<ol>
<li>把函数作为参数传入另一个函数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>第二个例子，排序上的应用</li>
</ol>
<p>使用 <code>ascending</code> 和 <code>descending</code> 两个函数代替大小判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>lambda 函数的书写结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数指针应用？lambda 函数？ </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br></pre></td></tr></table></figure>

<p>STL 中的<strong>迭代子类</strong>？？</p>
<h4 id="分而治之-divide-and-conquer"><a href="#分而治之-divide-and-conquer" class="headerlink" title="分而治之 divide-and-conquer"></a>分而治之 divide-and-conquer</h4><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</p>
<blockquote>
<p>整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 <strong>性质滚性质</strong>，一直带动，所以可以达到加速的目标。</p>
</blockquote>


<p>TO DO:</p>
<p>？？非递归版本的归并排序</p>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><!-- 快速排序时间复杂度
最坏 概率统计的意义下？ -->
<p>关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点…</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" class="">

<p>关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</p>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="">
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" class="">

<p>上面摘自知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/341201904">https://zhuanlan.zhihu.com/p/341201904</a></p>
<h5 id="2-D-maxima-finding-problem"><a href="#2-D-maxima-finding-problem" class="headerlink" title="2-D maxima finding problem"></a>2-D maxima finding problem</h5><p>这是一个 maxima 问题，一般这种问题有两种解决方式。</p>
<ol>
<li>排序法</li>
</ol>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E6%8E%92%E5%BA%8F%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png" class="">

<ol start="2">
<li>分治法</li>
</ol>
<img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%88%86%E6%B2%BB%E6%B3%95%E6%9E%81%E5%A4%A7%E7%82%B9.png" class="">

<p>摘自知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27850478">https://zhuanlan.zhihu.com/p/27850478</a></p>
<p>TO DO</p>
<!-- 平面极大点
分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 -->

<h5 id="the-closest-pair-problem"><a href="#the-closest-pair-problem" class="headerlink" title="the closest pair problem"></a>the closest pair problem</h5><p>感觉 OI-Wiki 讲解的很全面 <a target="_blank" rel="noopener" href="https://oi-wiki.org/geometry/nearest-points/%EF%BC%8C%E8%BF%98%E6%9C%89%E6%8E%A8%E5%B9%BF%EF%BC%9A%E5%B9%B3%E9%9D%A2%E6%9C%80%E5%B0%8F%E5%91%A8%E9%95%BF%E4%B8%89%E8%A7%92%E5%BD%A2">https://oi-wiki.org/geometry/nearest-points/，还有推广：平面最小周长三角形</a> $\dfrac{d \times 2d}{\frac{1}{4} \times \pi \times (\frac{d}{2})^{2}}$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</p>
<!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）

时间复杂度？ -->

<p>TO DO</p>
<h5 id="the-convex-hull-problem"><a href="#the-convex-hull-problem" class="headerlink" title="the convex hull problem"></a>the convex hull problem</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lemonxiaoxiao/article/details/108619552">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</a></p>
<p>TO DO</p>
<!-- ?
一个著名算法，礼物算法？ Jarvis March
首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着
不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了
但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去
找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 -->

<h5 id="matrix-multiplication"><a href="#matrix-multiplication" class="headerlink" title="matrix multiplication"></a>matrix multiplication</h5><!-- ?
P Q R S T U V?
时间复杂度大概是 $O(\log_2(7)) \approx O(n^{2.81})$?
但是仍然不是最优的，具体可以自己去搜索一下 -->

<p>使用类实现的矩阵的一些基础操作，可以看 <code>Fibonacci.cpp</code></p>
<p>TO DO</p>
<h5 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h5><p>分治做法，见 <code>FFT.md</code> 和 <code>FFT.cpp</code>(使用自带的 complex 类实现).其中，使用自己手写类实现的 FFT 在 <code>FFTClass.cpp</code>(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</p>
<h5 id="Medians-and-Order-Statistics"><a href="#Medians-and-Order-Statistics" class="headerlink" title="Medians and Order Statistics"></a>Medians and Order Statistics</h5><p>对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log{n})$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</p>
<p>每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</p>
<p>还有一种递归的算法，分为 5 个数，</p>
<p>nth_element() ?? 函数</p>
<p>TO DO</p>
<h5 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h5><p>尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。<br>只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。<br>为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</p>
<h5 id="Abstract-Data-Type-ADT"><a href="#Abstract-Data-Type-ADT" class="headerlink" title="Abstract Data Type(ADT)"></a>Abstract Data Type(ADT)</h5><p>抽象数据类型</p>
<h5 id="扩展-2"><a href="#扩展-2" class="headerlink" title="扩展"></a>扩展</h5><p>TO DO</p>
<p>Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</p>
<p>不想改变内部元素的时候记得加 const，如果不加的话，<code>void Func(const List&amp; l) &#123; l.print(); &#125;</code> 其中不允许调用，因为 Func 有修改成员变量的风险。</p>
<p><strong>常引用？</strong></p>
<p><strong>把函数当作函数的参数？</strong></p>
<p>派生类禁止父类的函数或者方法？ </p>
<p>括号匹配问题 Bracket Matching Problem</p>
<p>计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</p>
<p>双端队列 dequeue</p>
<p>环形数组</p>
<h4 id="递归消除"><a href="#递归消除" class="headerlink" title="递归消除"></a>递归消除</h4><h5 id="一般性消除办法"><a href="#一般性消除办法" class="headerlink" title="一般性消除办法"></a>一般性消除办法</h5><ul>
<li>利用堆栈，模拟栈来实现，见 <code>Hanoi.cpp</code></li>
</ul>
<p>汉诺塔问题 递归求解，如何去掉递归求解。$f_n &#x3D; 2 f_{n - 1} + 1$，所以 $(f_n + 1) &#x3D; 2(f_{n - 1} + 1)$</p>
<h5 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h5><p>这种任务方案其实挺多的。其实，背后对应的是<strong>辗转相除法</strong>。</p>
<p>我们可以倒出来的水的数量就是余数。</p>
<p>设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 <code>ax + by = c</code>，如果有解，就是 $\gcd{(a, b)} | c$</p>
<h5 id="求解组合数"><a href="#求解组合数" class="headerlink" title="求解组合数"></a>求解组合数</h5><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a> 见 OI-Wiki各种组合数公式</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a> 二项式反演</p>
<h5 id="扩展-3"><a href="#扩展-3" class="headerlink" title="扩展"></a>扩展</h5><p>实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是<strong>过于耦合了</strong>。所以，对于一个类来说，接口是很重要的。</p>
<h5 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit"></a>lowbit</h5><h4 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h4><p>树中所有节点度数的最大值叫做整个树的度。</p>
<h5 id="树的表示"><a href="#树的表示" class="headerlink" title="树的表示"></a>树的表示</h5><p>一共有四种表示树的方式：</p>
<ol>
<li><p>树形结构。很直观、形象</p>
</li>
<li><p>文氏图表示法。使用集合以及集合的包含关系描述树结构。</p>
</li>
<li><p>凹入表示法。使用线段的伸缩描述树结构。</p>
</li>
<li><p>括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</p>
</li>
</ol>
<p>树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</p>
<p>按层次遍历二叉树，可能还是比较吃内存的。</p>
<p>DLR LDR LRD </p>
<p>前序 中序 后序 和 根的区别？</p>
<h5 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h5><p>对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 <code>GetTreeOrderNor.cpp</code> </p>
<p>递归形式参见 <code>GetTreeOrderRecursion.cpp</code> </p>
<p>给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 <code>ParseTreeSequence.cpp</code></p>
<h5 id="中序遍历的线索二叉树"><a href="#中序遍历的线索二叉树" class="headerlink" title="中序遍历的线索二叉树"></a>中序遍历的线索二叉树</h5><p>这样也可以充分利用空间</p>
<p>将叶子节点的右孩子指向下一个应改遍历的节点(因为一开始叶子节点的右孩子是 null，造成了浪费)，并且加一个 bool 类型的变量，表示这个节点的右孩子是不是进行了修改。</p>
<p>这样中序遍历的时候好像也会简单很多(在中序遍历的意义下，将二叉树变成了一个单链表)</p>
<p>这样二叉树的遍历就不再依赖于堆栈，并且产生了向前向后的两个方向，和双链表的行为是比较相似的。</p>
<h5 id="前序遍历的线索二叉树"><a href="#前序遍历的线索二叉树" class="headerlink" title="前序遍历的线索二叉树"></a>前序遍历的线索二叉树</h5><p>顺序建立就是修改右子树</p>
<p>但是如果反过来会出现左孩子已经被占用的问题，此时需要借助堆栈</p>
<h5 id="后序遍历的线索二叉树"><a href="#后序遍历的线索二叉树" class="headerlink" title="后序遍历的线索二叉树"></a>后序遍历的线索二叉树</h5><img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" class="">

<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><h5 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h5><p>当我们谈论到堆(Heap)时，通常指的是二叉堆(Binary Heap)，它是一种特殊的树形结构，常用于实现优先队列和一些图算法(物理存储上是数组，但是逻辑结构上是二叉树，这也是为什么我们可以使用 vector 来模拟的原因)。</p>
<p>堆的性质：</p>
<ol>
<li><p>二叉树结构：堆是一种完全二叉树，除了最后一层，别的层的节点都是满的，最后一层的节点从左向右填充。</p>
</li>
<li><p>小根堆：任何父节点的值都小于等于其子节点的值。</p>
</li>
<li><p>不唯一性：对于给定的数据集，可能存在多个不同的最小堆或者最大堆。</p>
</li>
<li><p>只是保证了节点的权值大于两个儿子节点的权值，也就是说，堆维护的更是我们关注的相对大小关系，尤其是最顶部的元素大小，我们并不关心全序大小关系(也无法维护)。</p>
</li>
</ol>
<blockquote>
<p>  在实际中，实现堆（Heap）通常更倾向于使用向量（数组）来模拟二叉树的结构，而不是构建一个显式的二叉树数据结构。</p>
</blockquote>
<h5 id="二项堆"><a href="#二项堆" class="headerlink" title="二项堆"></a>二项堆</h5><h5 id="Fibonacci-堆"><a href="#Fibonacci-堆" class="headerlink" title="Fibonacci 堆"></a>Fibonacci 堆</h5><h5 id="lazy-机制"><a href="#lazy-机制" class="headerlink" title="lazy 机制"></a>lazy 机制</h5><p>上面的最简单的二叉堆做法呢，我们很好地利用了二叉树序号之间的关系(父子的序号有关系)，但是我们在更新的时候每一次都是 $\log{n}$ 的复杂度，不是很优，比如说有些元素我们以后根本用不到，而堆又本身不是关注全序关系的，所以我们可以利用 lazy 机制。</p>
<p>TODO </p>
<p>现在库里面的堆，基本上都不是基于 <strong>二叉堆</strong>(Binary Heap) 实现的。</p>
<p>Fibonacci 堆 也是希望我们去更多地了解一些堆。</p>
<p>堆的合并、二叉堆的合并？</p>
<p>二项堆</p>
<p>重载运算符</p>
<h4 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h4><p>结构光扫描中，我们如何马上知道这条光是第几条光？就要用到编码了</p>
<p>能不能发明一种序列，使得连续的几个在序列中是唯一的，longest ？ 是多长？3 个颜色的话，先画出 27 个节点。RRR 的话，连接 RRG RRB(它的后继节点)</p>
<p>寻找访问序列最长的，而且不能重复</p>
<p>深度遍历可以吗？最好不要写递归，可以队列、栈</p>
<h4 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h4><p>每一次找权值最小两个节点，变为 n - 1 个节点</p>
<ol>
<li><p>能不能构建出来</p>
</li>
<li><p>总体的最小代价</p>
</li>
</ol>
<p>可以搜索霍夫曼树的题目</p>
<p>实现持久化的最小两个数？手写优先队列？平衡树？</p>
<h4 id="左倾堆-左倾树-左偏堆-左偏树"><a href="#左倾堆-左倾树-左偏堆-左偏树" class="headerlink" title="左倾堆 &#x2F; 左倾树 &#x2F; 左偏堆 &#x2F; 左偏树"></a>左倾堆 &#x2F; 左倾树 &#x2F; 左偏堆 &#x2F; 左偏树</h4><p>虽然二叉堆的插入、删除操作挺好的，但是不支持合并。所以我们想寻找一种数据结构使得堆在合并的时候比较高效。</p>
<blockquote>
<p>Leftist Heap is a priority queue data structure that also supports merge of heaps in O(log n) time.</p>
</blockquote>
<p>FHQ Treap TODO</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji">https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji</a> TODO</p>
<p>最优传输理论</p>
<p>启发式合并堆</p>
<h4 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h4><p>可以证明平衡二叉树的高度为 $\log{n}$ 吗？</p>
<p>N(h) &#x3D; 1 + N(h - 1) + N(h - 2); AVL 树的高度推导 N(h) 表示高度为 h 时最不平衡时的节点个数。</p>
<p>我们是按照左右子树的树高度之差来定义的，这只是定义平衡的一种。但是还有很多别的方式，比如左右子树的节点。</p>
<p>维护平衡的机制有很多种，比如说典型的 B 树，2-3-4树，它所有的叶子都在同一个高度上面。它最不满的情况就是一个满二叉树，所以它可以保证高度在 $\log$ 级别。</p>
<p>AVL B树 红黑树 234树 Treap</p>
<p>红黑树的实际应用比较频繁，它的效率比较高一点。红黑树和 234树之间的关系？？ TODO</p>
<p>插入的时候常常面临三种情形。</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/MashPlant/solution2-p3369">https://www.luogu.com.cn/blog/MashPlant/solution2-p3369</a> B 树代码</p>
<p>LCT问题？ Link Cut Tree</p>
<p>Treap 的高度 log 证明？</p>
<h4 id="the-mathematics-of-rubik’s-cube"><a href="#the-mathematics-of-rubik’s-cube" class="headerlink" title="the mathematics of rubik’s cube"></a>the mathematics of rubik’s cube</h4><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><p>正确性证明？</p>
<p>多边形</p>
<p>差分约束问题 线性规划问题 max \sum d 要求比 dijkstra 更加严苛？</p>
<p>Gorubi </p>
<p>最短路的话线性规划没有 dijkstra 更加优</p>
<p>A* 算法？</p>
<h4 id="二叉树在区间上？"><a href="#二叉树在区间上？" class="headerlink" title="二叉树在区间上？"></a>二叉树在区间上？</h4><p>维护直接的 Rank 感觉代价过于高，因为每一次删除和插入都要把其余元素都改变一次，所以我们不直接维护 Rank。</p>
<p>二叉树序列化？<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26418233">https://zhuanlan.zhihu.com/p/26418233</a></p>
<h4 id="线段相交的问题"><a href="#线段相交的问题" class="headerlink" title="线段相交的问题"></a>线段相交的问题</h4><p>两个结构：</p>
<ol>
<li><p>处理事件的优先队列(关键位置停下来，遇到了水平线段的左端点，遇到了水平线段的右端点，遇到了竖直线段)(需要使用一个二叉树维护水平线段，包括水平竖直关系)(水平线段的 y 高度使用二叉树维护了？树套树？)</p>
</li>
<li><p>维护扫描的每个关键位置的全序列表</p>
</li>
</ol>
<h4 id="kd-树"><a href="#kd-树" class="headerlink" title="kd 树"></a>kd 树</h4><p>grid 2d tree</p>
<p>quadtree(四叉树，每一个格子一分为 4) bsptree(每一次有一个平面，对于所在的平面二分，在二维的情况下就是直线)</p>
<p>上面的结构，除了 grid 的应用都是很多的。各自在不同的应用场景下使用。</p>
<p>kd 树其实是 bst 树的延申。可是很多时候一维数据是不够的，很多情况都是高维的东西。在机器学习中应用也很多。</p>
<p>ray tracing</p>
<p>2d range serach</p>
<p>从乱序中在 O(n) 的时间复杂度下找出中位数。</p>
<ol>
<li><p>每一刀下去，都是将矩形分为两个部分。</p>
</li>
<li><p>奇偶相间，第一层竖线划分，第二层就是水平划分。(优化就是把点很紧密的包在一块？)</p>
</li>
</ol>
<p>nth_element 严格 O(n) 查找中位数</p>
<h4 id="跳表-Skip-List"><a href="#跳表-Skip-List" class="headerlink" title="跳表 Skip List"></a>跳表 Skip List</h4><p>跳表是相对年轻的一个数据结构，1990 年由 Bill Pugh 提出。</p>
<p>我们需要区分一下数据域和指针域 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/bigsai/p/14193225.html">https://www.cnblogs.com/bigsai/p/14193225.html</a></p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>前缀和后缀的问题</p>
<p>BM 算法？</p>
<p>DFA</p>
<h4 id="并查集-Union-find"><a href="#并查集-Union-find" class="headerlink" title="并查集(Union-find)"></a>并查集(Union-find)</h4><p>虽然并查集的代码是最少的一个，但是确实非常有用的。它可以解决<strong>等价类</strong>相关的问题。</p>
<p>link-by-size 按照大小合并，此时最高高度不超过 log n，当然也有按照 rank(height)高度合并。</p>
<p>还有路径压缩(path compression)</p>
<p>无路径压缩的时候，复杂度是 $m \log n$</p>
<p>有路径压缩的时候，复杂度是 $m \alpha (m, n)$</p>
<p>其中，$\alpha$ 是反阿克曼函数。</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>每一个节点有 in 和 out 两个邻接表</p>
<p>矩阵的形式存储的时候，可能并行化运算的时候更加容易。</p>
<p>prim 求最小生成树</p>
<p>稠密图和稀疏图使用不同的堆复杂度还不一样？？</p>
<p>Kruskal 实现最小生成树</p>
<p>稀疏图 prim 和 kruskal 复杂度差不多，但是稠密图中似乎 prim 算法比较好。</p>
<p>cut 割</p>
<p>割中最小权值的边一定出现在最小生成树上 证明了 Prim 的正确性？</p>
<h5 id="欧拉回路问题"><a href="#欧拉回路问题" class="headerlink" title="欧拉回路问题"></a>欧拉回路问题</h5><p>桥 bridge 它的去除，影响了整个图的连通性</p>
<p>证明方式</p>
<p>如何找到欧拉回路(两种算法)?</p>
<p>Fleury’s Algorithm(佛罗莱)算法 此时经常有一种方法和它相提并论，Hierholzer(希尔霍尔策算法) 算法，后者实际上运行效率会更高一点(标记的注意事项？)，感觉有一个硬伤，并查集没有办法递增式构建？？。</p>
<p>欧拉骰子？？</p>
<p>相联系的有一个哈密顿回路问题。</p>
<p>桥和割边的关系？</p>
<h4 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h4><p>大概有三种版本最短路，单源-单源、单源-多源、多源-多源。</p>
<p>并且单源-多源是其他两个版本的基础，Dijkstra 就是解决这个问题的一个优秀算法。实际上，对于单源-单源的最短路，很多人还是一样使用 Dijkstra 算法。</p>
<h5 id="Dijkstra-算法遇到负权边"><a href="#Dijkstra-算法遇到负权边" class="headerlink" title="Dijkstra 算法遇到负权边"></a>Dijkstra 算法遇到负权边</h5><p>后来人们想了很多种算法对于 Dijkstra 进行改进。其中 Bellman-Ford 就是一种。</p>
<h5 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h5><p>因为是简单路径，每一个顶点最多出现一次，所以最多 n - 1 条边。本质上，Bellman-Ford 算法更新一次，就是从 s 出发，经过边数不超过 k 的最短路(其中，k 是当前迭代到的次数)。</p>
<p>事实上，Bellman-Ford 算法遇到负环还是可能会绕圈的(TO DO)，所以人们想可不可以使用 Bellman-Ford 算法来判断是否有负环。</p>
<p>但是实际上，Bellman-Ford 算法是与 source 有关的算法。检测负环而又是和 source 无关的算法。所以，为什么要使用一个与 source 有关的算法来解决与 source 无关的问题呢？</p>
<h5 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h5><p>同样适用于负权重的图，并且解决的是多源-多源的问题。</p>
<h5 id="负环的检测"><a href="#负环的检测" class="headerlink" title="负环的检测"></a>负环的检测</h5><h4 id="图的闭包问题"><a href="#图的闭包问题" class="headerlink" title="图的闭包问题"></a>图的闭包问题</h4><p>无向图和有向图的算法，可以使用 bitset 优化？</p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li><p>手写一个 List</p>
<p> 见 <code>List.cpp</code> <code>LinkList.h</code> <code>LinkList.cpp</code><br> 其中，<code>List.cpp</code> 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 <code>Node&lt;T&gt;*</code> 的形式。<br> 但是在 <code>LinkList.h</code> 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 <code>&lt;T&gt;</code> 了，这种形式也是我们更加推荐的。</p>
</li>
<li><p>手写一个面向对象的快速排序</p>
<p> <code>quick_sort.cpp</code> 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢<br> 其中，需要注意<code>函数对象</code>的写法。</p>
<p> 非递归版本：</p>
<p> <strong>双指针前移法</strong>，感觉很强，短小精悍，见 <code>QuickSortNor.cpp</code>，使用自己手写的栈，实现了对于类的非递归版本的快速排序。</p>
</li>
<li><!-- 基于自己写的链表
实现堆栈
放在不同的文件中
想规范一下大家写代码习惯 -->

<p>在这次的作业中，注意：</p>
<p>我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template<class E></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class U&gt;</span><br><span class="line">friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LinkList&lt;U&gt;&amp; list);</span><br></pre></td></tr></table></figure>

<p>其中，ostream 是一种返回类型。</p>
</li>
<li></li>
</ol>
<ul>
<li><p>以非递归的形式实现汉诺塔，并且尽量少内存。<br>  见 <code>Hanoi.cpp</code></p>
</li>
<li><p>写最大公约数递推的程序。给定两个整数，写出最大公约数的标准形式，d &#x3D; ax + by，x y 可能是负数 我们规定 |x| &lt; |y| 此时取值是唯一的。<br>  见 <code>exgcd.cpp</code></p>
<p>  上面的扩展欧几里得是递归实现的，但是我们还是追求非递归版本，讲解参考下面的博客：</p>
<p>  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zbhfz/p/11267438.html">https://www.cnblogs.com/zbhfz/p/11267438.html</a></p>
  </li>
</ul>
<ol start="5">
<li><p>非递归全排列</p>
<p> 康托展开</p>
<p> 非递归，根据排列规律输出所有的排列</p>
<p> 见 <code>CantorExpansion.cpp</code> <code>permutation.cpp</code> <code>next_permutation.cpp</code> </p>
</li>
<li><p>求斐波那契数列通项</p>
<p> 特征根法怎么来的呢？</p>
<p> 人们发现特征根对于分解递推式子是有帮助的</p>
<p> 对于一个具体的 n 输出 F_n</p>
<p> 矩阵加速递推，见 <code>Fibonacci.cpp</code></p>
</li>
<li><p>写一写二叉树的数据结构，支持几种遍历方式</p>
<p> 层次 先序 中序 后序 每一个节点都不保存父亲节点 可以使用堆栈来实现 不要递归</p>
<p> 如果给出了不同遍历方式得到的结果，如何获得原来树的结构？</p>
<p> 二叉树有一个函数，传入两个字符串序列，是不是都能恢复成原来的二叉树结构？最后输出括号表示方式的形式。</p>
<p> 见 <code>ParseTreeSequence.cpp</code> 和 <code>GetTreeOrderNor.cpp</code></p>
<p> 还有一种比较简洁的方式可以参考 于老师代码中的 <code>parseTree.cpp</code></p>
</li>
<li><p>如何形成中序遍历意义下的线索二叉树(双向的)</p>
<p> 并且用自己的线索二叉树再次实现双向遍历</p>
<p> 前序和后序不完美</p>
<p> 线索二叉树的必要？历史的产物？</p>
</li>
<li><p>自己搜索霍夫曼树的题目</p>
<p> 多叉树到二叉树的转化？</p>
<p> Weighted Path Length of Tree, WPL</p>
<p> 中位数寻找？TODO</p>
<p> 为什么需要将 友元函数的定义直接写进去 ？ TODO</p>
</li>
<li><p>了解一下 Fibonacci 堆，有精力的同学可以尝试实现。</p>
</li>
<li><p>实现一个左偏堆</p>
</li>
<li><p>写一个 AVL 维护平衡，支持插入删除查找</p>
</li>
<li><p>R G B 非递归扫描？搜索如何存储路径状态？(直接将一个 vector 作为参数传入)</p>
</li>
<li><p>实现 Treap Splay FHQTreap ?（附加）</p>
</li>
<li><p>魔方？rubik’s cube?</p>
</li>
<li><p>若干不相交的多边形，输出从多边形外面一点到外面另一点的最短路径。</p>
</li>
<li><p>尝试完善代码，为二叉树每一个节点添加 size，同时提供一个接口，返回一个节点的 rank。</p>
</li>
<li><p>写一个 kd 树代码，支持最近邻的查询，查找一个框框有多少点？输入 n 个点，输出就是求最近的点，维护一个 kd 树的类，需要的基本行为还是最好支持一下，不过我们最关心的还是最近点。</p>
</li>
<li><p>快速排序进阶。多种排序方式组合实现一个高效的快速排序。使用快速排序(在其函数上进行修改)实现线性查找元素第 k 小。荷兰旗问题？</p>
</li>
<li><p>给定若干竖直和水平的随机长度的线段，并且保证一个 y 坐标或者一个 x 坐标下只有一条线段，求这些线段的交点个数。</p>
</li>
<li><p>最长公共子序列</p>
</li>
<li><p>bitset 求解高维偏序问题</p>
</li>
<li><p>k 短路问题</p>
</li>
<li><p>完成 KMP 算法</p>
</li>
<li><p>并查集实现 鼓励大家实现基于 rank 的 union，希望并查集中有路径压缩的功能（不需要新写一个函数，只需要在 find 时顺便修改）。</p>
</li>
<li><p>实现 Prim 算法</p>
</li>
<li><p>实现 Kruskal 算法</p>
</li>
<li><p>教材以 Fleury 算法为主，但是老师更希望实现 希尔霍尔策算法，体会在桥边上有没有更好的策略。</p>
</li>
<li><p>实现无向图和有向图的闭包问题</p>
<p>Floyd 传递闭包、bitset 优化</p>
<p>Tarjan 传递闭包？</p>
</li>
<li></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Data-Structure/" rel="tag"># Data Structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/04/python%E7%88%AC%E8%99%AB/" rel="prev" title="python爬虫">
                  <i class="fa fa-angle-left"></i> python爬虫
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/07/%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/" rel="next" title="登录实现">
                  登录实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Miraclys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  

  <a href="https://github.com/Miraclys" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"miraclys","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
