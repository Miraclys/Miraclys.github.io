---
title: JavaScript进阶
date: 2023-08-31 16:08:47
tags: 
- JavaScript
- Web
description: The key record of JavaScript advance.
---

#### 基础回顾

数据类型：
1. 基本类型
    String Number boolean undefined null
2. 对象(引用)类型
    Object Function Array

判断：
1. `typeof`
    返回的数据类型的字符串表达
2. `instanceof`
3. `===` 和 `==`

```
function Person(name, age) { // 这是一个 **类型对象**，因为函数也是一个对象。
    this.name = name;
    this.age = age;
}
var p = new Person(); // 这是一个实例对象。
```
`null` 和 `undefined` 
`null` 定义了并且赋值了，只是值为 `null`，而 `undefined` 是定义了但是没有赋值。初始赋值为 `null` 表示将要是一个对象。程序的最后赋值为 `null` 可以释放内存。

栈：全局变量 / 局部变量
堆：对象
(对象本身在栈里面，而表示对象的变量在栈空间，比如函数和函数名的关系)

JS 在调用函数传递变量的时候是 **值传递**（理解可能不同）
```
var a = 3;
function add(a) {
    a = a + 1;
}
console.log(a); // 程序输出为 3
```

```
function fn() {
    var b = {};
}
```
函数执行完以后 `b` 这个局部变量会自动释放，而后面对应的对象因为没有再被指向，被认为是垃圾对象，是在后面的某个时刻由垃圾回收器回收，释放空间。
```
var a = 3;
var b = {};
b = null;
```
`b=null;` 以后，`b` 所指向的对象没有被任何其他变量指向，所以会被标记为垃圾对象，由 `JS` 引擎在一定时间后回收，而 `b` 这个全局变量仍然存在。
在`JavaScript`中，全局变量通常在整个应用程序的生命周期内存在，不会自动释放内存。`JavaScript` 引擎会负责管理全局变量的内存，而不需要手动释放。当全局变量不再被引用时，`JavaScript`引擎会自动将其标记为可回收，并在适当的时候进行垃圾回收以释放内存。
`JavaScript` 的垃圾回收机制主要处理对象的内存释放，而不负责释放变量的内存。变量的生命周期通常由其作用域决定。在全局作用域中声明的变量通常会在整个应用程序的生命周期内存在，除非您显式删除它们或应用程序终止。在局部作用域中声明的变量在离开作用域时会被销毁，相应的内存也会被释放。

什么时候必须使用 `['属性名']` 的方式？
1. 属性名包含特殊字符：如`-` 和 ` `。
2. 使用表达式来动态访问属性
```
var person = {
    name: "John",
    age: 30
};

var propertyName = "name";
console.log(person[propertyName]); // 使用方括号来访问属性
```

`test.call/apply(obj);` 这个意思是把 `test` 函数临时作为 `obj` 内部的函数来调用。`obj` 内部可以没有 `test` 函数。

`JavaScript` 中的回调函数是一种常见的编程概念，它允许您将一个函数作为参数传递给另一个函数，并在需要时执行该函数。这通常用于处理异步操作，例如处理文件读取、网络请求、定时器等等，因为在这些情况下，不能立即得到结果，而需要在操作完成后执行特定的代码。

IIFE(Immediately-Invoked Function Expression)

`this` 是什么？
- 任何函数本质上都是通过某个对象来调用，如果我们没有直接指定，就是 `window` 来调用。
- 所有函数内部都以一个变量 `this`。
- 这个 `this` 的值是当前调用函数的对象。

在`JavaScript`中声明的全局函数通常是`window`对象的一部分，而不是`document`对象的一部分，这是因为`JavaScript`最初是为浏览器环境设计的，并且全局作用域在浏览器中通常与`window`对象关联。

在浏览器环境中，`window`对象代表整个浏览器窗口，它包含了全局`JavaScript`作用域的所有内容，包括全局变量和函数。当您声明一个全局函数时，它实际上是`window`对象的一个属性。这意味着您可以在全局范围内访问这个函数，无需任何其他前缀。

#### JS 原型和原型链
JS 的复杂类型都是对象类型(`Object`)，而 JS 不是一门完全面向对象的编程语言，所以如何涉及继承机制，这是一个问题。

##### 构造函数
因为 JS 中没有类(`Class`)这个概念，所以 JS 的设计者使用了 **构造函数** 来实现继承机制。
> ES6 中的 `Class` 可以看成一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 `Class` 写法只是让原型的写法更加清晰、更像面向对象编程的语言而已。

在构造函数中，通过 `this` 赋值的属性或者方法，是每个实例的 **实例属性** 和 **实例方法**，**无法共享公共属性**。所以就又设计出了一个**原型对象**，来存储这个**构造函数的公共属性以及方法**。

##### 函数的 `prototype`(原型)  
- 每一个函数都有一个 `prototype` 属性，它默认指向一个 `Object` 空实例对象(即称为：原型对象，但是 `Object` 不满足)。
> 为什么要有这个空对象？
> 它可以方便我们对于一个函数添加个性化的属性和方法，如果没有这个空对象而是直接链接到 Obejct，那么不同函数之间的个性化操作都会添加到 Obejct 下，会产生很多不必要的冲突和麻烦。
- 原型对象中有一个属性 `constructor`，它指向函数对象。
- 给原型对象添加属性(一般是方法) -> 实例对象可以访问使用。（感觉和类与对象的关系很像）
构造函数和它的原型对象相互引用。
每一个函数 `function` 都有一个 `prototype`，即显式原型(属性)
每一个对象都有一个 `__proto__` 可以称为隐式原型(属性)
对象隐式原型的值就是函数显式原型的值。

##### 原型链
- 访问一个对象的属性时，现在自身属性中查找，找到返回。
- 如果没有，再沿着 `__proto__` 这条链向上查找，找到返回。
- 如果最终没有找到，返回 `undefined`。
- 一直是沿着隐式原型找的，所以我们的原型链本质上是一个 **隐式原型链**
{%asset_img 原型.png%}
{%asset_img 原型链.png%}
所有函数的隐式原型都是相同的，`fun = new Function()` 都是 `Function` 的实例对象。
- 在读取对象的属性时，会自动到原型链中查找。
- 设置对象的属性时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。
- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。


To do:
利用js快速完成大学生新生安全教育课程
https://blog.csdn.net/m0_38072683/article/details/118878085