---
title: 算法设计与分析
date: 2024-02-26 16:03:09
tags: 
- Algorithm
description: lecture notes in algorithm analysis and design. 
---


---

### 定理、定义、推论

#### lecture1

1. Handshaking lemma
2. 奇数度数的定点有偶数个
3. Simple path: All vertices in the path are distinct. 
4. sub-path: a contiguous subsequence of its vertices
5. 导出子图(Induced Subgraph): 点集 V' 是 V 的子集，但是对于 V' 之间的所有点，只要原图有路径，则导出子图中也有对应的路径
6. 生成子图(Spanning Subgraph): 子图中的点就是原图的所有点，但是边集是之前的子集
7. 连通分支(Connected Component): 是连通（无向图中，其中的任意两个点都是互相可达的）的，并且是极大的。
8. 任意一个连通的无向图，边至少为点数减一个(Hints: Adding each edge decreases  # of connected components by at most one)
9. 强连通(Strongly Connected): 一个有向图如果是强连通的，就是图中的两点是任意可达的
10. 强连通分量(Strongly Connected Component): 有向图 1. 强连通的 2. 极大的
11. 完全图(Complete Graph): 无向图是一个完全图，所有点都是互相连接的
12. 二分图(bipartite)
13. 树: A tree is a connected, acyclic, undirected graph(证明，树的边是点数减一)
14. Ak[i,j]等于i和j之间长度为k的路径数目(证明，归纳，lecture1 的 34)

15. 说算法好的时候用上界，说算法不好的时候用下界。
16. O 是 上界，小 Omega 是下界，大 Omega 是上下都有

#### lecture2

1. 时间复杂度

#### lecture3

1. 人们一般使用 BFS 和 DFS 来发现一些图的性质，如环、强连通
2. 前驱子图(predecessor sub-graph): 节点和树边组成的一个图
3. \delta(s, v) <= \delta(s, u) + 1.分为 存在 s 到 u 的路径和 不存在 s 到 u 的路径两个方面来证明。
4. dfs 中维护的 d[v] 大小就是 \delta(s, v)。其实是先证明了两个引理，证明 大于等于 并且 小于等于，就是等于(lecture3 P35)。其中，如果归纳的时候，入队和出队都会产生影响，我们要分别按照入队和出队归纳，如果仅仅是入队产生影响，我们仅仅对于入队进行归纳即可。
5. 引理：BFS 得到的前驱图是 Breadth-first tree
6. BFS 时间复杂度分析

#### lecture4

1. 深度优先搜索导出深度优先林
2. 括号定理(Parenthesis Theorem): d[u] f[u] 和 d[v] f[v] 之间对于是否是后代、祖先、都不是 之间的关系
3. 推论：可以使用 d[] 和 f[] 来推断谁是谁的后代
4. 白色路径定理：v 是 u 的后代，当且仅当 发现 u 的时候，存在一条从 u 到 v 的白色路径(白色路径，首先表明是路径，是连通的，白色表示 u 是路径中第一个发现的点)(对于充分性和必要性的证明，其实有的时候是比较显然的，但是证明的话就需要使用基础的颜色、和 d[] f[] 之间的关系来推导，所以这就是说基础的，颜色、f、d 之间的关系对于我们后面的证明很重要)

#### lecture5

1. 对于无向图，DFS 时只有树边和反向边两种，没有前向边和交叉边
2. 单连通(singly connected): u 可以到达 v 并且 u 至多有一条边到达 v，叫做单连通。
3. 有向图非单连通 <=> 存在 u，进行 DFS 的时候可以发现前向边或者交叉边。
4. 单连通图的判定算法，对于每一个点开始，进行一次 DFS，然后看是否有交叉边或者前向边。
5. 一个有向图没有圈，当且仅当 DFS 不产生反向边(证明：有圈 <=> 产生反向边 lecture5 33 采用反证法)
6. DAG 中有 u -> v 的边，则 f[u] > f[v]。证明：35 分为 u -> v 是前向边、交叉边、树边三种情况来证明
7. 

#### lecture6

1. 

#### lecture7

1. 

#### lecture8

1. 最短的那一条边一定属于某颗最小生成树。
2. 一个图中的多个最小生成树的边的权值的序列，按照从小到大排列，完全相同。（如果图中每一条边的权值都不相同，那么最小生成树是唯一的）。（证明见 P7）
3. 每一条边的权值都不相同，此时最小生成树是唯一的，但是次小生成树却不一定是唯一的。
4. 次小生成树最多和最小生成树相差一条边
5. 一种次小生成树的求解方式是：对于每一个点，作为起点做一次 dfs，记录 u -> v 的路径上权值的最大值。所有的点都 dfs 完了以后，就开始枚举不在最小生成树的边，那么现在的生成树的权值应该是变为了 original - max(u -> v) + w(u -> v)
6. 瓶颈生成树中的边的最大值，是整个图的所有生成树的最大边的最小值。
7. 每一个最小生成树都是一个瓶颈生成树
8. 时间复杂度的分析？？？？
9. 

### 搜索

#### on a graph

简单路的定义：

子图、导出子图（induced sub-graph）：

联通分支：极大的联通子图

联通无向图中，边数大于等于 $n - 1$，证明：

有向图中强连通定义：

强连通分支：极大的（只有有向图有这一个定义吗？）n 方实现查找强连通分支？

完全图：无向图，两两的点都是相连的

森林：无向图，因为有向图我们没有定义树

稀疏图（sparse graph）：定义？

邻接链表（adjacency-list）：优势与劣势

邻接矩阵：邻接矩阵的 K 次幂，就是 i 到 j 长度为 K 的路径的数目（证明，数学归纳法？）2 次幂就是自己的度？

### 时间复杂度

可以看 https://oi-wiki.org/basic/complexity/ 和 https://www.luogu.com.cn/blog/GJY-JURUO/master-theorem

进行时间复杂度计算时，哪些变量被视作输入规模是很重要的，而所有和输入规模无关的量都被视作常量，计算复杂度时可当作 1 来处理。

规模随着输入规模的增加而增加的趋势，但是时间复杂度确实一个跟着数据的变化而变化的一个多值函数

线性规划的单纯形法 平滑分析平均时间复杂度

DFS BFS

### 最小生成树

Kruskal

Prim

瓶颈最小生成树算法

### 最短路

单源、多源

### 最大流

basic ford-fulkerson algorithm

edmonds carp algorithm

dinic's algorithm

push-relabel algorithm

### 最大匹配

Maximum Matching on Bipartite Graphs 最大流、匈牙利树？


---

#### 第一周 图的基本定义、性质 时间复杂度 




#### 第二周 DFS 与 BFS

1. 写的更加清楚一些，得分就多

2. 欧拉序和 dfs 序 等顺序？

3. 前驱子图（深度优先林）

4. 图中的括号定理 就是一个点的子树的覆盖空间

5. 白色路径定理（就是使用到括号定理）

6. 广度优先搜索简历广度优先树

7. 深度优先搜索的两种应用：1. 有向无环图的拓扑排序 2. 寻找一个有向图的强连通子图

8. 许多图的算法在开始的时候，都是通过搜索输入的图来获取图结构信息；另外还有一些图算法是由基本的图搜索算法经过扩充而成的，所以图搜索算法是图算法领域的核心。

9. 稀疏图一般是 E 远小于 V^{2}，稀疏图的时候，我们通常采用临界表来表示一张图；稠密图的时候，我们通常采用邻接矩阵来表示一张图。

10. 每一个邻接表中的顶点都是按照任意的顺序进行存储。

11. 邻接表表示一张图的存储空间为 $\boldsymbol{\Theta}(V+\boldsymbol{E})_0$。注意还有一个 V 的大小。

12. 邻接表稍作修改就可以支持其他多种图的变体，因此有着很强的适应性。不过邻接表也有着不足，比如如果想看边 u -> v 是否存在，只能遍历 adj[u]，除此之外，没有更快的方法。练习 22.1-8 中给出了支持快速查找功能的邻接表的变体

13. 邻接矩阵需要 $\boldsymbol{\Theta}(V^{2})$ 的存储空间，和边的数量没有关系。

14. 广度优先搜索（breadth-first search），书中 color[] 存储色彩变量，表示是白色、灰色或者黑色，\pi[] 存储的父母变量，如果没有父母或者还没有被发现就是 NIL，u 到原点 s 的距离使用 d[] 表示。

15. 循环不变式来证明算法的正确性？？？？

16. bfs 算法时间复杂度的分析，使用了「聚集分析」(aggregate analysis)????

17. $\delta(s, v)$ 表示从 s 到 v 到任意路径中最少的边数（也就是边权都是 1 的时候的最段路）

18. bfs 最段路的一个三角定理

19. 前驱子图的定义 P333

20. 单连通？？？

21. 有向图中会有一个强连通分支的定义

22. 一个有向图对于边进行分类，前驱图中的边叫做树边，

23. 无向图只有树边和后向边

24. 单连通的定义？树是单连通并且不能有圈

25. 有向图非单连通 <=> 存在 u，调用 DFS-VISIT(u) 的时候，能够发现前向边或者交叉边。所以证明不是单连通可以通过找前向边或者交叉边

26. 拓扑排序可以使用深度优先搜索吗？

27. 如何判断有向图是否是有向无环图

28. 有向无环图不可能有反向边？？？

29. 简单路径的定义 simple path？

30. 起初我们给出的 \delta(s, u) 表示的是 s 到 u 到最短路径（边的数量，因为在这里边权都为 1），d[u] 表示的是「广度优先搜索计算出的 s 到 u 到距离」，一开始我们不知道两者是否相等（虽然直观上是这样），但是我们需要严谨的证明。

31. 有向图是无环图当且仅当深度优先搜索不产生「后向边」

32. https://blog.csdn.net/qq_23096319/article/details/128102492 单连通的定义

33. 既是单连通，并且不能有圈，还有一个根，就是一棵树

34. 强连通和单连通之间没有什么关系

35. 缩点、强连通分量、点双、边双

36. 半连通图判定，对于有向无环图的半连通的判定？？

37. 割点和桥和点双、边双一般都是指的是无向图，缩点一般指的是有向图

38. 