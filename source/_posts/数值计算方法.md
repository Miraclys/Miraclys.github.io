---
title: 数值计算方法
date: 2024-02-29 14:13:27
tags:
- Numerical Analysis
description: 
---


---

1. 二分法收敛性的证明

2. 迭代程序结束的条件多样，直接指明迭代次数或者 ...

3. 二分法误差的阶，误差估计定理

4. 方程求根，不动点法 fixed point functional iteration 方程求根问题，转变为不动点求解问题，其实是有很多转换方法

5. 不动点存在与唯一性。存在性的条件和唯一性的条件。证明唯一性的做法通常是反证法。

6. 不动点的收敛性证明。证明使用到了微分中值定理与不动点存在的条件。

7. 不动点误差范围的两个推论。第二个推论是变为很多个绝对值公式相加。

8. 牛顿法或者切线法。和不动点？牛顿法的几个不同的视角？然后变为一个不动点问题？代数层面的理解和几何层面的理解。（牛顿法本质上还是不动点？）

9. 牛顿法的收敛性证明？也就是牛顿法的初始值不是随便选的，而是在解的一个小邻域范围内。（我们的不动点是用来求解什么？不动点对于迭代的关系？）

10. 对于牛顿法的初始点的选择？？牛顿法好是好，但是却需要求导。可不可以直接使用函数值去计算？不过在手链速率上，应该是切线比较快，不过割线也不会慢上很多。

11. 对于上面的那一种方法的一个优化就是初始的两个点选择异号的两个点，计算切线，然后再选择这三个点中异号的两个点，如此迭代（错位法）。

12. 割线法和错位法的收敛性我们都没有讲（因为用到很多泛函的东西）

13. 收敛快慢的定义。lambda 体现不出收敛速度来，只是一个比例常数，但是 alpha 越大，收敛越快。如果 alpha 为 1，我们叫做线性收敛。

14. 不动点是否是线性收敛的条件，或者是高阶的，取决于不动点处的导数是否是 0

15. 泰勒展开的英文 Taylor polynomial。然后是对于一阶导为 0 的时候，直接计算二阶导。以此类推，求得更高阶的收敛。

16. 先解决这个收敛性的问题，然后再去求收敛速度。lambda 的值是决定什么的收敛的？？？？

17. 对于我们求解方程根的问题，如果我们等价成一个不动点的问题，本质上是假设了线性收敛。但是不一定是线性的，我们可以使用待定的方法来求解。然后对于二次的收敛，求解出来其实就是牛顿法，所以牛顿法其实是二次收敛的。

18. 多重根的情况。单根的定义，它的一阶导数不能是 0，如果是 0 就是重根了。证明就是用几重根的定义。

19. 仿照前面的过程，证明 m 阶重根的条件。

20. 对于一个多重根（我们无法判断的时候？？？），我们构造一个函数 \mu，然后基于 \mu 做牛顿？做不动点？

21. 重根变单根，然后使用牛顿去做。但是这个时候有一个缺陷，需要二阶的导数？？


22. 割线法、基于割线法改进（选取的两个点，横跨 x 轴，也就是异号）

23. 但是对于根，有 simple 和 multiple 两种情况，我们把 multiple 化为一个 simple 的问题。

24. 是否是线性收敛

25. 割线法理论上是高于线性的，但是又小于二次，可以由更高级的数学知识算出来，收敛速率约为 1.618

26. 我们得到了一种新型的计算序列方式，比原来的方法来要快

27. 收敛的话，原则上我们是从同一侧靠近的

28. 我们没有纯使用不动点迭代，而是一种不动点加修正的融合方法。这一种方法收敛的阶是 三次 的

29. 多项式求解根

30. 先给出几个定理，代数基本定理

31. Horner's Method

32. 多项式除法加余项

33. 求解方程在某一点处的值

34. 求解多项式的根，使用 Horner 和 Newton 法融合起来。快，而且精度高。利用了多项式的特殊性质(总共合起来也就是 线性的)

35. Muller 这一个算法本身不做评价，确实可行，但是作为一种思想没有问题

---

Code:

1. 牛顿法求解方程的根

2. 二分法求解方程的根

3. Steffensen Algorithm

4. Horner's Algorithm

5. Muller's Algorithm

---

Report:

1. 梳理算法：流程图 or 描述；写出程序代码 C++ or matlab or Python；计算样例与结果分析，做一个算法的比较；样例 or 初始值的选择？；验证一下定理的要求；

    算法自己，对于数据的选取之间的比较；不同算法之间的比较；tolerance 和 迭代次数之间的关系；通过这种交互验证，加深我们对于阶的概念

2. 