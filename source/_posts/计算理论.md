---
title: 计算理论
date: 2024-03-01 08:11:24
tags:
- theory of computation
description: 
---

---

1. 自动机、图灵机、可计算性问题、算法的复杂度大小、近似算法不可能近似到多少

2. 图灵机不可计算

3. 是否等价于传统意义上的算法？因为传统的没有定义，我们无法证明，但是我们认为他们是等价的。基于两点。1. 那些科学家从不同角度定义的算法，它们都是等价的，我们认为是完备的、合理的。2. 没有人可以举出一个反例，他有传统算法，但是没有图灵机的算法。

4. power set 表示幂集 P(S)

5. 先给定一个字符集或者字母表(一个有限的非空集合)。字符串和语言（语言就是字符串的集合）。字符串是字符集中有限长的序列。序列是有序的。空串也是一个字符串，用 epsilon 表示。子串指的是从序列里面取出的连续的一段（注意 substring 和 subsequence 的区别）。language 是 string 的集合，也可以是一个空集。language 中包含 epsilon。

6. 主要研究的是 yes 或者 no 的问题。

7. 存在性往往是构造证明

8. 一般证明 不。。。 的时候使用反证法。

9. 都不管用的时候往往尝试归纳法。一定要严谨，有三步

10. 学习第一类的计算模型，FA（finite automaton, 有限自动机，这一个自动机效率很高？）

11. 如果一个东西需要存储的东西很少，一般都可以使用 DFA 来实现。

12. DFA 的五个部分：1. 有限的状态 2. 一个初始状态 3. 0 or 很多个结束状态 4. 明确输入字符集 5. 状态转换表

13. 识别的语言是接受的串的集合

14. DFS 接受语言，就可以解决一个问题；并且复杂度是线性的，所以比较好？？

15. DFA 是一个五元组。Q 不可以是空集，因为 S 是属于 Q 的，但是 F 却可以是 空集

16. DFA 的每一个状态需要对于每一个字符都有一个转移（因为我们定义的时候时是根据笛卡尔积定义的函数输入空间）

17. DFA 的输入字符集只需要看一个点射出去的所有字符；而且每一个点的出边应该是一样多的。

18. DFA 接受一个序列的三个条件。

    证明一个序列不接受：因为前面两条确定的序列是唯一的，而且又是 DFA，但是不满足第三条，所以不接受。

19. \sigma* 是 \sigma 中所有字符组合成的任意字符串的集合。

20. 一般我们不回去证明是不是识别某一个语言。证明集合的相等其实就是左右两边的。

21. DFA 是所有的字符串的一个划分

22. 正则语言就定义为 DFA 识别的语言

23. 初始状态之前一定记得加一个箭头

24. 正则语言在很多运算下都是封闭的

25. regular 语言的 并、连接、* 的封闭性在证明的时候，两者的状态我们不能独立开来，所以需要统一成一个状态来表示，所以可以选择笛卡尔积来证明。

26. 说明一个串不满足的时候，要先说明前两个条件是唯一满足的字符串，但是最后一个条件不满足，所以不接受。（接受 or 不接受 的三个条件）

27. 接受字符串的定义

28. NFA 和 DFA 接受字符串的定义

29. NFA 的并？