---
title: 数据结构关键记录3
date: 2024-01-09 08:39:29
tags: 
---

### 链表

#### 判断链表是否有环

存在环就说明链表的尾节点不是指向 null，而是指向了链表中的另外一个节点，只有这样才会构成环。

##### 哈希法

如果不对于空间进行限制，我们可以采用哈希表来解决。

##### 快慢双指针法

上面介绍的哈希法用到了额外的空间，所以上面的空间复杂度是 O(n) 的，我们不想占用过多空间。

快慢指针的具体做法是：定义两个指针，一个 slow 指针，一次走一步；一个 fast 指针，一次走两步。如果存在某一点 slow == fast，就说明存在环。

##### 如何判断链表中环的位置

采用哈希表的方法可以直接找到。

但是对于快慢指针的方法，两个指针相遇的位置不一定就是环的入口。详细讲解见参考 1

##### Brent 算法

上面的快慢指针的方法又叫做 Floyd 判圈法，下面介绍另外一种 Brent 算法，优点是缩短了判断是否有环的耗时，但是这个算法无法找到环的入口。

也是定义两个指针，但是这次是快指针每一次向前走 2n 步(n 为当前的回合数)。回合结束以后，慢指针直接传送到快指针的位置。在每一个回合快指针移动过程中判断是否与慢指针交会，如果交会，那么就判定存在环。

（正确性？）

#### 参考

1. https://www.cnblogs.com/lonely-wolf/p/15773656.html

### 分治

#### 归并排序

递归的方法和非递归的方法

```
 1 package com.algorithm.sort.mergenonrecursive;
 2 
 3 import java.util.Arrays;
 4 
 5 /**
 6  * 归并排序（非递归）
 7  * Created by yulinfeng on 2017/6/24.
 8  */
 9 public class Merge {
10 
11     public static void main(String[] args) {
12         int[] nums = {6, 5, 3, 1, 7, 2, 4};
13         nums = mergeSort(nums);
14         System.out.println(Arrays.toString(nums));
15     }
16 
17     /**
18      * 归并排序（非递归）
19      * 从切分的数组长度为1开始，一次归并变回原来长度的2倍
20      * @param nums 待排序数组
21      * @return 排好序的数组
22      */
23     private static int[] mergeSort(int[] nums) {
24         int len = 1;
25         while (len <= nums.length) {
26             for (int i = 0; i + len <= nums.length; i += len * 2) {
27                 int low = i, mid = i + len - 1, high = i + 2 * len - 1;
28                 if (high > nums.length - 1) {
29                     high = nums.length - 1; //整个待排序数组为奇数的情况
30                 }
31                 merge(nums, low, mid, high);
32             }
33             len *= 2;
34         }
35         return nums;
36     }
37 
38     /**
39      * 将切分的数组进行归并排序，同递归版
40      * @param nums 带排序数组
41      * @param low 左边数组第一个元素索引
42      * @param mid 左边数组最后一个元素索引，mid + 1为右边数组第一个元素索引
43      * @param high 右边数组最后一个元素索引
44      */
45     private static void merge(int[] nums, int low, int mid, int high) {
46         int[] tmpArray = new int[nums.length];
47         int rightIndex = mid + 1;
48         int tmpIndex = low;
49         int begin = low;
50         while (low <= mid && rightIndex <= high) {
51             if (nums[low] <= nums[rightIndex]) {
52                 tmpArray[tmpIndex++] = nums[low++];
53             } else {
54                 tmpArray[tmpIndex++] = nums[rightIndex++];
55             }
56         }
57         while (low <= mid) {
58             tmpArray[tmpIndex++] = nums[low++];
59         }
60         while (rightIndex <= high) {
61             tmpArray[tmpIndex++] = nums[rightIndex++];
62         }
63         while (begin <= high) {
64             nums[begin] = tmpArray[begin++];
65         }
66     }
67 }
```

归并排序的非递归写法

#### 快速排序

关于快速排序的平均时间复杂度证明，见参考 1

关于递归方式实现的代码，可以看洛谷 1177 题目。

关于快速排序的改进方法：

1. 递归改为非递归程序

2. 序列较短的时候，使用插入排序效率较高

3. 三路快速排序，将快速排序和基数排序混合，算法思想是基于荷兰国旗问题

4. 内省排序

三路快速排序的代码：

```
// 模板的 T 参数表示元素的类型，此类型需要定义小于（<）运算
template <typename T>
// arr 为需要被排序的数组，len 为数组长度
void quick_sort(T arr[], const int len) {
  if (len <= 1) return;
  // 随机选择基准（pivot）
  const T pivot = arr[rand() % len];
  // i：当前操作的元素下标
  // arr[0, j)：存储小于 pivot 的元素
  // arr[k, len)：存储大于 pivot 的元素
  int i = 0, j = 0, k = len;
  // 完成一趟三路快排，将序列分为：
  // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素
  while (i < k) {
    if (arr[i] < pivot)
      swap(arr[i++], arr[j++]);
    else if (pivot < arr[i])
      swap(arr[i], arr[--k]);
    else
      i++;
  }
  // 递归完成对于两个子序列的快速排序
  quick_sort(arr, j);
  quick_sort(arr + k, len - k);
}
```

##### 线性寻找第 k 大的数

我们按照快速排序的过程，但是在过程中，判断左边排序好的数组长度和 k 的关系，根据这个关系看是只进左侧数组还是右侧数组还是中间数组寻找第 k 大。

采取随机选取分解值的方式下，期望意义下，时间复杂度为 O(n)。证明可见参考 2

#### 基数排序

基数排序的英文名字是 Radix Sort，最早用于解决卡片排序的问题。

#### Maxima 问题

常见解决 Maxima 问题的方法有两种，排序法和分治法

具体做法见参考 3

#### 最近点问题

可以使用分治的方法来解决，见洛谷平面最近点对题目

##### 推广：平面最小周长三角形

可以推广到一个问题：在给定的一组点中，选择三个点，使得它们两两的距离的和最小。见参考 4

#### 凸包问题

一般有五种常用的凸包算法。

##### 斜率逼近法

这是一种比较容易想到的方法，但是不常用，因为时间复杂度过高。

就是先选中 y 值最小的点，然后旋转一个扫描线，时间复杂度为 O(nm)

##### Jarvis 算法

##### Graham 算法

扫描的时间是 O(n)，但是排序的时间是 O(nlogn)，所以合起来的时间复杂度是 O(nlogn)

##### Andrew 算法

##### 使用分治？？？

#### 参考

1. https://zhuanlan.zhihu.com/p/341201904

2. https://oiwiki.org/basic/quick-sort/

3. https://www.zhihu.com/column/p/27850478

4. https://oi-wiki.org/geometry/nearest-points/

### 矩阵乘法

一般用来矩阵加速递推。

### 括号问题

### 三种表达式

#### 中缀表达式

中缀表达式就是我们最常见的表达式，如 `(3+4)x5-6`

#### 前缀表达式

前缀表达式又被称为「波兰表达式」，运算符位于操作数之前

##### 中缀表达式转换为前缀表达式

参见参考 2

##### 前缀表达式求值过程

1. 从**右到左**扫描表达式

2. 遇到数字，将数字压入堆栈

3. 遇到运算符，将栈顶的两个数字使用运算符运算以后压入堆栈（先弹出来的 运算符 后弹出来的）

#### 后缀表达式

后缀表达式又称为「逆波兰表达式」，与前缀表达式类似，只不过运算符位于操作数后面。求值过程和前缀表达式反着，很类似。

#### 参考

1. https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/05/03.html

2. https://cloud.tencent.com/developer/article/2040680

### 汉诺塔问题

### 扩展欧几里得

### 树

#### 树的几种表示方式

1. 树形方式，很直观

2. 文氏图表示法，使用集合之间的包含关系

3. 凹入表示法

4. 括号表示法，将树的根节点写在括号的左边，除根节点以外的其余节点都写在括号中，中间使用逗号隔开

由括号表示法，反推出树的结构关系

#### 几种遍历方式

前序、中序、后序遍历，并且还有非递归的方式

还有从中序遍历和后序遍历或者中序遍历和前序遍历得到树的结构问题

#### 线索二叉树

### 堆

#### 二叉堆

#### 二项堆

#### Fibonacci 堆

#### 左偏堆

左偏树 / 左偏堆是一种配对堆，具有堆的性质，并且可以快速合并。

左偏树是一颗二叉树，不仅仅具有堆的性质，并且是「左偏」的：每一个节点的左儿子的 dist 都大于等于右儿子的 dist，所以每一个节点的 dist 都等于其右儿子的 dist 加一

但是，dist 不是指深度，左偏树的深度没有保证。

时间复杂度证明

### 三色编码问题

### 霍夫曼树

哈夫曼树：带权路径长度 WPL 最短的多叉树（最优多叉树）。

对于 k 叉哈夫曼树，我们在构建之前应该加一些节点，满足 (n - 1) % (k - 1) == 0

#### 哈夫曼编码

### 平衡树

#### 二叉搜索树

对于查搜索树节点的定义、遍历、搜索、插入、删除、求元素的排名、求排名为 k 的元素

#### AVL 树

实际上，AVL 平衡树原理简单，实现也不复杂。

关于树高的证明，可以看参考一中，用到了斐波那契序列。

其中，OIWIKI 中还有使用 AVL 对于 Map 的实现，可以看看。

#### 红黑树

#### B 树

### 图论

#### Floyd 算法

适用于任何图，不管有向还是无向，边权正负，但是不能有负环

##### 应用

1. 给定一个正权无向图，找一个最小权值的环

2. 已知一个有向图中任意两点之间是否有连边，要求判断任意两点之间是否联通，可以使用 bitset 优化

#### Bellman-Ford 算法

Bellman-Ford 是一种基于松弛 relax 的算法，可以求出有负权的图的最短路，并且可以对于最短路不存在的情况进行判断。

对于 Bellman-Ford 的松弛操作，每一次松弛都会使最短路的边数至少加 1，又因为最短路的边数最多为 n - 1，所以整个算法运行 n - 1 次松弛操作，时间复杂度为 O(nm)

所以，当第 n 轮循环仍然存在可能被松弛的边的时候，说明从 S 出发存在负环

##### 队列优化 SPFA

显然，很多时候我们不需要那么多松弛，或者说松弛的发生是有规律可寻的。只有上一轮松弛过的边，才可能引起下一轮的松弛，所以我们用队列维护哪些节点可能引起松弛，就能只访问必要的边了。

SPFA 算法也可以用来判断 S 点是否可以抵达一个负环，只需要记录最短路经过了多少条边，如果经过了至少 n 条边，说明可以抵达一个负环。

#### Dijkstra 算法

Dijkstra 算法是一种求解**非负权**图上单源最短路径的算法

使用不同的优化方案，Dijkstra 的时间复杂度是不同的。稠密图中，可能直接暴力更好

##### 正确性证明

可以使用数学归纳法证明。可见参考二

#### Johnson 全源最短路径算法

Johnson 和 Floyd 一样，是一种能求出无负环图上任意两点间最短路径的算法。

对于任意两点之间的最短路，可以跑 n 次 Bellman-Ford，时间复杂度是 $O(n^{2}m)$ 的，也可以直接使用 Floyd 算法，时间复杂度是 $O(n^{3})$ 的。

如果我们跑 n 次堆优化的 Dijkstra 算法，时间复杂度会更优，但是不适用于负权路，所以我们需要进行一些预处理，保证所有的边的边权为非负。

具体讲解可以看参考 3 或者 OIWIKI 最短路那一块的讲解。

#### 差分约束

差分约束问题可以转化为最短路或者最长路问题，所以两种转化也就形成了两种连边的方式。

#### 闭包传递

##### 负环 / 正环判断

若存在负环，不等式无解

#### 最小生成树

Minimum Spanning Tree, MST

Kruskal 算法和 Prim 算法

Kruskal 的复杂度为 mlogm

稠密图尤其是完全图上，Prim 算法的复杂度比 Kruskal 更优

Prim 使用二叉堆是 (n + m)logn

##### 正确性证明

Kruskal：使用归纳法。

Prim：这种算法之所以可行，是基于这样一个判断：对于任意一个顶点vi，连接到该顶点的所有边中的一条最短边(vi, vj)必然属于最小生成树（该判断也可以扩展成：任意一个属于最小生成树的连通子图（子树），从外部连接到该连通子图的所有边中的一条最短边必然属于最小生成树）

#### 欧拉回路

Fleury 算法和 Hierholzer 算法

可以看 https://www.zhihu.com/tardis/zm/art/108411618?source_id=1003

#### 哈密顿回路

#### 桥 割 边双 点双

#### 联通分量

### 网络流

实际上，Ford–Fulkerson 增广的正确性和最大流最小割定理（The Maxflow-Mincut Theorem）等价。

Dinic 算法

### 二分图

超级源点与超级汇点，然后进行 Dinic 就可以

### KD 树

K-D Tree 是 K-Dimension Tree 的缩写，可以高效处理 K 维空间信息。在节点数 n 远大于 $2^{k}$ 的时候，时间效率比较好。

关于 KD 树求解平面最近距离的代码，可以参见 https://blog.csdn.net/qq_43517189/article/details/105923098

### 跳表

#### 查询时间复杂度

一共 logn 层，每一层的遍历个数不会超过 3，所以查询的时间复杂度是 logn

#### 空间复杂度

就是线性的

#### 插入数据

插入的时候，我们对于跳表使用随机一个高度。删除的思路也是差不多的。详细可以看参考一

#### 参考

1. https://www.jianshu.com/p/9d8296562806

### KMP 算法

给定一个文本 t 和一个字符串 s，尝试找出并展示 s 在 t 中的所有出现

### 并查集

关于并查集使用启发式合并和路径压缩的时间复杂度

### 背包问题

0-1 背包

完全背包 区别在于一个物品可以选取无限次

多重背包 区别在于每一个物品的个数都是确定的，而不是无限的，注意直接转化或者二进制分组优化

混合背包 有的只能一次，有的无限次，有的 k 次

二维费用背包

分组背包 从所有物品中选择一件变为了从当前组中选择一件，于是对每一组进行一次 0-1 背包就行了

有依赖的背包

泛化物品的背包 这种背包没有固定的费用和价值，价值是随着分配给它的费用决定的

##### 背包问题变种

求方案数 转移方程变成了求和

求最优方案数

第 k 优解 增加一维用于记录当前状态下的前 k 优解，可以看为普通背包的一个序列，可以使用双指针的方法

#### 参考

1. https://oi-wiki.org/ds/avl/

2. https://www.cnblogs.com/jiangshaoyin/p/9954937.html

3. https://www.luogu.com.cn/problem/solution/P5905