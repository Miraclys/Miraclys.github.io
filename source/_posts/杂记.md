---
title: 杂记
date: 2023-08-31 20:27:31
tags: Miscellaneous
description: Just record some miscellaneous things.
---
#### Auto.js
Auto.js 是一种基于 JavaScript 的自动化工具，它允许你编写和运行 JavaScript 脚本来自动化执行 Android 设备上的各种任务。因此，Auto.js 使用 JavaScript 作为其编程语言。

关于 Auto.js 和 JavaScript 的关系如下：

1. Auto.js 使用 JavaScript：Auto.js 的脚本是用 JavaScript 编写的，因此你可以在 Auto.js 中编写标准的 JavaScript 代码。这使得 Auto.js 在编写和运行自动化脚本时非常灵活，因为你可以使用 JavaScript 的语法和功能。

2. Auto.js 扩展了 JavaScript：尽管 Auto.js 使用 JavaScript 作为其编程语言，但它还提供了一组额外的 API 和库，这些 API 和库允许你与 Android 设备的各种功能和资源进行交互，如模拟用户输入、操作屏幕、访问文件系统等。这些功能通常不是标准的 JavaScript 语言特性，而是 Auto.js 为 Android 自动化提供的功能扩展。

3. Auto.js 是 JavaScript 的运行环境：Auto.js 提供了一个运行 JavaScript 脚本的环境，这个环境专门设计用于在 Android 设备上执行脚本。它允许你使用 JavaScript 控制 Android 设备的各种操作，例如自动点击、滑动、截屏等等。

总之，Auto.js 是一个工具，它使用 JavaScript 作为编程语言，并扩展了 JavaScript，以便在 Android 设备上执行自动化任务。这使得开发人员可以使用 JavaScript 的语法和功能，结合 Auto.js 提供的 Android 自动化 API，编写用于自动化控制和操作 Android 应用和设备的脚本。

#### C++ 赋值

- 对于函数的变量，我们可以使用值传递或者引用传递，取决于函数的参数类型。如果是带有 `&`，此时就是引用传递，在函数中对于变量修改会影响到函数外部的值。对于数组，向函数传递的实际上是指向数组首元素的指针，这意味着参数的本质上是通过地址传递的，所以函数内部的修改可以影响到外部。
- 在C++中，当您将一个类对象赋值给另一个类对象时，默认情况下是使用复制构造函数来执行赋值操作，因此这也是一种值传递。这意味着目标对象会被复制为源对象的一个副本，两个对象之间是相互独立的，修改一个对象的属性不会影响另一个对象。

#### VSCode 重命名所有匹配项
按住 `alt` + `shift`
https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf VScode 的快捷键表

#### ES5 和 ES6 含义
ES6 和 ES5 是 JavaScript 的不同版本，它们代表了不同的 ECMAScript（简称 ES）标准。ECMAScript 是 JavaScript 语言的标准化规范，规定了 JavaScript 语法、特性和行为。
1. ES5（ECMAScript 5）： ES5 是 JavaScript 的第五个主要版本，它在2009年发布。它引入了许多重要的新特性，例如严格模式（Strict Mode）、数组方法（如 forEach、map、filter 等）和更强大的对象属性定义（Object.defineProperty）。ES5被广泛支持，并且在早期的浏览器中是主要的 JavaScript 标准。
2. ES6（ECMAScript 2015）： ES6 是 JavaScript 的第六个主要版本，也称为 ECMAScript 2015。它于2015年发布，并引入了许多新的特性和语法改进，如箭头函数、类、模块、解构赋值、let 和 const 变量声明等。ES6使得 JavaScript 更加现代化和强大，并提供了更好的开发工具和技术。尽管它在发布时得到了广泛的支持，但由于浏览器的兼容性问题，需要一些时间才能在所有主要环境中广泛使用。

#### Span
<span> 是一个行内元素（inline element）或内联元素，用于在文本中包裹一部分内容，而不会引入新的块级元素或换行。<span> 通常用于对文本的一部分进行样式设置或添加其他属性，以便在不破坏文本流的情况下对其进行操作。
<span> 元素本身不会对其包含的文本内容产生任何视觉效果，它主要用于以下情况：

1. 样式设置：你可以使用 <span> 元素为文本添加 CSS 样式，例如更改文本的颜色、字体、背景色等。这使得你可以有选择性地为文本的一部分应用样式，而不必更改整个段落或文本块的样式。
```
<p>This is <span style="color: red;">red text</span> and this is <span style="font-weight: bold;">bold text</span>.</p>
```
2. JavaScript 操作：<span> 通常用于 JavaScript 操作，你可以通过 JavaScript 选择 <span> 元素并修改其内容或属性。
```
<p>Click <span id="mySpan" onclick="changeText()">here</span>.</p>

<script>
function changeText() {
  var spanElement = document.getElementById("mySpan");
  spanElement.innerHTML = "clicked!";
}
</script>
```

#### HTML 中 img 标签中的 alt 属性
`alt` 属性用于提供图片的替代文本(Alternative Text)
1. 替代文字：如果图像无法加载或无法显示，浏览器会显示 alt 属性中的文本，以提供对图像内容的文字描述，从而使页面更具可访问性。
2. 辅助工具：屏幕阅读器等辅助技术会读取 alt 文本，以向用户描述图像。因此，良好的 alt 文本可以帮助视觉障碍者理解图像的含义。
3. 优化 SEO：搜索引擎可以使用 alt 文本来理解图像的内容，从而更好地索引和排名网页。
4. 图像加载失败时的占位符。
5. 提示信息：一些浏览器在用户将鼠标悬停在图像上时会显示 alt 文本作为工具提示，以提供附加信息。
```
<img src="example.jpg" alt="一只可爱的猫咪">
```

#### axios 和 jQuery
axios 是一个独立的 JavaScript 库，专注于处理 HTTP 请求。它是一个现代的、基于 Promise 的库，主要用于前端和后端（Node.js）开发，提供了清晰、简单的 API。
$.ajax() 是 jQuery 库的一部分，用于处理各种类型的 AJAX 请求。它除了处理 HTTP 请求外，还包括许多其他功能，如 DOM 操作、事件处理、动画等。因此，$.ajax() 只是 jQuery 库的一部分。
总结来说就是，axios 是一个相对较小的库，专注于 HTTP 请求。你可以单独引入它，而无需加载整个 jQuery 库。$.ajax() 是 jQuery 的一部分，如果你只需要进行 HTTP 请求，使用 jQuery 会显得冗余，因为它包含了许多其他功能。

#### VSCode 多光标编辑
1. 按住 `alt` 点击多个位置(这个方法选择就没有约束)。
2. 按住鼠标滚轮，往下拖动(这个方法只是支持在同一竖线上的多位置编辑)。

#### 快速创建 HTML 模板
创建xxx.html文件，输入: ! + Tab

#### 实体字符
在HTML中，实体字符是一种特殊的编码方式，用来表示一些特殊字符或保留字符，以确保它们能够正确地显示在网页上，而不会被解释为HTML标记。以下是一些常见的HTML实体字符
{%asset_img 实体字符.png%}

#### 系统变量和用户变量
系统变量与用户变量的区别，最重要的即系统变量的优先级高于用户变量。

#### BeautifulSoup 库
Beautiful Soup 是一个Python库，用于从HTML或XML文档中提取数据。它是一个强大的解析库，可以帮助你轻松地解析复杂的网页内容，并从中提取所需的信息。
它可以帮助我们(在使用Beautiful Soup库时，通常需要指定一个底层的解析器，而 lxml 是一个常用的解析器之一，因为它具有高性能和稳定性。Beautiful Soup本身并没有自带解析器，因此需要依赖第三方解析器来处理HTML或XML文档)：
1. 解析 HTML 和 XML。将他们转换为 Python 对象的树状结构。
2. 寻找元素。寻找特定的元素、属性、文本内容，从而提取所需的数据。
3. 修改文档结构。
4. 清除数据。

#### RE regular expression regex
正则表达式，是用来简介表达一组字符串特征的表达式，最主要的应用在字符串匹配。
具体内容见文章 python 爬虫。

#### IP 地址
IP地址（Internet Protocol Address，互联网协议地址）是一种用于在计算机网络中唯一标识和定位设备的数字地址。IP地址在互联网通信中起到了非常重要的作用，它允许设备在全球范围内进行通信。
一些概念和要点：
1. 唯一性：每个设备（如计算机、服务器、路由器）连接到互联网时都被分配一个唯一的IP地址。这确保了在互联网上的每个设备都可以被准确标识和寻址。
2. IPv4和IPv6：有两个主要的IP地址版本，分别是IPv4（Internet Protocol Version 4）和IPv6（Internet Protocol Version 6）。IPv4地址是32位的，通常以点分十进制表示，如192.168.1.1。IPv6地址是128位的，通常以冒号分隔的十六进制表示，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。由于IPv4地址空间有限，IPv6被引入以满足不断增长的互联网连接需求。
3. 分层和路由：IP地址的设计允许数据在网络中进行分层和路由。它可以告诉路由器和交换机如何将数据包从源设备传送到目标设备，经过多个网络节点。
4. 公共和私有IP地址：IP地址可以是公共的或私有的。公共IP地址用于直接连接到互联网，而私有IP地址用于在私有网络中进行内部通信。私有IP地址通常在家庭网络和企业内部网络中使用，路由器负责将这些地址与公共IP地址进行映射。
5. 动态和静态IP地址：IP地址可以是动态的或静态的。动态IP地址由DHCP（动态主机配置协议）服务器动态分配给设备，而静态IP地址是由网络管理员手动配置的，通常不会更改。
6. 网络服务：IP地址不仅用于标识设备，还用于定位网络服务和资源，如网站、邮件服务器、数据库服务器等。DNS（域名系统）用于将域名映射到IP地址，使人们更容易访问网络资源。

#### Ctrl + R
在 VSCode 中可以直接搜索文件夹。

#### 抓包 packet capture
「抓包」是将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包经常被用来进行数据截取等。

##### 为什么抓包
1. Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。
2. 经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。

##### 常用的抓包工具
1. httpwatch
2. fiddler
3. wireshark
4. firebug

#### HMAC-SHA256 算法
HMAC-SHA256（Hash-based Message Authentication Code with SHA-256）是一种基于哈希函数和密钥的消息认证码算法，用于确保消息的完整性和认证消息的发送方。它是SHA-256哈希函数与密钥结合使用

#### Token Cookie 和 Session
1. Token
Token 是一种轻量级的身份验证令牌，通常是一个长字符串，用于识别用户。
**原理：**当用户登录应用程序时，服务器会颁发一个Token给客户端（通常是JSON Web Token - JWT）。客户端将Token存储在本地（通常是在浏览器的localStorage或sessionStorage中，或在移动应用的存储中）。后面客户端的每个 HTTP 请求都会在 Headers 中附带 Token，服务器**只需要通过特定的密钥和加密算法来验证即可**，不需要再去额外存储用户的 Token 信息。
**优点：** 无状态(只需要验证，无需存储)、可扩展性强，适用于分布式系统和 API。
**缺点：** 需要额外的处理来管理 Token 的过期、刷新和安全性。
2. Cookie
Cookie是一小段数据，由服务器发送到用户浏览器，存储在用户本地。它通常包含了一些标识信息和可选的数据。
**原理：** 服务器在响应HTTP请求时，可以通过Set-Cookie头来设置Cookie。浏览器会将Cookie存储在用户的计算机上，并在后续请求中自动发送给服务器。
**优点：** 简单、易用，可以持久保存数据，对用户透明。
**缺点：** 有限的存储容量，每个请求都会带上Cookie，可能会影响性能和安全性（例如，可能受到跨站脚本攻击的影响）。
3. Session
Session是一种服务器端机制，用于跟踪用户在应用程序中的状态和身份。
**原理：** 服务器在用户登录时创建一个唯一的会话标识，通常是一个Session ID，并将其存储在服务器上。Session ID 可以存储在Cookie中或通过URL重写等方式传递给客户端。
**优点：** 相对于 Cookie 更加安全，可以存储更多的数据，不受 Cookie 容量限制。
**缺点：** 占用服务器内存，需要额外的服务器资源，不适于分布式系统。
通常，现代Web应用程序使用Token进行身份验证和授权，而Cookie和Session用于保持用户状态和临时数据的存储。

#### 通信协议
通信协议是计算机和网络设备之间进行数据交换和通信的**规则**和**约定**。它们定义了数据的格式、传输方式、错误检测和纠正机制以及通信参与方之间的行为。

##### 1. OSI 模型
OSI 模型即 **开放式通信系统互联参考模型**(Open System Interconnection Reference Model)，是国际标准化组织 ISO 提出的一个试图使各种计算机在世界范围内互联为网络的标准框架，简称 OSI

OSI 七层模型
OSI 定义了网络互连的七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
{%asset_img OSI模型.png%}
首字母组成 All people seem to need data processing. 所有人似乎都需要数据处理，这句话可以帮助来记忆。

##### 2. TCP/IP 协议族
从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。
它是把 OSI 七层模型简化成了五层模型，每一层模型都呼叫它的下一层所提供的网络来完成自己的需求。
{%asset_img OSI与TCPIP关联.png%}

##### 3. TCP 协议
TCP 是**面向连接的运输层协议**。应用程序在使用 TCP 协议之前，必须**先建立** TCP 连接。在传送数据完毕以后，**必须释放**已经建立的 TCP 连接(HTTP 协议通常使用 TCP 作为传输协议，HTTP 是典型的无状态，所以可以用来理解 TCP 协议)。

每一条 TCP 连接只能有两个端点，是点对点的。

TCP 提供**可靠交付**的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。

TCP 协议是**面向字节流**的，意味着TCP将数据视为一连串的字节而不是消息或数据块的集合。

产生的影响：
1. 无消息边界。
在TCP连接中，数据被视为一个连续的字节流，没有明确的消息边界或分隔符。这意味着TCP不会为你自动识别消息的开始或结束。你需要自行定义和实现消息的分割和解析机制。
2. 字节级的精确性
TCP保证了数据的字节级精确性，即接收到的数据的每个字节都与发送端相匹配。如果数据在传输过程中损坏或丢失，TCP会负责重传丢失的部分，以确保接收端获得完整且准确的数据。

TCP 提供了可靠的、有效的数据传输但是不考虑消息的边界。因此，我们在使用 TCP 协议的时候，应用程序需要负责**定义和实现消息的分割和解析方法**。

https://zhuanlan.zhihu.com/p/64155705 TCP 协议详解

##### 4. HTTP 协议
HTTP 是 Hyper Text Transfer Protocol(超文本传输协议) 的缩写。HTTP 协议用于 WWW 服务器传输超文本到本地浏览器的传送协议。
它不仅可以保证计算机**正确快速地传输**超文本文档，还确定传输文档中哪一部分，以及哪部分内容首先显示(如文本优先于图像)。
HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，是一个无状态的协议。

**特点：**
1. 简单快速。客户向服务器请求服务的时候，只需要请求方法和路径。请求方法通常包括 GET、HEAD、POST。
2. 灵活。HTTP 允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。

**持久连接**
HTTP 1.1 版本的变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 `Connection: keep-alive`。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在发送最后一个请求时，发送 `Connection: close`，明确要求服务器关闭 TCP 连接。

**Content-Length** 字段
一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪个回应的。这就是 Content-Length 字段的作用，声明本次回应的数据长度。
```
Content-Length: 3295
```
上面代码告诉浏览器，本次回应的长度是3295个字节，后面的字节就属于下一个回应了。

在 1.0 版本中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。
使用 Content-Length 的前提是，服务器发送回应前，必须知道回应的数据长度。**对于一些很耗时的动态操作来说，这意味着服务器要完成所有操作以后才可以发送数据**(毕竟是动态的)，显然这样的数据并不是很高。更好的处理方法是，产生一块数据就发送一块，采用「流模式」(stream) 取代「缓存模式」(buffer)。
因此，1.1 版本规定可以不使用 Content-Length 字段，而是使用「分块传输编码」(chunked transfer encoding)。只要请求或者回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。
{%asset_img http和tcp关系.png%}

##### 5. FTP 协议
FTP 协议(File Transfer Protocol)，也是运行在 TCP 上，保证了文件传输的可靠性。与 HTTP 相比，FTP 面向的直接是服务器的文件系统，并且具有维持状态的特点，在文件传输管理上，FTP 更胜一筹。
**传输流程**
{%asset_img FTP工作流程.png%}
一共有两个并行的连接，一个是「控制连接」(port: 21)，另一个是「数据连接」(port: 20)。
其中，控制连接用于在两个主机之间传输控制信息，如口令、用户标识、存放，获取文件等命令。数据连接用于实际发送一个文件，发送完文件以后数据连接是会关闭的。
由于 FTP 使用一个独立的控制连接，所以我们也称 FTP 的控制信息是带外(out-of-band) 传送的。HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行的，所以，HTTP 也可以说是带内 (in-band) 发送控制信息的。
**传输方式**
FTP 支持两种方式的传输：文本(ASCII)方式和二进制(Binary)方式。
通常文本文件的传输采用 ASCII 方式；而图像、声音文件、加密和压缩文件等非文本文件采用二级制传输方式。
**传输模式**
FTP 有两种传输模式--主动(FTP Port)模式和被动(FTP Passive)模式。由于主动模式存在着安全问题，最近几年，大部分的 FTP 客户端开始默认使用被动模式。
https://zhuanlan.zhihu.com/p/337513218
https://zhuanlan.zhihu.com/p/141472331

##### 6. DNS 协议
互联网上主机的一种标识方式是使用它的「主机名」(hostname)，如 `www.facebook.com`、`www.google.com` 等。但是这是我们人类的记忆方式，路由器不会这么理解，路由器喜欢定长的、有层次结构的 IP 地址。
> 主机名 (Hostname) 是计算机或者设备在网络上的名称标识符，用于唯一标识一个特定的计算机或者网络设备。**主机名**通常是人类可读的形式，**但是在网络协议中国会被映射为 IP 地址进行通信**。

IP 地址由 4 字节组成，并且有着严格的层次结构。例如 `121.7.106.83` 然而路由器喜欢的是 IP 地址进行解析，我们人类便于记忆的确实网址，此时就用到 DNS 了。
DNS 的全称是 `Domain Name System`，是由一个分层的 DNS 服务器(DNS Server) 实现的分布式数据库；还是一个使得主机能够查询分布式数据库的应用层协议。DNS 服务器通常是运行 `Berkeley Internet Name Domain` 软件的 Unix 机器。DNS 协议运行在 UDP 之上，使用 53 端口。

DNS 是**一个分布式的系统**

https://zhuanlan.zhihu.com/p/346236071


#### h 文件和 hpp 文件区别
{%asset_img h和hpp.png%}

#### 低耦合 Low Coupling
是在讨论软件工程中的一种设计原则，旨在创建更可维护、可扩展和可重用的代码。低耦合涉及到将代码分解成松散耦合的模块或组件，这些模块之间的依赖性尽量降低。

#### lambda 表达式
在 C++ 中，lambda 表达式的结构：
```
[capture clause](parameters) -> return_type {
    // 函数体
}
```
解释：
{%asset_img lambda表达式.png%}

#### delete 和 delete[]
当你使用 new[] 来分配动态数组时，编译器会记住你分配了多少个元素，因此在释放内存时，你必须使用 delete[] 来确保所有元素都得到释放。如果你使用 delete（而不是 delete[]）来尝试释放动态数组的内存，将导致未定义的行为，可能会导致内存泄漏或程序崩溃。
```
int* data_ = new int[size];
delete[] data_;
```

#### 静态数组
静态数组需要在编译的时候知道它的大小
```
int a[size];
```
也就是说其中的 `size` 需要是一个常量表达式。如果我们 `cin >> size;` 后面又 `int a[size];` 是不行的，因为静态数组要求 **编译的时候大小就确定。**

静态数组的内存分配发生在程序的静态存储区域，通常在编译的时候分配，并且在程序结束的时候才会释放，具有全局的声明周期。

#### 动态数组
动态数组的大小在运行的时候确定，通常在堆中分配内存。`int* ptr = new int[size];`。在最后不使用的时候记得要 `delete[] ptr;` 
其中 `new int[size]` 会在堆上分配一段连续的内存，大小为 `size * sizeof(int)` 个字节，然后返回一个指向这块内存的指针，并将这个指针赋值给 `ptr`

堆上分配的内存不会自动释放，需要程序员负责在确保不需要的时候手动释放，否则可能导致内存泄漏。

#### 栈内存
栈内存用于存储局部变量和函数调用信息。每个线程通常都有自己的栈。
栈内存的分配和释放是自动的，发生在函数的入栈和出栈过程中。当函数返回时，其局部变量的内存会自动被释放。
栈内存的生命周期与函数调用有关，它们在函数调用结束后自动释放。

#### 程序运行时内存区域
1. 栈区 Stack
栈区用于存储函数调用的局部变量、函数的参数值以及函数调用的返回地址。
栈区是**自动管理**的，函数的局部变量在函数被调用时分配内存，在函数结束时自动释放内存。
**栈区的大小通常较小**，且生命周期短暂，用于管理函数的执行和调用。
2. 堆区 Heap
堆区用于动态分配内存，例如使用 new 和 malloc 来分配内存。
堆区的内存分配和释放需要程序员**手动管理**，使用 delete 和 free 来释放内存。
**堆区的大小通常较大**，用于存储动态分配的数据结构，如动态数组、对象等。
3. 静态存储区域 Static Storage
静态存储区域用于**存储全局变量、静态变量和常量**(如静态分配的数组)。
这些变量在程序启动时分配内存，在程序结束时释放内存。
静态存储区域的变量具有全局可见性，并且在整个程序的生命周期内保持不变。
4. 代码区 Code Segment
代码区包含程序的机器码指令，用于执行程序的逻辑。
代码区通常是只读的，不允许写入和修改。
代码区存储程序的执行指令，每个函数和方法的机器代码以及程序的静态数据。
5. 常量区 Constant Area
常量区用于存储常量数据，如字符串文字（string literals）和全局 const 变量。
常量区的数据是只读的，不允许修改。
6. 栈帧区 Stack Frame

#### malloc free 和 new delete

**语言差异**：
malloc 和 free 是C语言中的函数，可以在C++中使用，但通常不推荐在C++代码中使用它们，因为C++提供了更强大的内存管理工具。
new 和 delete 是C++中的操作符，专门用于创建和销毁对象，并与类的构造函数和析构函数一起工作。

**类型安全性：**
new 和 delete 是类型安全的，它们会为对象的构造和销毁调用适当的构造函数和析构函数。这对于管理类对象非常重要。
malloc 和 free 不了解对象的类型，它们只是分配和释放内存块。如果你使用它们来分配和释放类对象，可能会绕过构造函数和析构函数，导致对象的行为不正常。

尽管 malloc 和 free 是C语言中的标准内存分配函数，但在C++中通常更推荐使用 new 和 delete，因为它们提供了更好的类型安全性、异常处理和对象生命周期管理。只有在特殊情况下，如与C库一起使用或需要更底层的内存分配控制时，才使用 malloc 和 free。

其中需要注意，malloc 函数返回的是 `void*` 类型的指针，也就是并没有规定它的类型，需要我们人为规定。所以我们一般写成这样的形式：
```
char* p = (char*)malloc(100);
```
其中，100 表示 100 个字节。

#### C++ 对象构造
有四种方式创建对象：
```
MyClass myClass;
MyClass myClass = MyClass();
MyClass* myClass = new MyClass();
MyClass* myClass = new MyClass;
```
其中，前两种方式是在栈中分配内存，由操作系统进行内存的分配和管理。
后两种是在堆中分配内存，由管理者(程序员)进行内存的分配和管理，用完必须 delete，否则会造成内存的泄露。

##### 不使用 new
对于第一种和第二种，一个隐式调用，一个显式调用。
**第一种：**
- 如果有构造函数，默认使用构造函数来初始化对象。
- 如果没有默认的构造函数，编译器会报错。

**第二种：**
- 默认使用构造函数
- 如果没有构造函数，编译器会报错。
- 与第一种方法不同，这个是先创建一个对象，然后进行对象的复制。

虽然上面两种那么说，但是如果我们没有显式定义构造函数，编译器会自动生成一个默认构造函数的。这个默认构造函数会对类中的一些基本数据类型的数据进行初始化，就是随机赋值。

所以，通常情况下，前两种方式相比较，第一种方式直接 `MyClass myClass;` 是更加直接高效的方法，一般使用这种方式。

##### 使用 new

在使用 new 创建对象的时候。对于有构造函数的类，不论有没有括号，都用构造函数进行初始化。如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。

对于 new 创建对象，可以作为函数的返回值和参数，因为如果不用new，函数中不能返回该对象的指针，因为函数结束后，该对象的内存就被释放了(函数是栈空间嘛，如果是 new 则在堆空间，由我们人为决定其寿命)。

{%asset_img new构造.png%}
上面是两种new构造的区别，其实不是很大，一般加个括号就好了。

使用 new 创建对象的实际步骤是：
1. 分配内存：new 会在堆上动态分配足够的内存来存储对象的数据成员，包括对象的成员变量和虚函数表（如果有的话）。

2. 调用构造函数：一旦内存分配完成，C++会调用对象的构造函数来初始化这块内存。构造函数是类的特殊成员函数，用于初始化对象的状态。如果你没有显式定义构造函数，编译器会为你生成一个默认的构造函数来执行默认的初始化操作。

3. 返回指针：new 表达式返回指向分配的内存的指针，该指针指向一个已经构造完成的对象。

#### CSV 文件(Comma-Separated Values)
CSV 格式是处理和存储数据的常用格式之一。
1. 简单易懂：CSV文件使用纯文本格式，数据之间使用逗号或其他分隔符分隔。
2. 跨平台兼容性：CSV文件是纯文本文件，几乎所有操作系统和应用程序都可以处理它们。
3. 轻量级。
4. 广泛支持：几乎所有类型的编程语言都支持 CSV 格式文件操作。

#### codecs
"codecs" 是 Python 编程语言中的一个标准库模块，用于处理各种字符编码和解码操作。
codecs 的名称来自 `code and decode`，提供了一种在不同字符码之间进行转换的方式，这在处理文本数据的时候非常有用。
下面是一个简单的示例，将 UTF-8 的编码转换为 ASCII 编码。
```
import codecs

# 要转换的文本
text = "Hello, 你好"

# 将文本从UTF-8编码转换为ASCII编码
ascii_text = codecs.encode(text, 'ascii', 'ignore')  # ignore 是一种错误处理，"ignore" 表示在转换时忽略不能被目标字符编码表示的字符。还有 replace 等

# 输出转换后的文本
print(ascii_text)
```

#### Python 列表推导(List Comprehension)
列表推导是一种简洁的方式来创建新的列表。
```
[expression for item in iterable if condition]
```
其中 `expression` 是生成新列表中元素的表达式，`item` 是可迭代对象 `iterable` 中的元素.
下面是一些例子：
```
# 创建一个包含1到10的平方的列表
squares = [x**2 for x in range(1, 11)]

# 将字符串列表中的所有字符串转换为大写
words = ["hello", "world", "python"]
uppercase_words = [word.upper() for word in words]

# 筛选出一个列表中的偶数元素
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
even_numbers = [x for x in numbers if x % 2 == 0]
```

#### Python 赋值
在 Python 中，赋值分为两种情况：
1. 不可变对象(Immutable Objects)
包括数字、字符串、元组等不可修改的对象。对不可变对象的赋值是值传递（Pass by Value），意味着在赋值时会创建一个新的对象，并将其值赋给新的变量，而不是将原始对象的引用传递给新的变量。
```
x = 5
y = x  # 这是值传递，y 拥有一个新的 5 的副本
```
2. 可变对象(Mutable Objects)
包括列表、字典、集合等可以修改的对象。对可变对象的赋值是地址传递（Pass by Reference），意味着在赋值时不会创建新的对象，而是将原始对象的引用传递给新的变量。因此，如果修改一个可变对象，会影响到所有引用它的变量。
```
list1 = [1, 2, 3]
list2 = list1  # 这是地址传递，list2 和 list1 引用同一个列表对象
```

#### Python 切片
切片是 Python 中非常强大的功能，可以用于许多不同的场景。
1. 提取子序列
可以提取列表、字符串或元组中的特定元素子集。
```
my_list = [1, 2, 3, 4, 5]
subset = my_list[1:4]  # 提取索引1到索引3的元素，得到[2, 3, 4]
```
2. 复制切片
我们上面说了，Python 序列是址传递的，所以我们想复制序列的话不可以简单的 `list2 = list1`
```
original_list = [1, 2, 3, 4, 5]
copy_list = original_list[:]  # 创建一个原始列表的副本，修改 copy_list 不会影响到 original_list
```
3. 步进切片
我们可以指定一个步进值
```
my_list = [1, 2, 3, 4, 5]
every_other = my_list[::2]  # 每隔一个元素提取，得到[1, 3, 5]
```
4. 字符串反转 or 序列 反转
```
my_string = "Hello, World!"
substring = my_string[0:5]  # 提取前五个字符 "Hello"
reversed_string = my_string[::-1]  # 字符串翻转
```
5. 删除元素
```
my_list = [1, 2, 3, 4, 5]
del my_list[1:3]  # 删除索引1到索引2的元素，my_list变为[1, 4, 5]
```
6. 替换元素
```
my_list = [1, 2, 3, 4, 5]
my_list[1:4] = [10, 20, 30]  # 替换索引1到索引3的元素，my_list变为[1, 10, 20, 30, 5]
```
7. 过滤数据
```
my_list = [1, 2, 3, 4, 5]
filtered_list = [x for x in my_list if x % 2 == 0]  # 过滤偶数，得到[2, 4]
```

#### 字符串面值的赋值
字符串字面值是指在代码中直接以文本形式表示的字符串，通常用双引号括起来的一系列字符。字符串字面值在编程中用于表示固定的文本数据。例如，以下是一些字符串字面值的示例：
```
"Hello, World!"
"This is a string literal."
"12345"
```
字符串面值通常是只读的，意味着我们不能对于它们的内容进行修改。
{%asset_img 字符串面值的赋值.png%}

#### 关于 char[] 与 char*
##### char[] 
- 它是一个字符数组，它在栈上分配内存，并且为数组内的每个元素分配空间。
- 当您使用字符串字面值来初始化字符数组时，编译器会自动为数组分配足够的空间来存储字符串字面值的内容，包括字符串结束符 '\0'(与指针直接指向字符串字面值的地址不同，数组是新创建一个空间，然后相当于在新的字符串空间中将字符串字面值给复制过去)。

##### char*
- char* 是一个字符指针，只是指向一个字符的内存地址。
- 当我们使用字符串字面值来初始化数组时，实际上是将字符串字面值的地址赋给了指针(但是我们知道，字符串字面值通常只是只读的，所以说我们指针指向了那个地址也是无法修改字符串的值的，因此一般不这么写，编译器也会报警告)。
- 如果我们想使用 char* 

并且对于 char* 和 char[]，C/C++ 有一种约定成俗的习惯，使用 cout 输出时，会自动识别数组或者指针指向的字符串，并且输出字符串的内容直到遇到空字符 `'\0'` 停止。

这种行为是通过C/C++标准库中的重载运算符和内置函数来实现的，它们会自动迭代字符数组或指针，并输出字符直到遇到空字符。这使得输出字符串变得方便，无需显式循环来逐个字符输出。

同样的，不仅仅是对于 `cout`，对于 char 的一些函数如 `strlen`、`strcpy`，参数为 char* 的时候，同样也是遇到 `'\0'` 时停止函数操作(一般来说，这些函数是操作 `char*` 的，我们如果操作 `char[]` 也是能操作的，因为 **字符数组可以隐式转换为字符指针**)。

如果我们实在想对于 `char*` 类型赋值，可以：
```
char* str = new char[20]; // 使用 new 动态分配 20 个字符的内存

// 将字符串常值赋值给 str
strcpy(str, "Hello, World!");

// 在不需要时记得释放内存
delete[] str;
```

#### 常见的 char* 函数
1. 字符串长度函数
`strlen(const char* str)`: 返回字符串的长度，不包括空字符终止符。
2. `strcpy(char* dest, const char* src)`: 将源字符串复制到目标字符串，包括空字符终止符。需要确保目标字符串有足够的空间来存储源字符串。
`strncpy(char* dest, const char* src, size_t n)`: 将源字符串的前 n 个字符复制到目标字符串，可以控制复制的字符数。
3. `strcat(char* dest, const char* src)`: 将源字符串连接到目标字符串的末尾，需要确保目标字符串有足够的空间来容纳源字符串
4. `strcmp(const char* str1, const char* str2)`: 比较两个字符串，返回值表示它们的字典顺序关系。
请注意，使用这些函数时应格外小心，确保正确处理内存和边界情况，以避免安全漏洞和未定义的行为。

{%asset_img strcpy和strdup.png%}
{%asset_img strdup使用.png%}

#### endl 与 "\n"
{%asset_img endl与n.png %}

#### vector 创建二维数组

一次性定义：
此种方法适用于每一行的列数都相等的二维数组定义(与初始化)
```
//使用vector一次性完成二维数组的定义（注意：此种方法适用于每一行的列数相等的二维数组）
vector<vector<int>> matrix(m, vector<int>(n, -1));

//以下是拆分理解
//创建一维数组matirx，这个数组里有m个元素，元素是int型vector。
vector<vector<int>> matrix(m);
//除了定义数组类型及数组大小外，同时给数组中的元素赋值：将元素赋值为大小为n的int型vector。
vector<vector<int>> matrix(m, vector<int>(n));
//除了定义数组类型、数组大小、列的大小，同时给数组列中的元素（或者说，数组中的所有元素）赋值为-1。
vector<vector<int>> matrix(m, vector<int>(n, -1));
```

插入元素型定义：
此种方法适用于每一行的列数都相等或不相等的二维数组的定义（与初始化）。
```
//比较具有普遍性的写法（注意：此种方法适用于每一行的列数相等的二维数组）
vector<vector<int>> matrix;//创建一维数组matirx，这个数组里的元素是int型vector。
int m = 3; //matrix有m行
int n = 10; //matrix有n列
int value = 1; //最终matrix成为二维数组后，其中每个元素的值为1（如果不需要进行初始化，此语句可以省略）
for (int i = 0; i < m; ++ i) {
    vector<int> tmp(n, value); //定义int型一维数组tmp，该数组有n个int型元素，且每个元素的初始值为value
    matrix.push_back(tmp); //将一维数组tmp（小容器）加入matrix（大容器）中，使之成为matrix的元素，令matrix成为二维数组
}

//如果需要每一行的列数不同（虽然一般很少这样做），也可以使用下面这种写法进行定义、初始化
vector<vector<int>> matrix;

vector<int> a(10, 1); //单独定义每个小容器的元素个数和元素初始值
vector<int> b(5, 2);
vector<int> c(10, 3);

matrix.push_back(a); //将每个小容器加入matrix（大容器）中
matrix.push_back(b);
matrix.push_back(c);
```

#### assign 函数分配与初始化

其实也可以使用 vector 的构造函数来初始化。

assign 函数主要用于重新分配 vector 元素并进行初始化。它的用法主要有两种：
1. 用迭代器范围进行分配：
assign 可以结构两个迭代器参数，从另一个容器或者序列中复制元素到当前 vector 中。
```
std::vector<int> vec;
std::vector<int> anotherVec = {1, 2, 3, 4, 5};

vec.assign(anotherVec.begin(), anotherVec.end());
```
2. 用大小和值进行分配：
assign 函数也可以接受一个大小参数和一个值参数，用于将 std::vector 的大小更改为指定大小，并用指定的值填充所有新元素。这是一种用于重新分配 std::vector 并**进行初始化的方法**。
```
std::vector<int> vec(5, 42); // 就是将 vec 的大小设置为 5，每一项设置为 42

std::vector<vector<int>> v(5, vector<int>(5, 0)); // 创建一个二维数组 v，其中是 5 行 5 列并且每一个元素都是 0
```

#### 遍历 vector 的几种方式
1. 
```
for (int i = 0; i < v.size(); ++i)
```
2. 
使用迭代器
```
for (std::vector<int>::iterator it = v.begin(); it != v.end(); ++it)
```
3. 
使用 auto 关键字
```
for (auto iterator it = v.begin(); it != v.end(); ++it)

for (const auto& element : v)
```
关于为什么写成 `const auto&` 可以避免拷贝(加快速度)，保持元素的不可变性。

#### 关于 vector 迭代器
vector 中迭代器是一个用于访问容器元素的抽象概念。它提供了一种通用的方式来遍历容器中的元素，而不依赖于容器的具体实现细节。
在 C++ 中，std::vector 提供了**两种主要类型**的迭代器：
1. begin() 迭代器。这个迭代器指向容器中的第一个元素。
2. end() 迭代器。这个迭代器指向容器中**最后一个元素的下一个位置**。

#### 主存
主存指的是内存 RAM

#### SSD
SSD 是固态硬盘 (Solid State Drive) 的缩写。与传统的机械硬盘（HDD）不同，SSD不包含可移动的机械部件，而是使用闪存存储技术来存储数据。这使得SSD在许多方面都具有一些显著的优势，包括：
1. 更快的速度：SSD比HDD更快，因为它们不需要旋转磁盘和寻道操作来读取数据。这意味着计算机可以更快地启动、加载应用程序和执行文件传输等任务
2. 更低的能耗：由于没有旋转的机械部件，SSD消耗的能量较少，因此在笔记本电脑和移动设备中通常能够延长电池寿命。
3. 更高的可靠性与更轻便
但是价格比较高。
HDD (Hard Disk Drive) 硬盘驱动器，有时候也成为硬盘或者机械硬盘

#### BIOS
BIOS（基本输入/输出系统，Basic Input/Output System）是计算机系统中的一组固件程序，它们位于计算机的主板上的一个特殊芯片中，通常是闪存芯片。
1. 启动自检（POST）：在计算机启动时，BIOS会执行自检程序，检查计算机的硬件组件，如处理器、内存、硬盘、光驱等是否正常工作。如果发现问题，BIOS通常会发出蜂鸣声或显示错误信息，以指示问题的位置。
2. 引导操作系统：一旦自检完成，BIOS会寻找可引导的设备，通常是硬盘驱动器或其他存储设备。它会加载操作系统的引导加载程序（Boot Loader），并将控制权转交给操作系统，使其能够继续启动过程。
3. 设置硬件参数：BIOS还包括一组用户可配置的硬件设置，这些设置通常可通过计算机的BIOS设置界面进行调整。用户可以在BIOS中设置硬盘启动顺序、系统时间、密码保护等选项。
4. 提供基本的输入/输出服务：BIOS提供了一些基本的输入/输出功能，以便在操作系统加载之前进行一些基本的操作，如键盘输入、显示输出和存储设备的读写。

#### Transistor-Transistor Logic
在集成电路型号中，通常以 74 开头的数字代表它们属于标准的 Transistor-Transistor Logic
具体来说，"74" 表示了 TTL 系列中的特定子系列。TTL 门和触发器的型号通常以 "74" 开头，例如，"7400" 代表四输入 NAND 门，"74138" 代表 3-8 译码器/多路复用器，等等。

#### vector 中的 find 函数
**find 函数是在 `algorithm` 中的，不写的话会报错，血的教训。**
C++ 标准库中的 `std::find()` 函数可以用来在容器 (包括 std::vector) 中查找特定值的位置。它的用法如下：
```#include <algorithm> // 必须包含这个头文件

// ...

vector<int> myVector = {1, 2, 3, 4, 5};
int targetValue = 3;

// 使用std::find查找特定值
auto it = std::find(myVector.begin(), myVector.end(), targetValue);

if (it != myVector.end()) {
    // 找到了目标值
    // 'it' 是一个迭代器，指向找到的元素的位置
    // 在这里，它指向了值为3的元素
    cout << "找到了目标值: " << *it << endl;
} else {
    // 没找到目标值
    cout << "未找到目标值" << endl;
}
```
std::find函数的返回类型是一个迭代器（iterator），它是一个指向容器中找到的元素的位置的指针。

#### string
string 中也是有着迭代器的

#### 电源适配器 power adapter
提到电源适配器可能很多人都不知道这是什么东西，如果说笔记本电脑充电线上那个长方形的配件或者说手机充电器大家倒是常见，是的，那个就是电源适配器，电源适配器（Power adapter）又叫外置电源，是小型便携式电子设备及电子电器的供电电压变换设备，常见于手机、液晶显示器和笔记本电脑等小型电子产品上。
它的作用是将家里的220伏高电压转换成这些电子产品能工作的5伏至20伏左右稳定的低电压，使他们能正常工作,一般由外壳、变压器、电感、电容、控制IC、PCB板等元器件组成，它的工作原理由交流输入转换为直流输出

#### vscode 中 alt 加 上下键

可以将光标所在的位置的代码行直接进行移动，向上或者向下移动。

#### 栈帧

当一个函数被调用时，通常会创建一个包含该函数的局部变量、参数和执行上下文信息的数据结构，这个数据结构称为栈帧（也称为调用帧或执行帧）。栈帧用于存储函数执行期间的局部状态信息，包括局部变量、函数参数、返回地址等。在函数调用栈中，每个函数调用都对应一个栈帧，它们按照调用的顺序依次排列。

所以我们采取非递归算法，即使是在函数中模拟栈，但是我们并没有过多递归导致产生过多栈帧，所以通常是更加节省空间的。

#### 比较函数规则

通常情况下，比较函数的返回值为1表示前面的元素大于后面的元素，而返回-1ee或者0表示前面的元素小于或等于后面的元素。这是一种常见的约定，但也可以根据具体需求和实现来定义不同的比较规则。

#### pair 模板类

std::pair 是 C++ 标准库提供的一个模板类，用于将两个不同类型的值组合成一个单元。定位于头文件 `utility` 中。

std::pair 最常见的用法是在函数的返回值中返回多个值，或者在容器中存储多个类型的数据。pair 有两个公共成员 `first` 和 `second` 

#### \0
在C/C++中，\0 通常用作字符串的结束标志，标识字符串的结尾。

当你在一个以\0结尾的字符数组（C-Style字符串）中遇到\0字符时，它表示字符串的结束，告诉程序在这里停止处理字符串。例如：

#### map 等容器创建

在C++中，std::map对象的创建方式取决于它是如何声明的。std::map可以在栈上或堆上创建，具体取决于其声明方式。

#### 模块化

将代码写成如下的形式：
```
 void insert(const T& value) {
        insertNode(root, value);
}
```
有下面的好处：
1. 代码模块化：将插入操作分为两个函数可以使得代码更加模块化，每个函数负责一个明确定义的任务。使得代码更加容易理解和维护。外部调用者著需要调用 insert 函数，而不需要了解内部的递归细节。
2. 可读性：使用 insert 和 insertNode 两个函数可以在外部接口提供更具描述性的函数名，使得代码更加容易理解。
3. 封装内部细节：insertNode 函数是一个内部的实现细节，不需要暴露给用户。这有助于隐藏内部数据结构和实现细节，提高了代码的封装性和安全性。

将插入操作拆分为两个函数是一种常见的编程实践，有助于提高代码的清晰度、可维护性和可读性。这种模块化设计方法可以应用于其他类似的操作，使代码更易于管理和扩展。

#### STL 容器传递用于比较的函数对象类

在C++的STL容器中（如std::map、std::set等），如果您想要自定义元素的比较行为，您可以传递一个用于比较的函数对象类，而不是传递一个函数对象的实例。这是因为STL容器需要在需要比较元素时创建比较器对象的实例，而不是在容器创建时就传递一个现成的比较结果。

因此，当您向std::map（或其他STL容器）传递一个自定义的比较函数对象时，STL容器会在内部创建该函数对象的实例，以便在需要时进行元素比较。这允许STL容器根据需要多次使用相同的比较器类的不同实例。

所以我们写为：
```
#include <iostream>
#include <map>

// 自定义的比较函数对象类
struct MyComparator {
    bool operator()(int a, int b) const {
        return a > b; // 比较a是否大于b
    }
};

int main() {
    // 使用自定义比较函数对象创建std::map
    std::map<int, std::string, MyComparator> customMap; // 传递一个结构体，而不是它的实例对象，STL容器会自动创建实例对象来比较

    // 插入一些元素
    customMap[5] = "Five";
    customMap[2] = "Two";
    customMap[8] = "Eight";

    // 遍历并打印map的内容
    for (const auto& pair : customMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }

    return 0;
}
```

#### struct 和 class

在C++中，struct和class都是用来定义用户自定义数据类型的关键字，它们之间的主要区别在于默认的访问控制和一些语法细节。下面是它们的主要区别和适用场景：

1. 访问控制：

struct：struct中的成员默认都是公共的（public），可以被外部代码直接访问。
class：class中的成员默认都是私有的（private），需要通过成员函数（方法）来访问。
2. 数据封装：

由于class默认成员是私有的，它更适合用于实现数据封装，即将数据隐藏在类的内部，通过公共接口提供访问和修改数据的方法，以维护数据的完整性和安全性。
struct通常用于轻量级的数据结构，其成员都是公开的，用于存储一组相关数据，不提供严格的封装。
继承：

3. struct和class都可以用于实现继承，但默认情况下，class的继承是私有的，而struct的继承是公共的。这意味着从class继承的成员在子类中默认是私有的，而从struct继承的成员在子类中默认是公共的。
适用场景：

4. 使用class：当需要实现封装、数据隐藏、访问控制、继承以及更复杂的类层次结构时，通常使用class。
使用struct：当只需要一个简单的数据容器，没有需要隐藏的数据，或者需要与C语言交互时，通常使用struct。也可以将struct用于只包含数据而不包含成员函数的情况。
无论选择使用struct还是class，都可以在其中定义成员函数（方法）以提供对数据的操作，这取决于您的设计需求和数据封装的程度。在实际应用中，这两个关键字的选择通常是根据项目的需求和编码风格来确定的。

#### 深入理解 C++ STL 迭代器

STL（Standard Template Library）中的容器实现迭代器是通过将迭代器作为容器类的内部类来实现的。迭代器是一种用于遍历容器中元素的抽象概念，它提供了访问容器元素的接口，使得可以轻松地遍历容器的内容。

以下是关于STL容器中迭代器的一些一般性原则：

1. 迭代器是容器的一部分：迭代器通常被定义为容器类的内部类，因此它们可以访问容器内部的数据结构，并提供访问和操作元素的方法。

2. 迭代器的种类：不同类型的STL容器可以提供不同种类的迭代器，例如前向迭代器、双向迭代器和随机访问迭代器。迭代器的种类决定了迭代器的功能和效率，不同的容器支持不同种类的迭代器。

3. 迭代器的操作：迭代器通常支持一组标准操作，如前进、后退、解引用等。这些操作允许您在容器中移动并访问元素。

4. Begin 和 End：STL容器通常提供 begin() 和 end() 成员函数，分别返回指向容器第一个元素和尾后位置（即不指向任何元素的位置）的迭代器。这些函数用于迭代容器的所有元素。

5. 迭代器的使用：迭代器可以用于遍历容器的元素，从容器的开始（begin()）到结束（end()）。使用迭代器，您可以执行诸如遍历、查找、修改和删除元素等操作。

6. 具体的实现细节和迭代器的性能特征取决于特定的容器类型。例如，std::vector 提供了随机访问迭代器，因此支持快速的随机访问，而 std::list 提供了双向迭代器，因此在列表中的元素上前进和后退较为高效。

总之，STL容器通过定义迭代器来提供对容器元素的访问和遍历，这是STL的一个核心概念，使得STL容器在使用上非常灵活。

#### 红黑树和 AVL 树实现差异

1. AVL树的插入操作通常使用递归来实现，这是因为AVL树在插入后需要递归地重新平衡，以确保树保持平衡因子的性质。与AVL树不同，红黑树的平衡性质更容易通过迭代修复，因为它只涉及相邻节点之间的颜色变化和旋转操作，而不需要像AVL树那样严格的平衡因子维护。

在红黑树中，使用迭代而不是递归的原因之一是它更简单且更高效。另一方面，AVL树的平衡因子维护涉及到更复杂的旋转和递归操作，因此递归更容易理解和实现。

总之，红黑树通常使用迭代插入操作，而AVL树通常使用递归插入操作。不同的数据结构有不同的性质和平衡要求，因此它们的插入和平衡策略也不同。

#### 类和结构体

1. 访问权限
类（class）的默认访问权限是私有（private）。这意味着类中的成员（数据成员和成员函数）默认情况下只能在类的内部访问，需要使用公有接口才能从外部访问。
结构体（struct）的默认访问权限是公共（public）。这意味着结构体中的成员在外部可以直接访问。

2. 继承
类可以用于实现类的继承和多态，因为类支持访问控制符（如private、protected、public）来控制基类成员的可见性和访问权限。
结构体也可以用于继承，但默认的访问权限是公共，因此它们的成员在子类中具有相同的访问权限。

3. 使用习惯
通常情况下，类用于表示具有私有成员和行为的抽象数据类型，用于封装数据和操作。
结构体通常用于表示简单的数据结构，其中成员通常是相关的数据字段而不包含复杂的行为。

#### 宏定义 define

宏定义是在编译前由预处理器处理的，因此它们不会进行类型检查，可能会导致一些潜在的错误。
作用：
1. 宏替换：预处理器会根据宏定义将源代码中的标识符替换为相应的文本。这允许您创建常量、宏函数以及在代码中的其他地方重复使用文本片段。这提高了代码的可维护性和可读性。
2. 条件编译：通过使用条件指令（如#ifdef、#ifndef、#if、#elif、#else和#endif），您可以根据条件包含或排除代码段。这对于在不同的编译环境或配置下启用或禁用特定功能非常有用，例如调试模式或发布模式下的不同行为。
3. 包含文件：#include指令允许您在源代码中包含其他头文件，以便使用其中定义的函数、变量和类型。这有助于模块化代码并实现代码重用
4. 删除注释：预处理器可以删除注释，这样它们不会包含在编译后的代码中。这有助于减小可执行文件的大小，同时保留了代码的可读性。
5. 定义符号常量：通过#define指令，您可以定义符号常量，以便在代码中使用这些常量而不必硬编码它们的值。这有助于提高代码的可维护性，并减少代码中的魔法数字。

#### 数据库语言

操作数据库经常使用特定的数据库查询语言(Database Query Language)。最常见的数据库查询语言是 SQL(Structured Query Language, 结构化查询语言)。

DBMS(Database manage system) 数据库管理系统

绝大多数数据库软件都支持 SQL 语言，尤其是关系型数据库管理系统(RDBMS)

**MySQL 和 SQLite 的关系：**
MySQL：MySQL是一个强大的关系型数据库管理系统，通常用于大型企业应用程序和高负载的网站。它可以处理大量数据和高并发访问。
SQLite：SQLite是一种轻量级的嵌入式数据库，适用于小型到中等规模的应用程序。它通常用于移动应用、桌面应用、嵌入
式系统等，不适用于大规模或高并发的场景。

其中，嵌入式指的是 **运行方式和部署方式**。这意味着它的数据库引擎以库（库文件或代码库）的形式直接嵌入到应用程序中，而不是作为一个独立的数据库服务器运行。(还记得如果使用 MySQL 的话，需要在电脑上开启它)

##### Redis
Redis(Remote Dictionary Server)。Redis 是一种开源的**内存数据库**，可以用作缓存、消息代理、持久化存储以及多种数据结构的高效存储和检索。

内存数据库将数据存储在内存中，可以实现非常快的读取和写入操作。这使得内存数据库在需要快速响应的应用中有非常大的优势，例如实时数据分析、缓存和实时计算。

##### std::string::npos

std::string::npos 是C++标准库中的一个特殊常量值，通常用于表示字符串操作的无效或失败状态，特别是在查找子字符串或字符时。

常见的使用方式是在 `std::string` 的 `find` 函数中

```
#include <string>
#include <iostream>

int main() {
    std::string text = "Hello, World!";
    std::size_t found = text.find("foo"); // 在字符串中查找"foo"
    
    if (found != std::string::npos) {
        std::cout << "Substring found at position " << found << std::endl;
    } else {
        std::cout << "Substring not found." << std::endl;
    }

    return 0;
}
```

#### size_t

`size_t`  是C/C++标准库中定义的一种用于表示对象大小或索引的无符号整数类型。它通常被用于数组索引、容器大小、内存分配、字符串长度以及其他需要表示对象大小的上下文中。
```
#include <vector>
#include <iostream>

int main() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    for (size_t i = 0; i < v.size(); ++i) {
        std::cout << v[i] << " ";
    }
    return 0;
}
```

