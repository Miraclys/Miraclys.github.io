<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/08/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo blog instructions list</title>
    <url>/2023/08/23/hexo-blog-instruction-list/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>指令</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>hexo n “我的博客” / hexo new “我的博客”</td>
<td>新建文章</td>
</tr>
<tr>
<td>hexo p / hexo publish</td>
<td>发表草稿文章</td>
</tr>
<tr>
<td>hexo g / hexo generate</td>
<td>生成</td>
</tr>
<tr>
<td>hexo s / hexo server</td>
<td>启动本地预览服务</td>
</tr>
</tbody>
</table>
</div>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><ol>
<li>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。<br>在 hexo 中使用 <strong>文章资源文件夹</strong> 需要在 <code>config.yaml</code> 文件中更改一下配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
当该配置被应用后，使用 hexo new 命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。<br>但是若干原因，需要使用 <code>&#123; %asset_image xxx.jpg 这是一张图片% &#125;</code> 来引用。</li>
<li>另一种方法是，在 <code>source</code> 文件夹下建立一个文件夹 <code>_pic</code> 专门用来存放图片，此时在 md 文件中 <code>![img](/_pic/xxx.jpg)</code> 的格式引用就可以了。<br>(不知道为啥这种没成功)</li>
</ol>
<h3 id="搭建参考"><a href="#搭建参考" class="headerlink" title="搭建参考"></a>搭建参考</h3><ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/94038688#:~:text=hexo">https://zhuanlan.zhihu.com/p/94038688#:~:text=hexo</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/44213627">https://zhuanlan.zhihu.com/p/44213627</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000002632530">https://segmentfault.com/a/1190000002632530</a> hexo 常用命令笔记</p>
</li>
<li><p><a href="https://blog.csdn.net/as480133937/article/details/100138838">https://blog.csdn.net/as480133937/article/details/100138838</a> hexo 博客美化配置</p>
</li>
<li><p><a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
</li>
<li><p><a href="https://theme-next.js.org/docs/theme-settings/">https://theme-next.js.org/docs/theme-settings/</a></p>
</li>
<li><p><a href="https://hexo.io/zh-cn/docs/configuration">https://hexo.io/zh-cn/docs/configuration</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/552639819">https://zhuanlan.zhihu.com/p/552639819</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_34243930/article/details/103994419#2_65">https://blog.csdn.net/qq_34243930/article/details/103994419#2_65</a> 关于 hexo 创建文章的讲解</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a> hexo 博客插入图片</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>莫队算法</title>
    <url>/2023/08/23/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>莫队</strong>，是莫涛发明的一种解决区间查询等问题的 <strong>离线算法</strong>，基于 <strong>分块</strong> 思想，复杂度为 $O(n\sqrt{n})$</p>
<p>一般来说，如果可以在 $O(1)$ 内从 $[l, r]$ 的答案转移到 $[l - 1, r]、[l + 1, r]、[l, r - 1]、[l, r + 1]$ 这四个与之紧邻的区间的答案，则可以考虑使用莫队。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/SP3267">DQUERY - D-query - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>HH 的项链弱化版</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Q = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, vis[M], bel[N], a[N], st[N], ed[N], cnt[M], ans[N];</span><br><span class="line"><span class="type">int</span> l, r, cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125; q[Q];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        st[i] = n / len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[len] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? bel[x.r] &lt; bel[y.r] : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --cnt[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>();</span><br><span class="line">        q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].num = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line">    l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) </span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) </span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        ans[q[i].num] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队算法的扩展-——-带修莫队"><a href="#莫队算法的扩展-——-带修莫队" class="headerlink" title="莫队算法的扩展 —— 带修莫队"></a>莫队算法的扩展 —— 带修莫队</h3><p>前面说过，莫队算法是离线算法，不支持修改，强制在线需要另寻他法。但是对于某些允许离线的带修改区间查询来说，莫队还是能大展拳脚的。做法就是把莫队直接加上一维，变为带修莫队。</p>
<p>我们的做法是把修改操作编号，称为「时间戳」。</p>
<p>跑主算法时定义当前时间戳为 t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</p>
<p><strong>跑主算法时定义当前时间戳为 t，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</strong></p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/P1903">P1903 [国家集训队] 数颜色 / 维护队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">133335</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, bel[N], st[N], ed[N], a[N], len;</span><br><span class="line"><span class="type">int</span> cnt_1, cnt_2, vis[M], ans[N], cur;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_1</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> time;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q1[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question_2</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">&#125; q2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    len = sqrt(n);</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i) &#123;</span></span><br><span class="line"><span class="comment">        st[i] = n / len * (i - 1) + 1;</span></span><br><span class="line"><span class="comment">        ed[i] = n / len * i;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ed[len] = n;</span></span><br><span class="line"><span class="comment">    for (int i = 1; i &lt;= len; ++i)</span></span><br><span class="line"><span class="comment">        for (int j = st[i]; j &lt;= ed[i]; ++j)</span></span><br><span class="line"><span class="comment">            bel[j] = i;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">ceil</span>((<span class="type">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) &#123;</span><br><span class="line">        st[i] = len * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = len * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question_1 x, Question_1 y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? (bel[x.r] == bel[y.r] ? x.time &lt; y.time : bel[x.r] &lt; bel[y.r]) : bel[x.l] &lt; bel[y.l]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++vis[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    --vis[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (vis[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">char</span> opt;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q1[++cnt_1].l = x;</span><br><span class="line">            q1[cnt_1].r = y;</span><br><span class="line">            q1[cnt_1].time = cnt_2;</span><br><span class="line">            q1[cnt_1].id = cnt_1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q2[++cnt_2].col = y;</span><br><span class="line">            q2[cnt_2].pos = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; &quot;no error&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q1 + <span class="number">1</span>, q1 + <span class="number">1</span> + cnt_1, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q1[i].l)</span><br><span class="line">            <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q1[i].r)</span><br><span class="line">            <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q1[i].l)</span><br><span class="line">            <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q1[i].r)</span><br><span class="line">            <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q1[i].time) &#123;</span><br><span class="line">            ++t;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q1[i].time) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q1[i].l &lt;= q2[t].pos &amp;&amp; q2[t].pos &lt;= q1[i].r) &#123;</span><br><span class="line">                <span class="built_in">del</span>(q2[t].pos);</span><br><span class="line">                <span class="keyword">if</span> (vis[q2[t].col] == <span class="number">0</span>)</span><br><span class="line">                    ++cur;</span><br><span class="line">                ++vis[q2[t].col];</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">swap</span>(a[q2[t].pos], q2[t].col);</span><br><span class="line">            --t;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q1[i].id] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt_1; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一道题目块的大小取得 $n^{\frac{2}{3}} $ 时时间复杂度最小。如果还是 $\sqrt{n}$ 的话，会超时。</p>
<h3 id="莫队算法的扩展-——-树上莫队"><a href="#莫队算法的扩展-——-树上莫队" class="headerlink" title="莫队算法的扩展 —— 树上莫队"></a>莫队算法的扩展 —— 树上莫队</h3><p>前面我们所使用的莫队都是在一维的序列上进行，即使加了一维的时间轴，但是主题还是一维序列。那么树上统计问题能否用莫队来处理呢？答案是肯定的。</p>
<p>但是普通的 dfs 序没有办法确定一个对应区间</p>
<p>使用 <strong>欧拉序</strong>，可以解决许多普通 dfs 序无法解决的问题（就比如树上莫队）。</p>
<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230723182411099.png" alt="image-20230723182411099"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, cur, cnt, tot, date[N], a[N], dep[N], top[N], fa[N], bel[N &lt;&lt; <span class="number">1</span>], siz[N], son[N], head[N], st[N &lt;&lt; <span class="number">1</span>], ed[N &lt;&lt; <span class="number">1</span>], id[N], fir[N], las[N], use[N &lt;&lt; <span class="number">1</span>], ans[M], cot[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> nxt, to;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> lca;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">&#125; q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++cnt].nxt = head[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[x] = f;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Max = <span class="number">-1</span>;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    fir[x] = tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to, x);</span><br><span class="line">        siz[x] += siz[to];</span><br><span class="line">        <span class="keyword">if</span> (siz[to] &gt; Max) &#123;</span><br><span class="line">            Max = siz[to];</span><br><span class="line">            son[x] = to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    id[++tot] = x;</span><br><span class="line">    las[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> tp)</span> </span>&#123;</span><br><span class="line">    top[x] = tp;</span><br><span class="line">    <span class="keyword">if</span> (!son[x]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], tp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i ; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="type">int</span> to = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (to == fa[x] || to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(to, to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (++cot[pos] == 1) cur++;</span></span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        ++cur;</span><br><span class="line">    ++cot[a[pos]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if (--cot[pos] == 0) cur--;</span></span><br><span class="line">    --cot[a[pos]];</span><br><span class="line">    <span class="keyword">if</span> (cot[a[pos]] == <span class="number">0</span>)</span><br><span class="line">        --cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; &quot;this is a test&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//use[pos] ? del(a[pos]) : add(a[pos]);</span></span><br><span class="line">    <span class="comment">//use[pos] ^= 1;</span></span><br><span class="line">    use[pos] ? <span class="built_in">del</span>(pos) : <span class="built_in">add</span>(pos);</span><br><span class="line">    use[pos] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = date[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> num = std::<span class="built_in">unique</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n) - date - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(date + <span class="number">1</span>, date + <span class="number">1</span> + n, a[i]) - date;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; ++i)</span><br><span class="line">        bel[i] = i / block + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int x, y;</span></span><br><span class="line">    <span class="type">int</span> ancestor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (fir[x] &gt; fir[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">        ancestor = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        q[i].id = i;</span><br><span class="line">        <span class="keyword">if</span> (ancestor == x) &#123;</span><br><span class="line">            q[i].l = fir[x]; <span class="comment">// 欧拉序中的位置</span></span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = las[x];</span><br><span class="line">            q[i].r = fir[y];</span><br><span class="line">            q[i].lca = ancestor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp2);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) &#123;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) &#123;</span><br><span class="line">            l--;</span><br><span class="line">            <span class="built_in">Add</span>(id[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="built_in">Add</span>(id[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">        q[i].ans = cur;</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; &quot;htih&quot; &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="keyword">if</span> (q[i].lca)</span><br><span class="line">            <span class="built_in">Add</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        ans[q[i].id] = q[i].ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="莫队算法的扩展——回滚莫队"><a href="#莫队算法的扩展——回滚莫队" class="headerlink" title="莫队算法的扩展——回滚莫队"></a>莫队算法的扩展——回滚莫队</h3><p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230724130521246.png" alt="image-20230724130521246"></p>
<p>感觉细节有一些多，比较麻烦的</p>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><a href="https://www.luogu.com.cn/problem/AT_joisc2014_c">AT_joisc2014_c 歴史の研究</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll n, m, Max, tot, a[N], b[N], st[N], ed[N], bel[N], ans[N], cnt[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Question</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Question x, Question y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bel[x.l] == bel[y.l] ? x.r &lt; y.r : bel[x.l] &lt; bel[y.l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x = x * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    ++cnt[a[pos]];</span><br><span class="line">    Max = std::<span class="built_in">max</span>(Max, cnt[a[pos]] * b[a[pos]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = b[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// discretization</span></span><br><span class="line">    std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> len = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) - b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// split block </span></span><br><span class="line">    ll block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        st[i] = n / block * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        ed[i] = n / block * i;</span><br><span class="line">    &#125;</span><br><span class="line">    ed[block] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = st[i]; j &lt;= ed[i]; ++j)</span><br><span class="line">            bel[j] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sort question </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(), q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mo</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= block; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> l;</span><br><span class="line">        <span class="type">int</span> r = ed[i];</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span> (cnt));</span><br><span class="line">        Max = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (bel[q[p].l] == i) &#123;</span><br><span class="line">            <span class="comment">// std::cout &lt;&lt; &quot;sdasda&quot;;</span></span><br><span class="line">            <span class="comment">//Max = -1;</span></span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            l = ed[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (bel[q[p].l] == bel[q[p].r]) &#123;</span><br><span class="line">                ll cur = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = q[p].l; j &lt;= q[p].r; ++j) &#123;</span><br><span class="line">                    ++cnt[a[j]];</span><br><span class="line">                    c[++tot] = a[j];</span><br><span class="line">                    Max = std::<span class="built_in">max</span>(Max, cnt[a[j]] * b[a[j]]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans[q[p].id] = Max;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j)</span><br><span class="line">                    --cnt[c[j]];</span><br><span class="line">                ++p;</span><br><span class="line">                Max = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[p].r)</span><br><span class="line">                <span class="built_in">add</span>(++r);</span><br><span class="line">            ll cur = Max;</span><br><span class="line">            <span class="comment">//std::cout &lt;&lt; &quot;cur: &quot; &lt;&lt; cur &lt;&lt; std::endl;</span></span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[p].l)</span><br><span class="line">                <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[p].id] = Max;</span><br><span class="line">            Max = cur;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= ed[i]) </span><br><span class="line">                --cnt[a[l++]];</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="C:\Users\梁云森\AppData\Roaming\Typora\typora-user-images\image-20230725000620621.png" alt="image-20230725000620621"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.cnblogs.com/WAMonster/p/10118934.html">莫队算法——从入门到黑题 - WAMonster - 博客园 (cnblogs.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/115243708">算法学习笔记(24): 莫队 - 知乎 (zhihu.com)</a></p>
<p>OIwiki</p>
]]></content>
  </entry>
  <entry>
    <title>test</title>
    <url>/2023/08/23/test/</url>
    <content><![CDATA[<p>{ %asset_img machine_learning.jpg this is a example image. %}</p>
]]></content>
  </entry>
  <entry>
    <title>差分方程模型</title>
    <url>/2023/08/24/%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>在连续系统里，我们用常微分方程表示时域；<br>而在离散系统里，由于输入 | 输出都是离散信号，微分失去了意义，所以用差分计算。</p>
</blockquote>
<p>设有未知序列 $\{x_n\}$，称 $F(n;x_n,x_{n + 1}, …, x_{n + k}) = 0$ 为 k 阶差分方程。</p>
<p>关于差分方程的解，可以参考文章 <a href="https://zhuanlan.zhihu.com/p/385787482">https://zhuanlan.zhihu.com/p/385787482</a> </p>
<h4 id="金融问题中的差分方程模型"><a href="#金融问题中的差分方程模型" class="headerlink" title="金融问题中的差分方程模型"></a>金融问题中的差分方程模型</h4><p>现在有一笔 p 万元的贷款，贷款期是 n 年，月利率是 r，采用等额还款的方式逐月偿还，计算每月的还款数。<br>设 k 个月后，欠额为 $A_k$，每月还款 m 元，则有 $A_{k + 1} = (1 +r)A_k - m$</p>
<h4 id="养老保险模型"><a href="#养老保险模型" class="headerlink" title="养老保险模型"></a>养老保险模型</h4><p>设 k 个月后所交资金以及利息总和为 $F_k$，则有 $F_k = (1 + r)F_{k - 1} + p, k &lt;= N$ 和 $F_k = (1 +r)F_{k - 1} - q, N &lt; k &lt;= M$，N 个月后，不再交钱，只拿钱。</p>
<h4 id="市场经济中的蛛网模型"><a href="#市场经济中的蛛网模型" class="headerlink" title="市场经济中的蛛网模型"></a>市场经济中的蛛网模型</h4><p>在自由竞争的社会中，很多领域会出现 <strong>循环波动</strong> 的现象，比如说自由市场上商品的价格。<br>将时间离散化为时段，一个时期相当于商品的一个生产周期。设 k 时段商品数量为 $x_k$，商品价格为 $y_k$</p>
<p>同一时段商品的价格取决于该段商品的数量，$y_k = f(x_k)$，称为需求函数，我们自然地认为这个函数是单调下降函数。</p>
<p>下一段商品的数量取决于上一个时段的商品价格，$x_{k + 1} = g(y_k)$，称为供应函数，假设为单调上升函数。</p>
<p>在进行市场经济分析中，f 取决于消费者对于某种产品的需求程度以及消费水平，g 取决于生产能力和管理水平。</p>
<p>两个曲线的交点 $P(x_0, y_0)$ 处，$|f’(x_0)| &lt; |g’(x_0)|$ 时，P 点稳定，反之不稳定。</p>
<p>设 $|f’(x_0)| = \alpha, |g’(y_0)| = \frac{1}{\beta}$，在 P 点附近取 $y_k - y_0 = -\alpha(x_k - x_0), x_{k + 1} - x_0 = \beta(y_k - y_0)$，消去 $y_k$，得到 $x_k$ 的递推式，可以求出通项，求极限和上面的条件等价。</p>
<h4 id="简单的种群增长模型"><a href="#简单的种群增长模型" class="headerlink" title="简单的种群增长模型"></a>简单的种群增长模型</h4><p>利用了矩阵的特征方程求解。对角化或者化为若尔当标准型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>微分方程模型</title>
    <url>/2023/08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h4 id="微分方程模型"><a href="#微分方程模型" class="headerlink" title="微分方程模型"></a>微分方程模型</h4><p>如果能得到解析解的形式固然便于分析和应用，但是大多数微分方程无法得到解析解，因此研究其稳定性和数值解法就十分重要。</p>
<ol>
<li><img src="/2023/08/24/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/liuliangxishu.jpg" class="" title="流量系数">
 容器漏水问题。<br> 好像是 $Q = Sv$ 流量前面一个系数，不是很懂。</li>
<li>导弹追踪问题<br> 列出关于斜率的微分方程，然后代入初值条件。</li>
</ol>
<h5 id="传染病模型"><a href="#传染病模型" class="headerlink" title="传染病模型"></a>传染病模型</h5><p>我们一开始不把所有的因素考虑在内，而是抓住主要因素，把问题简化，建立相应的数学模型。然后与实际比较，再做出修改。</p>
<ol>
<li>指数模型<br> 用 $i(t)$ 表示 t 时刻病人的数量，每个病人传染的人数为 k, 则有 $i(t + \Delta t) - i(t) = ki(t)\Delta t$<br> 解得 $i(t) = i_0e^{kt}$，随着时间增长，人数是无穷的，不符合实际，所以我们对于这个模型进行修改。</li>
<li>SI 模型<br> 设 t 时刻病人为 $i(t)$，健康人数为 $s(t)$，每个病人传染的人数和健康人数呈正比，比例系数为 k，则有 $i(t + \Delta t) - i(t) = i(t)\Delta ks(t) = ki(t)(n - i(t))$，解得 $i(t) = \dfrac{n}{1 + (\frac{n}{i_0} - 1)e^{-kt}}$<br> 医学上一般称这个 $i(t)$ 曲线为传染病曲线。<br> 但是这个模型的缺点是，当 $t \to +\infty$ 的时候，人人都会生病，这是不符合实际的。</li>
<li>SIS 模型<br> 考虑到人们生病后是恢复的，或者说有人可能会感染多次。<br> 在上一个模型的基础上，添加日治愈率 $\mu$，和病人的数量呈正比。<br> 现在就有 $i(t + \Delta t) - i(t) = (ks(t)i(t) - \mu i(t))\Delta t, i(0) = i_0$。</li>
</ol>
<h4 id="捕鱼业的持续收获模型"><a href="#捕鱼业的持续收获模型" class="headerlink" title="捕鱼业的持续收获模型"></a>捕鱼业的持续收获模型</h4><h6 id="阻滞增长模型-Logistic-模型"><a href="#阻滞增长模型-Logistic-模型" class="headerlink" title="阻滞增长模型 (Logistic 模型)"></a>阻滞增长模型 (Logistic 模型)</h6><p>将增长率 r 修正为 r - sx 一个关于 x 的线性函数。自然资源和环境限制所能容纳的最大人数为 $x_m$，也就是 $x = x_m$ 的时候，$r =0$，所以有 $r(x) = r(1 - \dfrac{x}{x_m})$，其实和上面传染病模型中的 SI 模型是差不多的。)</p>
<ol>
<li>产量模型<br> 记时刻 t 时渔场中的鱼量为 $x(t)$，由 Logistic 模型则有 $x’(t) = f(x) = rx(1 - \frac{x}{N})$，N 是环境允许的最大鱼量。<br> 设捕鱼强度为 E，也就是单位时间捕鱼量为 $Ex$，记 $F(x) = f(x) - Ex$，则持续捕捞下，平衡的鱼量为 $x_0 = N(1 - \frac{E}{r})$<br> $x_0 \times E$ 求二次函数的最值，就是最大的持续捕捞量了，此时 $E = \dfrac{r}{2}$（好像和高中生物学的一样了）。<br> (其实和人口增长差不多)</li>
<li>效益模型</li>
<li>捕捞过度模型</li>
</ol>
<h4 id="战争模型"><a href="#战争模型" class="headerlink" title="战争模型"></a>战争模型</h4><p>「兰彻斯特平方定律」：作战部队的实力同投入战斗的士兵人数的平方成正比。</p>
<ol>
<li>正规战模型<br> 以 $x(t), y(t)$ 分别表示 t 时刻红军和蓝军的士兵人数，每队士兵的减员率和对方士兵的人数成正比，所以有方程 $\frac{\mathrm{d}x}{\mathrm{d}t} = -ay, \frac{\mathrm{d}y}{\mathrm{d}t} = -bx$，这两个式子相除，积分得到 $ay^2 - bx^2 = ay_0^{2} - bx_0^{2} = c$</li>
<li>混合战模型<br> 红军游击队，蓝军正规部队，但是游击队伍位于不易发现的有利位置，所以把红军的人员损失方程再乘一个 x，表示损失与自身规模大小有关。<br> $\frac{\mathrm{d}x}{\mathrm{d}t} = -cxy + f(t)$，f(t) 表示红军的增援情况。</li>
<li>游击战模型<br> 双方都是游击队伍。就都变成上个模型红军的方程形式。</li>
</ol>
<p>恩格尔(Engel)将第二次世界大战时美军和日军争夺硫磺岛所进行的战斗资料进行分析，发现与兰彻斯特作战数学模型非常吻合，这说明兰彻斯特作战数学模型是可以来描述实际战争的。</p>
<h4 id="对药物剂量开处方"><a href="#对药物剂量开处方" class="headerlink" title="对药物剂量开处方"></a>对药物剂量开处方</h4><h4 id="捕食者——食饵模型"><a href="#捕食者——食饵模型" class="headerlink" title="捕食者——食饵模型"></a>捕食者——食饵模型</h4><p>感觉和战争模型比较相似，不过这里的捕食者和被捕食者是会自然增长的（其实等价于战争模型中的援助）。</p>
<h4 id="微分方程的数值解"><a href="#微分方程的数值解" class="headerlink" title="微分方程的数值解"></a>微分方程的数值解</h4><p>很多方程往往复杂且大多数情况下求不出解析解，因而在实际生产和科研中，常常是求满足精度要求的近似解。</p>
<ol>
<li>欧拉方法</li>
<li>梯形方法</li>
<li>龙格-库塔方法</li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>组合优化与随机性模型</title>
    <url>/2023/08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>在有限个可行解集合中找出最优解，这类问题称为组合优化问题。如最短路径问题、最小连接问题、分配问题、运输问题、服务点设置问题、中国邮递员问题、背包问题、装箱问题等等。</p>
<p>贪心法和分支定界法是组合优化问题中常见的两种有效的方法。</p>
<h4 id="随机性模型"><a href="#随机性模型" class="headerlink" title="随机性模型"></a>随机性模型</h4><ol>
<li>报童问题<br> 一个分区间讨论收益的问题（可以抽象为类似的生产或者进货然后销售求最大收益的问题），下面的问题建模对于未出售完的报纸进行退回（可以抽象为低价处理）。<br> 设没份报纸的进价为 b，零售价为 a，退回价格为 c，报童应该如何购进报纸数量以获得最高的收入？ <img src="/2023/08/24/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%80%A7%E6%A8%A1%E5%9E%8B/%E6%8A%A5%E7%AB%A5%E9%97%AE%E9%A2%98.png" class="" title="收入和 n 的函数关系">
 假设需求量 r 的分布为 $P\{r = k\} = f(k), k = 0, 1, 2, …$<br> 但是注意到 G 是一个<strong>随机目标函数</strong>，求其最大值没有什么意义，我们转为求解其最大期望。<br> $\overline{G}(n) = \sum\limits_{r = 0}^{n}[(a - b)r - (b - c)(n - r)]f(r) + \sum\limits_{r = n + 1}^{+\infty} (a-b)nf(r)$，<strong>该问题很难求解，可以将上述函数进行连续化</strong>（数列求和和积分之间的转化使问题求解简单），可以得到 $\overline{G}(n) = \int_0^{n}[(a - b)r - (b - c)(n - r)]f(r)\mathrm{d}r + \int_{n + 1}^{+\infty} (a - b)nf(r)\mathrm{d}r$，所求问题变为 $\max \overline{G}(n)$，求导，导数为 0，得到 $\int_0^{n} f(r)\mathrm{d}r = \frac{a- b}{a - c}$ 的时候，期望收益最大。</li>
<li>轧钢中的浪费问题<br> 由于收到环境技术的影响，得到的钢材的长度是随机的，其数值上大体呈正态分布，均值可以通过调整轧机设定，而均方误差是由设备的精度决定的，不能随意改变。如果粗轧后的钢材长度大于规定长度，精轧时要把多余的部分切除，造成浪费；而如果粗轧后的钢材长度小于规定长度，则造成整根浪费。（一般我们不会利用多余的切除部分再次制作成钢材，因为实际生产中钢材长度 $l &gt;&gt; \sigma$）<br> 这样我们有模型总的平均浪费长度：<br> $W = \int_{l}^{+\infty} (x - l)f(x)\mathrm{d}x + \int_{-\infty}^{l} xf(x) \mathrm{d}x = \int_{-\infty}^{+\infty}xf(x)\mathrm{d}x - l\int_{-\infty}^{+\infty} f(x)\mathrm{d}x $<br> $ = E(X) - lP\{X &gt; l\} = m - lp$<br> 其中，$p = P\{X &gt; l\} = 1 - \Phi(\frac{l - m}{\sigma})$<br> 但是上式中，W 的含义是没轧一根钢材平均浪费的长度，这是从<strong>最终的产量分析浪费量</strong>；但是从实际中一个工厂的发展来看，工厂追求的是效益，可以由生产一根成品钢材浪费的平均长度来衡量，所以目标函数修改为：<br> $J = \frac{W}{P\{X &gt; l\}} = \frac{m - lp}{p}= \dfrac{m}{1 - \Phi(\frac{l - m}{\sigma}) - l}$，决策目标为 $\min J(m)$</li>
</ol>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>回归分析与时间序列方法</title>
    <url>/2023/08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>统计推断的另一类重要问题是假设检验问题。在总体的分布函数未知或者只知道其形式、但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对于所提出的假设做出是接受还是拒绝的决策，<strong>假设检验</strong>就是做出这一决策的过程。</p>
<p>这种只对于第一种错误的概率进行控制，而不考虑第二种错误的概率的检验，称为显著性检验。对应的还有双边假设检验、右边检验和左边检验。<br><img src="/2023/08/24/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%96%B9%E6%B3%95/%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C.png" class=""></p>
<h4 id="一元线性回归方程的检验"><a href="#一元线性回归方程的检验" class="headerlink" title="一元线性回归方程的检验"></a>一元线性回归方程的检验</h4><p>根据样本数据算出的回归可能有一定的抽样误差。为了考察这两个变量在同体内是否是存在线性关系以及回归方程对估计预测因变量的有效性如何，首先进行的就是显著性检验。</p>
<h5 id="t-检验"><a href="#t-检验" class="headerlink" title="t 检验"></a>t 检验</h5><p>t 检验又称学生 t 检验，是统计推断中一种非常常见的检验方法，<strong>用于统计量服从正态分布</strong>但是方差未知(如果知道方差，我们可以直接 Z 检验，或者叫做 U 检验，就是正态检验)的情况。</p>
<p>t检验的前提是要求样本服从正态分布或近似正态分布，不然可以利用一些变换（取对数、开根号、倒数等等）试图将其转化为服从正态分布是数据，如若还是不满足正态分布，只能利用非参数检验方法。</p>
<p>t 检验最常见的四个用途：</p>
<ol>
<li>单样本均值检验（One-sample t-test）<br> 用于检验 总体方差未知、正态数据或近似正态的 单样本的均值 是否与 已知的总体均值相等</li>
<li>两独立样本均值检验（Independent two-sample t-test）<br> 用于检验 两对独立的 正态数据或近似正态的 样本的均值 是否相等，这里可根据总体方差是否相等分类讨论</li>
<li>配对样本均值检验（Dependent t-test for paired samples）<br> 用于检验 一对配对样本的均值的差 是否等于某一个值</li>
<li>回归系数的显著性检验（t-test for regression coefficient significance）<br> 用于检验 回归模型的解释变量对被解释变量是否有显著影响</li>
</ol>
<p>具体内容见 <a href="https://zhuanlan.zhihu.com/p/138711532">https://zhuanlan.zhihu.com/p/138711532</a></p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵求导</title>
    <url>/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h4 id="向量变元的实值函数"><a href="#向量变元的实值函数" class="headerlink" title="向量变元的实值函数"></a>向量变元的实值函数</h4><p>单纯的对于<strong>向量</strong>求导和实数的求导大同小异，也是常数为 0，乘法有链式法则，除法的形式也是一样的。<br>其中有行向量形式和列向量形式（也叫做<strong>梯度向量形式</strong>，记作 $\nabla _{x}f(\boldsymbol{x})$）<br>然后就是几个比较重要的常见公式</p>
<h4 id="几个重要的向量变元求导公式"><a href="#几个重要的向量变元求导公式" class="headerlink" title="几个重要的向量变元求导公式"></a>几个重要的向量变元求导公式</h4><p>符合分子布局或者分母布局的形式(谁是列向量就是什么布局)</p>
<img src="/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC.png" class="" title="矩阵求导公式">
<h4 id="矩阵变元的实值函数"><a href="#矩阵变元的实值函数" class="headerlink" title="矩阵变元的实值函数"></a>矩阵变元的实值函数</h4><p>实值函数的求导其实还是比较容易理解的。对于矩阵变元无非是对于矩阵中每一个元素求导。<br>和对于向量变元的实值函数求导差不多，也是有着四个求导法则，分别对应常数、线性相加、乘法和商。</p>
<h4 id="几个重要的矩阵变元的求导公式"><a href="#几个重要的矩阵变元的求导公式" class="headerlink" title="几个重要的矩阵变元的求导公式"></a>几个重要的矩阵变元的求导公式</h4><img src="/2023/08/24/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/%E7%9F%A9%E9%98%B5%E5%8F%98%E5%85%83%E6%B1%82%E5%AF%BC%E5%85%AC%E5%BC%8F.png" class="" title="矩阵变元常用求导公式">
<h4 id="更详细证明了解链接"><a href="#更详细证明了解链接" class="headerlink" title="更详细证明了解链接"></a>更详细证明了解链接</h4><p>比较懒，贴几个链接，更深的内容可以看 <strong>矩阵分析</strong> 相关的书籍。<br><a href="https://www.zhihu.com/question/352174717/answer/1436808747">https://www.zhihu.com/question/352174717/answer/1436808747</a><br><a href="https://zhuanlan.zhihu.com/p/263777564">https://zhuanlan.zhihu.com/p/263777564</a><br><a href="https://zhuanlan.zhihu.com/p/273729929">https://zhuanlan.zhihu.com/p/273729929</a><br>讲解最小二乘法的高维形式 <a href="https://zhuanlan.zhihu.com/p/38128785">https://zhuanlan.zhihu.com/p/38128785</a></p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>插值与拟合建模</title>
    <url>/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<p>插值方法实数值分析中的一种古老而重要的方法。在实际生产和科学实验中，有时候仅仅能获得函数 f(x) 在若干点的函数值或者微商值，即只能给出 f(x) 的一张数据表。如果根据这张数据表构造一个函数 $\varphi(x)$ ，使之满足这张表中的数据，这样的函数 $\varphi(x)$ 就是函数 f(x) 的逼近函数。这种逼近问题称为插值问题。</p>
<h4 id="插值多项式的存在性和唯一性"><a href="#插值多项式的存在性和唯一性" class="headerlink" title="插值多项式的存在性和唯一性"></a>插值多项式的存在性和唯一性</h4><p>设 $p_n(x) = a_0 + a_1x + a_2x^{2} + … + a_nx^n$，由插值条件可以得到非齐次线性方程组：<br><img src="/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8F%92%E5%80%BC%E6%9D%A1%E4%BB%B6%E9%9D%9E%E9%BD%90%E6%AC%A1%E6%96%B9%E7%A8%8B%E7%BB%84.png" class="" title="插值条件非齐次方程组"><br>可以由 $\text{Vandermonde}$ 行列式，各个点是互异的来得到系数矩阵的行列式 $D \neq 0$。由 $\text{Cramer}$ 法则知道，方程有唯一的解，所以多项式存在且唯一。 </p>
<p><strong>几何解释：</strong> 一个 n 次的多项式一定可以由 n + 1 个点唯一确定。</p>
<h4 id="Lagrange-插值公式"><a href="#Lagrange-插值公式" class="headerlink" title="Lagrange 插值公式"></a>Lagrange 插值公式</h4><img src="/2023/08/25/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88%E5%BB%BA%E6%A8%A1/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%85%AC%E5%BC%8F.png" class="" title="拉格朗日插值公式">
<h4 id="Newton-插值公式"><a href="#Newton-插值公式" class="headerlink" title="Newton 插值公式"></a>Newton 插值公式</h4><p><a href="https://www.zhihu.com/question/22320408/answer/141973314">https://www.zhihu.com/question/22320408/answer/141973314</a> 马同学关于牛顿插值的解释<br>牛顿插值法的特点在于：每增加一个点，不会导致之前的重新计算，只需要算和新增点有关的就可以了（这里不同于拉格朗日插值法）。</p>
<h4 id="两种插值的比较"><a href="#两种插值的比较" class="headerlink" title="两种插值的比较"></a>两种插值的比较</h4><p>也不是很懂，给出 ChatGPT 的解释</p>
<ol>
<li><p>数值稳定性： 牛顿插值通常在数值上更稳定，特别是在高次插值中。高次的拉格朗日插值多项式的系数可能会变得非常大，导致数值计算问题，这在计算机中可能会引发数值溢出或不稳定性。牛顿插值使用分裂差分形式，这种形式在数值计算上通常更可靠。</p>
</li>
<li><p>数据更新效率： 如果您需要在运行时动态添加新的数据点并更新插值多项式，牛顿插值更为高效。因为在牛顿插值中，您可以通过添加一个新的数据点来更新插值多项式，而不需要重新计算整个多项式。</p>
</li>
<li><p>分布不均匀的数据： 如果您的数据点分布不均匀，拉格朗日插值可能会导致插值多项式的阶数变得非常高，这会增加计算的复杂性和开销。牛顿插值在这种情况下通常更具优势。</p>
</li>
</ol>
<p>然而，需要注意的是，即使在大数据集的情况下，牛顿插值也不是绝对适用的。在一些特定情况下，如数据点的数量非常大或插值多项式的次数非常高，都可能导致数值计算问题。在这种情况下，考虑使用更高级的插值技术，例如分段插值（如样条插值）或基于快速傅里叶变换的方法，以提高数值稳定性和计算效率。选择合适的插值方法需要综合考虑数据的性质、计算需求和数值稳定性。</p>
<h4 id="三次样条插值函数"><a href="#三次样条插值函数" class="headerlink" title="三次样条插值函数"></a>三次样条插值函数</h4><p>三次样条插值在科学和工程计算中起到重要作用，它只在插值区间的断点比 Lagrange 插值多两个边界条件，但是却在内节点处二阶导数连续。<br>样条一词来源于工程制图。绘图员为了将一些指定点（称作样点）连接成一条光滑的曲线，往往把富有弹性的细长木条（称为样条）固定在样点上，然后画下木条表示的曲线所形成的样条曲线。</p>
<p>有三种边界条件：</p>
<ol>
<li>自然边界(Natural Spline) 指端点处二阶导数为 0.</li>
<li>固定边界(Clamped Spline) 指定端点一阶导数，这里分别定为 A 和 B，即 $S_0’(x_0) = A, S_{n - 1}^{x_n} = B$</li>
<li>非扭结边界(Not-A-Knot Spline) 强制第一个插值点的三阶导数等于第二个点的三阶导数，最后一个点的三阶导数等于倒数第二个点的三阶导数。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/62860859?utm_medium=social&amp;utm_oi=1127691903852081152&amp;utm_psn=1678405306240057344&amp;utm_source=qq">https://zhuanlan.zhihu.com/p/62860859?utm_medium=social&amp;utm_oi=1127691903852081152&amp;utm_psn=1678405306240057344&amp;utm_source=qq</a> 关于三次样条的具体推导和最终求解矩阵方程。</p>
<h4 id="最小二乘法拟合"><a href="#最小二乘法拟合" class="headerlink" title="最小二乘法拟合"></a>最小二乘法拟合</h4><p>$r_i = y_i - \varphi(x_i)$ 称为残量，$\boldsymbol{r} = (r_0, r_1, …, r_m)^{T}$ 称为<strong>残向量</strong>。所以用 $\varphi(x)$ 去拟合 $f(x)$ 的问题就变成了残量的大小问题。<br>我们用 $\sum\limits_{i = 0}^{m} r_i^{2} = \boldsymbol{r^{T}}\boldsymbol{r}$ 去度量残量的大小。<br>后面的具体推导可以参考：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/128083562">https://zhuanlan.zhihu.com/p/128083562</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109986821">https://zhuanlan.zhihu.com/p/109986821</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38128785">https://zhuanlan.zhihu.com/p/38128785</a></li>
</ol>
<p>最终结果就是参数向量 $\widehat{w} = \boldsymbol{(X^{T}X)^{-1}X^{T}Y}$</p>
<p>内积表示？？？</p>
<h4 id="最佳平方逼近"><a href="#最佳平方逼近" class="headerlink" title="最佳平方逼近"></a>最佳平方逼近</h4>]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>现代优化算法</title>
    <url>/2023/08/25/%E7%8E%B0%E4%BB%A3%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>20 世纪 70 年代初期，随着计算复杂性的理论逐步形成，科学工作者发现并证明了大量来源于实际生活中的组合最优化问题是非常难解的，即所谓的 NP 完全问题和 NP 难问题。<br>80 年代一些现代化优化算法，如遗传算法、模拟退火算法、人工神经网络算法等。这些算法可以比较容易的解决一些复杂的、常规算法很难解决的问题。</p>
<h4 id="遗传算法-Genetic-Algorithm-GA"><a href="#遗传算法-Genetic-Algorithm-GA" class="headerlink" title="遗传算法(Genetic Algorithm, GA)"></a>遗传算法(Genetic Algorithm, GA)</h4>]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>决策分析方法</title>
    <url>/2023/08/25/%E5%86%B3%E7%AD%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>策略集、状态集和溢损函数是构成一个决策问题的三项最基本要素。</p>
<h4 id="风险型决策"><a href="#风险型决策" class="headerlink" title="风险型决策"></a>风险型决策</h4><p>风险型决策也称作随机决策，是在状态概率已知的条件下进行的决策。</p>
<h5 id="最大可能准则"><a href="#最大可能准则" class="headerlink" title="最大可能准则"></a>最大可能准则</h5><p>在若干种自然状态发生的概率相差很大，而相对应的益损值又相差不大时，这种决策准则效果较好。但是如果若干种自然状态发生的概率都很小，而且相互很接近时，使用这种决策准则的效果不会好，甚至会引起很严重的错误。</p>
<h5 id="期望值准则"><a href="#期望值准则" class="headerlink" title="期望值准则"></a>期望值准则</h5><p>期望值准则就是选择期望益损值最大（或者最小）的方案作为最优方案。</p>
<h4 id="决策树法"><a href="#决策树法" class="headerlink" title="决策树法"></a>决策树法</h4><p>采用决策树法的步骤：</p>
<ol>
<li>画出决策树。一般是从左往右画，先画出决策点，再画出由决策点引起的方案分支。</li>
<li>计算方案的期望益损值。</li>
<li>根据期望益损值进行决策，将期望益损值小的舍去，而期望益损值大的方案则保留，这就是最优策略。</li>
</ol>
<h4 id="不确定型决策"><a href="#不确定型决策" class="headerlink" title="不确定型决策"></a>不确定型决策</h4><p>不确定型决策是在只有几种自然状态可能发生，但是这些状态发生的概率并不知道时做出的决策。<br>由于不确定型问题不知道状态的概率，所以无法计算每种方案的益损值，于是这类问题在理论上没有一个最优决策准则提供决策者决策，它存在着几种不同的决策分析方法，每种都有合理性。</p>
<h5 id="乐观准则"><a href="#乐观准则" class="headerlink" title="乐观准则"></a>乐观准则</h5><p>从最乐观状态出发，每种方案都按照最有利状态来考虑。$R^{*} = \max\limits_i \{\max\limits_j r_{ij}\}$</p>
<h5 id="悲观准则"><a href="#悲观准则" class="headerlink" title="悲观准则"></a>悲观准则</h5><p>从最悲观的观点出发对每个方案按最不利的状态来考虑，然后从中选取最优方案。$R^{*} = \max\limits_{i} \{\min\limits_{j} r_{ij}\}$</p>
<h5 id="折衷准则"><a href="#折衷准则" class="headerlink" title="折衷准则"></a>折衷准则</h5><p>引入一个表达乐观程度的乐观系数。$R^{*} = \max\limits_i \{\lambda \max\limits_j r_{ij} +(1 - \lambda) \min\limits_{j} r_{ij}\}$</p>
<h5 id="等可能准则"><a href="#等可能准则" class="headerlink" title="等可能准则"></a>等可能准则</h5><p>假定每种自然状态发生的概率总是相同的。</p>
<h5 id="后悔值准则"><a href="#后悔值准则" class="headerlink" title="后悔值准则"></a>后悔值准则</h5><p>后悔值准则是从后悔值考虑，希望能找到一个这样的策略，以使在实施这个策略时能产生较少的后悔。所谓后悔就是指每种状态下最大收益值与此状态下其他益损值之差。在所有方案的最大后悔值中选最小者，此时对应的方案为最优策略。 $R^{*}  =\min\limits_{i} \{\max\limits_{j} RV_{ij}\}$，其中 $RV_{ij} = \max\limits_{i} r_{ij} - r_{ij}$</p>
<h4 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h4><p>层次分析法是对一些较为复杂、模糊的问题做出决策的多准则决策方法，它特别适用于难以完全定量分析的问题。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab记录</title>
    <url>/2023/08/26/matlab%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/matlab%E7%82%B9%E4%B9%98%E7%82%B9%E9%99%A4.png" class="">
<p>x:y:z 一般表示 x 初值 y 步长 z 终值</p>
<p>if - end 和 if - else - end</p>
<p>x(i) 访问 x 数组中下标为 i 的元素</p>
<p>meshgrid 函数是MATLAB中用于生成网格采样点数的函数，通常进行2D、3D图形的绘制。<br><img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/meshgrid%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC.png" class=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = -10:0.5:10;</span><br><span class="line">y = -10:0.5:10;</span><br><span class="line">[xx, yy] = meshgrid(x, y);</span><br><span class="line">z = xx .^2 - yy .^2;</span><br><span class="line">mesh(xx, yy, z);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://blog.csdn.net/qq_54186956/article/details/127274462">https://blog.csdn.net/qq_54186956/article/details/127274462</a> sym syms 函数应用</p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/subs%E5%87%BD%E6%95%B0.png" class="">
<p>在命令行输入 <code>format rat</code> 后，输出为分数格式，不再约成小数。</p>
<p>在命令行输入 <code>doc xxx</code> 可以直接查看官方解释 <code>xxx</code> 函数的文档。</p>
<p><code>num2str(xxx)</code> 其中 xxx 是一个数，转换一个行向量，每个字符代表向量的一个元素</p>
<p><code>result = [s1, s2]</code> 进行字符串拼接</p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C.jpg" class="">
<p>提取矩阵的行数：$length(A(:,1))$<br>提取矩阵的列数：$length(A(1,:))$</p>
<p>matlab 中读取图片和显示图片函数 <code>imread</code> 和 <code>imshow</code> <a href="https://blog.csdn.net/dp327264/article/details/105087849">https://blog.csdn.net/dp327264/article/details/105087849</a></p>
<p><code>subplot</code> 函数是将多个图片画到一个画面上的工具 <code>subplot(m,n,p)</code> 表示 m 行 n 列从左到右 从上到下第 p 个</p>
<p>灰度图像二值化：图像二值化（ Image Binarization）就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的黑白效果的过程。<br>在数字图像处理中，二值图像占有非常重要的地位，图像的二值化使图像中数据量大为减少，从而能凸显出目标的轮廓。</p>
<p>matlab 中关于数字图像处理的工具箱是 IPT(Image Processing Toolbox) </p>
<img src="/2023/08/26/matlab%E8%AE%B0%E5%BD%95/%E7%81%B0%E5%BA%A6%E5%9B%BE.png" class="">
<p>对于汉字处理的话，灰度图会引入误差，所我们转化为二值图。</p>
<p><code>find(xx)</code> 函数可以返回满足 xx 条件的下标组成的行向量。<br>例如 <code>x=[1 2 3 4 5 6 7]; find(x &gt;= 5)</code> 返回的就是：<code>5     6     7</code></p>
<p><code>max(A)</code> A 可以是矩阵或者向量，就是返回其中最大的元素</p>
<p>元组是matlab的数据类型之一，其元胞中可存储文本，数值，矩阵等等不同的数据类型，因此应用较为方便。因此，在采用matlab进行数据处理时，对元组的创建、读取、写入、转化函数的掌握尤为重要。<br><code>cell(dim)</code> 是创建 dim$\times$dim维的空元组，下标必须是正整数，不能是 0.</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>规划论模型</title>
    <url>/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>规划论模型也成为运筹与优化模型，在实际问题的建模中应用最为广泛，涉及面较广。</p>
<h4 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h4><p>通常对于只有两个决策变量的情形，可以使用图解法加以求解。而对于大于两个决策变量的情形，需要借助单纯形方法加以求解。单纯形方法的基本思想是迭代思想的一种体现。首先找到初始可行解，并通过迭代逐步从可行域的一个顶点走向另一个顶点，最终走到最优解。<br><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/linprog.png" class=""><br>下面的例题：<br><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/problem1.jpg" class=""><br>其中，求 max，所以我们把 z 的系数取反。第二个不等式是大于等于，我们也同样取反。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-1; -2; 3];</span><br><span class="line">A = [3 2 1; -4 -7 6];</span><br><span class="line">b = [6; -8];</span><br><span class="line">Aeq = [2 1 5];</span><br><span class="line">beq = [4];</span><br><span class="line">vlb = [0; 0; 0];</span><br><span class="line">vub= [];</span><br><span class="line">[x, fval] = linprog(f, A, b, Aeq, beq, vlb, vub)</span><br></pre></td></tr></table></figure></p>
<h5 id="运输问题"><a href="#运输问题" class="headerlink" title="运输问题"></a>运输问题</h5><p>较为常见的运输模型叙述如下：</p>
<blockquote>
<p>某物资有 m 个原产地 $A_i$，产量为 $a_i$；有 n 个销地 $B_j$，销量关系为 $b_j$，从 $A_i$ 到 $B_j$ 之间的单位物资运价为 $d_{ij}$，则产销平衡时有 $\sum\limits_{i = 1}^{m}a_i = \sum\limits_{j = 1}^{n} b_j$</p>
</blockquote>
<h5 id="多目标规划问题"><a href="#多目标规划问题" class="headerlink" title="多目标规划问题"></a>多目标规划问题</h5><p>在建立优化模型时有时追求的目标可能是多个，无论忽略其中的哪个因素可能都会降低优化结果的可信度。对于这类问题通常有下面的三种处理方式：</p>
<ol>
<li>为每个目标设置重要性权重。<br> 当存在 n 个目标时，首先对目标函数进行归一化处理（就是消除量纲的影响，进行标准统一）后分别设置自己的权重，假设第 i 个目标的权重为 $\alpha_i$，目标取值为 $M_i$，则可以建立下面的优化模型：$\max \alpha_1M_1 + \alpha_2M_2 + … + \alpha_nM_n$</li>
<li>为各种目标设定优先权，并将模型转化为多个优化模型。</li>
<li>分别求得个目标的最优值后，将主要目标设定为目标函数，而将次要目标适当调整后修改为约束条件。</li>
</ol>
<h4 id="适度指标的线性处理"><a href="#适度指标的线性处理" class="headerlink" title="适度指标的线性处理"></a>适度指标的线性处理</h4><p>适度指标是指该指标的他正是数据大了或者小了均不好，要充分地接近于某一事先给定的标准指标，比如水的 PH 值。<br>求 $\min |x - D|$，D 为数据指标的理想取值。<br>例题：<br>一个富豪准备拿 10 万元买股票。经过他的筛选，有三种候选投资股票。这三种股票的价格、收益率以及风险系数如表所示：<br><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E8%82%A1%E7%A5%A8.png" class=""><br>这是一个多规划问题，我们如果直接列两个不等式的话，可能存在无解的情况。所以我们可以采取上面所说的方法2，建立如下的两个不等式条件：<br><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E7%AD%89%E5%BC%8F.png" class=""><br>如果我们优先考虑投资的风险，就可以建立下面的线性规划模型：<br><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B.png" class=""><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear all</span><br><span class="line">Aeq = [1 3 5 1 -1 0 0; 2 5 8 0 0 1 -1; 10 20 30 0 0 0 0];</span><br><span class="line">beq = [15000; 25000; 100000];</span><br><span class="line">f = zeros(7, 1);</span><br><span class="line">f(5) = 1;</span><br><span class="line">vlb = zeros(7, 1);</span><br><span class="line">vub = [];</span><br><span class="line">a = [];</span><br><span class="line">b = [];</span><br><span class="line">[x, y] = linprog(f, a, b, Aeq, beq, vlb, vub);</span><br><span class="line">fx = x(1) + 3 * x(2) + 5 * x(3)</span><br><span class="line">lr = 2 * x(1) + 5 * x(2) + 8 * x(3)</span><br></pre></td></tr></table></figure></p>
<h4 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h4><p>在线性规划模型中，如果各个决策变量的取值均为整数，则称此类模型为整数规划模型。<br>整数规划的解法主要有穷举法(变量维数较高时不可行)、舍入凑整法、分支定界法(比较可行)、割平面法(比较可行)等。</p>
<ol>
<li>舍入凑整法<br> 感觉很是玄学，就是假装没有整数约束，求解出最优解后每个变量往下或者上取整比较一下。</li>
<li>分支界定法<br> 如果不满足整数条件，任选一个不满足整数条件的变量来构造新的约束，在原可行域中剔除部分非整数解。然后，再在缩小的可行域中求解新构造的线性规划的最优解（好抽象）。<br> 步骤：<ol>
<li>解没有整数约束的问题。</li>
<li>定界</li>
<li>分支</li>
<li>修改上下界</li>
<li>比较与剪枝</li>
</ol>
</li>
</ol>
<h5 id="0-1-型整数规划"><a href="#0-1-型整数规划" class="headerlink" title="0-1 型整数规划"></a>0-1 型整数规划</h5><p>约束条件为 $0 \leq x_i \leq 1,x_i$ 为整数。这样就和一般的整数规划问题统一了。 </p>
<img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92.png" class="" title="整数规划求解函数">
<p>实例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = [-3; 2; -5];</span><br><span class="line">intcon = [1, 2, 3]; % 表示哪几个变量为整数</span><br><span class="line">A = [1 2 -1; 1 4 1; 1 1 0; 4 0 1];</span><br><span class="line">b = [2; 4; 3; 6];</span><br><span class="line">Aeq = [];</span><br><span class="line">beq = [];</span><br><span class="line">lb = [0; 0; 0]; % 如果下界为 0 上界为 1，其实就是 0-1 整数规划了。</span><br><span class="line">rb = [1; 1; 1];</span><br><span class="line">[x, val] = intlinprog(f, intcon, A, b, Aeq, beq, lb, rb)</span><br></pre></td></tr></table></figure></p>
<h5 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h5><img src="/2023/08/26/%E8%A7%84%E5%88%92%E8%AE%BA%E6%A8%A1%E5%9E%8B/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98.png" class="" title="指派问题">
<p>当人数和任务的个数不同的时候，会出现某些人没有任务可做或者某些任务无人完成的情况。出现这两种情况的时候只需将约束条件中的某一个等于 1 的约束条件修改为小于等于 1 即可。有时也可以一对多（一个人多任务，一个任务多个人）。<br>2013 年碎纸片拼接复原问题 1：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cell&#123;1,1&#125;=imread(&#x27;000.bmp&#x27;);</span><br><span class="line">cell&#123;1,2&#125;=imread(&#x27;001.bmp&#x27;);</span><br><span class="line">cell&#123;1,3&#125;=imread(&#x27;002.bmp&#x27;);</span><br><span class="line">cell&#123;1,4&#125;=imread(&#x27;003.bmp&#x27;);</span><br><span class="line">cell&#123;1,5&#125;=imread(&#x27;004.bmp&#x27;);</span><br><span class="line">cell&#123;1,6&#125;=imread(&#x27;005.bmp&#x27;);</span><br><span class="line">cell&#123;1,7&#125;=imread(&#x27;006.bmp&#x27;);</span><br><span class="line">cell&#123;1,8&#125;=imread(&#x27;007.bmp&#x27;);</span><br><span class="line">cell&#123;1,9&#125;=imread(&#x27;008.bmp&#x27;);</span><br><span class="line">cell&#123;1,10&#125;=imread(&#x27;009.bmp&#x27;);</span><br><span class="line">cell&#123;1,11&#125;=imread(&#x27;010.bmp&#x27;);</span><br><span class="line">cell&#123;1,12&#125;=imread(&#x27;011.bmp&#x27;);</span><br><span class="line">cell&#123;1,13&#125;=imread(&#x27;012.bmp&#x27;);</span><br><span class="line">cell&#123;1,14&#125;=imread(&#x27;013.bmp&#x27;);</span><br><span class="line">cell&#123;1,15&#125;=imread(&#x27;014.bmp&#x27;);</span><br><span class="line">cell&#123;1,16&#125;=imread(&#x27;015.bmp&#x27;);</span><br><span class="line">cell&#123;1,17&#125;=imread(&#x27;016.bmp&#x27;);</span><br><span class="line">cell&#123;1,18&#125;=imread(&#x27;017.bmp&#x27;);</span><br><span class="line">cell&#123;1,19&#125;=imread(&#x27;018.bmp&#x27;);</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">level=graythresh(cell&#123;1,i&#125;);%选择灰度阈值</span><br><span class="line">cell1&#123;1,i&#125;=im2bw(cell&#123;1,i&#125;,level); %将图像二值化</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19                %循环19个图像</span><br><span class="line">    for k=1:19</span><br><span class="line">        xs(i,k)=0;</span><br><span class="line">        for j=1:1980</span><br><span class="line">            if (cell1&#123;1,i&#125;(j,72)==cell1&#123;1,k&#125;(j,1))%判断图像的边缘信息特征，求相似度矩阵</span><br><span class="line">                xs(i,k)=1+xs(i,k);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19</span><br><span class="line">    xs(i,i)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i=1:19 </span><br><span class="line">da(i)=max(xs(i,:));</span><br><span class="line">end</span><br><span class="line">wei=find(da==max(da));for i=1:19</span><br><span class="line">    k=find(xs(i,[1:19])==da(i));  %求两两相邻的矩阵</span><br><span class="line">    lian(i,1)=i;                  %前面一个</span><br><span class="line">    lian(i,2)=k;                  %后面一个</span><br><span class="line">end</span><br><span class="line">lian(wei,1)=0;</span><br><span class="line">tou=lian(wei,2);</span><br><span class="line">xu(1)=tou;</span><br><span class="line">for i=1:18</span><br><span class="line">    xu(i+1)=lian(xu(i),2);        %正确的排列顺序</span><br><span class="line">end</span><br><span class="line">%根据排出来顺序xu画图</span><br><span class="line">for i=1:19</span><br><span class="line">I(:,[72*(i-1)+1:72*i])=cell&#123;1,xu(i)&#125;;   %图像的整合</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">imwrite(I,&#x27;hanzi.jpg&#x27;,&#x27;quality&#x27;,100);</span><br><span class="line">imshow(&#x27;hanzi.jpg&#x27;)          %输出图像</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="选址问题"><a href="#选址问题" class="headerlink" title="选址问题"></a>选址问题</h5><p>集合覆盖选址模型和最大覆盖选址模型。</p>
]]></content>
      <tags>
        <tag>Mathematic</tag>
      </tags>
  </entry>
  <entry>
    <title>python 数学建模与实验</title>
    <url>/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>虽然列表 list 可以完成数组操作，但不是真正意义上的数组，当数据量很大时，其速度很慢，故提供了 NumPy 扩展库完成数组操作。很多高级扩展库也依赖于它，比如 Scipy, Pandas 和 Matplotlib 等。</p>
<p>数组创建的几种方式：<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA.png" class=""></p>
<p>NumPy 中的数组 array 和 list 的区别是：列表中可以是数据类型不同的元素，而 array 数组只允许存储相同数据类型。</p>
<p>二维数组中的索引 list 为 a[i][j] 而 array 为 a[i, j]</p>
<p>一般索引：<br>感觉有的地方还是和 matlab 很相似的。<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%B8%80%E8%88%AC%E7%B4%A2%E5%BC%95.png" class=""></p>
<p>文本文件读取：<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E6%9C%AC%E8%AF%BB%E5%8F%96.png" class=""><br>二进制文件读取：<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96.png" class=""><br>另外，如果我们使用 NumPy 专用的二进制存取函数 <code>load() save() savez()</code> 会自动处理元素的类型和形状等信息。</p>
<p>open 打开文件的时候，如果打开的文件不在当前的目录，需要指定完整路径。注意，此时文件路径中的 <code>\</code> 要改为 <code>\\</code>，例如 <code>e:\mypython\test.txt</code> 应该改为 <code>e:\\mypython\\test.txt</code>.<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F.png" class=""></p>
<p>join 函数：<br><img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/join%E5%87%BD%E6%95%B0.png" class=""></p>
<h4 id="数据处理工具-Pandas"><a href="#数据处理工具-Pandas" class="headerlink" title="数据处理工具 Pandas"></a>数据处理工具 Pandas</h4><p>Pandas(Panel data, 面板数据) 是在 NumPy 的基础上开发的，是 Python 最强大的数据分析和探索工具之一。</p>
<h4 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h4><p>Matplotib 是 Python 强大的数据可视化工具，类似于 MATLAB 语言。</p>
<p>pie 绘制饼状图 bar 绘制柱状图 hist 绘制二维直方图 scatter 绘制散点图</p>
<img src="/2023/08/28/python-%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%AE%9E%E9%AA%8C/%E5%B8%B8%E8%A7%81%E6%A0%B7%E5%BC%8F%E9%A2%9C%E8%89%B2.png" class="">
<h4 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h4><p>scipy 包含各种专用于科学计算常见问题的工具箱。其中 scipy.stats 则是统计和随机数的专门的库。<br>NumPy 能生成一定概率分布的随机数，但是如果需要更具体的概率密度、分布函数等，就用到 scipy.stats 模块了。Python 做简单的统计分析也可以用 scipy.stats 模块。</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>变量的声明就是 <code>var name = xxx;</code>。其中 <code>var</code> 是 <code>variable</code> 的缩写（虽然和方差 variance 的缩写一样）。</p>
<p>在 JS 中使用 {} 来分块，同一个 {} 中的语句我们称之为一组语句，它们要么都执行，要么都不执行。</p>
<p>其实函数也是一个对象，可以如下定义一个函数：<code>f = new Function(&quot;console.log(&#39;this is a function. &#39;)&quot;)</code>。但是一般不这么使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;lys&#x27;,</span><br><span class="line">    age: 19,</span><br><span class="line">    address: &#x27;SDU&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj) &#123;</span><br><span class="line">    console.log(x); // 这样只是枚举的对象中的元素名字</span><br><span class="line">&#125;</span><br><span class="line">for (var x in obj)&#123;</span><br><span class="line">    console.log(obj[x]); // 不能直接 obj.x 来获得具体元素，应用 [] 的引用方式。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组创建 <code>var arr = new Array()</code> 或者 <code>var arr = []</code>。但是一般不使用 <code>new Array()</code> 的创建方式。并且数组中的元素类型也是不一定的，不一定非要是 Number 类型的。<br>其实数组也是一个对象，只不过索引方式是 []，所以对象有的东西数组也有。</p>
<p>数组既然是对象，就有方法，在 JS 中数组有一些常用的方法：</p>
<ol>
<li><code>push()</code> 向数组末尾添加一个或者多个元素，并且返回新的数组的长度。</li>
<li><code>pop()</code> 从数组末尾删除一个元素，并且返回删除的元素。</li>
<li><code>unshift()</code> 向数组的<strong>开头</strong>添加一个或者多个元素，并且返回新的数组的长度。</li>
<li><code>shift()</code> 从数组开头删除一个元素，并且返回删除的元素。</li>
<li><code>join()</code> 将所有的元素连接成一个字符串。</li>
<li><code>slice()</code> 返回数组的一部分，不修改原数组。</li>
</ol>
<p>建立函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function xxx() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是构造函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var person = new Person();</span><br></pre></td></tr></table></figure><br>如果不写前面的 function 直接 new，会出现错误。</p>
<p>arr.forEach(xx) 中间 xx 都要传递一个函数，如果之前定义了 <code>function fun() &#123;&#125;</code> 就写为 <code>arr.forEach(fun)</code>，但是一般不这样，一般都是用匿名函数。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">arr.forEach(function(a, b, c) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>上面就是输出 a，遍历的时候会将 arr 中的元素传递给 function。<br>会传递三个参数，第一个是数组当前遍历到元素 value，第二个是当前遍历到的索引 index，第三个是正在遍历的数组。</p>
<p>函数在调用的时候，浏览器会向里面传递两个隐含的参数</p>
<ol>
<li>上下文对象的 this</li>
<li>封装实参的类数组对象 arguments，在调用函数的时候，我们所传递的实参都会在 arguments 中保存。</li>
</ol>
<p>在 JS 中，对象有 3 类<br><img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E5%AF%B9%E8%B1%A1.png" class=""><br>DOM Document Object Model<br>JS 通过 DOM 对于 HTML 文档进行操作，只要理解了 DOM，就可以随心所欲操作 WEB 页面。</p>
<p>节点 Node 是构成 HTML 文档的最基本的单元，常用节点分为四类</p>
<ul>
<li>文档节点 整个 HTML 文档</li>
<li>元素节点 HTML 文档中的 HTML 标签</li>
<li>属性节点 元素的属性</li>
<li>文本节点 HTML 标签中的文本<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9.png" class="">
</li>
</ul>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8A%82%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7.png" class="">
<p>上面的三个属性是每一个节点都有的三个属性。</p>
<p>innerHTML 可以获得到文字</p>
<p>事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。JavaScript 与 HTML 之间的交互是通过事件实现的。比如对于 Web 应用来说，有下面一些有代表性的事件：点击某个元素、将鼠标移动至某个元素上方、按下键盘上某个键等等。</p>
<p><code>onload</code> 事件会在整个页面加载完成之后发生。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.onload= function() &#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这一段代码是页面加载完成之后执行的。</p>
<p>标签就是元素，元素就是标签。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E8%8A%82%E7%82%B9.png" class="">
<p>innerHTML 对于「自结束标签」没有意义。如：<br><img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%87%AA%E7%BB%93%E6%9D%9F%E6%A0%87%E7%AD%BE.png" class=""><br>如果想读取元素的属性，直接 <code>元素.属性名</code>。但是读取元素的 <code>class</code> 属性的时候不能直接 <code>元素.class</code> 因为 class 是 JS 中的保留字，应该写为 <code>元素.className</code></p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%9F%A5%E6%89%BE%E5%AD%90%E8%8A%82%E7%82%B9.png" class="">
<p>但是 <code>childNodes</code> 有个缺陷，此时如果我们使用 <code>children</code> 就不会出现这种问题了，它返回的是当前元素的所有子元素。<br><img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/childnodes%E7%BC%BA%E9%99%B7.png" class=""></p>
<p><code>innerText</code> 和 <code>innerHTML</code> 类似，但是 <code>innerText</code> 获取的会将 html 标签去除。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E8%8E%B7%E5%8F%96%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9.png" class="">
<p><code>getElementsByName()</code> 一般用来操作一些表单项目。 </p>
<p>获取 <code>body</code> 标签的话有两种方式：</p>
<ol>
<li><code>var body = document.getElementsByTagName()[0];</code> 因为 <code>getElementsByTagName()</code> 返回的是一个集合 <code>Collection</code>，但是我们又只有一个 <code>body</code>，所以直接返回索引 0 就可以了。</li>
<li>其实在 <code>document</code> 中就有一个属性 <code>body</code>，我们直接 <code>var body = document.body;</code> 就可以了。</li>
</ol>
<p><code>html</code> 元素是 <code>document.documentElement;</code></p>
<p><code>document.all</code> 代表的是页面的所有元素。也可以写成 <code>document.getElementsByTagName(&quot;*&quot;)</code></p>
<p><code>document.getElementsByClassName();</code> 可以根据元素的 <code>class</code> 属性值获取一组节点对象。</p>
<p><code>document.querySelector();</code> 需要一个选择器字符串作为参数，可以根据一个 CSS 选择器来查询一个元素节点对象。但是使用这个方法只会返回唯一的一个元素，如果满足条件的元素有多个，但是只会返回第一个。如果需要多个就使用 <code>document.querySelectorAll();</code></p>
<p><code>父节点.insertBefore(新节点, 旧节点)</code> 是在旧节点前面添加新节点。</p>
<p>超链接点击以后会默认跳转页面，如果我们不希望出现此默认行为，我们可以在超链接的 <code>onclick = function() &#123;&#125;</code> 中写上 <code>return false;</code></p>
<p><code>confirm()</code> 函数会弹出一个带有确定和取消两个按键的提示框，并且如果我们点击确定，会返回 true，如果点击取消，会返回 false。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" class="">
<p>一个比较细节容易忽视的点，直观上我们认为 this 和 allA[i] 是一样的。<br>图中，我们的 <code>onclick = function() &#123;&#125;</code> 可以认为只是函数之间的一个赋值，里面的内容并没有执行。只有我们在点击按钮的时候，<code>function</code> 里面的内容才会执行。如果我们 <code>function</code> 里面使用 <code>allA[i]</code>，等到我们点击的时候 for 循环早就已经执行完毕，此时的 i 必然是 all 的length，所以就会出现错误。我们正确的做法应该是将 function 里面的 allA[i] 改为 this。</p>
<p>通过 JS 修改元素的样式：<code>元素.style.样式名 = 样式值</code> 其中样式值需要是一个字符串。<br>注意，如果 CSS 样式名称中含有 <code>-</code>，如 <code>background-color</code> 这种命名在 JS 中是不合法的，我们需要将这种命名改为驼峰命名法，去掉 <code>-</code>，然后将 <code>-</code> 的字母大写。</p>
<p>通过 JS 的 style 修改的往往是内联样式，而内联样式有较高的优先级，所以通过 JS 修改的样式往往会立即显示。</p>
<p>事件对象：<br>当事件的响应函数被触发的时候，浏览器每次会将一个事件对象作为实参传递进响应函数。在事件对象中封装了当前关于事件的一切信息，比如鼠标的坐标、键盘的哪一个按键被按下、鼠标滚轮的移动方向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a title.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                document.onmousemove = function(event) &#123;</span><br><span class="line">                    var clientX = event.clientX;</span><br><span class="line">                    var clientY = event.clientY;</span><br><span class="line">                    box1.style.left = clientX + &quot;px&quot;;</span><br><span class="line">                    box1.style.top = clientY + &quot;px&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;box id=&quot;box1&quot;&gt;&lt;/box&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><code>clientX</code> 和 <code>clientY</code> 是用于我们鼠标在当前可见窗口的坐标，所以对于有滚动条的窗口的话可能会出现一些错误。所以我们这时候使用 <code>pageX</code> 和 <code>pageY</code> 这两和属性是相对于整个页面的。</p>
<img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/document%E5%92%8Cwindow.png" class="">
<p>事件的冒泡(bubble)<br>所谓事件的冒泡就是事件的想上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发。在开发中，大部分情况冒泡是有用的，如果不希望发生事件冒泡可以通过事件对象来取消冒泡。<br><code>event.cancelBubble = true;</code></p>
<p>我们希望只绑定一次事件，即可应用到多个元素之上，即使元素是后来添加的。我们可以尝试将元素绑定给其共同的祖先元素。然后通过冒泡来实现事件的发生。这其实就是事件的「委派」。</p>
<p><code>document.getElementsByTagName();</code> 返回的不是一个数组（一个NodeList对象，指定标签名的集合 collection），虽然我们可以遍历，它也有长度。</p>
<p>点击超链接时会自动默认跳转，我们把超链接的 <code>href</code> 修改为 <code>javascript:;</code> 就不会发生跳转了。</p>
<p>事件给谁绑定的，function 中的 this 就是谁。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ul.onclick = function() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">    alert(&quot;我是一个响应函数。&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>像这一个，第一个 <code>alert</code> 输出的就是 <code>[object HTMLUListElement]</code>。<br>但是事件绑定对象不等于事件触发对象，我们如果想要获得事件<strong>触发对象</strong>需要使用 <code>event.target</code> 属性。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;this is a test.&lt;/title&gt;</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var btn1 = document.getElementById(&quot;btn1&quot;);</span><br><span class="line">                var ul = document.getElementsByTagName(&quot;ul&quot;)[0];</span><br><span class="line">                btn1.onclick = function() &#123;</span><br><span class="line">                    var li = document.createElement(&quot;li&quot;);</span><br><span class="line">                    li.innerHTML = &quot;&lt;a href=&#x27;javascript:;&#x27; class=&#x27;link&#x27;&gt;新建的超链接&lt;/a&gt;&quot;</span><br><span class="line">                    ul.appendChild(li);</span><br><span class="line">                &#125;</span><br><span class="line">                ul.onclick = function(event) &#123;</span><br><span class="line">                    if (event.target.className == &#x27;link&#x27;) &#123;</span><br><span class="line">                        alert(&quot;这是一个响应函数&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;button id=&quot;btn1&quot;&gt;我是一个按钮&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;javascript:;&quot; class=&quot;link&quot;&gt;这是一个超链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>对象.事件 = 函数</code> 的形式绑定响应函数，它只能同时为一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个，那么后面的就会覆盖掉前面的。<br>我们可以使用 <code>addEventListener(xxx, xxx, xxx)</code> 为元素绑定响应函数。<br>它的参数：</p>
<ol>
<li>事件的字符串，如果是 onclick 不要前面的 on</li>
<li>回调函数，当事件被触发时，该函数会被调用。</li>
<li>是否在捕获阶段触发，需要布尔值，一般是 false</li>
</ol>
<p>JavaScript中的call()函数是用于调用函数的方法之一，它允许你显式地指定函数内部的this关键字，并传递参数给该函数。call()方法的语法如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionName.call(thisArg, arg1, arg2, ...);</span><br></pre></td></tr></table></figure><br>总之，call()方法是JavaScript中用于在指定上下文对象上调用函数的强大工具，它允许你更灵活地控制函数的执行环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;</span><br><span class="line">        &lt;meta charset=&quot;UFT-8&quot;&gt;</span><br><span class="line">        this is a test.</span><br><span class="line">    &lt;/title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            #box1 &#123;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: red;</span><br><span class="line">                position: absolute;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            window.onload = function() &#123;</span><br><span class="line">                var box1 = document.getElementById(&quot;box1&quot;);</span><br><span class="line">                box1.onmousedown = function(event) &#123;</span><br><span class="line">                    var offsetX = event.clientX - box1.offsetLeft;</span><br><span class="line">                    var offsetY = event.clientY - box1.offsetTop;</span><br><span class="line">                    document.onmousemove = function(event) &#123;</span><br><span class="line">                        var x = event.clientX;</span><br><span class="line">                        var y = event.clientY;</span><br><span class="line">                        box1.style.left = x - offsetX + &quot;px&quot;;</span><br><span class="line">                        box1.style.top = y - offsetY + &quot;px&quot;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    document.onmouseup = function() &#123;</span><br><span class="line">                        document.onmousemove = null;</span><br><span class="line">                        document.onmouseup = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">        &lt;div id=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>实现一个小方块位置的拖拽。</p>
<p>键盘事件一般都会绑定给可以获取到焦点的对象或者是 <code>document</code> 对象。对于 <code>onkeydown</code> 事件来说，如果我们一直按着某个按键不松手，则事件就会一直触发。当 <code>onkeydown</code> 连续触发时，第一次和第二次之间的间隔会长一点，其他后面的会非常快，这是为了防止我们误操作。</p>
<p>我们可以使用 <code>event</code> 的 <code>keyCode</code> 属性可以返回被按下键的 <code>Unicode</code> 编码。或者使用 <code>key</code> 属性直接返回被按键的按键。<br>如果判断 <code>alt</code> 或者 <code>ctrl</code> 或者 <code>shift</code> 和某个键是否同时被按下，可以同时使用 <code>event</code> 的 <code>altKey、shiftKey、ctrlKey</code> 属性和 <code>key</code> 属性。</p>
<p>BOM browser object model 浏览器对象模型<br>BOM 可以使我们通过 JS 来操作浏览器，DOM 可以使我们通过 JS 来操作网页。<br><img src="/2023/08/28/JavaScript%E5%9F%BA%E7%A1%80/bom%E5%AF%B9%E8%B1%A1.png" class=""></p>
<p><code>uerAgent</code> 用户代理，通常指的是浏览器，其中 <code>navigator</code> 的属性 <code>userAgent</code> 是一个字符串，包含用来描述浏览器的内容，不同的浏览器有着不同的 userAgent</p>
<p>Gecko CSS 渲染的一个引擎。</p>
<p><code>history</code> 对象 <code>length</code> 属性，返回浏览器历史列表中 url 数量。<br>方法：<code>back</code> 加载 <code>history</code> 列表中前一个 url，<code>forward</code> 加载 <code>history</code> 列表中下一个 url，<code>go(xx)</code> 加载列表中某一个具体的页面，xx 如果是正，就是前多少个，如果是负，就是加载后面第xx个页面。</p>
<p><code>location</code> 对象<br>如果直接打印 <code>location</code> 可以获取当前的地址栏，也就是网页的完整路径。如果直接将 <code>location</code> 修改为一个路径，就会直接跳转到那个页面。</p>
<p><code>window</code> 的 <code>setInterval</code> 方法。(Interval 是 间隔、中场休息、幕间休息、间隙 的意思)</p>
<ul>
<li>定时调用</li>
<li>可以将一个函数，每隔一段时间执行一次</li>
<li>参数：<ol>
<li>回调函数</li>
<li>每次调用的时间间隔，单位是毫秒</li>
</ol>
</li>
<li>返回值：<br>  返回一个 Number 类型的数据<br>  这个数字用来作为定时器的唯一标识(因为一个页面上可能有很多个定时器)<br>  比如我们的 <code>clearInterval(xx)</code> 方法，可以用来关闭一个定时器，其中的 <code>xx</code> 就需要我们的标识作为参数。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setInterval(function() &#123;</span><br><span class="line">    xxx.innerHTML = ++count;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>延时调用：一个函数不是马上执行，而是一段时间之后再执行(只会执行一次)。<br>用法和定时调用差不多 <code>setTimeout(xxx);</code><br><code>clearTimeout(xxx);</code> 是关闭延时调用。</p>
<p>延时调用其实和定时调用是可以互相代替的。</p>
<p>JSON(JavaScript Object Notation)<br>因为和 JavaScript 中对象的表示方法一样，只不过在 JSON 中属性名字必须加双引号。<br>JSON 分类：</p>
<ol>
<li>对象 <code>&#123;&#125;</code></li>
<li>数组 <code>[]</code></li>
</ol>
<p>在 JS 中，为我们提供了一个工具类就叫做 JSON，这个对象可以帮助我们将一个 JSON 转换为 JS 对象，也可以将一个 JS 对象转换为 JSON。<br><code>JSON.parse(xx);</code></p>
<ul>
<li>将字符串转换为 JS 对象</li>
<li>需要一个 JSON 字符串作为参数，返回一个 JS 对象</li>
</ul>
<p><code>JSON.stringfy();</code></p>
<ul>
<li>将 JS 对象转换为字符串</li>
<li>需要一个 JS 对象作为参数，但会一个 JSON 字符串。</li>
</ul>
<p><code>===</code> 是严格相等的意思，它用于比较两个值是否完全相等，包括值和数据类型。<br>使用严格相等运算符是 JavaScript 编程中的一种良好实践，因为它可以减少潜在的错误和不确定性，确保比较的值具有相同的类型和值。</p>
]]></content>
      <tags>
        <tag>JavaScript, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript进阶</title>
    <url>/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a>基础回顾</h4><p>数据类型：</p>
<ol>
<li>基本类型<br> String Number boolean undefined null</li>
<li>对象(引用)类型<br> Object Function Array</li>
</ol>
<p>判断：</p>
<ol>
<li><code>typeof</code><br> 返回的数据类型的字符串表达</li>
<li><code>instanceof</code></li>
<li><code>===</code> 和 <code>==</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123; // 这是一个 **类型对象**，因为函数也是一个对象。</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var p = new Person(); // 这是一个实例对象。</span><br></pre></td></tr></table></figure>
<p><code>null</code> 和 <code>undefined</code><br><code>null</code> 定义了并且赋值了，只是值为 <code>null</code>，而 <code>undefined</code> 是定义了但是没有赋值。初始赋值为 <code>null</code> 表示将要是一个对象。程序的最后赋值为 <code>null</code> 可以释放内存。</p>
<p>栈：全局变量 / 局部变量<br>堆：对象<br>(对象本身在栈里面，而表示对象的变量在栈空间，比如函数和函数名的关系)</p>
<p>JS 在调用函数传递变量的时候是 <strong>值传递</strong>（理解可能不同）<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">function add(a) &#123;</span><br><span class="line">    a = a + 1;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 程序输出为 3</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    var b = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数执行完以后 <code>b</code> 这个局部变量会自动释放，而后面对应的对象因为没有再被指向，被认为是垃圾对象，是在后面的某个时刻由垃圾回收器回收，释放空间。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">var b = &#123;&#125;;</span><br><span class="line">b = null;</span><br></pre></td></tr></table></figure><br><code>b=null;</code> 以后，<code>b</code> 所指向的对象没有被任何其他变量指向，所以会被标记为垃圾对象，由 <code>JS</code> 引擎在一定时间后回收，而 <code>b</code> 这个全局变量仍然存在。<br>在<code>JavaScript</code>中，全局变量通常在整个应用程序的生命周期内存在，不会自动释放内存。<code>JavaScript</code> 引擎会负责管理全局变量的内存，而不需要手动释放。当全局变量不再被引用时，<code>JavaScript</code>引擎会自动将其标记为可回收，并在适当的时候进行垃圾回收以释放内存。<br><code>JavaScript</code> 的垃圾回收机制主要处理对象的内存释放，而不负责释放变量的内存。变量的生命周期通常由其作用域决定。在全局作用域中声明的变量通常会在整个应用程序的生命周期内存在，除非您显式删除它们或应用程序终止。在局部作用域中声明的变量在离开作用域时会被销毁，相应的内存也会被释放。</p>
<p>什么时候必须使用 <code>[&#39;属性名&#39;]</code> 的方式？</p>
<ol>
<li>属性名包含特殊字符：如<code>-</code> 和 <code> </code>。</li>
<li>使用表达式来动态访问属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;John&quot;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var propertyName = &quot;name&quot;;</span><br><span class="line">console.log(person[propertyName]); // 使用方括号来访问属性</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>test.call/apply(obj);</code> 这个意思是把 <code>test</code> 函数临时作为 <code>obj</code> 内部的函数来调用。<code>obj</code> 内部可以没有 <code>test</code> 函数。</p>
<p><code>JavaScript</code> 中的回调函数是一种常见的编程概念，它允许您将一个函数作为参数传递给另一个函数，并在需要时执行该函数。这通常用于处理异步操作，例如处理文件读取、网络请求、定时器等等，因为在这些情况下，不能立即得到结果，而需要在操作完成后执行特定的代码。</p>
<p>IIFE(Immediately-Invoked Function Expression)</p>
<p><code>this</code> 是什么？</p>
<ul>
<li>任何函数本质上都是通过某个对象来调用，如果我们没有直接指定，就是 <code>window</code> 来调用。</li>
<li>所有函数内部都以一个变量 <code>this</code>。</li>
<li>这个 <code>this</code> 的值是当前调用函数的对象。</li>
</ul>
<p>在<code>JavaScript</code>中声明的全局函数通常是<code>window</code>对象的一部分，而不是<code>document</code>对象的一部分，这是因为<code>JavaScript</code>最初是为浏览器环境设计的，并且全局作用域在浏览器中通常与<code>window</code>对象关联。</p>
<p>在浏览器环境中，<code>window</code>对象代表整个浏览器窗口，它包含了全局<code>JavaScript</code>作用域的所有内容，包括全局变量和函数。当您声明一个全局函数时，它实际上是<code>window</code>对象的一个属性。这意味着您可以在全局范围内访问这个函数，无需任何其他前缀。</p>
<h4 id="JS-原型和原型链"><a href="#JS-原型和原型链" class="headerlink" title="JS 原型和原型链"></a>JS 原型和原型链</h4><p>JS 的复杂类型都是对象类型(<code>Object</code>)，而 JS 不是一门完全面向对象的编程语言，所以如何涉及继承机制，这是一个问题。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>因为 JS 中没有类(<code>Class</code>)这个概念，所以 JS 的设计者使用了 <strong>构造函数</strong> 来实现继承机制。</p>
<blockquote>
<p>ES6 中的 <code>Class</code> 可以看成一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>Class</code> 写法只是让原型的写法更加清晰、更像面向对象编程的语言而已。</p>
</blockquote>
<p>在构造函数中，通过 <code>this</code> 赋值的属性或者方法，是每个实例的 <strong>实例属性</strong> 和 <strong>实例方法</strong>，<strong>无法共享公共属性</strong>。所以就又设计出了一个<strong>原型对象</strong>，来存储这个<strong>构造函数的公共属性以及方法</strong>。</p>
<h5 id="函数的-prototype-原型"><a href="#函数的-prototype-原型" class="headerlink" title="函数的 prototype(原型)"></a>函数的 <code>prototype</code>(原型)</h5><ul>
<li>每一个函数都有一个 <code>prototype</code> 属性，它默认指向一个 <code>Object</code> 空实例对象(即称为：原型对象，但是 <code>Object</code> 不满足)。<blockquote>
<p>为什么要有这个空对象？<br>它可以方便我们对于一个函数添加个性化的属性和方法，如果没有这个空对象而是直接链接到 Obejct，那么不同函数之间的个性化操作都会添加到 Obejct 下，会产生很多不必要的冲突和麻烦。</p>
</blockquote>
</li>
<li>原型对象中有一个属性 <code>constructor</code>，它指向函数对象。</li>
<li>给原型对象添加属性(一般是方法) -&gt; 实例对象可以访问使用。（感觉和类与对象的关系很像）<br>构造函数和它的原型对象相互引用。<br>每一个函数 <code>function</code> 都有一个 <code>prototype</code>，即显式原型(属性)<br>每一个对象都有一个 <code>__proto__</code> 可以称为隐式原型(属性)<br>对象隐式原型的值就是函数显式原型的值。</li>
</ul>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><ul>
<li>访问一个对象的属性时，现在自身属性中查找，找到返回。</li>
<li>如果没有，再沿着 <code>__proto__</code> 这条链向上查找，找到返回。</li>
<li>如果最终没有找到，返回 <code>undefined</code>。</li>
<li>一直是沿着隐式原型找的，所以我们的原型链本质上是一个 <strong>隐式原型链</strong><img src="/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B.png" class="">
<img src="/2023/08/31/JavaScript%E8%BF%9B%E9%98%B6/%E5%8E%9F%E5%9E%8B%E9%93%BE.png" class="">
所有函数的隐式原型都是相同的，<code>fun = new Function()</code> 都是 <code>Function</code> 的实例对象。</li>
<li>在读取对象的属性时，会自动到原型链中查找。</li>
<li>设置对象的属性时，不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值。</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上。</li>
</ul>
<p>To do:<br>利用js快速完成大学生新生安全教育课程<br><a href="https://blog.csdn.net/m0_38072683/article/details/118878085">https://blog.csdn.net/m0_38072683/article/details/118878085</a></p>
]]></content>
      <tags>
        <tag>JavaScript, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>杂记</title>
    <url>/2023/08/31/%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="Auto-js"><a href="#Auto-js" class="headerlink" title="Auto.js"></a>Auto.js</h4><p>Auto.js 是一种基于 JavaScript 的自动化工具，它允许你编写和运行 JavaScript 脚本来自动化执行 Android 设备上的各种任务。因此，Auto.js 使用 JavaScript 作为其编程语言。</p>
<p>关于 Auto.js 和 JavaScript 的关系如下：</p>
<ol>
<li><p>Auto.js 使用 JavaScript：Auto.js 的脚本是用 JavaScript 编写的，因此你可以在 Auto.js 中编写标准的 JavaScript 代码。这使得 Auto.js 在编写和运行自动化脚本时非常灵活，因为你可以使用 JavaScript 的语法和功能。</p>
</li>
<li><p>Auto.js 扩展了 JavaScript：尽管 Auto.js 使用 JavaScript 作为其编程语言，但它还提供了一组额外的 API 和库，这些 API 和库允许你与 Android 设备的各种功能和资源进行交互，如模拟用户输入、操作屏幕、访问文件系统等。这些功能通常不是标准的 JavaScript 语言特性，而是 Auto.js 为 Android 自动化提供的功能扩展。</p>
</li>
<li><p>Auto.js 是 JavaScript 的运行环境：Auto.js 提供了一个运行 JavaScript 脚本的环境，这个环境专门设计用于在 Android 设备上执行脚本。它允许你使用 JavaScript 控制 Android 设备的各种操作，例如自动点击、滑动、截屏等等。</p>
</li>
</ol>
<p>总之，Auto.js 是一个工具，它使用 JavaScript 作为编程语言，并扩展了 JavaScript，以便在 Android 设备上执行自动化任务。这使得开发人员可以使用 JavaScript 的语法和功能，结合 Auto.js 提供的 Android 自动化 API，编写用于自动化控制和操作 Android 应用和设备的脚本。</p>
<h4 id="C-赋值"><a href="#C-赋值" class="headerlink" title="C++ 赋值"></a>C++ 赋值</h4><ul>
<li>对于函数的变量，我们可以使用值传递或者引用传递，取决于函数的参数类型。如果是带有 <code>&amp;</code>，此时就是引用传递，在函数中对于变量修改会影响到函数外部的值。对于数组，向函数传递的实际上是指向数组首元素的指针，这意味着参数的本质上是通过地址传递的，所以函数内部的修改可以影响到外部。</li>
<li>在C++中，当您将一个类对象赋值给另一个类对象时，默认情况下是使用复制构造函数来执行赋值操作，因此这也是一种值传递。这意味着目标对象会被复制为源对象的一个副本，两个对象之间是相互独立的，修改一个对象的属性不会影响另一个对象。</li>
</ul>
<h4 id="VSCode-重命名所有匹配项"><a href="#VSCode-重命名所有匹配项" class="headerlink" title="VSCode 重命名所有匹配项"></a>VSCode 重命名所有匹配项</h4><p>按住 <code>alt</code> + <code>shift</code><br><a href="https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf">https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf</a> VScode 的快捷键表</p>
<h4 id="ES5-和-ES6-含义"><a href="#ES5-和-ES6-含义" class="headerlink" title="ES5 和 ES6 含义"></a>ES5 和 ES6 含义</h4><p>ES6 和 ES5 是 JavaScript 的不同版本，它们代表了不同的 ECMAScript（简称 ES）标准。ECMAScript 是 JavaScript 语言的标准化规范，规定了 JavaScript 语法、特性和行为。</p>
<ol>
<li>ES5（ECMAScript 5）： ES5 是 JavaScript 的第五个主要版本，它在2009年发布。它引入了许多重要的新特性，例如严格模式（Strict Mode）、数组方法（如 forEach、map、filter 等）和更强大的对象属性定义（Object.defineProperty）。ES5被广泛支持，并且在早期的浏览器中是主要的 JavaScript 标准。</li>
<li>ES6（ECMAScript 2015）： ES6 是 JavaScript 的第六个主要版本，也称为 ECMAScript 2015。它于2015年发布，并引入了许多新的特性和语法改进，如箭头函数、类、模块、解构赋值、let 和 const 变量声明等。ES6使得 JavaScript 更加现代化和强大，并提供了更好的开发工具和技术。尽管它在发布时得到了广泛的支持，但由于浏览器的兼容性问题，需要一些时间才能在所有主要环境中广泛使用。</li>
</ol>
<h4 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h4><p><span> 是一个行内元素（inline element）或内联元素，用于在文本中包裹一部分内容，而不会引入新的块级元素或换行。<span> 通常用于对文本的一部分进行样式设置或添加其他属性，以便在不破坏文本流的情况下对其进行操作。<br><span> 元素本身不会对其包含的文本内容产生任何视觉效果，它主要用于以下情况：</p>
<ol>
<li>样式设置：你可以使用 <span> 元素为文本添加 CSS 样式，例如更改文本的颜色、字体、背景色等。这使得你可以有选择性地为文本的一部分应用样式，而不必更改整个段落或文本块的样式。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is &lt;span style=&quot;color: red;&quot;&gt;red text&lt;/span&gt; and this is &lt;span style=&quot;font-weight: bold;&quot;&gt;bold text&lt;/span&gt;.&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
<li>JavaScript 操作：<span> 通常用于 JavaScript 操作，你可以通过 JavaScript 选择 <span> 元素并修改其内容或属性。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;Click &lt;span id=&quot;mySpan&quot; onclick=&quot;changeText()&quot;&gt;here&lt;/span&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function changeText() &#123;</span><br><span class="line">  var spanElement = document.getElementById(&quot;mySpan&quot;);</span><br><span class="line">  spanElement.innerHTML = &quot;clicked!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="HTML-中-img-标签中的-alt-属性"><a href="#HTML-中-img-标签中的-alt-属性" class="headerlink" title="HTML 中 img 标签中的 alt 属性"></a>HTML 中 img 标签中的 alt 属性</h4><p><code>alt</code> 属性用于提供图片的替代文本(Alternative Text)</p>
<ol>
<li>替代文字：如果图像无法加载或无法显示，浏览器会显示 alt 属性中的文本，以提供对图像内容的文字描述，从而使页面更具可访问性。</li>
<li>辅助工具：屏幕阅读器等辅助技术会读取 alt 文本，以向用户描述图像。因此，良好的 alt 文本可以帮助视觉障碍者理解图像的含义。</li>
<li>优化 SEO：搜索引擎可以使用 alt 文本来理解图像的内容，从而更好地索引和排名网页。</li>
<li>图像加载失败时的占位符。</li>
<li>提示信息：一些浏览器在用户将鼠标悬停在图像上时会显示 alt 文本作为工具提示，以提供附加信息。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;example.jpg&quot; alt=&quot;一只可爱的猫咪&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="axios-和-jQuery"><a href="#axios-和-jQuery" class="headerlink" title="axios 和 jQuery"></a>axios 和 jQuery</h4><p>axios 是一个独立的 JavaScript 库，专注于处理 HTTP 请求。它是一个现代的、基于 Promise 的库，主要用于前端和后端（Node.js）开发，提供了清晰、简单的 API。<br>$.ajax() 是 jQuery 库的一部分，用于处理各种类型的 AJAX 请求。它除了处理 HTTP 请求外，还包括许多其他功能，如 DOM 操作、事件处理、动画等。因此，$.ajax() 只是 jQuery 库的一部分。<br>总结来说就是，axios 是一个相对较小的库，专注于 HTTP 请求。你可以单独引入它，而无需加载整个 jQuery 库。$.ajax() 是 jQuery 的一部分，如果你只需要进行 HTTP 请求，使用 jQuery 会显得冗余，因为它包含了许多其他功能。</p>
<h4 id="VSCode-多光标编辑"><a href="#VSCode-多光标编辑" class="headerlink" title="VSCode 多光标编辑"></a>VSCode 多光标编辑</h4><ol>
<li>按住 <code>alt</code> 点击多个位置(这个方法选择就没有约束)。</li>
<li>按住鼠标滚轮，往下拖动(这个方法只是支持在同一竖线上的多位置编辑)。</li>
</ol>
<h4 id="快速创建-HTML-模板"><a href="#快速创建-HTML-模板" class="headerlink" title="快速创建 HTML 模板"></a>快速创建 HTML 模板</h4><p>创建xxx.html文件，输入: ! + Tab</p>
<h4 id="实体字符"><a href="#实体字符" class="headerlink" title="实体字符"></a>实体字符</h4><p>在HTML中，实体字符是一种特殊的编码方式，用来表示一些特殊字符或保留字符，以确保它们能够正确地显示在网页上，而不会被解释为HTML标记。以下是一些常见的HTML实体字符<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/%E5%AE%9E%E4%BD%93%E5%AD%97%E7%AC%A6.png" class=""></p>
<h4 id="系统变量和用户变量"><a href="#系统变量和用户变量" class="headerlink" title="系统变量和用户变量"></a>系统变量和用户变量</h4><p>系统变量与用户变量的区别，最重要的即系统变量的优先级高于用户变量。</p>
<h4 id="BeautifulSoup-库"><a href="#BeautifulSoup-库" class="headerlink" title="BeautifulSoup 库"></a>BeautifulSoup 库</h4><p>Beautiful Soup 是一个Python库，用于从HTML或XML文档中提取数据。它是一个强大的解析库，可以帮助你轻松地解析复杂的网页内容，并从中提取所需的信息。<br>它可以帮助我们(在使用Beautiful Soup库时，通常需要指定一个底层的解析器，而 lxml 是一个常用的解析器之一，因为它具有高性能和稳定性。Beautiful Soup本身并没有自带解析器，因此需要依赖第三方解析器来处理HTML或XML文档)：</p>
<ol>
<li>解析 HTML 和 XML。将他们转换为 Python 对象的树状结构。</li>
<li>寻找元素。寻找特定的元素、属性、文本内容，从而提取所需的数据。</li>
<li>修改文档结构。</li>
<li>清除数据。</li>
</ol>
<h4 id="RE-regular-expression-regex"><a href="#RE-regular-expression-regex" class="headerlink" title="RE regular expression regex"></a>RE regular expression regex</h4><p>正则表达式，是用来简介表达一组字符串特征的表达式，最主要的应用在字符串匹配。<br>具体内容见文章 python 爬虫。</p>
<h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>IP地址（Internet Protocol Address，互联网协议地址）是一种用于在计算机网络中唯一标识和定位设备的数字地址。IP地址在互联网通信中起到了非常重要的作用，它允许设备在全球范围内进行通信。<br>一些概念和要点：</p>
<ol>
<li>唯一性：每个设备（如计算机、服务器、路由器）连接到互联网时都被分配一个唯一的IP地址。这确保了在互联网上的每个设备都可以被准确标识和寻址。</li>
<li>IPv4和IPv6：有两个主要的IP地址版本，分别是IPv4（Internet Protocol Version 4）和IPv6（Internet Protocol Version 6）。IPv4地址是32位的，通常以点分十进制表示，如192.168.1.1。IPv6地址是128位的，通常以冒号分隔的十六进制表示，如2001:0db8:85a3:0000:0000:8a2e:0370:7334。由于IPv4地址空间有限，IPv6被引入以满足不断增长的互联网连接需求。</li>
<li>分层和路由：IP地址的设计允许数据在网络中进行分层和路由。它可以告诉路由器和交换机如何将数据包从源设备传送到目标设备，经过多个网络节点。</li>
<li>公共和私有IP地址：IP地址可以是公共的或私有的。公共IP地址用于直接连接到互联网，而私有IP地址用于在私有网络中进行内部通信。私有IP地址通常在家庭网络和企业内部网络中使用，路由器负责将这些地址与公共IP地址进行映射。</li>
<li>动态和静态IP地址：IP地址可以是动态的或静态的。动态IP地址由DHCP（动态主机配置协议）服务器动态分配给设备，而静态IP地址是由网络管理员手动配置的，通常不会更改。</li>
<li>网络服务：IP地址不仅用于标识设备，还用于定位网络服务和资源，如网站、邮件服务器、数据库服务器等。DNS（域名系统）用于将域名映射到IP地址，使人们更容易访问网络资源。</li>
</ol>
<h4 id="Ctrl-R"><a href="#Ctrl-R" class="headerlink" title="Ctrl + R"></a>Ctrl + R</h4><p>在 VSCode 中可以直接搜索文件夹。</p>
<h4 id="抓包-packet-capture"><a href="#抓包-packet-capture" class="headerlink" title="抓包 packet capture"></a>抓包 packet capture</h4><p>「抓包」是将网络传输发送与接受的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包经常被用来进行数据截取等。</p>
<h5 id="为什么抓包"><a href="#为什么抓包" class="headerlink" title="为什么抓包"></a>为什么抓包</h5><ol>
<li>Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。</li>
<li>经常使用抓包工具辅助测试，可以很好的了解整个系统，比如数据传输过程前后端的关系，以及整个系统的结构。特别是对现在的微服务架构的产品，抓包能够更好的梳理和掌握整个系统各个服务之间的关系，大大增加测试的覆盖度。另外还可以增进对代码、HTTP协议方面知识的理解。</li>
</ol>
<h5 id="常用的抓包工具"><a href="#常用的抓包工具" class="headerlink" title="常用的抓包工具"></a>常用的抓包工具</h5><ol>
<li>httpwatch</li>
<li>fiddler</li>
<li>wireshark</li>
<li>firebug</li>
</ol>
<h4 id="HMAC-SHA256-算法"><a href="#HMAC-SHA256-算法" class="headerlink" title="HMAC-SHA256 算法"></a>HMAC-SHA256 算法</h4><p>HMAC-SHA256（Hash-based Message Authentication Code with SHA-256）是一种基于哈希函数和密钥的消息认证码算法，用于确保消息的完整性和认证消息的发送方。它是SHA-256哈希函数与密钥结合使用</p>
<h4 id="Token-Cookie-和-Session"><a href="#Token-Cookie-和-Session" class="headerlink" title="Token Cookie 和 Session"></a>Token Cookie 和 Session</h4><ol>
<li>Token<br>Token 是一种轻量级的身份验证令牌，通常是一个长字符串，用于识别用户。<br><strong>原理：</strong>当用户登录应用程序时，服务器会颁发一个Token给客户端（通常是JSON Web Token - JWT）。客户端将Token存储在本地（通常是在浏览器的localStorage或sessionStorage中，或在移动应用的存储中）。后面客户端的每个 HTTP 请求都会在 Headers 中附带 Token，服务器<strong>只需要通过特定的密钥和加密算法来验证即可</strong>，不需要再去额外存储用户的 Token 信息。<br><strong>优点：</strong> 无状态(只需要验证，无需存储)、可扩展性强，适用于分布式系统和 API。<br><strong>缺点：</strong> 需要额外的处理来管理 Token 的过期、刷新和安全性。</li>
<li>Cookie<br>Cookie是一小段数据，由服务器发送到用户浏览器，存储在用户本地。它通常包含了一些标识信息和可选的数据。<br><strong>原理：</strong> 服务器在响应HTTP请求时，可以通过Set-Cookie头来设置Cookie。浏览器会将Cookie存储在用户的计算机上，并在后续请求中自动发送给服务器。<br><strong>优点：</strong> 简单、易用，可以持久保存数据，对用户透明。<br><strong>缺点：</strong> 有限的存储容量，每个请求都会带上Cookie，可能会影响性能和安全性（例如，可能受到跨站脚本攻击的影响）。</li>
<li>Session<br>Session是一种服务器端机制，用于跟踪用户在应用程序中的状态和身份。<br><strong>原理：</strong> 服务器在用户登录时创建一个唯一的会话标识，通常是一个Session ID，并将其存储在服务器上。Session ID 可以存储在Cookie中或通过URL重写等方式传递给客户端。<br><strong>优点：</strong> 相对于 Cookie 更加安全，可以存储更多的数据，不受 Cookie 容量限制。<br><strong>缺点：</strong> 占用服务器内存，需要额外的服务器资源，不适于分布式系统。<br>通常，现代Web应用程序使用Token进行身份验证和授权，而Cookie和Session用于保持用户状态和临时数据的存储。</li>
</ol>
<h4 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h4><p>通信协议是计算机和网络设备之间进行数据交换和通信的<strong>规则</strong>和<strong>约定</strong>。它们定义了数据的格式、传输方式、错误检测和纠正机制以及通信参与方之间的行为。</p>
<h5 id="1-OSI-模型"><a href="#1-OSI-模型" class="headerlink" title="1. OSI 模型"></a>1. OSI 模型</h5><p>OSI 模型即 <strong>开放式通信系统互联参考模型</strong>(Open System Interconnection Reference Model)，是国际标准化组织 ISO 提出的一个试图使各种计算机在世界范围内互联为网络的标准框架，简称 OSI</p>
<p>OSI 七层模型<br>OSI 定义了网络互连的七层模型，物理层、数据链路层、网络层、传输层、会话层、表示层、应用层<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/OSI%E6%A8%A1%E5%9E%8B.png" class=""><br>首字母组成 All people seem to need data processing. 所有人似乎都需要数据处理，这句话可以帮助来记忆。</p>
<h5 id="2-TCP-IP-协议族"><a href="#2-TCP-IP-协议族" class="headerlink" title="2. TCP/IP 协议族"></a>2. TCP/IP 协议族</h5><p>从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。<br>它是把 OSI 七层模型简化成了五层模型，每一层模型都呼叫它的下一层所提供的网络来完成自己的需求。<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/OSI%E4%B8%8ETCPIP%E5%85%B3%E8%81%94.png" class=""></p>
<h5 id="3-TCP-协议"><a href="#3-TCP-协议" class="headerlink" title="3. TCP 协议"></a>3. TCP 协议</h5><p>TCP 是<strong>面向连接的运输层协议</strong>。应用程序在使用 TCP 协议之前，必须<strong>先建立</strong> TCP 连接。在传送数据完毕以后，<strong>必须释放</strong>已经建立的 TCP 连接(HTTP 协议通常使用 TCP 作为传输协议，HTTP 是典型的无状态，所以可以用来理解 TCP 协议)。</p>
<p>每一条 TCP 连接只能有两个端点，是点对点的。</p>
<p>TCP 提供<strong>可靠交付</strong>的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p>
<p>TCP 协议是<strong>面向字节流</strong>的，意味着TCP将数据视为一连串的字节而不是消息或数据块的集合。</p>
<p>产生的影响：</p>
<ol>
<li>无消息边界。<br>在TCP连接中，数据被视为一个连续的字节流，没有明确的消息边界或分隔符。这意味着TCP不会为你自动识别消息的开始或结束。你需要自行定义和实现消息的分割和解析机制。</li>
<li>字节级的精确性<br>TCP保证了数据的字节级精确性，即接收到的数据的每个字节都与发送端相匹配。如果数据在传输过程中损坏或丢失，TCP会负责重传丢失的部分，以确保接收端获得完整且准确的数据。</li>
</ol>
<p>TCP 提供了可靠的、有效的数据传输但是不考虑消息的边界。因此，我们在使用 TCP 协议的时候，应用程序需要负责<strong>定义和实现消息的分割和解析方法</strong>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/64155705">https://zhuanlan.zhihu.com/p/64155705</a> TCP 协议详解</p>
<h5 id="4-HTTP-协议"><a href="#4-HTTP-协议" class="headerlink" title="4. HTTP 协议"></a>4. HTTP 协议</h5><p>HTTP 是 Hyper Text Transfer Protocol(超文本传输协议) 的缩写。HTTP 协议用于 WWW 服务器传输超文本到本地浏览器的传送协议。<br>它不仅可以保证计算机<strong>正确快速地传输</strong>超文本文档，还确定传输文档中哪一部分，以及哪部分内容首先显示(如文本优先于图像)。<br>HTTP 是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型，是一个无状态的协议。</p>
<p><strong>特点：</strong></p>
<ol>
<li>简单快速。客户向服务器请求服务的时候，只需要请求方法和路径。请求方法通常包括 GET、HEAD、POST。</li>
<li>灵活。HTTP 允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。</li>
</ol>
<p><strong>持久连接</strong><br>HTTP 1.1 版本的变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 <code>Connection: keep-alive</code>。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在发送最后一个请求时，发送 <code>Connection: close</code>，明确要求服务器关闭 TCP 连接。</p>
<p><strong>Content-Length</strong> 字段<br>一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪个回应的。这就是 Content-Length 字段的作用，声明本次回应的数据长度。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Length: 3295</span><br></pre></td></tr></table></figure><br>上面代码告诉浏览器，本次回应的长度是3295个字节，后面的字节就属于下一个回应了。</p>
<p>在 1.0 版本中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了。<br>使用 Content-Length 的前提是，服务器发送回应前，必须知道回应的数据长度。<strong>对于一些很耗时的动态操作来说，这意味着服务器要完成所有操作以后才可以发送数据</strong>(毕竟是动态的)，显然这样的数据并不是很高。更好的处理方法是，产生一块数据就发送一块，采用「流模式」(stream) 取代「缓存模式」(buffer)。<br>因此，1.1 版本规定可以不使用 Content-Length 字段，而是使用「分块传输编码」(chunked transfer encoding)。只要请求或者回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/http%E5%92%8Ctcp%E5%85%B3%E7%B3%BB.png" class=""></p>
<h5 id="5-FTP-协议"><a href="#5-FTP-协议" class="headerlink" title="5. FTP 协议"></a>5. FTP 协议</h5><p>FTP 协议(File Transfer Protocol)，也是运行在 TCP 上，保证了文件传输的可靠性。与 HTTP 相比，FTP 面向的直接是服务器的文件系统，并且具有维持状态的特点，在文件传输管理上，FTP 更胜一筹。<br><strong>传输流程</strong><br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/FTP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" class=""><br>一共有两个并行的连接，一个是「控制连接」(port: 21)，另一个是「数据连接」(port: 20)。<br>其中，控制连接用于在两个主机之间传输控制信息，如口令、用户标识、存放，获取文件等命令。数据连接用于实际发送一个文件，发送完文件以后数据连接是会关闭的。<br>由于 FTP 使用一个独立的控制连接，所以我们也称 FTP 的控制信息是带外(out-of-band) 传送的。HTTP 协议是在传输文件的同一个 TCP 连接中发送请求和响应首部行的，所以，HTTP 也可以说是带内 (in-band) 发送控制信息的。<br><strong>传输方式</strong><br>FTP 支持两种方式的传输：文本(ASCII)方式和二进制(Binary)方式。<br>通常文本文件的传输采用 ASCII 方式；而图像、声音文件、加密和压缩文件等非文本文件采用二级制传输方式。<br><strong>传输模式</strong><br>FTP 有两种传输模式—主动(FTP Port)模式和被动(FTP Passive)模式。由于主动模式存在着安全问题，最近几年，大部分的 FTP 客户端开始默认使用被动模式。<br><a href="https://zhuanlan.zhihu.com/p/337513218">https://zhuanlan.zhihu.com/p/337513218</a><br><a href="https://zhuanlan.zhihu.com/p/141472331">https://zhuanlan.zhihu.com/p/141472331</a></p>
<h5 id="6-DNS-协议"><a href="#6-DNS-协议" class="headerlink" title="6. DNS 协议"></a>6. DNS 协议</h5><p>互联网上主机的一种标识方式是使用它的「主机名」(hostname)，如 <code>www.facebook.com</code>、<code>www.google.com</code> 等。但是这是我们人类的记忆方式，路由器不会这么理解，路由器喜欢定长的、有层次结构的 IP 地址。</p>
<blockquote>
<p>主机名 (Hostname) 是计算机或者设备在网络上的名称标识符，用于唯一标识一个特定的计算机或者网络设备。<strong>主机名</strong>通常是人类可读的形式，<strong>但是在网络协议中国会被映射为 IP 地址进行通信</strong>。</p>
</blockquote>
<p>IP 地址由 4 字节组成，并且有着严格的层次结构。例如 <code>121.7.106.83</code> 然而路由器喜欢的是 IP 地址进行解析，我们人类便于记忆的确实网址，此时就用到 DNS 了。<br>DNS 的全称是 <code>Domain Name System</code>，是由一个分层的 DNS 服务器(DNS Server) 实现的分布式数据库；还是一个使得主机能够查询分布式数据库的应用层协议。DNS 服务器通常是运行 <code>Berkeley Internet Name Domain</code> 软件的 Unix 机器。DNS 协议运行在 UDP 之上，使用 53 端口。</p>
<p>DNS 是<strong>一个分布式的系统</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/346236071">https://zhuanlan.zhihu.com/p/346236071</a></p>
<h4 id="h-文件和-hpp-文件区别"><a href="#h-文件和-hpp-文件区别" class="headerlink" title="h 文件和 hpp 文件区别"></a>h 文件和 hpp 文件区别</h4><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/h%E5%92%8Chpp.png" class="">
<h4 id="低耦合-Low-Coupling"><a href="#低耦合-Low-Coupling" class="headerlink" title="低耦合 Low Coupling"></a>低耦合 Low Coupling</h4><p>是在讨论软件工程中的一种设计原则，旨在创建更可维护、可扩展和可重用的代码。低耦合涉及到将代码分解成松散耦合的模块或组件，这些模块之间的依赖性尽量降低。</p>
<h4 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h4><p>在 C++ 中，lambda 表达式的结构：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameters) -&gt; return_type &#123;</span><br><span class="line">    // 函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>解释：<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" class=""></p>
<h4 id="delete-和-delete"><a href="#delete-和-delete" class="headerlink" title="delete 和 delete[]"></a>delete 和 delete[]</h4><p>当你使用 new[] 来分配动态数组时，编译器会记住你分配了多少个元素，因此在释放内存时，你必须使用 delete[] 来确保所有元素都得到释放。如果你使用 delete（而不是 delete[]）来尝试释放动态数组的内存，将导致未定义的行为，可能会导致内存泄漏或程序崩溃。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* data_ = new int[size];</span><br><span class="line">delete[] data_;</span><br></pre></td></tr></table></figure></p>
<h4 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h4><p>静态数组需要在编译的时候知道它的大小<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[size];</span><br></pre></td></tr></table></figure><br>也就是说其中的 <code>size</code> 需要是一个常量表达式。如果我们 <code>cin &gt;&gt; size;</code> 后面又 <code>int a[size];</code> 是不行的，因为静态数组要求 <strong>编译的时候大小就确定。</strong></p>
<p>静态数组的内存分配发生在程序的静态存储区域，通常在编译的时候分配，并且在程序结束的时候才会释放，具有全局的声明周期。</p>
<h4 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h4><p>动态数组的大小在运行的时候确定，通常在堆中分配内存。<code>int* ptr = new int[size];</code>。在最后不使用的时候记得要 <code>delete[] ptr;</code><br>其中 <code>new int[size]</code> 会在堆上分配一段连续的内存，大小为 <code>size * sizeof(int)</code> 个字节，然后返回一个指向这块内存的指针，并将这个指针赋值给 <code>ptr</code></p>
<p>堆上分配的内存不会自动释放，需要程序员负责在确保不需要的时候手动释放，否则可能导致内存泄漏。</p>
<h4 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h4><p>栈内存用于存储局部变量和函数调用信息。每个线程通常都有自己的栈。<br>栈内存的分配和释放是自动的，发生在函数的入栈和出栈过程中。当函数返回时，其局部变量的内存会自动被释放。<br>栈内存的生命周期与函数调用有关，它们在函数调用结束后自动释放。</p>
<h4 id="程序运行时内存区域"><a href="#程序运行时内存区域" class="headerlink" title="程序运行时内存区域"></a>程序运行时内存区域</h4><ol>
<li>栈区 Stack<br>栈区用于存储函数调用的局部变量、函数的参数值以及函数调用的返回地址。<br>栈区是<strong>自动管理</strong>的，函数的局部变量在函数被调用时分配内存，在函数结束时自动释放内存。<br><strong>栈区的大小通常较小</strong>，且生命周期短暂，用于管理函数的执行和调用。</li>
<li>堆区 Heap<br>堆区用于动态分配内存，例如使用 new 和 malloc 来分配内存。<br>堆区的内存分配和释放需要程序员<strong>手动管理</strong>，使用 delete 和 free 来释放内存。<br><strong>堆区的大小通常较大</strong>，用于存储动态分配的数据结构，如动态数组、对象等。</li>
<li>静态存储区域 Static Storage<br>静态存储区域用于<strong>存储全局变量、静态变量和常量</strong>(如静态分配的数组)。<br>这些变量在程序启动时分配内存，在程序结束时释放内存。<br>静态存储区域的变量具有全局可见性，并且在整个程序的生命周期内保持不变。</li>
<li>代码区 Code Segment<br>代码区包含程序的机器码指令，用于执行程序的逻辑。<br>代码区通常是只读的，不允许写入和修改。<br>代码区存储程序的执行指令，每个函数和方法的机器代码以及程序的静态数据。</li>
<li>常量区 Constant Area<br>常量区用于存储常量数据，如字符串文字（string literals）和全局 const 变量。<br>常量区的数据是只读的，不允许修改。</li>
<li>栈帧区 Stack Frame</li>
</ol>
<h4 id="malloc-free-和-new-delete"><a href="#malloc-free-和-new-delete" class="headerlink" title="malloc free 和 new delete"></a>malloc free 和 new delete</h4><p><strong>语言差异</strong>：<br>malloc 和 free 是C语言中的函数，可以在C++中使用，但通常不推荐在C++代码中使用它们，因为C++提供了更强大的内存管理工具。<br>new 和 delete 是C++中的操作符，专门用于创建和销毁对象，并与类的构造函数和析构函数一起工作。</p>
<p><strong>类型安全性：</strong><br>new 和 delete 是类型安全的，它们会为对象的构造和销毁调用适当的构造函数和析构函数。这对于管理类对象非常重要。<br>malloc 和 free 不了解对象的类型，它们只是分配和释放内存块。如果你使用它们来分配和释放类对象，可能会绕过构造函数和析构函数，导致对象的行为不正常。</p>
<p>尽管 malloc 和 free 是C语言中的标准内存分配函数，但在C++中通常更推荐使用 new 和 delete，因为它们提供了更好的类型安全性、异常处理和对象生命周期管理。只有在特殊情况下，如与C库一起使用或需要更底层的内存分配控制时，才使用 malloc 和 free。</p>
<p>其中需要注意，malloc 函数返回的是 <code>void*</code> 类型的指针，也就是并没有规定它的类型，需要我们人为规定。所以我们一般写成这样的形式：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* p = (char*)malloc(100);</span><br></pre></td></tr></table></figure><br>其中，100 表示 100 个字节。</p>
<h4 id="C-对象构造"><a href="#C-对象构造" class="headerlink" title="C++ 对象构造"></a>C++ 对象构造</h4><p>有四种方式创建对象：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyClass myClass;</span><br><span class="line">MyClass myClass = MyClass();</span><br><span class="line">MyClass* myClass = new MyClass();</span><br><span class="line">MyClass* myClass = new MyClass;</span><br></pre></td></tr></table></figure><br>其中，前两种方式是在栈中分配内存，由操作系统进行内存的分配和管理。<br>后两种是在堆中分配内存，由管理者(程序员)进行内存的分配和管理，用完必须 delete，否则会造成内存的泄露。</p>
<h5 id="不使用-new"><a href="#不使用-new" class="headerlink" title="不使用 new"></a>不使用 new</h5><p>对于第一种和第二种，一个隐式调用，一个显式调用。<br><strong>第一种：</strong></p>
<ul>
<li>如果有构造函数，默认使用构造函数来初始化对象。</li>
<li>如果没有默认的构造函数，编译器会报错。</li>
</ul>
<p><strong>第二种：</strong></p>
<ul>
<li>默认使用构造函数</li>
<li>如果没有构造函数，编译器会报错。</li>
<li>与第一种方法不同，这个是先创建一个对象，然后进行对象的复制。</li>
</ul>
<p>虽然上面两种那么说，但是如果我们没有显式定义构造函数，编译器会自动生成一个默认构造函数的。这个默认构造函数会对类中的一些基本数据类型的数据进行初始化，就是随机赋值。</p>
<p>所以，通常情况下，前两种方式相比较，第一种方式直接 <code>MyClass myClass;</code> 是更加直接高效的方法，一般使用这种方式。</p>
<h5 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 new"></a>使用 new</h5><p>在使用 new 创建对象的时候。对于有构造函数的类，不论有没有括号，都用构造函数进行初始化。如果没有构造函数，则不加括号的new只分配内存空间，不进行内存的初始化，而加了括号的new会在分配内存的同时初始化为0。</p>
<p>对于 new 创建对象，可以作为函数的返回值和参数，因为如果不用new，函数中不能返回该对象的指针，因为函数结束后，该对象的内存就被释放了(函数是栈空间嘛，如果是 new 则在堆空间，由我们人为决定其寿命)。</p>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/new%E6%9E%84%E9%80%A0.png" class="">
<p>上面是两种new构造的区别，其实不是很大，一般加个括号就好了。</p>
<p>使用 new 创建对象的实际步骤是：</p>
<ol>
<li><p>分配内存：new 会在堆上动态分配足够的内存来存储对象的数据成员，包括对象的成员变量和虚函数表（如果有的话）。</p>
</li>
<li><p>调用构造函数：一旦内存分配完成，C++会调用对象的构造函数来初始化这块内存。构造函数是类的特殊成员函数，用于初始化对象的状态。如果你没有显式定义构造函数，编译器会为你生成一个默认的构造函数来执行默认的初始化操作。</p>
</li>
<li><p>返回指针：new 表达式返回指向分配的内存的指针，该指针指向一个已经构造完成的对象。</p>
</li>
</ol>
<h4 id="CSV-文件-Comma-Separated-Values"><a href="#CSV-文件-Comma-Separated-Values" class="headerlink" title="CSV 文件(Comma-Separated Values)"></a>CSV 文件(Comma-Separated Values)</h4><p>CSV 格式是处理和存储数据的常用格式之一。</p>
<ol>
<li>简单易懂：CSV文件使用纯文本格式，数据之间使用逗号或其他分隔符分隔。</li>
<li>跨平台兼容性：CSV文件是纯文本文件，几乎所有操作系统和应用程序都可以处理它们。</li>
<li>轻量级。</li>
<li>广泛支持：几乎所有类型的编程语言都支持 CSV 格式文件操作。</li>
</ol>
<h4 id="codecs"><a href="#codecs" class="headerlink" title="codecs"></a>codecs</h4><p>“codecs” 是 Python 编程语言中的一个标准库模块，用于处理各种字符编码和解码操作。<br>codecs 的名称来自 <code>code and decode</code>，提供了一种在不同字符码之间进行转换的方式，这在处理文本数据的时候非常有用。<br>下面是一个简单的示例，将 UTF-8 的编码转换为 ASCII 编码。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import codecs</span><br><span class="line"></span><br><span class="line"># 要转换的文本</span><br><span class="line">text = &quot;Hello, 你好&quot;</span><br><span class="line"></span><br><span class="line"># 将文本从UTF-8编码转换为ASCII编码</span><br><span class="line">ascii_text = codecs.encode(text, &#x27;ascii&#x27;, &#x27;ignore&#x27;)  # ignore 是一种错误处理，&quot;ignore&quot; 表示在转换时忽略不能被目标字符编码表示的字符。还有 replace 等</span><br><span class="line"></span><br><span class="line"># 输出转换后的文本</span><br><span class="line">print(ascii_text)</span><br></pre></td></tr></table></figure></p>
<h4 id="Python-列表推导-List-Comprehension"><a href="#Python-列表推导-List-Comprehension" class="headerlink" title="Python 列表推导(List Comprehension)"></a>Python 列表推导(List Comprehension)</h4><p>列表推导是一种简洁的方式来创建新的列表。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[expression for item in iterable if condition]</span><br></pre></td></tr></table></figure><br>其中 <code>expression</code> 是生成新列表中元素的表达式，<code>item</code> 是可迭代对象 <code>iterable</code> 中的元素.<br>下面是一些例子：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个包含1到10的平方的列表</span><br><span class="line">squares = [x**2 for x in range(1, 11)]</span><br><span class="line"></span><br><span class="line"># 将字符串列表中的所有字符串转换为大写</span><br><span class="line">words = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]</span><br><span class="line">uppercase_words = [word.upper() for word in words]</span><br><span class="line"></span><br><span class="line"># 筛选出一个列表中的偶数元素</span><br><span class="line">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">even_numbers = [x for x in numbers if x % 2 == 0]</span><br></pre></td></tr></table></figure></p>
<h4 id="Python-赋值"><a href="#Python-赋值" class="headerlink" title="Python 赋值"></a>Python 赋值</h4><p>在 Python 中，赋值分为两种情况：</p>
<ol>
<li>不可变对象(Immutable Objects)<br>包括数字、字符串、元组等不可修改的对象。对不可变对象的赋值是值传递（Pass by Value），意味着在赋值时会创建一个新的对象，并将其值赋给新的变量，而不是将原始对象的引用传递给新的变量。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 5</span><br><span class="line">y = x  # 这是值传递，y 拥有一个新的 5 的副本</span><br></pre></td></tr></table></figure></li>
<li>可变对象(Mutable Objects)<br>包括列表、字典、集合等可以修改的对象。对可变对象的赋值是地址传递（Pass by Reference），意味着在赋值时不会创建新的对象，而是将原始对象的引用传递给新的变量。因此，如果修改一个可变对象，会影响到所有引用它的变量。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list1 = [1, 2, 3]</span><br><span class="line">list2 = list1  # 这是地址传递，list2 和 list1 引用同一个列表对象</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Python-切片"><a href="#Python-切片" class="headerlink" title="Python 切片"></a>Python 切片</h4><p>切片是 Python 中非常强大的功能，可以用于许多不同的场景。</p>
<ol>
<li>提取子序列<br>可以提取列表、字符串或元组中的特定元素子集。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">subset = my_list[1:4]  # 提取索引1到索引3的元素，得到[2, 3, 4]</span><br></pre></td></tr></table></figure></li>
<li>复制切片<br>我们上面说了，Python 序列是址传递的，所以我们想复制序列的话不可以简单的 <code>list2 = list1</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">original_list = [1, 2, 3, 4, 5]</span><br><span class="line">copy_list = original_list[:]  # 创建一个原始列表的副本，修改 copy_list 不会影响到 original_list</span><br></pre></td></tr></table></figure></li>
<li>步进切片<br>我们可以指定一个步进值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">every_other = my_list[::2]  # 每隔一个元素提取，得到[1, 3, 5]</span><br></pre></td></tr></table></figure></li>
<li>字符串反转 or 序列 反转<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_string = &quot;Hello, World!&quot;</span><br><span class="line">substring = my_string[0:5]  # 提取前五个字符 &quot;Hello&quot;</span><br><span class="line">reversed_string = my_string[::-1]  # 字符串翻转</span><br></pre></td></tr></table></figure></li>
<li>删除元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">del my_list[1:3]  # 删除索引1到索引2的元素，my_list变为[1, 4, 5]</span><br></pre></td></tr></table></figure></li>
<li>替换元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">my_list[1:4] = [10, 20, 30]  # 替换索引1到索引3的元素，my_list变为[1, 10, 20, 30, 5]</span><br></pre></td></tr></table></figure></li>
<li>过滤数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_list = [1, 2, 3, 4, 5]</span><br><span class="line">filtered_list = [x for x in my_list if x % 2 == 0]  # 过滤偶数，得到[2, 4]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="字符串面值的赋值"><a href="#字符串面值的赋值" class="headerlink" title="字符串面值的赋值"></a>字符串面值的赋值</h4><p>字符串字面值是指在代码中直接以文本形式表示的字符串，通常用双引号括起来的一系列字符。字符串字面值在编程中用于表示固定的文本数据。例如，以下是一些字符串字面值的示例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Hello, World!&quot;</span><br><span class="line">&quot;This is a string literal.&quot;</span><br><span class="line">&quot;12345&quot;</span><br></pre></td></tr></table></figure><br>字符串面值通常是只读的，意味着我们不能对于它们的内容进行修改。<br><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9D%A2%E5%80%BC%E7%9A%84%E8%B5%8B%E5%80%BC.png" class=""></p>
<h4 id="关于-char-与-char"><a href="#关于-char-与-char" class="headerlink" title="关于 char[] 与 char*"></a>关于 char[] 与 char*</h4><h5 id="char"><a href="#char" class="headerlink" title="char[]"></a>char[]</h5><ul>
<li>它是一个字符数组，它在栈上分配内存，并且为数组内的每个元素分配空间。</li>
<li>当您使用字符串字面值来初始化字符数组时，编译器会自动为数组分配足够的空间来存储字符串字面值的内容，包括字符串结束符 ‘\0’(与指针直接指向字符串字面值的地址不同，数组是新创建一个空间，然后相当于在新的字符串空间中将字符串字面值给复制过去)。</li>
</ul>
<h5 id="char-1"><a href="#char-1" class="headerlink" title="char*"></a>char*</h5><ul>
<li>char* 是一个字符指针，只是指向一个字符的内存地址。</li>
<li>当我们使用字符串字面值来初始化数组时，实际上是将字符串字面值的地址赋给了指针(但是我们知道，字符串字面值通常只是只读的，所以说我们指针指向了那个地址也是无法修改字符串的值的，因此一般不这么写，编译器也会报警告)。</li>
<li>如果我们想使用 char* </li>
</ul>
<p>并且对于 char* 和 char[]，C/C++ 有一种约定成俗的习惯，使用 cout 输出时，会自动识别数组或者指针指向的字符串，并且输出字符串的内容直到遇到空字符 <code>&#39;\0&#39;</code> 停止。</p>
<p>这种行为是通过C/C++标准库中的重载运算符和内置函数来实现的，它们会自动迭代字符数组或指针，并输出字符直到遇到空字符。这使得输出字符串变得方便，无需显式循环来逐个字符输出。</p>
<p>同样的，不仅仅是对于 <code>cout</code>，对于 char 的一些函数如 <code>strlen</code>、<code>strcpy</code>，参数为 char<em> 的时候，同样也是遇到 <code>&#39;\0&#39;</code> 时停止函数操作(一般来说，这些函数是操作 `char</em><code>的，我们如果操作</code>char[]` 也是能操作的，因为 <strong>字符数组可以隐式转换为字符指针</strong>)。</p>
<p>如果我们实在想对于 <code>char*</code> 类型赋值，可以：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char* str = new char[20]; // 使用 new 动态分配 20 个字符的内存</span><br><span class="line"></span><br><span class="line">// 将字符串常值赋值给 str</span><br><span class="line">strcpy(str, &quot;Hello, World!&quot;);</span><br><span class="line"></span><br><span class="line">// 在不需要时记得释放内存</span><br><span class="line">delete[] str;</span><br></pre></td></tr></table></figure></p>
<h4 id="常见的-char-函数"><a href="#常见的-char-函数" class="headerlink" title="常见的 char* 函数"></a>常见的 char* 函数</h4><ol>
<li>字符串长度函数<br><code>strlen(const char* str)</code>: 返回字符串的长度，不包括空字符终止符。</li>
<li><code>strcpy(char* dest, const char* src)</code>: 将源字符串复制到目标字符串，包括空字符终止符。需要确保目标字符串有足够的空间来存储源字符串。<br><code>strncpy(char* dest, const char* src, size_t n)</code>: 将源字符串的前 n 个字符复制到目标字符串，可以控制复制的字符数。</li>
<li><code>strcat(char* dest, const char* src)</code>: 将源字符串连接到目标字符串的末尾，需要确保目标字符串有足够的空间来容纳源字符串</li>
<li><code>strcmp(const char* str1, const char* str2)</code>: 比较两个字符串，返回值表示它们的字典顺序关系。<br>请注意，使用这些函数时应格外小心，确保正确处理内存和边界情况，以避免安全漏洞和未定义的行为。</li>
</ol>
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/strcpy%E5%92%8Cstrdup.png" class="">
<img src="/2023/08/31/%E6%9D%82%E8%AE%B0/strdup%E4%BD%BF%E7%94%A8.png" class="">
<h4 id="endl-与-“-n”"><a href="#endl-与-“-n”" class="headerlink" title="endl 与 “\n”"></a>endl 与 “\n”</h4><img src="/2023/08/31/%E6%9D%82%E8%AE%B0/endl%E4%B8%8En.png" class="">
<h4 id="vector-创建二维数组"><a href="#vector-创建二维数组" class="headerlink" title="vector 创建二维数组"></a>vector 创建二维数组</h4><p>一次性定义：<br>此种方法适用于每一行的列数都相等的二维数组定义(与初始化)<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用vector一次性完成二维数组的定义（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br><span class="line"></span><br><span class="line">//以下是拆分理解</span><br><span class="line">//创建一维数组matirx，这个数组里有m个元素，元素是int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m);</span><br><span class="line">//除了定义数组类型及数组大小外，同时给数组中的元素赋值：将元素赋值为大小为n的int型vector。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n));</span><br><span class="line">//除了定义数组类型、数组大小、列的大小，同时给数组列中的元素（或者说，数组中的所有元素）赋值为-1。</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n, -1));</span><br></pre></td></tr></table></figure></p>
<p>插入元素型定义：<br>此种方法适用于每一行的列数都相等或不相等的二维数组的定义（与初始化）。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//比较具有普遍性的写法（注意：此种方法适用于每一行的列数相等的二维数组）</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;//创建一维数组matirx，这个数组里的元素是int型vector。</span><br><span class="line">int m = 3; //matrix有m行</span><br><span class="line">int n = 10; //matrix有n列</span><br><span class="line">int value = 1; //最终matrix成为二维数组后，其中每个元素的值为1（如果不需要进行初始化，此语句可以省略）</span><br><span class="line">for (int i = 0; i &lt; m; ++ i) &#123;</span><br><span class="line">    vector&lt;int&gt; tmp(n, value); //定义int型一维数组tmp，该数组有n个int型元素，且每个元素的初始值为value</span><br><span class="line">    matrix.push_back(tmp); //将一维数组tmp（小容器）加入matrix（大容器）中，使之成为matrix的元素，令matrix成为二维数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果需要每一行的列数不同（虽然一般很少这样做），也可以使用下面这种写法进行定义、初始化</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; matrix;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; a(10, 1); //单独定义每个小容器的元素个数和元素初始值</span><br><span class="line">vector&lt;int&gt; b(5, 2);</span><br><span class="line">vector&lt;int&gt; c(10, 3);</span><br><span class="line"></span><br><span class="line">matrix.push_back(a); //将每个小容器加入matrix（大容器）中</span><br><span class="line">matrix.push_back(b);</span><br><span class="line">matrix.push_back(c);</span><br></pre></td></tr></table></figure></p>
<h4 id="assign-函数分配与初始化"><a href="#assign-函数分配与初始化" class="headerlink" title="assign 函数分配与初始化"></a>assign 函数分配与初始化</h4><p>其实也可以使用 vector 的构造函数来初始化。</p>
<p>assign 函数主要用于重新分配 vector 元素并进行初始化。它的用法主要有两种：</p>
<ol>
<li>用迭代器范围进行分配：<br>assign 可以结构两个迭代器参数，从另一个容器或者序列中复制元素到当前 vector 中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">std::vector&lt;int&gt; anotherVec = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">vec.assign(anotherVec.begin(), anotherVec.end());</span><br></pre></td></tr></table></figure></li>
<li>用大小和值进行分配：<br>assign 函数也可以接受一个大小参数和一个值参数，用于将 std::vector 的大小更改为指定大小，并用指定的值填充所有新元素。这是一种用于重新分配 std::vector 并<strong>进行初始化的方法</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec(5, 42); // 就是将 vec 的大小设置为 5，每一项设置为 42</span><br><span class="line"></span><br><span class="line">std::vector&lt;vector&lt;int&gt;&gt; v(5, vector&lt;int&gt;(5, 0)); // 创建一个二维数组 v，其中是 5 行 5 列并且每一个元素都是 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="遍历-vector-的几种方式"><a href="#遍历-vector-的几种方式" class="headerlink" title="遍历 vector 的几种方式"></a>遍历 vector 的几种方式</h4><ol>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; v.size(); ++i)</span><br></pre></td></tr></table></figure></li>
<li>使用迭代器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it)</span><br></pre></td></tr></table></figure></li>
<li>使用 auto 关键字<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (auto iterator it = v.begin(); it != v.end(); ++it)</span><br><span class="line"></span><br><span class="line">for (const auto&amp; element : v)</span><br></pre></td></tr></table></figure>
关于为什么写成 <code>const auto&amp;</code> 可以避免拷贝(加快速度)，保持元素的不可变性。</li>
</ol>
<h4 id="关于-vector-迭代器"><a href="#关于-vector-迭代器" class="headerlink" title="关于 vector 迭代器"></a>关于 vector 迭代器</h4><p>vector 中迭代器是一个用于访问容器元素的抽象概念。它提供了一种通用的方式来遍历容器中的元素，而不依赖于容器的具体实现细节。<br>在 C++ 中，std::vector 提供了<strong>两种主要类型</strong>的迭代器：</p>
<ol>
<li>begin() 迭代器。这个迭代器指向容器中的第一个元素。</li>
<li>end() 迭代器。这个迭代器指向容器中<strong>最后一个元素的下一个位置</strong>。</li>
</ol>
<h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>主存指的是内存 RAM</p>
<h4 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h4><p>SSD 是固态硬盘 (Solid State Drive) 的缩写。与传统的机械硬盘（HDD）不同，SSD不包含可移动的机械部件，而是使用闪存存储技术来存储数据。这使得SSD在许多方面都具有一些显著的优势，包括：</p>
<ol>
<li>更快的速度：SSD比HDD更快，因为它们不需要旋转磁盘和寻道操作来读取数据。这意味着计算机可以更快地启动、加载应用程序和执行文件传输等任务</li>
<li>更低的能耗：由于没有旋转的机械部件，SSD消耗的能量较少，因此在笔记本电脑和移动设备中通常能够延长电池寿命。</li>
<li>更高的可靠性与更轻便<br>但是价格比较高。<br>HDD (Hard Disk Drive) 硬盘驱动器，有时候也成为硬盘或者机械硬盘</li>
</ol>
<h4 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h4><p>BIOS（基本输入/输出系统，Basic Input/Output System）是计算机系统中的一组固件程序，它们位于计算机的主板上的一个特殊芯片中，通常是闪存芯片。</p>
<ol>
<li>启动自检（POST）：在计算机启动时，BIOS会执行自检程序，检查计算机的硬件组件，如处理器、内存、硬盘、光驱等是否正常工作。如果发现问题，BIOS通常会发出蜂鸣声或显示错误信息，以指示问题的位置。</li>
<li>引导操作系统：一旦自检完成，BIOS会寻找可引导的设备，通常是硬盘驱动器或其他存储设备。它会加载操作系统的引导加载程序（Boot Loader），并将控制权转交给操作系统，使其能够继续启动过程。</li>
<li>设置硬件参数：BIOS还包括一组用户可配置的硬件设置，这些设置通常可通过计算机的BIOS设置界面进行调整。用户可以在BIOS中设置硬盘启动顺序、系统时间、密码保护等选项。</li>
<li>提供基本的输入/输出服务：BIOS提供了一些基本的输入/输出功能，以便在操作系统加载之前进行一些基本的操作，如键盘输入、显示输出和存储设备的读写。</li>
</ol>
<h4 id="Transistor-Transistor-Logic"><a href="#Transistor-Transistor-Logic" class="headerlink" title="Transistor-Transistor Logic"></a>Transistor-Transistor Logic</h4><p>在集成电路型号中，通常以 74 开头的数字代表它们属于标准的 Transistor-Transistor Logic<br>具体来说，”74” 表示了 TTL 系列中的特定子系列。TTL 门和触发器的型号通常以 “74” 开头，例如，”7400” 代表四输入 NAND 门，”74138” 代表 3-8 译码器/多路复用器，等等。</p>
<h4 id="vector-中的-find-函数"><a href="#vector-中的-find-函数" class="headerlink" title="vector 中的 find 函数"></a>vector 中的 find 函数</h4><p><strong>find 函数是在 <code>algorithm</code> 中的，不写的话会报错，血的教训。</strong><br>C++ 标准库中的 <code>std::find()</code> 函数可以用来在容器 (包括 std::vector) 中查找特定值的位置。它的用法如下：<br><figure class="highlight plaintext"><figcaption><span><algorithm></span><a href="//">必须包含这个头文件</a></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; myVector = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int targetValue = 3;</span><br><span class="line"></span><br><span class="line">// 使用std::find查找特定值</span><br><span class="line">auto it = std::find(myVector.begin(), myVector.end(), targetValue);</span><br><span class="line"></span><br><span class="line">if (it != myVector.end()) &#123;</span><br><span class="line">    // 找到了目标值</span><br><span class="line">    // &#x27;it&#x27; 是一个迭代器，指向找到的元素的位置</span><br><span class="line">    // 在这里，它指向了值为3的元素</span><br><span class="line">    cout &lt;&lt; &quot;找到了目标值: &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 没找到目标值</span><br><span class="line">    cout &lt;&lt; &quot;未找到目标值&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>std::find函数的返回类型是一个迭代器（iterator），它是一个指向容器中找到的元素的位置的指针。</p>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>string 中也是有着迭代器的</p>
<h4 id="电源适配器-power-adapter"><a href="#电源适配器-power-adapter" class="headerlink" title="电源适配器 power adapter"></a>电源适配器 power adapter</h4><p>提到电源适配器可能很多人都不知道这是什么东西，如果说笔记本电脑充电线上那个长方形的配件或者说手机充电器大家倒是常见，是的，那个就是电源适配器，电源适配器（Power adapter）又叫外置电源，是小型便携式电子设备及电子电器的供电电压变换设备，常见于手机、液晶显示器和笔记本电脑等小型电子产品上。<br>它的作用是将家里的220伏高电压转换成这些电子产品能工作的5伏至20伏左右稳定的低电压，使他们能正常工作,一般由外壳、变压器、电感、电容、控制IC、PCB板等元器件组成，它的工作原理由交流输入转换为直流输出</p>
]]></content>
      <tags>
        <tag>Miscellaneous</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS记录</title>
    <url>/2023/09/01/CSS%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h4><p><code>style</code> 是 CSS 的属性名<br>在 CSS 中名-值对中间用 <code>:</code><br><code>font-size: xx px;</code> 可以设置字体大小<br>一般不推荐使用行内样式，不能复用并且不利于维护。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1 style=&quot;color: red; font-size: 50px;&quot;&gt;Hello World&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h4><p>在 <code>&lt;head&gt;</code> 标签或者 <code>&lt;body&gt;</code> 标签中加一个 <code>&lt;style&gt;</code> 标签(不过一般都是写在 <code>head</code> 里面)。</p>
<h4 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h4><p>可以新建一个 <code>xxx.css</code> 文件，然后在 HTML 文件的 <code>&lt;head&gt;</code> 标签中加一个 <code>&lt;link&gt;</code> 标签<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx.css&quot;&gt;</span><br></pre></td></tr></table></figure><br>其中 <code>rel</code> 是 <code>relation</code> 的缩写，就是说 <code>href</code> 的文件和当前 HTML 文件的关系。</p>
<h4 id="样式优先级"><a href="#样式优先级" class="headerlink" title="样式优先级"></a>样式优先级</h4><p>行内样式的优先级 &gt; 内部样式<br>对于内部样式和外部样式，它俩平级，但是后来者居上，也就是说，谁写在后面，就是展现谁的样式。</p>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><ol>
<li><p>通配选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器：在标签中添加属性 <code>class=&quot;xxx&quot;</code>，注意在 <code>style</code> 中的格式，需要在 <code>xxx</code> 前面加一个 <code>.</code>，来区分类名和标签名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要是一个标签属于两个 <code>class</code> 的话，写成 <code>class=&quot;xxx yyy&quot;</code> 的格式，而不是分开写两个 <code>class</code>，那样的话后一个 <code>class</code> 会被忽略。</p>
</li>
<li><p>ID 选择器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>交集选择器：<br>就是将两个选择器紧紧的写在一起。如果交集选择器中有元素，元素必须在开头(因为字母放在最后会引起单词的歧义)，并且我们交集的条件可以是多个。<br><code>id</code> 选择器理论上可以作为交集选择器，但是我们的 <code>id</code> 是唯一的，已经可以唯一定义了，所以一般就是 <code>class</code> 和标签一起写。<br>同时也不存在两个元素同时在标签选择器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p.xxx &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并集选择器<br>就是在不同选择器之间加上逗号 <code>,</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,.beauty,.dog,.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这样写的话，逗号和点写在一起看起来有些乱，我们一般竖着写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rich,</span><br><span class="line">.beauty,</span><br><span class="line">.dog,</span><br><span class="line">.pig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后代选择器<br>比如说 <code>ul</code> 中的所有 <code>li</code>，中间直接空格就可以。但是除了选择了儿子以外，孙子 <code>li</code> 也被选择了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul li &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子代选择器<br><code>div</code> 标签中的子代 <code>a</code> 标签(排除了孙子等标签，只有儿子)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div&gt;a &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>兄弟选择器<br>用 <code>+</code> 连接，只有紧紧相邻的兄弟，如果 <code>div</code> 紧紧相邻的没有 <code>p</code>，但是有 <code>p</code> 中间隔了别的标签，也不不起作用的。(睡在我下铺的兄弟) 相邻兄弟选择器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div+p &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 <code>div~p &#123;&#125;</code> 就是 <code>div</code> 的所有兄弟 <code>p</code>，而不是紧紧相邻的了。</p>
</li>
<li><p>属性选择器<br><code>[title] &#123;&#125;</code> 选择具有 <code>title</code> 属性的标签<br><code>[title=&quot;xxx&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是 <code>xxx</code> 的标签。<br><code>[title^=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是以 <code>a</code> 开头的标签。<br><code>[title$=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容是以 <code>a</code> 结尾的标签。<br><code>[title*=&quot;a&quot;] &#123;&#125;</code> 选择具有 <code>title</code> 属性并且属性内容中含有 <code>a</code> 的标签</p>
</li>
</ol>
<h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>可以理解为是对于元素的状态的一种描述。比如，已经访问过的超链接和未访问过的超链接，就是加一个冒号，后面就是元素的状态<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">a:visited &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ol>
<li>层叠性<br>如果样式发生了冲突，就会根据一定的规则(选择器优先级)，进行样式层叠(覆盖)。(当权重一样的时候，我们才考虑在代码中的顺序)</li>
<li>继承性<br>元素会自动拥有其父元素、或者祖先元素上设置的<strong>某些样式</strong>，优先继承离得最近的。<br>常见的可继承属性：<code>test-?? font-?? line-?? color</code></li>
<li>优先级<br><code>!important &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 元素选择器 &gt; * &gt; 继承的样式</code></li>
</ol>
<h4 id="像素-Pixel"><a href="#像素-Pixel" class="headerlink" title="像素 Pixel"></a>像素 Pixel</h4><p>虽然 <code>cm</code> 和 <code>mm</code> 这两个单位也可以用在网页中，但是对于网页来说，这两个单位不够精细。所以我们就是用 <code>px</code> 这个单位(是 Pixel 的缩写)，因为它很小，所以很精细。<br><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%83%8F%E7%B4%A0.png" class=""><br>可以看出来，虽然电脑屏幕一般大小，但是右边的像素多，所以每一个像素的大小就小。所以像素我们不确定多么大，需要看屏幕，它是一个相对单位。<br>像素点越小，呈现出来的图片就越细腻，越清晰</p>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ol>
<li>颜色名<br>但是它太有限了，并且不是很精确，所以开发的时候一般不用。</li>
<li>RGB 或者 RGBA<br>RGB 中三个字母分别是 RED GREEN BLUE(范围都是从 0 到 255)<br><code>rgb(xx, xx, xx);</code><br><code>rgba(xx, xx, xx, xx);</code> 前三位和 <code>rgb</code> 相同，最后一位是透明度，范围是 0 - 1。</li>
<li>HEX 或者 HEXA<br><code>#xxxxxx</code> 井号后面一共六位，每一位都是十六进制的数字，每两位组合起来分别表示红、绿、蓝<br>然后 HEXA 就像 RGBA，就是添加了一个透明度，它也是用两位十六进制来表示，也就是说一共八位。</li>
<li>HSL 或者 HSLA<br>这两个东西用的不是很多。<br><code>hsl(hue, saturation, lightness);</code> 色相、饱和度、亮度<br><code>Hue</code> 在这里是用角度表示的，写为 <code>xxdeg</code><br>HELA 就是 <code>hsl(hue, saturation, lightness, xx);</code> 最后一位 0 - 1 表示透明度。<img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E8%89%B2%E7%9B%B8%E7%8E%AF.png" class="">
</li>
</ol>
<h4 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h4><p><code>font-family: &quot;xxx&quot;;</code> 字体族，其实就是字体样式。通常情况下，把字体分为两大类。第一类是衬线字体，第二类是非衬线字体。衬线字体的横竖撇捺特别有棱角，目前写网页还是非衬线字体比较多。</p>
<p><code>font-style: xxx;</code> 字体风格。默认为 <code>normal</code>，斜体是 <code>italic</code></p>
<p><code>font-weight:xxx;</code> 字体粗细，参数为 <code>lighter normal bold bolder</code>，或者写 100 - 1000 的数字，数字越大越粗。</p>
<h4 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h4><p><code>letter-spacing:xxx px;</code> 字母间距(汉字被认为是字母)<br><code>word-spacing:xxx px;</code> 词间距<br><code>text-decoration:xxx;</code> 文本修饰 <code>overline underline line-through</code> 还可以改为波浪线等形式，并且也可以改颜色。<br><code>text-indent:xx;</code> 文本缩进<br><code>text-align:xxx;</code> <code>xxx</code> 可以是 <code>left center right</code> 就是靠哪里对齐。<br><code>line-height:xxx;</code> 调整行高，就是上下之间的距离变大，但是字体的大小不变。其中 <code>xxx</code> 可以为像素、也可以写一个数字，表示是 <code>font-size</code> 的多少倍，也可以写成百分比，表示是 <code>font-size</code> 的多少倍。<br><code>vertical-align:xxx;</code> <code>xxx</code> 可以是 <code>top baseline bottom middle</code> </p>
<h4 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h4><p><code>list-style-type:xxx;</code> <code>xxx</code> 可以是 <code>none square lower-roman upper-roman decimal</code><br><code>list-style-position:xxx;</code> 可以是 <code>inside outside</code><br><code>list-style-image:xxx;</code> 找一个图片，自定义前面的点。</p>
<h4 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h4><p><code>border-width:xxx px;</code> 宽度<br><code>border-color:xxx;</code> 颜色<br><code>border-style:xxx;</code> 样式<br>边框的相关属性，不仅仅是表格可以使用，其他元素如 <code>h1 p</code> 也可以使用。<br><code>table-layout:fixed;</code> 可以控制表格的列宽。<br><code>border-spacing:xxx px;</code> 控制单元格之间的距离。<br><code>borer-collapse: collapse;</code> 合并相邻单元格的标签。写了合并以后，上面的 <code>border-spacing:xxx;</code> 无论 <code>xx</code> 是多少都失效了。<br><code>empty-cells: show / hide;</code> 隐藏没有内容的单元格。<br><code>caption-side:xxx;</code> 设置表格标题的位置，可以是 <code>top bottom</code></p>
<h4 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h4><p><code>background-color:xxx;</code><br><code>background-repeat:repeat / no-repeat / repeat-y / repeat-x;</code> 如果图片较小，是否重复显示<br><code>background-image:xxx;</code><br><code>background-position:xxx;</code> 可以控制背景图片的位置。<code>xxx</code> 可以是 <code>left top / left bottom / left center / xx px xx px</code></p>
<h4 id="鼠标属性"><a href="#鼠标属性" class="headerlink" title="鼠标属性"></a>鼠标属性</h4><p><code>cursor:xxx;</code> 参数可以为 <code>pointer / move / wait / crosshair / help</code><br><code>cursor: url(&quot;xxx&quot;),pointer;</code> 其中 <code>xx</code> 是一个图片的地址，此时鼠标的样式就变为了图片的样子。</p>
<h4 id="CSS-常用的长度单位"><a href="#CSS-常用的长度单位" class="headerlink" title="CSS 常用的长度单位"></a>CSS 常用的长度单位</h4><ol>
<li><code>px</code></li>
<li><code>em</code> 相当于当前元素的 <code>font-size</code> 的倍数。如果自己没有就沿着父元素一直网上找，如果都没有，就是用默认的。</li>
<li><code>rem</code> r 是 root 的意思。相对于根元素的 <code>font-size</code> 的倍数，如果没有，就使用默认的。</li>
<li><code>%</code> 相对于父元素计算。</li>
</ol>
<h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ol>
<li>块元素 block<br>在页面中独占一行，不会与任何元素共占一行，是从上到下排列的。<br>默认宽度就是撑满父级元素，高度由内容决定。</li>
<li>行内元素 inline<br>在页面中不是独占一行，一行中不能容下的行内元素，会在下一行继续从左到右排列。<br>默认宽度和高度都是由内容决定。<br>但是 <strong>无法通过 CSS 设置宽和高。</strong><br>最具有代表性的其实就是 <code>&lt;span&gt;</code></li>
<li>行内块元素 inline-block<br>又叫做内联块元素。在页面中不独占一行，会在下一行继续从左到右排列。<br>默认宽度和高度都是由内容决定。<br><strong>可以通过 CSS 设置宽和高。</strong><br>最具代表性的其实是 <code>&lt;img&gt;</code><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%90%84%E5%85%83%E7%B4%A0%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F.png" class="">
</li>
</ol>
<h5 id="修改元素的显示模式"><a href="#修改元素的显示模式" class="headerlink" title="修改元素的显示模式"></a>修改元素的显示模式</h5><p>上面是各种元素的默认显示形式，不过我们可以在 CSS 中修改 <code>display</code> 属性来调整它的显示形式。<br><code>display: block / inline-block / inline;</code> 如果是 <code>display: none;</code> 那么这个元素就直接不显示了，并且也不会占用网页的空间。</p>
<h5 id="盒子模型的组成部分"><a href="#盒子模型的组成部分" class="headerlink" title="盒子模型的组成部分"></a>盒子模型的组成部分</h5><p>我们设置的背景颜色会填充内边距区域，也会填充边框区域。<br>外边距不会影响盒子大小，只会影响其位置。<br><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%88%86%E5%8C%BA.png" class=""></p>
<p><code>width-min width-max height-min height-max padding-left padding-top padding-bottom padding-right</code></p>
<p><code>border</code> 的属性同样也可以是 <code>border-left-width border-left-style ...</code></p>
<p><code>margin</code> 的属性可以同 <code>padding</code> 一样修改。</p>
<h4 id="处理溢出"><a href="#处理溢出" class="headerlink" title="处理溢出"></a>处理溢出</h4><p><code>overflow: hidden;</code> 直接隐藏，还可以写 <code>scroll auto</code> 默认是 <code>visible</code>，也可以 x y 方向分开处理，就是写成 <code>overflow-x</code> 和 <code>overflow-y</code></p>
<h4 id="隐藏元素的方式"><a href="#隐藏元素的方式" class="headerlink" title="隐藏元素的方式"></a>隐藏元素的方式</h4><ol>
<li>就是 <code>display: none;</code> 通过这种方式隐藏的元素不会再去占据页面的位置。</li>
<li>有一个属性专门控制元素的显示 <code>visibility: show;</code> 默认是 <code>show</code>，如果想隐藏就改为 <code>hidden</code>。不过通过这种方式隐藏的仍然会占位。</li>
</ol>
<p>一个关于开发者模式四个分区作用的说明。<br><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F.png" class=""><br><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7.png" class=""></p>
<h4 id="浮动-float"><a href="#浮动-float" class="headerlink" title="浮动 float"></a>浮动 float</h4><p>浮动最早期设计出来是为了实现文字环绕图片或者说文字环绕文字。现在浮动是主流的页面布局方式之一。</p>
<ol>
<li>给第一个子元素设置 <code>margin-top</code> 会被父元素抢走，但是如果这个子元素浮动以后，就不会这样了。</li>
<li>浮动后的元素不会被当作文本处理了(行内和行内块都会被当作文本处理)</li>
<li>脱离文档流</li>
<li>不会独占一行，可以共用一行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            this is a test.</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line">            .outer &#123;</span><br><span class="line">                background-color: gray;</span><br><span class="line">                border: black 1px solid;</span><br><span class="line">            &#125;</span><br><span class="line">            .box &#123;</span><br><span class="line">                margin: 10px;</span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">                background-color: skyblue;</span><br><span class="line">                border: solid black 1px;</span><br><span class="line">            &#125;</span><br><span class="line">            .box1 &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;box box1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;box box3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>浮动之后，盒子因为脱离了标准文档流，它撑不起父盒子的高度，导致父盒子高度塌陷</p>
<h5 id="清除浮动带来影响的方式"><a href="#清除浮动带来影响的方式" class="headerlink" title="清除浮动带来影响的方式"></a>清除浮动带来影响的方式</h5><ol>
<li>父盒子设置固定高度<br>虽然，给父盒子设置了固定高度能暂时解决我们的问题，但是它的使用不灵活，如果未来子盒子的高度需求发生了改变(网页的多处地方)，那么我们得手动需要更改父盒子的高度。后期不易维护。</li>
<li>内墙法<br>所谓内墙法,有一个规则:在浮动元素的后面加一个空的块级元素(通常是div),并且该元素设置clear:both；属性。<br>clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。</li>
<li>伪元素清除法<br><a href="https://juejin.cn/post/6886247611318140942">https://juejin.cn/post/6886247611318140942</a><br>在最后补加一个没有实际意义的块元素 <code>div</code>，然后添加 <code>div</code> 的 CSS 属性 <code>clear: both;</code>，这个块元素没有高，没有宽，没有内容，就是专门用来撑起父元素。<br>或者更加优雅写成<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxx::after &#123;</span><br><span class="line">    content: &#x27;&#x27;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中 <code>content: &#39;&#39;</code> 表示元素为空，<code>display: block</code> 才能撑起父元素(因为另起一行了)，<code>clear: both;</code> 就是消除之前的浮动带来的所有影响。</li>
<li><code>overflow: hidden;</code></li>
</ol>
<h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><p>开启相对定位的元素并未脱离文档流。<br>如果一个元素开启了定位，那么它的层级就比普通元素的层级高。<br>相对定位：</p>
<ol>
<li>对于元素的位置进行微调。</li>
<li>配合绝对定位</li>
</ol>
<p>绝对定位：</p>
<ol>
<li>一旦开启绝对定位，就脱离了文档流。</li>
<li>绝对定位参考的点是它的包含块。<br> 对于没有脱离文档流的元素，它的父元素就是它的包含块。<br> 对于脱离文档流的元素，它的第一个开启定位的祖先元素就是它的包含块。</li>
<li>不论是块元素、行内元素还是行内块元素，只要进行了绝对定位，就变成了<strong>定位元素</strong><br> 定位元素：<ol>
<li>默认被内容撑开。</li>
<li>但是也是可以进行设置的。</li>
</ol>
</li>
</ol>
<p>固定定位：<br>就是直接对于视口定位。</p>
<ol>
<li>并且元素变成了定位元素。</li>
<li>脱离了文档流。</li>
</ol>
<p>粘性定位：<br><code>position: sticky;</code><br>参考点是离它最近的拥有滚动行为的祖先元素。包含粘性定位元素的父容器也不在视图上时，胶水就失效了。</p>
<p>这几个定位的层级是平等的。</p>
<h4 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h4><p>属性 <code>z-index</code>(纯数值，没有单位) 就相当于 <code>z</code> 轴上的坐标，<code>z</code> 越大，层级越高，所以在屏幕上显示的优先级越高。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>版心的大小一般是 900 - 1200 px<br><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E5%90%8D%E8%AF%8D.png" class=""></p>
<h4 id="重置默认样式"><a href="#重置默认样式" class="headerlink" title="重置默认样式"></a>重置默认样式</h4><ol>
<li>使用全局选择器<br>在简单的案例中，我们可能使用这种方式，但是实际开发中我们不会使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* &#123; padding: 0px; margin: 0px; &#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>reset.css</code> 可以是自己一直以来的一个标准模板，也可以是使用一些公司开源的自己的 <code>reset.css</code>(比如小米、阿里…)</li>
<li><code>Normalize.css</code> 是一种最新方案，它再清楚默认样式的基础上，保留了一些有价值的默认样式。<br>这是一个标准化的东西，有很多的网站和用户去维护这个东西。<br><a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></li>
</ol>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><img src="/2023/09/01/CSS%E8%AE%B0%E5%BD%95/%E7%BB%83%E4%B9%A01.png" class="">
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            padding: 0px;</span><br><span class="line">        &#125;</span><br><span class="line">        .leftfix &#123;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .rightfix &#123;</span><br><span class="line">            float: right;</span><br><span class="line">        &#125;</span><br><span class="line">        .clearfix &#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        .container &#123;</span><br><span class="line">            margin: 0 auto;</span><br><span class="line">            width: 960px;</span><br><span class="line">            text-align: center;</span><br><span class="line">        &#125;</span><br><span class="line">        .top-header &#123;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 80px; </span><br><span class="line">        &#125;</span><br><span class="line">        .logo,</span><br><span class="line">        .banner1,</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 80px;</span><br><span class="line">            line-height: 80px;</span><br><span class="line">        &#125;</span><br><span class="line">        .logo &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner2 &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        .banner1 &#123;</span><br><span class="line">            width: 540px;</span><br><span class="line">            margin: 0 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .menu &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            height: 30px;</span><br><span class="line">            margin: 10px auto;</span><br><span class="line">            line-height: 30px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item1,</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            height: 198px;</span><br><span class="line">            width: 368px;</span><br><span class="line">            border: solid black 1px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item2 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">            margin-right: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item3,</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            width: 178px;</span><br><span class="line">            height: 198px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            line-height: 198px;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item4,</span><br><span class="line">        .item5,</span><br><span class="line">        .item6 &#123;</span><br><span class="line">            margin-left: 10px;</span><br><span class="line">        &#125;</span><br><span class="line">        .item7,</span><br><span class="line">        .item8,</span><br><span class="line">        .item9 &#123;</span><br><span class="line">            width: 198px;</span><br><span class="line">            height: 128px;</span><br><span class="line">            border: 1px solid black;</span><br><span class="line">            margin-bottom: 10px;</span><br><span class="line">            line-height: 128px;</span><br><span class="line">        &#125;</span><br><span class="line">        .footer &#123;</span><br><span class="line">            background-color: gray;</span><br><span class="line">            width: 960px;</span><br><span class="line">            height: 60px;</span><br><span class="line">            line-height: 60px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;!--header--&gt;</span><br><span class="line">        &lt;div class=&quot;top-header clearfix&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;logo leftfix&quot;&gt;</span><br><span class="line">                logo</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner1 leftfix&quot;&gt;</span><br><span class="line">                banner1</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=&quot;banner2 leftfix&quot;&gt;</span><br><span class="line">                banner2</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--menu--&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            菜单</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--content--&gt;</span><br><span class="line">        &lt;div class=&quot;content clearfix&quot;&gt;</span><br><span class="line">            &lt;!--left--&gt;</span><br><span class="line">            &lt;div class=&quot;left-content leftfix&quot;&gt;</span><br><span class="line">                &lt;!--top--&gt;</span><br><span class="line">                &lt;div class=&quot;top-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item1 leftfix&quot;&gt;</span><br><span class="line">                        栏目一</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item2 leftfix&quot;&gt;</span><br><span class="line">                        栏目二</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;!--bottom--&gt;</span><br><span class="line">                &lt;div class=&quot;bottom-content clearfix&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;item3 leftfix&quot;&gt;栏目三&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item4 leftfix&quot;&gt;栏目四&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item5 leftfix&quot;&gt;栏目五&lt;/div&gt;</span><br><span class="line">                    &lt;div class=&quot;item6 leftfix&quot;&gt;栏目六&lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--right--&gt;</span><br><span class="line">            &lt;div class=&quot;right-content leftfix&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;item7&quot;&gt;栏目七&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item8&quot;&gt;栏目八&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;item9&quot;&gt;栏目九&lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;!--footer--&gt;</span><br><span class="line">        &lt;div class=&quot;footer&quot;&gt;</span><br><span class="line">            页脚</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>调整背景图的位置用 <code>background-position:xxx;</code></p>
<p>布局里面，一堆东西横向排列一堆东西纵向排列，而且这一堆东西还很相似，往往我们都用 ul li</p>
<p>大多数情况都是给子元素开启固定定位，给父元素开启相对定位。</p>
<p>img 方式引入图片的话，我们不需要给出宽和高，就是图片默认的宽和高。但是 <code>div</code> 设置图片背景的时候，<code>div</code> 必须先有宽和高，才能显示图片。</p>
]]></content>
      <tags>
        <tag>CSS, WEB</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫</title>
    <url>/2023/09/04/python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h4 id="识别网页所用技术"><a href="#识别网页所用技术" class="headerlink" title="识别网页所用技术"></a>识别网页所用技术</h4><p>构建网站所用的技术类型会对我们如何爬取信息产生影响。有一个十分有用的工具可以检查网站构建的技术类型—detectem 模块，该模块需要 python3.5+ 环境以及 Docker</p>
<h4 id="python-读写文件"><a href="#python-读写文件" class="headerlink" title="python 读写文件"></a>python 读写文件</h4><ol>
<li>open() + close()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先打开文件：</span><br><span class="line">f = open(&#x27;C:\\Users\\Administrator\\Desktop\\测试文件.txt&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;)</span><br><span class="line"></span><br><span class="line">#再使用read()方法，查看文件里的内容：</span><br><span class="line">print(f.read())</span><br><span class="line"></span><br><span class="line">$关闭文件</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
注意如果使用 <code>open</code>，结尾一定要使用close（）来关闭文件。原因主要是：</li>
</ol>
<ul>
<li>节约资源和内存耗损；</li>
<li>可以释放所占用的系统资源并尽早将文件置于更安全的状态，只有关闭文件后，文件内容才能同步到磁盘。</li>
</ul>
<ol>
<li><code>with open</code> 推荐使用<br>with 的作用相当于调用close（）方法，因此当我们使用with open( )在对文件操作完成后，无需通过close()关闭文件，文件会自动关闭，这种方法的安全系数更高，同时也避免了有些时候忘记关闭文件的毛病。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;file_name&#x27;,&#x27;r&#x27;,encoding = &#x27;utf-8&#x27;) as f:</span><br></pre></td></tr></table></figure>
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class="">
<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B.png" class="">
</li>
</ol>
<h4 id="python-requests-模块"><a href="#python-requests-模块" class="headerlink" title="python requests 模块"></a>python requests 模块</h4><p>python requests 是一个常用的 HTTP 请求库，可以方便地向网站发送 HTTP 请求，并获取响应结果。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response = requests.get(url=url, headers=headers)</span><br></pre></td></tr></table></figure><br>返回一个 response 对象，该对象包含了具体的响应信息，如状态码、响应头(200 OK 404 NotFound)、响应内容等。<br>对于其中的content 和 text 属性</p>
<blockquote>
<p>content中间存的是字节码，而text中存的是Beautifulsoup根据猜测的编码方式将content内容编码成字符串。直接输出content，会发现前面存在b’这样的标志，这是字节字符串的标志，而text是，没有前面的b,对于纯ascii码，这两个可以说一模一样，对于其他的文字，需要正确编码才能正常显示。大部分情况建议使用.text，因为显示的是汉字，但有时会显示乱码，这时需要用.content.decode(‘utf-8’)，中文常用utf-8和GBK，GB2312等。这样可以手工选择文字编码方式。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 发送GET请求</span><br><span class="line">url = &#x27;https://example.com/some-page&#x27;</span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"># 尝试获取内容的编码方式</span><br><span class="line">encoding = response.apparent_encoding ## 来尝试获取爬取内容的编码方式。这个属性会尝试根据响应内容来猜测编码方式，通常用于解决服务器没有显式提供编码信息的情况。</span><br><span class="line"></span><br><span class="line"># 设置编码方式并解码内容</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line"></span><br><span class="line"># 打印内容</span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们一般可以爬取网页的 <code>html</code> 代码。</p>
<h4 id="python-标准库-os-模块"><a href="#python-标准库-os-模块" class="headerlink" title="python 标准库 os 模块"></a>python 标准库 os 模块</h4><p>Python的os模块是一个用于与操作系统交互的内置模块。它提供了许多功能，允许你执行各种文件和目录操作，例如创建、删除、移动和重命名文件和目录，以及检查文件和目录的属性。下面是一些os模块的常见用法和功能：</p>
<ol>
<li>获取当前工作目录(current work directory)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current_directory = os.getcwd()</span><br><span class="line">print(current_directory)</span><br></pre></td></tr></table></figure></li>
<li>列出目录中的文件和子目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">files_and_dirs = os.listdir(&#x27;/path/to/directory&#x27;)</span><br><span class="line">print(files_and_dirs)</span><br></pre></td></tr></table></figure></li>
<li>创建目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.mkdir(&#x27;/path/to/new_directory&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>删除目录<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.rmdir(&#x27;/path/to/directory_to_delete&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>检查文件或者目录是否存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if os.path.exists(&#x27;/path/to/file_or_directory&#x27;):</span><br><span class="line">    print(&quot;存在&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;不存在&quot;)</span><br></pre></td></tr></table></figure>
其他 os 模块<img src="/2023/09/04/python%E7%88%AC%E8%99%AB/os%E6%A8%A1%E5%9D%97.png" class=""> 
</li>
</ol>
<h4 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h4><p>XPath（XML Path Language）是一种用于在XML文档中定位和选择元素的查询语言。它是一种重要的标准，广泛用于XML文档的解析和数据提取。XPath不仅可以用于XML文档，还可以用于HTML文档，因此它在Web开发和数据抓取中也非常有用。 (感觉可能类似于正则表达式？只是另一种不同的方式)<br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/xpath.png" class=""><br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E6%9C%AA%E7%9F%A5%E8%8A%82%E7%82%B9.png" class=""></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><code>Regular Expression</code> 或者简称 <code>regex, RE</code>.<br>它的设计思想是用一种<strong>描述性的语言</strong>来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<h4 id="RE-库"><a href="#RE-库" class="headerlink" title="RE 库"></a>RE 库</h4><p>RE 库就是正则表达式库，通过 RE 库我们可以匹配某些特定字符串的一些内容，比如爬虫爬取网页的时候，通过 RE 库可以获取网页内容中的某些特定标签内容。<br>量词：<br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%87%8F%E8%AF%8D.png" class=""><br>字符类：</p>
<ul>
<li><code>[]</code>: 匹配括号内的任意一个字符。例如 <code>[abc]</code> 匹配字符 a、b 或者 c</li>
<li><code>[^ ]</code>: 匹配括号内字符以外的任意一个字符。例如 <sup><a href="#fn_abc" id="reffn_abc">abc</a></sup> 就是除了 a、b或者c以外的任意字符。 <img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png" class="">
</li>
</ul>
<h5 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h5><ul>
<li><code>re.search(pattern, string, flags=0)</code> 在字符串中搜索第一个匹配的模式，并返回一个匹配对象。</li>
<li><code>re.match(pattern, string, flags=0)</code> 在字符串的开头匹配模式，并返回一个匹配对象。</li>
<li><code>re.findall(pattern, string, flags=0)</code> 返回一个包含所有匹配项的列表。</li>
<li><code>re.sub(pattern, repl, string, count=0, flags=0)</code> 用指定的替换字符串替换匹配的文本。</li>
<li><code>re.split(pattern, string, maxsplit=0, flags=0)</code> 根据模式拆分字符串。<br>其中 <code>flags</code> 是标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。<blockquote>
<p>在Python中，前缀r表示一个原始字符串（raw string）。原始字符串中的反斜杠字符\会被当作普通字符处理，而不会被解释为转义字符。这在处理正则表达式等包含大量反斜杠的字符串时非常有用，因为正则表达式模式本身通常包含许多反斜杠，这些反斜杠需要被保留而不被解释为转义字符。</p>
</blockquote>
</li>
</ul>
<h4 id="python-爬取图片简单示例"><a href="#python-爬取图片简单示例" class="headerlink" title="python 爬取图片简单示例"></a>python 爬取图片简单示例</h4><p>我们打开一个下载图片的网址 <a href="https://pic.netbian.com/new/">https://pic.netbian.com/new/</a><br>我们向这个网站发送请求以后获得的 <code>text</code> 就是网站的 <code>html</code> 代码。我们分析一下其中的 <code>html</code> 代码<br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/html%E4%BB%A3%E7%A0%81.png" class=""><br>其中的 <code>/uploads/allimg/xxx</code> 就是我们的图片的具体地址。<br>我们可以使用正则表达式(re 库)来获取 <code>html</code> 代码中所有符合图片格式的地址，然后存储到 <code>img</code> 中。再向图片的具体地址发送请求，此时我们使用 python 的文件读写(二进制模式)，就可以批量地将图片下载下来了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url = &quot;https://pic.netbian.com/&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encoding = response.apparent_encoding</span><br><span class="line">content = response.content</span><br><span class="line">text = content.decode(encoding)</span><br><span class="line">parr = re.compile(&#x27;src=&quot;(/u.*?)&quot;.alt=&quot;(.*?)&quot;&#x27;) # 匹配图片链接和图片名字 使用正则表达式</span><br><span class="line">image = re.findall(parr, text) # 所有的图片链接</span><br><span class="line">path = &quot;photos&quot;</span><br><span class="line">if not os.path.isdir(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">for i in image:</span><br><span class="line">    link = i[0]</span><br><span class="line">    name = i[1]</span><br><span class="line">    with open(path+&quot;/&#123;name&#125;.jpg&quot;.format(name),&quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https://pic.netbian.com&quot; + link)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(name+&quot;.jpg 获取成功......&quot;)</span><br></pre></td></tr></table></figure><br>爬取王者荣耀头像，感觉写的很丑很傻。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">url = &quot;https://pvp.qq.com/web201605/herolist.shtml&quot;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, &quot;</span><br><span class="line">                  &quot;like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&quot;</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, headers=headers)</span><br><span class="line">encode = response.apparent_encoding</span><br><span class="line">text = response.content.decode(encode)</span><br><span class="line">pattern = re.compile(r&#x27;(//game.+\.jpg)&#x27;)</span><br><span class="line">pattern1 = re.compile(r&#x27;alt=&quot;(.+?)&quot;&#x27;)</span><br><span class="line">images = re.findall(pattern, text)</span><br><span class="line">names = re.findall(pattern1, text)</span><br><span class="line">path = &quot;heroes&quot;</span><br><span class="line">if not os.path.exists(path):</span><br><span class="line">    os.mkdir(path)</span><br><span class="line">cnt = 0</span><br><span class="line">for element in images:</span><br><span class="line">    cur = element</span><br><span class="line">    with open(path + &quot;/&#123;&#125;.jpg&quot;.format(names[cnt]), &quot;wb&quot;) as img:</span><br><span class="line">        res = requests.get(&quot;https:&quot; + cur)</span><br><span class="line">        img.write(res.content)</span><br><span class="line">        img.close()</span><br><span class="line">    print(&quot;捕获成功&quot;)</span><br><span class="line">    cnt = cnt + 1</span><br></pre></td></tr></table></figure></p>
<h4 id="lxml-库"><a href="#lxml-库" class="headerlink" title="lxml 库"></a>lxml 库</h4><p>lxml 库是一个使用 python 编写的库，可以迅速、灵活地处理 XML 和 HTML。</p>
<p>其中 lxml.etree 模块是最常用的 HTML、XML 文档解析模块。其中lxml.etree.Element是处理xml的一个核心类，Element对象可以直观的理解为是XML中的节点。使用Element类，可以实现对XML节点、节点属性、节点内文本的操作。</p>
<p><a href="https://blog.csdn.net/weixin_57440207/article/details/116363166">https://blog.csdn.net/weixin_57440207/article/details/116363166</a> lxml 库的基本使用。</p>
<h4 id="BeautifulSoup-示例"><a href="#BeautifulSoup-示例" class="headerlink" title="BeautifulSoup 示例"></a>BeautifulSoup 示例</h4><p>上面的都是比较基础的，对于一些动态的网页结构还是无能为力的。<br>我们可以使用 python <code>bs4</code> 库的 <code>BeautifulSoup</code> 库来对于请求后获得的 <code>html</code> 文本进行解析。<br>这是一段爬取豆瓣网站上<code>电影top250</code>的电影名称。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;user-agent&quot;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                  &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36 Edg/116.0.1938.69&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for page_num in range(0, 250, 25):</span><br><span class="line">    url = f&quot;https://movie.douban.com/top250?start=&#123;page_num&#125;&amp;filter=&quot;</span><br><span class="line">    response = requests.get(url=url, headers=headers)</span><br><span class="line">    encode = response.apparent_encoding</span><br><span class="line">    content = response.content.decode(encode)</span><br><span class="line">    html = BeautifulSoup(content, &#x27;lxml&#x27;)</span><br><span class="line">    titles = html.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)</span><br><span class="line">    for title in titles:</span><br><span class="line">        if &#x27;/&#x27; not in title.string:</span><br><span class="line">            print(title.string)</span><br></pre></td></tr></table></figure><br>我们通过 <code>BeatifulSoup(content, &#39;lxml&#39;)</code> 获取的是一个 BeatifulSoup 解析得到的结构。<br>其中 content 就是我们请求网站获得的 html 代码，后面的 <code>lxml</code> 是一个 html 的解析器，我们需要手动指定解析器，因为 BeautifulSoup 不仅仅可以解析 html。<br><code>html = BeautifulSoup(content, &#39;lxml&#39;)</code> 获得到的 html，有许多的方法。<br>其中如果我们想获得哪一元素，比如说段落，就可以直接 <code>html.findAll(&quot;p&quot;)</code> 返回的是一个可以迭代的对象。如果直接写 <code>html.find(&quot;p&quot;)</code> 则是获得的第一个段落元素。<br>如果我们仍想要对于段落进一步细化，我们可以在后面加上参数，其中的格式是若干组键值。比如，我们想获取类名为<code>title</code>的span，就可以写为 <code>titles = html.findAll(&quot;span&quot;, attrs=&#123;&quot;class&quot;: &quot;title&quot;&#125;)</code><br>对于提取到的元素，我们会获得一个 <code>bs4.element.Tag</code> 就是一个 bs4 中的 Tag 对象，比如说我们有一个 <code>cur</code> 是 <code>bs4.elemnt.tag</code> 对象。<br><code>cur.name</code> 就是输出标签的名字，比如 <code>p</code> <code>img</code> <code>div</code><br>如果我们想要获得里面的单个属性值，就直接 <code>cur[&#39;xx&#39;]</code> 或者 <code>cur.get(&#39;xx&#39;)</code>，如果我们想获取全部的属性值，就是 <code>cur.attrs</code><br>获得标签内的文本，<code>cur.get_text()</code></p>
<h4 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h4><p>前面都是模拟发送一个 <code>request</code> 获得返回，下面是真是模拟我们打开浏览器后进行操作。<br>Python 中的 Selenium 是一个用于自动化网页操作和测试的强大工具。它提供了一种方式来模拟用户在浏览器中的操作，例如打开网页、填写表单、点击按钮、抓取数据等。<br>Selenium 的核心之一就是 WebDriver，它是一个接口，允许我们与不同的浏览器进行交互。我们需要下载与我们所使用浏览器相对应的 WebDriver 驱动程序。将 WebDriver 的路径指定为您的 Python 脚本中。</p>
<p>下面是一段打开百度首页并且搜索「你好」的代码。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line">from selenium.webdriver.common.by import By # 使用 find_element by=xxx 一定要引入这个</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;kw&#x27;).send_keys(&#x27;你好&#x27;)</span><br><span class="line">driver.find_element(by=By.ID, value=&#x27;su&#x27;).click()</span><br><span class="line">time.sleep(5)</span><br></pre></td></tr></table></figure><br>下面是查找元素的 by 赋值情况，后面的 <code>value</code> 就是目标的索引值。这是新版本的 <code>find</code> 操作，之前的 <code>find_element_by</code> 方法现在已经弃用。<br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/selenium%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0.png" class=""></p>
<p>对于查找后，如果是 <code>find_elements</code> 得到的是一个链表，如果是 <code>find_element</code> 得到的是一个 <code>&lt;class &#39;selenium.webdriver.remote.webelement.WebElement&#39;&gt;</code>，后面对于这个类元素，我们可以 <code>xxx.click()</code> 点击<br><code>xxx.send_keys(&quot;xxx&quot;)</code> 发送信息<br><code>xxx.text</code> 获取文本<br><code>xxx.clear()</code> 清除元素内容 如 input 中的内容<br><code>get_attribute(&quot;value&quot;)</code> 获得<code>value</code>的属性值<br><code>current_url</code> 可以获取当前页面的 url</p>
<p>下面是更深入的对于鼠标和键盘<br>模拟鼠标操作需要读入类 <code>ActionChains</code><br><code>from selenium.webdriver.common.action_chains import ActionChains</code><br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%BC%A0%E6%A0%87%E6%93%8D%E4%BD%9C.png" class=""></p>
<p>模拟键盘操作的话，也需要导入键盘的类<br><code>from selenium.webdriver.common.keys import Keys</code><br><img src="/2023/09/04/python%E7%88%AC%E8%99%AB/%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C.png" class=""></p>
<h5 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h5><p>遇到使用ajax加载的网页，页面元素可能不是同时加载出来的，这个时候尝试在get方法执行完成时获取网页源代码可能并非浏览器完全加载完成的页面。所以，这种情况下需要设置延时等待一定时间，确保全部节点都加载出来。<br>有三种方式：</p>
<ol>
<li>强制等待<br>直接 <code>time.sleep(xx)</code>(记得先导入包 <code>import time</code>)</li>
<li>隐式等待<br><code>implicitly_wait(xx)</code> 设置等待时间，如果到时间还有元素没有加载出来就会抛出异常。</li>
<li>显式等待<br>设置一个等待时间和等待条件，在规定时间内，每隔一段时间查看下条件是否成立，如果成立那么程序就继续执行，否则就抛出一个超时异常。</li>
</ol>
<h5 id="对-Cookie-的操作-亦称为-Http-Cookie"><a href="#对-Cookie-的操作-亦称为-Http-Cookie" class="headerlink" title="对 Cookie 的操作(亦称为 Http Cookie)"></a>对 Cookie 的操作(亦称为 Http Cookie)</h5><p>Cookie 通常用于在客户端（浏览器）和服务器之间存储一些小型数据，以便在用户与网站进行交互时进行识别、跟踪和状态管理。<br><br>爬虫中常常使用 selenium + requests 实现 cookie持久化，即先用 selenium 模拟登陆获取 cookie ，再通过 requests 携带 cookie 进行请求。<br><code>webdriver</code> 提供 cookie 的几种操作：读取、添加和删除。</p>
<ol>
<li>get_cookies：以字典的形式返回当前会话中可见的 cookie 信息。</li>
<li>get_cookie(name)：返回 cookie 字典中key == name 的 cookie 信息</li>
<li>dd_cookie(cookie_dict)：将 cookie 添加到当前会话中</li>
<li>delete_cookie(name)：删除指定名称的单个 cookie</li>
<li>delete_all_cookies()：删除会话范围内的所有cookie</li>
</ol>
<p><a href="https://blog.csdn.net/kobepaul123/article/details/128796839">https://blog.csdn.net/kobepaul123/article/details/128796839</a><br><a href="https://blog.csdn.net/weixin_50835854/article/details/117170894">https://blog.csdn.net/weixin_50835854/article/details/117170894</a> selenium 爬取图片<br><a href="https://zhuanlan.zhihu.com/p/270391233">https://zhuanlan.zhihu.com/p/270391233</a><br><a href="https://blog.csdn.net/qq_37267676/article/details/111667266">https://blog.csdn.net/qq_37267676/article/details/111667266</a><br><a href="https://zhuanlan.zhihu.com/p/366773104">https://zhuanlan.zhihu.com/p/366773104</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">import time</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">for index in range(0, 250, 25):</span><br><span class="line">    driver.get(f&#x27;https://movie.douban.com/top250?start=&#123;index&#125;&amp;filter=&#x27;)</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    list = driver.find_elements(by=By.XPATH, value=&#x27;//div[@class=&quot;pic&quot;]/a/img&#x27;)</span><br><span class="line">    for cur in list:</span><br><span class="line">        print(cur.get_attribute(&#x27;alt&#x27;))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="selenium-和-splinter"><a href="#selenium-和-splinter" class="headerlink" title="selenium 和 splinter"></a>selenium 和 splinter</h4><p>splinter和selenium都是用于测试网页的程序，可以模拟浏览器操作，进行自动化测试，可以用于爬虫，自动抢票，网页自动化处理等。Selenium是Splinter的底层，Splinter是Selenium的一个上层封装。使用splinter和selenium时也会用到和html，css相关的使用。</p>
<h4 id="Scrapy-框架"><a href="#Scrapy-框架" class="headerlink" title="Scrapy 框架"></a>Scrapy 框架</h4><p><code>Scrapy</code> 是一个异步网络 python 爬虫框架，可以高效地处理大量的请求和响应。它能够并行发送HTTP请求，从而加快数据抓取速度。异步处理允许我们同时处理多个请求而无需等待每一个请求的完成，这对于大规模的数据抓取任务十分有用。<br>它的优势：</p>
<ol>
<li>内置选择器(Selector)，使用 XPath 或者 CSS 选择器语法，使我们可以轻松获取 HTML 文档中的数据(我们不需要再去使用 bs4 ?)。</li>
<li>模块化和可扩展性<br>允许我们将爬虫任务分解为多个模块，包括爬虫、中间件、管道等，使代码易于维护和扩展。</li>
<li>自动化处理<br>Scrapy提供了强大的自动化功能，包括请求的调度、URL跟踪、重试失败的请求等。它还支持自动限速，以避免过度请求目标网站，从而遵守网站的使用政策。</li>
<li>内置 HTTP 请求处理<br>Scrapy可以处理HTTP请求和响应的所有细节，包括Cookies、User-Agent、重定向、状态码处理等。这减轻了用户的负担，让你专注于爬取和数据处理。</li>
</ol>
<p><a href="https://www.runoob.com/w3cnote/scrapy-detail.html">https://www.runoob.com/w3cnote/scrapy-detail.html</a> 上面讲解了 Scrapy 的爬行流程，感觉还是挺形象的。只有当调度器中不存在任何 request 的时候，整个程序才会停止，又因为对于下载失败的 url 会再次进入 scheduler(调度器)，所以对于下载失败的 url，Scrapy 会重新进行下载。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键记录</title>
    <url>/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h3><p>2023-9-6</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>TO DO<br>定义一个模板类 ? </p>
<p>如何判断链表是否有环</p>
<ol>
<li>使用 map 对于地址打上标记，如果同一个地址被访问了两次就是有环的。</li>
<li>快慢指针(Floyd’s Cycle Detection Algorithm)，使用同余方程得到 $a + kp$ 和 $b + kq \pmod{n}$，其中 a b 分别是两个指针进入环的初始步长，k 是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 $b - a \equiv k(p - q)$ 它们的步长差值为 1 的时候可以始终保证同余。</li>
</ol>
<p>对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为 1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。<br>下面是一段 Python 程序演示：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure></p>
<h5 id="找出有环链表的入环点"><a href="#找出有环链表的入环点" class="headerlink" title="找出有环链表的入环点"></a>找出有环链表的入环点</h5><p>可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S 点，入环点是 T 点，绿色的部分是慢指针所走过的路程。<br>对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S 点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。<br>可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以 ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。<br><img src="/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class=""></p>
<h5 id="Floyd-判圈算法和-Brent-判圈算法"><a href="#Floyd-判圈算法和-Brent-判圈算法" class="headerlink" title="Floyd 判圈算法和 Brent 判圈算法"></a>Floyd 判圈算法和 Brent 判圈算法</h5><p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。<br>其实上面的快慢指针方法就是 Floyd 判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。<br>还有一种判圈的算法，比它更快，就是 <strong>Brent</strong> 判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第 n 轮，乌龟跳到兔子的位置，兔子走$2^{n-1}$步。</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>在申明类中的成员函数后面加上 <code>const</code> 函数就成了只读函数，如 <code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字”static”的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
</blockquote>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure><br>函数指针的应用：</p>
<ol>
<li>把函数作为参数传入另一个函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二个例子，排序上的应用<br>使用 <code>ascending</code> 和 <code>descending</code> 两个函数代替大小判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda 函数的书写结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
函数指针应用？lambda 函数？ 
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- STL 中的**迭代子类**？？ --&gt;</span><br><span class="line"></span><br><span class="line">#### 分而治之 divide-and-conquer</span><br><span class="line">##### 归并排序</span><br><span class="line">一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</span><br><span class="line">&gt; 整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 **性质滚性质**，一直带动，所以可以达到加速的目标。</span><br><span class="line">&#123;%asset_img 时间复杂度计算.png%&#125;</span><br><span class="line"></span><br><span class="line">TO DO:</span><br><span class="line">？？非递归版本的归并排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 快速排序</span><br><span class="line">&lt;!-- 快速排序时间复杂度</span><br><span class="line">最坏 概率统计的意义下？ --&gt;</span><br><span class="line">关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点...</span><br><span class="line">&#123;%asset_img 快速排序算法.png%&#125;</span><br><span class="line">关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</span><br><span class="line">&#123;%asset_img 快速排序时间复杂度.png%&#125;</span><br><span class="line">&#123;%asset_img 快速排序平均时间复杂度.png%&#125;</span><br><span class="line">上面摘自知乎 https://zhuanlan.zhihu.com/p/341201904</span><br><span class="line">##### 2-D maxima finding problem</span><br><span class="line">这是一个 maxima 问题，一般这种问题有两种解决方式。</span><br><span class="line">1. 排序法</span><br><span class="line">&#123;%asset_img 排序法极大点.png%&#125;</span><br><span class="line">2. 分治法</span><br><span class="line">&#123;%asset_img 分治法极大点.png%&#125;</span><br><span class="line">摘自知乎 https://zhuanlan.zhihu.com/p/27850478</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- 平面极大点</span><br><span class="line">分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 --&gt;</span><br><span class="line"></span><br><span class="line">##### the closest pair problem</span><br><span class="line">感觉 OI-Wiki 讲解的很全面</span><br><span class="line">https://oi-wiki.org/geometry/nearest-points/</span><br><span class="line">还有推广：平面最小周长三角形</span><br><span class="line">$\dfrac&#123;d \times 2d&#125;&#123;\frac&#123;1&#125;&#123;4&#125; \times \pi \times (\frac&#123;d&#125;&#123;2&#125;)^&#123;2&#125;&#125;$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</span><br><span class="line"></span><br><span class="line">&lt;!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）</span><br><span class="line"></span><br><span class="line">时间复杂度？ --&gt;</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### the convex hull problem</span><br><span class="line">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- ?</span><br><span class="line">一个著名算法，礼物算法？ Jarvis March</span><br><span class="line">首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着</span><br><span class="line">不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了</span><br><span class="line">但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去</span><br><span class="line">找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 --&gt;</span><br><span class="line"></span><br><span class="line">##### matrix multiplication </span><br><span class="line">&lt;!-- ?</span><br><span class="line">P Q R S T U V?</span><br><span class="line">时间复杂度大概是 $O(\log_2(7)) \approx O(n^&#123;2.81&#125;)$?</span><br><span class="line">但是仍然不是最优的，具体可以自己去搜索一下 --&gt;</span><br><span class="line">使用类实现的矩阵的一些基础操作，可以看 `Fibonacci.cpp`</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### FFT</span><br><span class="line">分治做法，见 `FFT.md` 和 `FFT.cpp`(使用自带的 complex 类实现)</span><br><span class="line">其中，使用自己手写类实现的 FFT 在 `FFTClass.cpp`</span><br><span class="line">(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</span><br><span class="line"></span><br><span class="line">##### Medians and Order Statistics</span><br><span class="line">对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log&#123;n&#125;)$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</span><br><span class="line">每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</span><br><span class="line">还有一种递归的算法，分为 5 个数，</span><br><span class="line"></span><br><span class="line">nth_element() ?? 函数</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。</span><br><span class="line">只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。</span><br><span class="line">为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</span><br><span class="line"></span><br><span class="line">##### Abstract Data Type(ADT)</span><br><span class="line">抽象数据类型</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</span><br><span class="line">不想改变内部元素的时候记得加 const，如果不加的话，`void Func(const List&amp; l) &#123; l.print(); &#125;` 其中不允许调用，因为 Func 有修改成员变量的风险。</span><br><span class="line">**常引用？**</span><br><span class="line">**把函数当作函数的参数？**</span><br><span class="line">派生类禁止父类的函数或者方法？ </span><br><span class="line">括号匹配问题 Bracket Matching Problem</span><br><span class="line">计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</span><br><span class="line">双端队列 dequeue</span><br><span class="line">环形数组</span><br><span class="line"></span><br><span class="line">#### 递归消除</span><br><span class="line">##### 一般性消除办法</span><br><span class="line">- 利用堆栈，模拟栈来实现，见 `Hanoi.cpp`</span><br><span class="line"></span><br><span class="line">汉诺塔问题 递归求解，如何去掉递归求解。</span><br><span class="line">$f_n = 2 f_&#123;n - 1&#125; + 1$，所以 $(f_n + 1) = 2(f_&#123;n - 1&#125; + 1)$</span><br><span class="line"></span><br><span class="line">##### 倒水问题</span><br><span class="line">这种任务方案其实挺多的。其实，背后对应的是**辗转相除法**。</span><br><span class="line">我们可以倒出来的水的数量就是余数。</span><br><span class="line">设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 `ax + by = c`，如果有解，就是 $\gcd&#123;(a, b)&#125; | c$</span><br><span class="line"></span><br><span class="line">##### 求解组合数</span><br><span class="line">https://oi-wiki.org/math/combinatorics/combination/ 见 OI-Wiki各种组合数公式</span><br><span class="line">https://zhuanlan.zhihu.com/p/602675596 二项式反演</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是**过于耦合了**。所以，对于一个类来说，接口是很重要的。</span><br><span class="line"></span><br><span class="line">##### lowbit</span><br><span class="line"></span><br><span class="line">#### 树和二叉树</span><br><span class="line">树中所有节点度数的最大值叫做整个树的度。</span><br><span class="line"></span><br><span class="line">##### 树的表示</span><br><span class="line">一共有四种表示树的方式：</span><br><span class="line">1. 树形结构。很直观、形象</span><br><span class="line">2. 文氏图表示法。使用集合以及集合的包含关系描述树结构。</span><br><span class="line">3. 凹入表示法。使用线段的伸缩描述树结构。</span><br><span class="line">4. 括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</span><br><span class="line"></span><br><span class="line">树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</span><br><span class="line"></span><br><span class="line">按层次遍历二叉树，可能还是比较吃内存的。</span><br><span class="line">DLR LDR LRD </span><br><span class="line">前序 中序 后序 和 根的区别？</span><br><span class="line"></span><br><span class="line">##### 非递归遍历</span><br><span class="line">对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 `GetTreeOrderNor.cpp` </span><br><span class="line">递归形式参见 `GetTreeOrderRecursion.cpp` </span><br><span class="line">给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 `ParseTreeSequence.cpp`</span><br><span class="line"></span><br><span class="line">### 作业</span><br><span class="line">1. 手写一个 List</span><br><span class="line"></span><br><span class="line">见 `List.cpp` `LinkList.h` `LinkList.cpp` </span><br><span class="line">其中，`List.cpp` 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 `Node&lt;T&gt;*` 的形式。</span><br><span class="line">但是在 `LinkList.h` 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 `&lt;T&gt;` 了，这种形式也是我们更加推荐的。</span><br><span class="line"></span><br><span class="line">2. 手写一个面向对象的快速排序</span><br><span class="line">`quick_sort.cpp` 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢</span><br><span class="line">其中，需要注意`函数对象`的写法。</span><br><span class="line"></span><br><span class="line">非递归版本：</span><br><span class="line">**双指针前移法**</span><br><span class="line">感觉很强，短小精悍</span><br><span class="line">见 `QuickSortNor.cpp`</span><br><span class="line">使用自己手写的栈，实现了对于类的非递归版本的快速排序。</span><br><span class="line"></span><br><span class="line">3.  </span><br><span class="line">&lt;!-- 基于自己写的链表</span><br><span class="line">实现堆栈</span><br><span class="line">放在不同的文件中</span><br><span class="line">想规范一下大家写代码习惯 --&gt;</span><br><span class="line">在这次的作业中，注意：</span><br><span class="line">我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template&lt;class E&gt;</span><br></pre></td></tr></table></figure>
<p>template<class U><br>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LinkList<U>&amp; list);<br>```<br>其中，ostream 是一种返回类型。</p>
</li>
<li></li>
</ol>
<ul>
<li>以非递归的形式实现汉诺塔，并且尽量少内存。<br>见 <code>Hanoi.cpp</code></li>
<li>写最大公约数递推的程序。给定两个整数，写出最大公约数的标准形式，d = ax + by，x y 可能是负数 我们规定 |x| &lt; |y| 此时取值是唯一的。<br>见 <code>exgcd.cpp</code><br>上面的扩展欧几里得是递归实现的，但是我们还是追求非递归版本，讲解参考下面的博客：<br><a href="https://www.cnblogs.com/zbhfz/p/11267438.html">https://www.cnblogs.com/zbhfz/p/11267438.html</a>
</li>
</ul>
<ol>
<li>非递归全排列<br>康托展开<br>非递归，根据排列规律输出所有的排列</li>
</ol>
<p>见 <code>CantorExpansion.cpp</code> <code>permutation.cpp</code> <code>next_permutation.cpp</code> </p>
<ol>
<li><p>求斐波那契数列通项<br>特征根法怎么来的呢？<br>人们发现特征根对于分解递推式子是有帮助的<br>对于一个具体的 n 输出 F_n<br>矩阵加速递推<br>见 <code>Fibonacci.cpp</code></p>
</li>
<li><p>写一写二叉树的数据结构，支持几种遍历方式<br>层次 先序 中序 后序 每一个节点都不保存父亲节点 可以使用堆栈来实现 不要递归</p>
</li>
</ol>
<p>如果给出了不同遍历方式得到的结果，如何获得原来树的结构？</p>
<p>二叉树有一个函数，传入两个字符串序列，是不是都能恢复成原来的二叉树结构？最后输出括号表示方式的形式。</p>
<p>见 <code>ParseTreeSequence.cpp</code> 和 <code>GetTreeOrderNor.cpp</code></p>
<p>还有一种比较简洁的方式可以参考 于老师代码中的 <code>parseTree.cpp</code></p>
]]></content>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>登录实现</title>
    <url>/2023/09/07/%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>一个讲解 <a href="https://www.jianshu.com/p/53e687c198b5">https://www.jianshu.com/p/53e687c198b5</a></p>
]]></content>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>抢课脚本</title>
    <url>/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>本质上就是模拟一个请求。<br>我们点击选课页面的时候，是将带有特定功能的数据包发送给对方，也就是服务器，然后得到服务器的反馈。</p>
<blockquote>
<p>之前 Github 上下载的学长写的选课脚本因为学校系统后台的更新没办法使用了，于是想为何不自己学习一下，自己写一个。</p>
</blockquote>
<h4 id="抓包-capture-packet"><a href="#抓包-capture-packet" class="headerlink" title="抓包 capture packet"></a>抓包 capture packet</h4><p>因为Web 表单中会有很多隐藏的字段，这些隐藏字段一般都有一些特殊的用途，比如收集用户的数据，预防 CRSF 攻击，防网络爬虫，以及一些其他用途。这些隐藏字段在界面上都看不到，如果想检测这些字段，就必须要使用抓包工具。<br>使用 F12 开发者工具找了一圈也没找到 Github 上下载的 SDU 抢课脚本的路径，搜索了一下感觉就是运用了抓包。</p>
<h5 id="抓包工具的原理"><a href="#抓包工具的原理" class="headerlink" title="抓包工具的原理"></a>抓包工具的原理</h5><p>那 Fiddler 举例，Fiddler 相当于一个「代理」，浏览器访问服务器页面时，就会先把 HTTP 请求先发送给 Fiddler，Fiddler 再把请求转发给服务器，当服务器返回数据时，Fiddler 拿到返回数据，再把数据交给浏览器。<br>因此 Fiddler 对于浏览器和服务器之间的交互细节是非常清楚的，进而可以帮助我们完成相应的抓包工作(其实后来感觉浏览器自带的开发者工具中的「网络」就够用了)。<br><img src="/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/fiddler.png" class=""></p>
<h4 id="url-编码"><a href="#url-编码" class="headerlink" title="url 编码"></a>url 编码</h4><p>这段文字中，<code>https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/xsxkGgxxkxk</code> 是 URL 基本部分，用于定位服务器上的特定资源或者页面。<br><code>?</code> 表示查询字符串的开始。然后在 <code>?</code> 后面，通常会带有一个或者多个参数，每个参数都有一个名称和一个对应的值，它们之间用等号<code>=</code>连接，并且多个参数之间使用和号<code>&amp;</code>分隔。<br>其中，参数的值是根据 <code>url</code> 编码的，因此需要 <code>url decoding</code> 来将他们还原为原始文本。<br>可以直接使用 python<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from urllib.parse import unquote</span><br><span class="line"></span><br><span class="line">encoded_value = &quot;%E6%96%87%E5%AD%A6&quot;</span><br><span class="line">decoded_value = unquote(encoded_value, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">print(decoded_value)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在计算机编程领域，特别是在处理字符串时，”quote” 通常表示在文本中添加引号或对特殊字符进行编码，而 “unquote” 则表示将文本中的引号或编码解除，还原为原始的形式。</p>
</blockquote>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>Referer（也写作”referrer”，拼写时不包括第二个 “e”）是一个HTTP头部字段，通常在Web请求中使用。这个字段用于指示请求的来源或引用页面的URL。当您从一个网页点击链接跳转到另一个页面时，浏览器通常会在请求中包含Referer字段，以告知目标页面是从哪个页面链接过来的。<br>Referer字段对于网站分析、统计和跟踪用户流量非常有用，因为它可以帮助网站所有者了解访问者是如何到达其网站的。例如，如果您运营一个电子商务网站，您可以使用Referer字段来确定哪些外部网站或广告渠道为您带来了最多的流量和销售。<br>需要注意的是，虽然Referer字段通常包含有用的信息，但它并不是100%可信的，因为用户可以通过浏览器设置或浏览器插件来修改或禁用Referer字段。因此，在进行任何安全性或敏感性操作时，不应仅依赖于Referer字段来验证请求的来源。</p>
<h4 id="Network-栏"><a href="#Network-栏" class="headerlink" title="Network 栏"></a>Network 栏</h4><p>这一栏通常会用来监视和分析与当前网页加载和网络请求相关的信息。下面是它的一些常见用途：</p>
<ol>
<li>查看网络请求。<code>Network</code> 栏显示了当前页面加载期间发出的所有网络请求，包括HTML、CSS、JavaScript、图像、API请求等。</li>
<li>查看请求头和响应头。我们可以通过 <code>Network</code> 来查看 <code>RequestHeaders</code> 和 <code>ResponseHeaders</code>，这对于检查服务器返回的信息、设置请求头来模拟不同的客户端环境或者调试跨域问题很有帮助。</li>
<li>筛选和搜索请求。<code>Network</code> 栏通常提供了筛选和搜索功能，使你可以根据请求类型（XHR、Fetch、Document等）或关键字来查找特定的请求，从而更轻松地定位问题或查找特定资源。</li>
</ol>
<h4 id="request-具体操作"><a href="#request-具体操作" class="headerlink" title="request 具体操作"></a>request 具体操作</h4><p>打开 F12，选择 <code>Network</code> 一栏。<br>然后在找到上搜索自己想选择的课程，点击右侧的「选课」按键(即使课程已经被选满了也无所谓，我们需要的是课程数据包的来源信息)，此时观察 <code>Network</code> 栏目，最下方应该会出现一个 <code>ggxxkxk</code> 开头的文件，点击后会出现它的具体信息。<br>如图：<br><img src="/2023/09/11/%E6%8A%A2%E8%AF%BE%E8%84%9A%E6%9C%AC/selectCourseInfo.png" class=""><br>其中 <code>Request Url</code> 就是我们获得数据包的地址，<code>kcid</code> 和 <code>jx0404id</code> 后面的数字感觉没有什么实际意义，不过可以在 HTML 代码中「选课」按键的属性值中找到，也可以查看 HTML 代码对应一下而不需要点击「选课」按键。<br><code>Cookie</code> 代表的是我们的身份信息，是服务器辨识我们身份的信息，和 <code>User-Agent</code> 还有 <code>referer</code> 一起设置在请求头中。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def selectCourse():</span><br><span class="line">    cur_num = 0</span><br><span class="line">    url = &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/ggxxkxkOper?kcid=xxxxxx&#x27; \</span><br><span class="line">          &#x27;&amp;cfbs=null&amp;jx0404id=xxxxxxx&amp;xkzy=&amp;trjf=&#x27;</span><br><span class="line">    cookie = &#x27;你的 Cookie&#x27;</span><br><span class="line">    headers = &#123;</span><br><span class="line">        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 &#x27;</span><br><span class="line">                      &#x27;(KHTML, like Gecko) Chrome/116.0.0.0 Safari/537.36&#x27;,</span><br><span class="line">        &#x27;cookie&#x27;: cookie,</span><br><span class="line">        &#x27;referer&#x27;: &#x27;https://bkzhjx.wh.sdu.edu.cn/jsxsd/xsxkkc/getGgxxk&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    while True:</span><br><span class="line">        response = requests.get(url=url, headers=headers)</span><br><span class="line">        data = json.loads(response.content.decode(response.apparent_encoding))</span><br><span class="line">        cur_num = cur_num + 1</span><br><span class="line">        print(f&quot;&#123;cur_num&#125; &#123;data[&#x27;message&#x27;]&#125;&quot;)</span><br><span class="line">        if data[&#x27;message&#x27;] != &#x27;选课失败：此课堂选课人数已满！&#x27;:</span><br><span class="line">            break</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    selectCourse()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://www.cnblogs.com/xubin97/p/10331558.html">https://www.cnblogs.com/xubin97/p/10331558.html</a> 抢课脚本链接<br><a href="https://blog.csdn.net/shenqueying/article/details/79426884">https://blog.csdn.net/shenqueying/article/details/79426884</a> referer 的作用<br><a href="https://blog.csdn.net/weixin_43314519/article/details/107095245">https://blog.csdn.net/weixin_43314519/article/details/107095245</a> 讲的挺好，还用到了多线程</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>A Missing Semester of Your CS Education</title>
    <url>/2023/09/20/A-Missing-Semester-of-Your-CS-Education/</url>
    <content><![CDATA[<p>见 “E:\Notes\A Missing Semester of Your CS Education\关键记录.md”</p>
]]></content>
  </entry>
  <entry>
    <title>log</title>
    <url>/2023/09/18/log/</url>
    <content><![CDATA[<h4 id="2023年9月18日"><a href="#2023年9月18日" class="headerlink" title="2023年9月18日"></a>2023年9月18日</h4><ol>
<li>多种计算逆元的方式：扩展欧几里得、费马小定理、递推、阶乘</li>
<li>扩展欧几里得推导：先假设一组解 <code>x^&#123;&#39;&#125; y^&#123;&#39;&#125;</code>，然后找到和原来的解 <code>x y</code> 之间的对应关系 或者 非递归实现</li>
<li>组合数的各种公式和基础二项式反演了解：<br><a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a><br><a href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a></li>
</ol>
<h4 id="2023年9月21日"><a href="#2023年9月21日" class="headerlink" title="2023年9月21日"></a>2023年9月21日</h4><ol>
<li>矩阵加速递推<br>Fibonacci 数列的项公式推导。<br>不动点法？求解微分方程？</li>
<li>康托展开与康托逆展开 直接看 OI-Wiki 就行<br>全排列 next_permutation 函数</li>
<li>Hanoi 问题的数学方法求解(无需开辟新空间，直接输出移动方式)<br>对于 最小块的移动 是隔一个移动一次，而且是有规律的<br>lowbit 函数可以知道移动哪一个块<br>根据最小块的移动规律和lowbit函数就可以直接计算出哪一块移动到哪一个地方了</li>
</ol>
<h4 id="2023年9月27日"><a href="#2023年9月27日" class="headerlink" title="2023年9月27日"></a>2023年9月27日</h4><ol>
<li>二叉树的层序遍历、中序遍历、前序遍历、后序遍历的非递归实现</li>
<li>二叉树中序遍历和前序或者中序和后序可以确定二叉树的结构</li>
<li>二叉树的括号形式解析和输出二叉树的括号形式，当然是非递归形式。</li>
</ol>
]]></content>
      <tags>
        <tag>the record ?</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序的几种实现</title>
    <url>/2023/09/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="双指针前移法"><a href="#双指针前移法" class="headerlink" title="双指针前移法"></a>双指针前移法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e5 + 5;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int partition(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	int pre = left;</span><br><span class="line">	int cur = pre + 1;</span><br><span class="line">	int key = v[left];</span><br><span class="line">	while (cur &lt;= right) &#123;</span><br><span class="line">		if (v[cur] &lt; key &amp;&amp; ++pre != cur) swap(v[cur], v[pre]);</span><br><span class="line">		++cur;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(v[left], v[pre]); // 将基准元素放回正确的位置</span><br><span class="line">	return pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quickSort(vector&lt;int&gt;&amp; v, int left, int right) &#123;</span><br><span class="line">	stack&lt;int&gt; s;</span><br><span class="line">	s.push(left);</span><br><span class="line">	s.push(right);</span><br><span class="line">	while (!s.empty()) &#123;</span><br><span class="line">		int r = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		int l = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		if (l &gt;= r) continue;</span><br><span class="line">		int boundary = partition(v, l, r);</span><br><span class="line">		s.push(l);</span><br><span class="line">		s.push(boundary - 1);</span><br><span class="line">		s.push(boundary + 1);</span><br><span class="line">		s.push(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; v;	</span><br><span class="line">	int x;</span><br><span class="line">	for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		v.push_back(x);</span><br><span class="line">	&#125;	</span><br><span class="line">	quickSort(v, 0, n - 1);</span><br><span class="line">	for (auto element : v) &#123;</span><br><span class="line">		cout &lt;&lt; element &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>计算机可以分成两个部分：硬件和软件。<br>软件的话，又分为<strong>系统软件</strong>和<strong>应用软件</strong>两种。</p>
<p>下层是硬件，硬件进行了相对的封装，它对软件提供了接口，比如说提供了指令集，软件可以利用这些指令集，编写完成一定功能的软件。</p>
<p>最早出现的语言是 <strong>机器语言</strong>(是由 01 代码构成的)，为了简化记忆，人们提出了汇编代码，符号化。汇编语言和机器语言之间一般是一一对应的，也就是一条汇编语言指令对应一条机器语言指令。</p>
<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AF%AD%E8%A8%80%E5%8F%91%E5%B1%95.png" class="">  
<h5 id="冯诺伊曼计算机"><a href="#冯诺伊曼计算机" class="headerlink" title="冯诺伊曼计算机"></a>冯诺伊曼计算机</h5><p>冯诺依曼也被称为现代计算机之父。</p>
<h6 id="EDVAC"><a href="#EDVAC" class="headerlink" title="EDVAC"></a>EDVAC</h6><p>EDVAC(Electronic Discrete Variable Automatic Computer)是计算机科学史上一台著名的计算机，是早期计算机发展中的一个里程碑。下面是它的一些特点：</p>
<ol>
<li>存储程序。是世界上第一台真正的<strong>存储程序计算机</strong>。这意味着它可以存储和执行在存储器中的程序，而不仅仅是执行预先固定在硬件中的计算任务。<strong>这一概念成为现代计算机架构的基础</strong></li>
<li>二进制表示。EDVAC 使用了二进制表示法来处理数据和指令。</li>
<li>使用了冯诺伊曼体系结构</li>
<li>高度可编程。EDVAC的可编程性使得它可以执行各种计算任务，而不仅仅是用于特定目的的计算。</li>
</ol>
<p>而ENIAC是一台<strong>固定程序计算机</strong>，它的计算任务是<strong>通过物理重新连接电路来更改的</strong>，而不是通过存储在内存中的程序。这使得ENIAC的重新配置非常耗时和繁琐，限制了它的通用性。</p>
<h6 id="冯诺依曼结构特点："><a href="#冯诺依曼结构特点：" class="headerlink" title="冯诺依曼结构特点："></a><strong>冯诺依曼结构特点：</strong></h6><ol>
<li>计算机由五大部件组成。</li>
<li>指令和数据以同等地位存储在存储器，可按地址访问。</li>
<li>指令和数据都是二进制表示。</li>
<li>指令由操作码和地址码组成，操作码就是表明这条指令干什么，地址码指明了<strong>操作数在哪里</strong>。</li>
<li><strong>存储程序。程序存储在存储器中(核心特征)。</strong></li>
<li>以运算器为中心。</li>
</ol>
<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6.png" class="">
<h6 id="冯诺依曼结构的问题："><a href="#冯诺依曼结构的问题：" class="headerlink" title="冯诺依曼结构的问题："></a><strong>冯诺依曼结构的问题：</strong></h6><ol>
<li>TODO</li>
</ol>
<p>ALU 和 CU 合成了 CPU<br>存储器又被分为了 主存和辅存<br>CPU 和存储器构成了我们的主机(也就是运算器、存储器、控制器构成了我们的主机)</p>
<h5 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h5><p>存储单元：存放一串二进制代码。存储单元构成存储体。<br>存储字：在存储单元中存放的二进制代码组合。<br>存储字长：存储单元中二进制代码的位数。</p>
<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%84%E6%88%90.png" class="">
<p>MAR 存储器地址寄存器，反应存储器的个数。这个寄存器的长度和存储单元的个数相关。<br>MDR 保存了要保存到存储体中的数据或者是刚刚从存储器中取出来的数据。所以，这个寄存器的长度是存储单元的长度。</p>
<h5 id="运算器基本组成及操作"><a href="#运算器基本组成及操作" class="headerlink" title="运算器基本组成及操作"></a>运算器基本组成及操作</h5><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%BF%90%E7%AE%97%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E5%8F%8A%E6%93%8D%E4%BD%9C.png" class="">
<p>加法的操作过程<br>初态 ACC 中保存了被减数和被加数<br>下一个操作就是把内存单元中的内容 M 放入寄存器 X</p>
<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B9%98%E6%B3%95%E6%93%8D%E4%BD%9C.png" class="">
<img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%99%A4%E6%B3%95%E6%93%8D%E4%BD%9C.png" class="">
<h5 id="控制器基本结构"><a href="#控制器基本结构" class="headerlink" title="控制器基本结构"></a>控制器基本结构</h5><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8E%A7%E5%88%B6%E5%99%A8%E7%BB%93%E6%9E%84.png" class="">
<p>IR 中也就是指令的操作码，其中核心是 CU，来执行指令。</p>
<h5 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h5><p>运算器、存储器、控制器构成了主机。<br>将上面我们各自讲解的结构组合在一起，就得到了 <strong>主机的架构</strong>。<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%B8%BB%E6%9C%BA%E6%9E%B6%E6%9E%84.png" class=""></p>
<p>对于取数操作：</p>
<ol>
<li>先获得取数指令。PC 中存储的是指令地址，传到 MAR，在内存单元中获得指令，然后将指令传到 MDR，再传给<br>IR(IR 中存储的是指令信息)。</li>
<li>IR 中拿到了指令，再交给 CU 对于指令进行分析。对于操作码分析是取数，将地址码传递到 MAR，在内存单元中寻找获得数值，然后传递给 MDR，再传递给 ACC(累加器)，完成取数操作。</li>
</ol>
<h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><p>这一章不是很重要。</p>
<h4 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h4><h5 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h5><p>为了解决分散连接的<strong>不易扩展性</strong>，我们采取了<strong>总线</strong>(bus)来连接各个部件的信息传出线，是各个部件共享的传输介质。总线的英文就是 BUS 其实很生动形象了。</p>
<p>传输方式有<strong>串行和并行</strong>两种。但是并行传输的话，线和线之间会有干扰，所以如果传输距离比较长的话信息会不准确。所以，对于并行传输一般仅用于距离较短的传输。</p>
<h5 id="总线的结构"><a href="#总线的结构" class="headerlink" title="总线的结构"></a>总线的结构</h5><p>总线的结构有单总线、面向 CPU 的双总线和面向存储器的双总线</p>
<p>总线是信号的公共传输线。在任意时刻只能有一个部件来使用总线，对于单总线，会成为我们系统的一个瓶颈。<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class=""></p>
<p>为了改进这种问题，我们提出了 <strong>面向 CPU 的双总线结构</strong>。<br>容易看出，这种总线主存和I/O设备交互的时候，CPU执行任务还是会打断，所以我们提出了 <strong>面向存储器的总线结构</strong>。<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class=""></p>
<p>面向存储器的总线结构：<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.png" class=""></p>
<h5 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h5><p>按照不同分类标准总线可以分为好多中。<br>如果按照在计算机内部的位置来分类有两大种：</p>
<ol>
<li>片内总线。芯片内部的总线</li>
<li>系统总线。计算机各部件之间的信息传输线<br>系统总线又可以分为：数据总线、地址总线、控制总线</li>
</ol>
<h5 id="总线特性及指标"><a href="#总线特性及指标" class="headerlink" title="总线特性及指标"></a>总线特性及指标</h5><p>总线要想进行有效的连接，必须满足一些特性。<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%80%BB%E7%BA%BF%E7%89%B9%E6%80%A7.png" class=""></p>
<h5 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h5><ol>
<li>总线宽度</li>
<li>标准传输律：每秒传输的最大字节</li>
<li>时钟同步</li>
<li>总线复用 地址线和数据线共用。为什么复用？主要是为了减少芯片的管脚数，芯片的管脚数越少，芯片的封装性越好。</li>
<li>信号线数 地址线、数据线和控制线的总和。</li>
</ol>
<h5 id="总线的控制"><a href="#总线的控制" class="headerlink" title="总线的控制"></a>总线的控制</h5><h4 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h4><h5 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h5><p>标准很多，所以分类也很多。</p>
<ol>
<li>按照介质分类<br> 半导体存储器 TTL MOS    易失<br> 磁表面存储器 磁头、载磁体<br> 磁芯存储器<br> 光盘存储器</li>
<li>按照存取方式分类<br> 存取时间和物理地址无关(随机访问)<br> 存取时间和物理地址有关(串行访问) 如磁带、磁带</li>
<li>按照在计算机种的作用分类</li>
</ol>
<p>高速缓冲存储器 (Cache) 是在 CPU 与 主存之间的一块存储器。</p>
<h5 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h5><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1.png" class="">
<p>主存和辅存之间通过软硬件相结合的方式连接在一起。他俩连接在一起如何定位存储地址呢？我们使用的是虚拟地址，就是我们以我们比较好理解的形式来写地址，比如 <code>0x7fff</code> 但是在执行的时候是有特定的机构去<strong>将虚拟地址转换为内存单元种的地址。</strong></p>
<h5 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h5><h6 id="主存储器的地址分配"><a href="#主存储器的地址分配" class="headerlink" title="主存储器的地址分配"></a>主存储器的地址分配</h6><p>高位字节地址为字地址称为「大端、大尾方式」<br>低位字节地址为字地址称为「小端、小尾方式」<br>这两种方式都有机器使用，但是这样的话两种机器进行通讯就会出现问题。</p>
<h6 id="主存的技术指标"><a href="#主存的技术指标" class="headerlink" title="主存的技术指标"></a>主存的技术指标</h6><p>主要是速度和容量两个方面。</p>
<h5 id="半导体存储芯片"><a href="#半导体存储芯片" class="headerlink" title="半导体存储芯片"></a>半导体存储芯片</h5><p>CS Chip Select   选择芯片<br>CE Chip Enable   芯片使能，和 CS 功能一样<br>WE Write Enable  允许写入<br>OE Output Enable 允许输出<br>WR Write         允许写入的另一个形式?<br>上面的一般都是低电位有效。</p>
<p>Column Address Select CAS 列选<br>Row Address Select RAS 行选<br>latency time 延迟时间</p>
<p>双稳态触发器<br>珊极</p>
<h6 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h6><p>有静态的和动态的。</p>
<p>动态 RAM 是利用电容存储电荷的方式来存储信息的。<br>如果不对于动态 RAM 进行刷新，电容就会漏电，原来内部保存的 1 就会变成 0。动态 RAM 的刷新与行地址有关。</p>
<p>动态 RAM 和静态 RAM 比价：<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8A%A8%E6%80%81RAM%E5%92%8C%E9%9D%99%E6%80%81RAM%E6%AF%94%E8%BE%83.png" class=""></p>
<p>DRAM 一般用来做主存，SRAM 一般用来做缓存</p>
<p>最初的 ROM 芯片是固定的，数据在制造时被写入并且无法更改。即使后来出现了 EPROM(Erasable Programmable Read-Only Memory) EEPROM(Electrically Erasable Programmable Read-Only Memory) 和闪存，这种可擦除可编程的，也仍然用 ROM 来称呼他们。EPROM 使用紫外线来擦除，后者 EEPROM 使用电子来擦除。</p>
<h5 id="存储器和-CPU-的连接"><a href="#存储器和-CPU-的连接" class="headerlink" title="存储器和 CPU 的连接"></a>存储器和 CPU 的连接</h5><p>存储器的两种扩展：位扩展(增加存储字长)和字扩展(增加存储字的数量)<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E4%BD%8D%E6%89%A9%E5%B1%95.png" class=""><br>其中字扩展是使用地址线最高位 是 1 或者是 0 来作为片选器(CS)<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97%E6%89%A9%E5%B1%95.png" class=""></p>
<p>还有字和位同时扩展：<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%AD%97%E5%92%8C%E4%BD%8D%E6%89%A9%E5%B1%95.png" class=""></p>
<p>MREQ 通常是计算机领域用来表示内存请求信号的缩写，其全称是 “Memory Request”。这个信号通常用于微处理器（CPU）与计算机系统中的内存之间的通信，以请求对内存进行读取或写入操作。<br>当 CPU 需要访问内存中的数据或指令时，它会生成 MREQ 信号，该信号将传递给内存控制器或内存子系统。内存控制器将根据 MREQ 信号执行相应的操作，例如读取请求时，将数据从内存中读取并提供给 CPU，或者写入请求时，将数据写入内存。<strong>一般是低电平是存储器，高电平时访问IO</strong></p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>计算机的多样性：<br><img src="/2023/09/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%A4%9A%E6%A0%B7%E6%80%A7.png" class=""></p>
<p>HPC 是 <code>High-Performance-Computer</code> 的简称，一般指一些超级计算机。</p>
<p>MPI 消息传递接口 <code>Messag Passing Interface</code> 服务程序通常是指在高性能计算 (HPC) 环境中使用的一种通信库或协议，用于在分布式计算集群中的不同节点之间进行通信和数据交换(毕竟程序之间的并行运算必须有数据信息的交互)。</p>
<p>控制器负责译码。</p>
]]></content>
      <tags>
        <tag>ComputerScience</tag>
      </tags>
  </entry>
  <entry>
    <title>二项式反演</title>
    <url>/2023/09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h4 id="参考见"><a href="#参考见" class="headerlink" title="参考见"></a>参考见</h4><p><a href="https://oi-wiki.org/math/combinatorics/combination/">https://oi-wiki.org/math/combinatorics/combination/</a> 组合式公式<br><a href="https://zhuanlan.zhihu.com/p/602675596">https://zhuanlan.zhihu.com/p/602675596</a> 笔记</p>
<p>一共有两种情况</p>
<p><a href="https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu">炫酷反演魔术 - command_block 的博客 - 洛谷博客 (luogu.com.cn)</a> 介绍了反演的来历、各种反演</p>
<p><a href="https://www.cnblogs.com/GXZlegend/p/11407185.html">二项式反演及其应用 - GXZlegend - 博客园 (cnblogs.com)</a> 有几个题目讲解</p>
<img src="/2023/09/18/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94/%E5%BC%95%E7%90%86.png" class="">
<p><a href="https://www.cnblogs.com/GDOI2018/p/14491894.html">二项式反演 - __allenge - 博客园 (cnblogs.com)</a></p>
]]></content>
      <tags>
        <tag>Math Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>公共关系实务</title>
    <url>/2023/09/18/%E5%85%AC%E5%85%B1%E5%85%B3%E7%B3%BB%E5%AE%9E%E5%8A%A1/</url>
    <content><![CDATA[<h4 id="第二章-公共关系产生与发展"><a href="#第二章-公共关系产生与发展" class="headerlink" title="第二章 公共关系产生与发展"></a>第二章 公共关系产生与发展</h4><p>古代时期—公共关系思想的萌芽</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>公共关系确实有一段黑暗的历史，我们不否认，正视历史。</p>
]]></content>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2023/09/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>具体的更多可以参见代码 <code>GetTreeOrderNor.cpp</code> 和 <code>ParseTreeSequence.cpp</code></p>
<p>这是一段输入先序遍历和中序遍历输出后序遍历的代码。<br><figure class="highlight plaintext"><figcaption><span><iostream></span></figcaption><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">class TreeNode &#123;</span><br><span class="line">    public:</span><br><span class="line">        char value;</span><br><span class="line">        TreeNode* leftChild;</span><br><span class="line">        TreeNode* rightChild;</span><br><span class="line">        TreeNode(char val) : value(val), leftChild(nullptr), rightChild(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode* buildTree(std::vector&lt;char&gt; preOrder, std::vector&lt;char&gt; inOrder) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;char, int&gt; vis;</span><br><span class="line">    for (int i = 0; i &lt; inOrder.size(); ++i) &#123;</span><br><span class="line">        vis[inOrder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = new TreeNode(preOrder[0]);</span><br><span class="line">    s.push(root);</span><br><span class="line">    for (int i = 1; i &lt; preOrder.size(); ++i) &#123;</span><br><span class="line">        TreeNode* curNode = new TreeNode(preOrder[i]);</span><br><span class="line">        TreeNode* parent = nullptr;</span><br><span class="line">        while (!s.empty() &amp;&amp; vis[s.top()-&gt;value] &lt; vis[preOrder[i]]) &#123;</span><br><span class="line">            parent = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        if (parent) &#123;</span><br><span class="line">            parent-&gt;rightChild = curNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            s.top()-&gt;leftChild = curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(curNode);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getPostOrder(TreeNode* root) &#123;</span><br><span class="line">    std::stack&lt;TreeNode*&gt; s;</span><br><span class="line">    std::map&lt;TreeNode*, bool&gt; tag;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    while (!s.empty() || cur) &#123;</span><br><span class="line">        if (cur) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur-&gt;leftChild;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (tag[s.top()] == 1) &#123;</span><br><span class="line">                std::cout &lt;&lt; s.top()-&gt;value;</span><br><span class="line">                s.pop();</span><br><span class="line">                cur = nullptr;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tag[s.top()] = 1;</span><br><span class="line">                cur = s.top()-&gt;rightChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string pre, in;</span><br><span class="line">    while (std::cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">        std::vector&lt;char&gt; preOrder(pre.begin(), pre.end());</span><br><span class="line">        std::vector&lt;char&gt; inOrder(in.begin(), in.end());</span><br><span class="line">        TreeNode* root = buildTree(preOrder, inOrder);</span><br><span class="line">        getPostOrder(root);</span><br><span class="line">        std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
</search>
