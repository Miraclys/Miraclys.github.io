<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:300,300italic,400,400italic,700,700italic%7CCinzel+Decorative:300,300italic,400,400italic,700,700italic%7Cfira+code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The key record of data structure.">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构关键记录">
<meta property="og:url" content="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Miraclys">
<meta property="og:description" content="The key record of data structure.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/.com//09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png">
<meta property="article:published_time" content="2023-09-06T06:06:06.000Z">
<meta property="article:modified_time" content="2023-11-06T01:50:46.000Z">
<meta property="article:author" content="Miraclys">
<meta property="article:tag" content="DataStructure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png">


<link rel="canonical" href="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/","path":"2023/09/06/数据结构关键记录/","title":"数据结构关键记录"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>数据结构关键记录 | Miraclys</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Miraclys</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">课堂笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%BE%E5%87%BA%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E7%8E%AF%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">找出有环链表的入环点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%E5%92%8C-Brent-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.2.</span> <span class="nav-text">Floyd 判圈算法和 Brent 判圈算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95"><span class="nav-number">1.1.3.</span> <span class="nav-text">扩展</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Miraclys"
      src="/../images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Miraclys</p>
  <div class="site-description" itemprop="description">Live a life you will remember.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/../images/avatar.jpg">
      <meta itemprop="name" content="Miraclys">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Miraclys">
      <meta itemprop="description" content="Live a life you will remember.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="数据结构关键记录 | Miraclys">
      <meta itemprop="description" content="The key record of data structure.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构关键记录
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-09-06 14:06:06" itemprop="dateCreated datePublished" datetime="2023-09-06T14:06:06+08:00">2023-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-11-06 09:50:46" itemprop="dateModified" datetime="2023-11-06T09:50:46+08:00">2023-11-06</time>
    </span>

  
</div>

            <div class="post-description">The key record of data structure.</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="课堂笔记"><a href="#课堂笔记" class="headerlink" title="课堂笔记"></a>课堂笔记</h3><p>2023-9-6</p>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>TO DO<br>定义一个模板类 ? </p>
<p>如何判断链表是否有环</p>
<ol>
<li>使用 map 对于地址打上标记，如果同一个地址被访问了两次就是有环的。</li>
<li>快慢指针(Floyd’s Cycle Detection Algorithm)，使用同余方程得到 $a + kp$ 和 $b + kq \pmod{n}$，其中 a b 分别是两个指针进入环的初始步长，k 是一个未知常量，p q 分别是两个指针的步长，n 是环长，得到 $b - a \equiv k(p - q)$ 它们的步长差值为 1 的时候可以始终保证同余。</li>
</ol>
<p>对于快慢指针法，我们一般是设快指针的步长为 2，慢指针的步长为 1，如果链表中有环，那么快指针始终会追上慢指针，如果没有环，快指针会先到达链表的末尾。<br>下面是一段 Python 程序演示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, val=0, next=None):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">def hasCycle(head):</span><br><span class="line">    if not head or not head.next:</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.next</span><br><span class="line">    </span><br><span class="line">    while slow != fast:</span><br><span class="line">        if not fast or not fast.next:</span><br><span class="line">            return False</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">    </span><br><span class="line">    return True</span><br></pre></td></tr></table></figure></p>
<h5 id="找出有环链表的入环点"><a href="#找出有环链表的入环点" class="headerlink" title="找出有环链表的入环点"></a>找出有环链表的入环点</h5><p>可以看下面的这张图片，我们设快慢指针相遇的节点是 A 点，出发点是 S 点，入环点是 T 点，绿色的部分是慢指针所走过的路程。<br>对于找出入环点，我们在快慢指针相遇的时候，在 A 点和 S 点分别再设一个指针，但是这一次它们都是每一次走一步，两个指针必定会相遇，这个第一相遇点就是链表的入环点。<br>可以看下面的图片来理解，因为快指针比满指针路程多一倍，第一次相遇的时候又是快指针比慢指针多走了一个环的长度，所以一个环的长度就是现在慢指针所走过的长度，所以 ST 和 AT 的长度是相等的，所以第一个相遇的点就是入环点。<br><img src="/.com//09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%B0%E5%BD%95/%E5%85%A5%E7%8E%AF%E7%82%B9.png" class></p>
<h5 id="Floyd-判圈算法和-Brent-判圈算法"><a href="#Floyd-判圈算法和-Brent-判圈算法" class="headerlink" title="Floyd 判圈算法和 Brent 判圈算法"></a>Floyd 判圈算法和 Brent 判圈算法</h5><p>或者又称为「龟兔赛跑算法」，是一个可以在<strong>有限状态机、迭代函数或者链表</strong>上判断是否存在环，求出该环的起点和长度的算法。<br>其实上面的快慢指针方法就是 Floyd 判圈算法，它不像哈希一样需要很大的空间，所以在空间上是更优的。<br>还有一种判圈的算法，比它更快，就是 <strong>Brent</strong> 判圈算法，但是这种方式并没有解决计算换的长度、找出换的入口这两个问题。该算法同样会使用两个指针：快慢指针。当着两个指针相遇，就说明存在环。比如，龟和兔子同时出发，龟不动，兔子走一步，第二轮，乌龟跳到兔子的位置，兔子走两步，第三轮。。。。第 n 轮，乌龟跳到兔子的位置，兔子走$2^{n-1}$步。</p>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>在申明类中的成员函数后面加上 <code>const</code> 函数就成了只读函数，如 <code>void append() const &#123;&#125;</code>，不能修改类的数据成员。</p>
<p>函数指针，创建函数指针可以<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int(*funPtr)(int, int, double, ...); // 没有参数就什么都不写</span><br><span class="line">int(*const funcPtr)(); // 这样可以创建静态的函数指针</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>静态函数指针是指指向静态函数的指针。在C语言和C++中，静态函数是指在函数定义前面加上关键字”static”的函数。静态函数的特点是它们只在定义它们的源文件中可见，不能被其他源文件访问。这意味着静态函数的作用域限制在定义它们的源文件内部。</p>
</blockquote>
<p>函数指针在赋值的时候，目标函数比如和函数指针定义的返回值类型和参数个数完全相同。下面两种情况是一样的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*funcPtr1)() = foo;</span><br><span class="line">int (*funcPtr2)() = &amp;foo; // c++会隐式得把foo转换成&amp;foo，所以你无需再加入&amp;</span><br></pre></td></tr></table></figure><br>函数指针的应用：</p>
<ol>
<li>把函数作为参数传入另一个函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int add(int a, int b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a, int b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line">void func(int e, int d, int(*f)(int a, int b))&#123; // 这里才是我想说的，</span><br><span class="line">// 传入了一个int型，双参数，返回值为int的函数</span><br><span class="line">    std::cout&lt;&lt;f(e,d)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func(2,3,add);</span><br><span class="line">    func(2,3,sub);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二个例子，排序上的应用<br>使用 <code>ascending</code> 和 <code>descending</code> 两个函数代替大小判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool ascending(T x, T y) &#123;</span><br><span class="line">    return x &gt; y; </span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">bool descending(T x, T y) &#123;</span><br><span class="line">    return x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void bubblesort(T *a, int n, bool(*cmpfunc)(T, T))&#123;</span><br><span class="line">    bool sorted = false;</span><br><span class="line">    while(!sorted)&#123;</span><br><span class="line">        sorted = true;</span><br><span class="line">        for (int i=0; i&lt;n-1; i++)</span><br><span class="line">            if (cmpfunc(a[i], a[i+1])) &#123;</span><br><span class="line">                std::swap(a[i], a[i+1]);</span><br><span class="line">                sorted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line">    int b[8] = &#123;5,2,5,7,1,-3,99,56&#125;;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(a, 8, ascending);</span><br><span class="line"></span><br><span class="line">    for (auto e:a) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    bubblesort&lt;int&gt;(b, 8, descending);</span><br><span class="line"></span><br><span class="line">    for (auto e:b) std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda 函数的书写结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture clause](parameter list) -&gt; return type &#123;</span><br><span class="line">    // Lambda函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- 
函数指针应用？lambda 函数？ 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br></pre></td><td class="code"><pre><span class="line">struct FUN &#123;</span><br><span class="line">    成员变量</span><br><span class="line">    void operator()(T t);</span><br><span class="line">&#125;</span><br><span class="line">FUN fun;</span><br><span class="line">fun() 伪装为一个函数？</span><br><span class="line">``` --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- STL 中的**迭代子类**？？ --&gt;</span><br><span class="line"></span><br><span class="line">#### 分而治之 divide-and-conquer</span><br><span class="line">##### 归并排序</span><br><span class="line">一个典例就是归并排序，对于归并排序，为什么递归分成两部分以后排序程序就更快了呢？我感觉是</span><br><span class="line">&gt; 整个数组是无序的，是性质很差的，我们如果想加快排序必需有一些比较好的性质。但是如果对于整个数组获得比较好的性质还不如直接排序？所以我们把数组分成两部分一直分，知道性质很明显，获得有序序列，然后 **性质滚性质**，一直带动，所以可以达到加速的目标。</span><br><span class="line">&#123;%asset_img 时间复杂度计算.png%&#125;</span><br><span class="line"></span><br><span class="line">TO DO:</span><br><span class="line">？？非递归版本的归并排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 快速排序</span><br><span class="line">&lt;!-- 快速排序时间复杂度</span><br><span class="line">最坏 概率统计的意义下？ --&gt;</span><br><span class="line">关于快速排序的过程，其实就是每一次取一个数作为基准，然后想把整个数组分为两个部分一个是小于这个基准的，另一个是大于这个基准的。然后有一种很好的方式就是建立两个指针，分别指向数组的左端点和右端点...</span><br><span class="line">&#123;%asset_img 快速排序算法.png%&#125;</span><br><span class="line">关于快速排序的时间复杂度，有最优复杂度、最差复杂度还有平均时间复杂度。</span><br><span class="line">&#123;%asset_img 快速排序时间复杂度.png%&#125;</span><br><span class="line">&#123;%asset_img 快速排序平均时间复杂度.png%&#125;</span><br><span class="line">上面摘自知乎 https://zhuanlan.zhihu.com/p/341201904</span><br><span class="line">##### 2-D maxima finding problem</span><br><span class="line">这是一个 maxima 问题，一般这种问题有两种解决方式。</span><br><span class="line">1. 排序法</span><br><span class="line">&#123;%asset_img 排序法极大点.png%&#125;</span><br><span class="line">2. 分治法</span><br><span class="line">&#123;%asset_img 分治法极大点.png%&#125;</span><br><span class="line">摘自知乎 https://zhuanlan.zhihu.com/p/27850478</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- 平面极大点</span><br><span class="line">分别解决完左右后，找出右边的第一个 y 最大的点，把左侧的x 和 y 都低于它的点排除 --&gt;</span><br><span class="line"></span><br><span class="line">##### the closest pair problem</span><br><span class="line">感觉 OI-Wiki 讲解的很全面</span><br><span class="line">https://oi-wiki.org/geometry/nearest-points/</span><br><span class="line">还有推广：平面最小周长三角形</span><br><span class="line">$\dfrac&#123;d \times 2d&#125;&#123;\frac&#123;1&#125;&#123;4&#125; \times \pi \times (\frac&#123;d&#125;&#123;2&#125;)^&#123;2&#125;&#125;$ 虽然不是最精确的，但是已经可以得到一个常数来界定这个范围</span><br><span class="line"></span><br><span class="line">&lt;!-- 也是用一个竖线将平面分为左右两个部分，然后分别解决，假设左右的最短距离为 d，那么再遍历竖线左右两边距离 d 内的所有点，找出最小值。？（不缺定）</span><br><span class="line"></span><br><span class="line">时间复杂度？ --&gt;</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### the convex hull problem</span><br><span class="line">https://blog.csdn.net/lemonxiaoxiao/article/details/108619552</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">&lt;!-- ?</span><br><span class="line">一个著名算法，礼物算法？ Jarvis March</span><br><span class="line">首先最下面的点一定选择，然后逐渐旋转，遇到就选？逆时针还是顺时针呢？有一个判断是向量的叉乘，大于 0 还是小于 0 就是顺着还是逆着</span><br><span class="line">不对的时候是需要回退的，也可能不止一次 Grasham Scan 但是到了三维就不行了</span><br><span class="line">但是 divide-and-conquer 就不一样了，不仅仅更快，而且可以推广到三维空间里面去</span><br><span class="line">找到交点最高和最低，二维的时间复杂度就是 $O(n \log n)$ 三维的就是找三角形了 --&gt;</span><br><span class="line"></span><br><span class="line">##### matrix multiplication </span><br><span class="line">&lt;!-- ?</span><br><span class="line">P Q R S T U V?</span><br><span class="line">时间复杂度大概是 $O(\log_2(7)) \approx O(n^&#123;2.81&#125;)$?</span><br><span class="line">但是仍然不是最优的，具体可以自己去搜索一下 --&gt;</span><br><span class="line">使用类实现的矩阵的一些基础操作，可以看 `Fibonacci.cpp`</span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### FFT</span><br><span class="line">分治做法，见 `FFT.md` 和 `FFT.cpp`(使用自带的 complex 类实现)</span><br><span class="line">其中，使用自己手写类实现的 FFT 在 `FFTClass.cpp`</span><br><span class="line">(注意，如果使用 reverse 函数，注意反转的 F 的区间范围，一开始这里错了，好长时间没找出来)</span><br><span class="line"></span><br><span class="line">##### Medians and Order Statistics</span><br><span class="line">对于 n 个数，找出 k-th 数，不排序如何做？因为一排序复杂度就 $O(n\log&#123;n&#125;)$ 了，我们如果只想要一个，可不可以做到 $O(n)$。</span><br><span class="line">每一次只选择半个部分，虽然是使用类似于 quick_sort 的方式，但是问题的效率越来越小，所以就得到了 $O(n)$ 的方式，但是 quick_sort 的时间复杂度并不是很稳定。</span><br><span class="line">还有一种递归的算法，分为 5 个数，</span><br><span class="line"></span><br><span class="line">nth_element() ?? 函数</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">尽量不要写递归，但是可以按递归的思路来想，因为递归的程序一般是比较慢。</span><br><span class="line">只是几个简单的案例，但是对于每一个案例都是值得我们去深究的。</span><br><span class="line">为什么这次课讲这部分呢？我们也是要掌握算法思想的。除了分而治之呢，还有自上而下，多层次，自上而下思想等等。</span><br><span class="line"></span><br><span class="line">##### Abstract Data Type(ADT)</span><br><span class="line">抽象数据类型</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line"></span><br><span class="line">TO DO</span><br><span class="line"></span><br><span class="line">Node 是 List 下面下属的概念，没有必要将 Node 写在 List 外面。</span><br><span class="line">不想改变内部元素的时候记得加 const，如果不加的话，`void Func(const List&amp; l) &#123; l.print(); &#125;` 其中不允许调用，因为 Func 有修改成员变量的风险。</span><br><span class="line">**常引用？**</span><br><span class="line">**把函数当作函数的参数？**</span><br><span class="line">派生类禁止父类的函数或者方法？ </span><br><span class="line">括号匹配问题 Bracket Matching Problem</span><br><span class="line">计算一个式子的值 postfix calculator 也可以适用于简单的四则运算的场合</span><br><span class="line">双端队列 dequeue</span><br><span class="line">环形数组</span><br><span class="line"></span><br><span class="line">#### 递归消除</span><br><span class="line">##### 一般性消除办法</span><br><span class="line">- 利用堆栈，模拟栈来实现，见 `Hanoi.cpp`</span><br><span class="line"></span><br><span class="line">汉诺塔问题 递归求解，如何去掉递归求解。</span><br><span class="line">$f_n = 2 f_&#123;n - 1&#125; + 1$，所以 $(f_n + 1) = 2(f_&#123;n - 1&#125; + 1)$</span><br><span class="line"></span><br><span class="line">##### 倒水问题</span><br><span class="line">这种任务方案其实挺多的。其实，背后对应的是**辗转相除法**。</span><br><span class="line">我们可以倒出来的水的数量就是余数。</span><br><span class="line">设一个杯子是 a 升，另一个杯子是 b 升，我们想获得 c 升水，就是 `ax + by = c`，如果有解，就是 $\gcd&#123;(a, b)&#125; | c$</span><br><span class="line"></span><br><span class="line">##### 求解组合数</span><br><span class="line">https://oi-wiki.org/math/combinatorics/combination/ 见 OI-Wiki各种组合数公式</span><br><span class="line">https://zhuanlan.zhihu.com/p/602675596 二项式反演</span><br><span class="line"></span><br><span class="line">##### 扩展</span><br><span class="line">实现 Stack 的时候，太过于依赖于 List 的实现机理，比如说直接从底层指针上来做。但是这样的话，List 一旦修改，我们的 Stack 就会出现问题。这就是**过于耦合了**。所以，对于一个类来说，接口是很重要的。</span><br><span class="line"></span><br><span class="line">##### lowbit</span><br><span class="line"></span><br><span class="line">#### 树和二叉树</span><br><span class="line">树中所有节点度数的最大值叫做整个树的度。</span><br><span class="line"></span><br><span class="line">##### 树的表示</span><br><span class="line">一共有四种表示树的方式：</span><br><span class="line">1. 树形结构。很直观、形象</span><br><span class="line">2. 文氏图表示法。使用集合以及集合的包含关系描述树结构。</span><br><span class="line">3. 凹入表示法。使用线段的伸缩描述树结构。</span><br><span class="line">4. 括号表示法。将树的根节点写在括号的左边，除根节点以外的其余节点写在括号中并用逗号间隔来描述树结构。</span><br><span class="line"></span><br><span class="line">树的各种遍历，一般的树形结构上，大家不讨论中根的问题，一般都是先根和后根。</span><br><span class="line"></span><br><span class="line">按层次遍历二叉树，可能还是比较吃内存的。</span><br><span class="line">DLR LDR LRD </span><br><span class="line">前序 中序 后序 和 根的区别？</span><br><span class="line"></span><br><span class="line">##### 非递归遍历</span><br><span class="line">对于二叉树的非递归遍历，前序、后序以及获得括号形式都参见作业 `GetTreeOrderNor.cpp` </span><br><span class="line">递归形式参见 `GetTreeOrderRecursion.cpp` </span><br><span class="line">给定一个二叉树的括号形式，将其解析并且输出前序、中序、层序、后序遍历参见 `ParseTreeSequence.cpp`</span><br><span class="line"></span><br><span class="line">##### 中序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">这样也可以充分利用空间</span><br><span class="line">将叶子节点的右孩子指向下一个应改遍历的节点(因为一开始叶子节点的右孩子是 null，造成了浪费)</span><br><span class="line">并且加一个 bool 类型的变量，表示这个节点的右孩子是不是进行了修改。</span><br><span class="line">这样中序遍历的时候好像也会简单很多(在中序遍历的意义下，将二叉树变成了一个单链表)</span><br><span class="line">这样二叉树的遍历就不再依赖于堆栈，并且产生了向前向后的两个方向，和双链表的行为是比较相似的。</span><br><span class="line"></span><br><span class="line">##### 前序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line">顺序建立就是修改右子树</span><br><span class="line">但是如果反过来会出现左孩子已经被占用的问题，此时需要借助堆栈</span><br><span class="line"></span><br><span class="line">##### 后序遍历的线索二叉树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%asset_img 线索二叉树.png%&#125;</span><br><span class="line"></span><br><span class="line">#### 堆</span><br><span class="line"></span><br><span class="line">##### 二叉堆</span><br><span class="line"></span><br><span class="line">当我们谈论到堆(Heap)时，通常指的是二叉堆(Binary Heap)，它是一种特殊的树形结构，常用于实现优先队列和一些图算法(物理存储上是数组，但是逻辑结构上是二叉树，这也是为什么我们可以使用 vector 来模拟的原因)。</span><br><span class="line"></span><br><span class="line">堆的性质：</span><br><span class="line">1. 二叉树结构：堆是一种完全二叉树，除了最后一层，别的层的节点都是满的，最后一层的节点从左向右填充。</span><br><span class="line">2. 小根堆：任何父节点的值都小于等于其子节点的值。</span><br><span class="line">3. 不唯一性：对于给定的数据集，可能存在多个不同的最小堆或者最大堆。</span><br><span class="line">4. 只是保证了节点的权值大于两个儿子节点的权值，也就是说，堆维护的更是我们关注的相对大小关系，尤其是最顶部的元素大小，我们并不关心全序大小关系(也无法维护)。</span><br><span class="line"></span><br><span class="line">&gt;   在实际中，实现堆（Heap）通常更倾向于使用向量（数组）来模拟二叉树的结构，而不是构建一个显式的二叉树数据结构。</span><br><span class="line"></span><br><span class="line">##### 二项堆</span><br><span class="line"></span><br><span class="line">##### Fibonacci 堆</span><br><span class="line"></span><br><span class="line">##### lazy 机制</span><br><span class="line"></span><br><span class="line">上面的最简单的二叉堆做法呢，我们很好地利用了二叉树序号之间的关系(父子的序号有关系)，但是我们在更新的时候每一次都是 $\log&#123;n&#125;$ 的复杂度，不是很优，比如说有些元素我们以后根本用不到，而堆又本身不是关注全序关系的，所以我们可以利用 lazy 机制。</span><br><span class="line"></span><br><span class="line">TODO </span><br><span class="line">现在库里面的堆，基本上都不是基于 **二叉堆**(Binary Heap) 实现的。</span><br><span class="line">Fibonacci 堆 也是希望我们去更多地了解一些堆。</span><br><span class="line">堆的合并、二叉堆的合并？</span><br><span class="line">二项堆</span><br><span class="line">重载运算符</span><br><span class="line"></span><br><span class="line">#### 编码问题</span><br><span class="line"></span><br><span class="line">结构光扫描中，我们如何马上知道这条光是第几条光？就要用到编码了</span><br><span class="line">能不能发明一种序列，使得连续的几个在序列中是唯一的，longest ？ 是多长？</span><br><span class="line">3 个颜色的话，先画出 27 个节点。RRR 的话，连接 RRG RRB(它的后继节点)</span><br><span class="line">寻找访问序列最长的，而且不能重复</span><br><span class="line">深度遍历可以吗？最好不要写递归，可以队列、栈</span><br><span class="line"></span><br><span class="line">#### 霍夫曼树</span><br><span class="line"></span><br><span class="line">每一次找权值最小两个节点，变为 n - 1 个节点</span><br><span class="line">1. 能不能构建出来</span><br><span class="line">2. 总体的最小代价</span><br><span class="line">可以搜索霍夫曼树的题目</span><br><span class="line">实现持久化的最小两个数？手写优先队列？平衡树？</span><br><span class="line"></span><br><span class="line">#### 左倾堆 / 左倾树 / 左偏堆 / 左偏树</span><br><span class="line"></span><br><span class="line">虽然二叉堆的插入、删除操作挺好的，但是不支持合并。所以我们想寻找一种数据结构使得堆在合并的时候比较高效。</span><br><span class="line">&gt; Leftist Heap is a priority queue data structure that also supports merge of heaps in O(log n) time.</span><br><span class="line"></span><br><span class="line">FHQ Treap TODO</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/qkhm/zuo-pian-shu-xue-xi-bi-ji TODO</span><br><span class="line"></span><br><span class="line">最优传输理论</span><br><span class="line"></span><br><span class="line">启发式合并堆</span><br><span class="line"></span><br><span class="line">#### 二叉平衡树</span><br><span class="line"></span><br><span class="line">可以证明平衡二叉树的高度为 $\log&#123;n&#125;$ 吗？</span><br><span class="line"></span><br><span class="line">N(h) = 1 + N(h - 1) + N(h - 2); AVL 树的高度推导 N(h) 表示高度为 h 时最不平衡时的节点个数。</span><br><span class="line"></span><br><span class="line">我们是按照左右子树的树高度之差来定义的，这只是定义平衡的一种。但是还有很多别的方式，比如左右子树的节点。</span><br><span class="line"></span><br><span class="line">维护平衡的机制有很多种，比如说典型的 B 树，2-3-4树，它所有的叶子都在同一个高度上面。它最不满的情况就是一个满二叉树，所以它可以保证高度在 $\log$ 级别。</span><br><span class="line"></span><br><span class="line">AVL B树 红黑树 234树 Treap</span><br><span class="line">红黑树的实际应用比较频繁，它的效率比较高一点。红黑树和 234树之间的关系？？ TODO</span><br><span class="line"></span><br><span class="line">插入的时候常常面临三种情形。</span><br><span class="line"></span><br><span class="line">https://www.luogu.com.cn/blog/MashPlant/solution2-p3369 B 树代码</span><br><span class="line"></span><br><span class="line">LCT问题？ Link Cut Tree</span><br><span class="line"></span><br><span class="line">Treap 的高度 log 证明？</span><br><span class="line"></span><br><span class="line">#### the mathematics of rubik&#x27;s cube</span><br><span class="line"></span><br><span class="line">#### Dijkstra 算法</span><br><span class="line"></span><br><span class="line">正确性证明？</span><br><span class="line"></span><br><span class="line">多边形</span><br><span class="line"></span><br><span class="line">差分约束问题 线性规划问题 max \sum d 要求比 dijkstra 更加严苛？</span><br><span class="line"></span><br><span class="line">Gorubi </span><br><span class="line"></span><br><span class="line">最短路的话线性规划没有 dijkstra 更加优</span><br><span class="line"></span><br><span class="line">A* 算法？</span><br><span class="line"></span><br><span class="line">#### 二叉树在区间上？</span><br><span class="line"></span><br><span class="line">维护直接的 Rank 感觉代价过于高，因为每一次删除和插入都要把其余元素都改变一次，所以我们不直接维护 Rank。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二叉树序列化？https://zhuanlan.zhihu.com/p/26418233</span><br><span class="line"></span><br><span class="line">#### 线段相交的问题</span><br><span class="line"></span><br><span class="line">两个结构：</span><br><span class="line">1. 处理事件的优先队列(关键位置停下来，遇到了水平线段的左端点，遇到了水平线段的右端点，遇到了竖直线段)(需要使用一个二叉树维护水平线段，包括水平竖直关系)(水平线段的 y 高度使用二叉树维护了？树套树？)</span><br><span class="line">2. 维护扫描的每个关键位置的全序列表</span><br><span class="line"></span><br><span class="line">#### kd 树</span><br><span class="line"></span><br><span class="line">grid 2d tree</span><br><span class="line">quadtree(四叉树，每一个格子一分为 4) bsptree(每一次有一个平面，对于所在的平面二分，在二维的情况下就是直线)</span><br><span class="line"></span><br><span class="line">上面的结构，除了 grid 的应用都是很多的。各自在不同的应用场景下使用。</span><br><span class="line"></span><br><span class="line">kd 树其实是 bst 树的延申。可是很多时候一维数据是不够的，很多情况都是高维的东西。在机器学习中应用也很多。</span><br><span class="line">ray tracing</span><br><span class="line">2d range serach</span><br><span class="line"></span><br><span class="line">从乱序中在 O(n) 的时间复杂度下找出中位数。</span><br><span class="line"></span><br><span class="line">1. 每一刀下去，都是将矩形分为两个部分。</span><br><span class="line">2. 奇偶相间，第一层竖线划分，第二层就是水平划分。(优化就是把点很紧密的包在一块？)</span><br><span class="line"></span><br><span class="line">nth_element 严格 O(n) 查找中位数</span><br><span class="line"></span><br><span class="line">#### 跳表 Skip List</span><br><span class="line"></span><br><span class="line">跳表是相对年轻的一个数据结构，1990 年由 Bill Pugh 提出。</span><br><span class="line">我们需要区分一下数据域和指针域</span><br><span class="line">https://www.cnblogs.com/bigsai/p/14193225.html</span><br><span class="line"></span><br><span class="line">#### KMP</span><br><span class="line"></span><br><span class="line">前缀和后缀的问题</span><br><span class="line"></span><br><span class="line">BM 算法？</span><br><span class="line"></span><br><span class="line">DFA</span><br><span class="line"></span><br><span class="line">#### 并查集(Union-find)</span><br><span class="line"></span><br><span class="line">虽然并查集的代码是最少的一个，但是确实非常有用的。它可以解决**等价类**相关的问题。</span><br><span class="line"></span><br><span class="line">link-by-size 按照大小合并，此时最高高度不超过 log n</span><br><span class="line">当然也有按照 rank(height)高度合并。</span><br><span class="line"></span><br><span class="line">还有路径压缩(path compression)</span><br><span class="line"></span><br><span class="line">无路径压缩的时候，复杂度是 $m \log n$</span><br><span class="line">有路径压缩的时候，复杂度是 $m \alpha (m, n)$</span><br><span class="line">其中，$\alpha$ 是反阿克曼函数。</span><br><span class="line"></span><br><span class="line">#### 图</span><br><span class="line"></span><br><span class="line">每一个节点有 in 和 out 两个邻接表</span><br><span class="line"></span><br><span class="line">矩阵的形式存储的时候，可能并行化运算的时候更加容易。</span><br><span class="line"></span><br><span class="line">prim 求最小生成树</span><br><span class="line"></span><br><span class="line">cut 割</span><br><span class="line"></span><br><span class="line">割中最小权值的边一定出现在最小生成树上 证明了 Prim 的正确性？</span><br><span class="line"></span><br><span class="line">### 作业</span><br><span class="line"></span><br><span class="line">1. 手写一个 List</span><br><span class="line"></span><br><span class="line">见 `List.cpp` `LinkList.h` `LinkList.cpp` </span><br><span class="line">其中，`List.cpp` 将 Node 和 List 两个类分开写了，所以在 List 中使用 Node 的时候要写成 `Node&lt;T&gt;*` 的形式。</span><br><span class="line">但是在 `LinkList.h` 中，将 Node 写在了 List 类里面，此时就不需要在 Node 后面额外加 `&lt;T&gt;` 了，这种形式也是我们更加推荐的。</span><br><span class="line"></span><br><span class="line">2. 手写一个面向对象的快速排序</span><br><span class="line">`quick_sort.cpp` 是一个递归版本的，但是我们一般不鼓励写递归，会比较慢</span><br><span class="line">其中，需要注意`函数对象`的写法。</span><br><span class="line"></span><br><span class="line">非递归版本：</span><br><span class="line">**双指针前移法**</span><br><span class="line">感觉很强，短小精悍</span><br><span class="line">见 `QuickSortNor.cpp`</span><br><span class="line">使用自己手写的栈，实现了对于类的非递归版本的快速排序。</span><br><span class="line"></span><br><span class="line">3.  </span><br><span class="line">&lt;!-- 基于自己写的链表</span><br><span class="line">实现堆栈</span><br><span class="line">放在不同的文件中</span><br><span class="line">想规范一下大家写代码习惯 --&gt;</span><br><span class="line">在这次的作业中，注意：</span><br><span class="line">我们在使用了模板类的 LinkList 中添加重载输出的友元函数。因为我们毕竟添加的是一个友元函数，是一个函数，所以我们需要在 LinkList 中再写一个 template&lt;class E&gt;</span><br></pre></td></tr></table></figure>
<p>template<class U><br>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const LinkList<U>&amp; list);<br>```<br>其中，ostream 是一种返回类型。</p>
</li>
<li></li>
</ol>
<ul>
<li>以非递归的形式实现汉诺塔，并且尽量少内存。<br>见 <code>Hanoi.cpp</code></li>
<li>写最大公约数递推的程序。给定两个整数，写出最大公约数的标准形式，d = ax + by，x y 可能是负数 我们规定 |x| &lt; |y| 此时取值是唯一的。<br>见 <code>exgcd.cpp</code><br>上面的扩展欧几里得是递归实现的，但是我们还是追求非递归版本，讲解参考下面的博客：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zbhfz/p/11267438.html">https://www.cnblogs.com/zbhfz/p/11267438.html</a>
</li>
</ul>
<ol>
<li>非递归全排列<br>康托展开<br>非递归，根据排列规律输出所有的排列</li>
</ol>
<p>见 <code>CantorExpansion.cpp</code> <code>permutation.cpp</code> <code>next_permutation.cpp</code> </p>
<ol>
<li><p>求斐波那契数列通项<br>特征根法怎么来的呢？<br>人们发现特征根对于分解递推式子是有帮助的<br>对于一个具体的 n 输出 F_n<br>矩阵加速递推<br>见 <code>Fibonacci.cpp</code></p>
</li>
<li><p>写一写二叉树的数据结构，支持几种遍历方式<br>层次 先序 中序 后序 每一个节点都不保存父亲节点 可以使用堆栈来实现 不要递归</p>
</li>
</ol>
<p>如果给出了不同遍历方式得到的结果，如何获得原来树的结构？</p>
<p>二叉树有一个函数，传入两个字符串序列，是不是都能恢复成原来的二叉树结构？最后输出括号表示方式的形式。</p>
<p>见 <code>ParseTreeSequence.cpp</code> 和 <code>GetTreeOrderNor.cpp</code></p>
<p>还有一种比较简洁的方式可以参考 于老师代码中的 <code>parseTree.cpp</code></p>
<ol>
<li>如何形成中序遍历意义下的线索二叉树(双向的)<br>并且用自己的线索二叉树再次实现双向遍历</li>
</ol>
<p>前序和后序不完美</p>
<p>线索二叉树的必要？历史的产物？</p>
<ol>
<li>自己搜索霍夫曼树的题目</li>
</ol>
<p>多叉树到二叉树的转化？</p>
<p>Weighted Path Length of Tree, WPL</p>
<p>中位数寻找？TODO</p>
<p>为什么需要将 友元函数的定义直接写进去 ？ TODO</p>
<ol>
<li><p>了解一下 Fibonacci 堆，有精力的同学可以尝试实现。</p>
</li>
<li><p>实现一个左偏堆</p>
</li>
<li><p>写一个 AVL 维护平衡，支持插入删除查找</p>
</li>
<li><p>R G B 非递归扫描？搜索如何存储路径状态？(直接将一个 vector 作为参数传入)</p>
</li>
<li><p>实现 Treap Splay FHQTreap ?（附加）</p>
</li>
<li><p>魔方？rubik’s cube?</p>
</li>
<li><p>若干不相交的多边形，输出从多边形外面一点到外面另一点的最短路径。</p>
</li>
<li><p>尝试完善代码，为二叉树每一个节点添加 size，同时提供一个接口，返回一个节点的 rank。</p>
</li>
<li><p>写一个 kd 树代码，支持最近邻的查询，查找一个框框有多少点？输入 n 个点，输出就是求最近的点，维护一个 kd 树的类，需要的基本行为还是最好支持一下，不过我们最关心的还是最近点。</p>
</li>
<li><p>快速排序进阶。多种排序方式组合实现一个高效的快速排序。<br>使用快速排序(在其函数上进行修改)实现线性查找元素第 k 小。<br>荷兰旗问题？</p>
</li>
<li><p>给定若干竖直和水平的随机长度的线段，并且保证一个 y 坐标或者一个 x 坐标下只有一条线段，求这些线段的交点个数。</p>
</li>
<li><p>最长公共子序列</p>
</li>
<li><p>bitset 求解高维偏序问题</p>
</li>
<li><p>k 短路问题</p>
</li>
<li><p>完成 KMP 算法</p>
</li>
<li><p>并查集实现 鼓励大家实现基于 rank 的 union，希望并查集中有路径压缩的功能（不需要新写一个函数，只需要在 find 时顺便修改）。</p>
</li>
<li><p>实现 Prim 算法</p>
</li>
</ol>
--></li></ol>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/DataStructure/" rel="tag"># DataStructure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/04/python%E7%88%AC%E8%99%AB/" rel="prev" title="python爬虫">
                  <i class="fa fa-angle-left"></i> python爬虫
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/09/07/%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/" rel="next" title="登录实现">
                  登录实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Miraclys</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Miraclys" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
